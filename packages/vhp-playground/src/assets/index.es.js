var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { ref, reactive, onMounted, watch, toRefs, watchEffect, onUnmounted, computed, isRef, markRaw, onBeforeUnmount, nextTick } from "vue";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN2 = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag2 = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart2 = /^\s+/;
    var reWhitespace2 = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary2 = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal2 = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN2;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim2(string) {
      return string ? string.slice(0, trimmedEndIndex2(string) + 1).replace(reTrimStart2, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator2) {
      var data, result = [];
      while (!(data = iterator2.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex2(string) {
      var index = string.length;
      while (index-- && reWhitespace2.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto2 = Array2.prototype, funcProto = Function2.prototype, objectProto2 = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString2 = objectProto2.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root2._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto2.propertyIsEnumerable, splice = arrayProto2.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty2 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir3 = this.__dir__, isArr = isArray2(array), isRight = dir3 < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length = end2 - start2, index = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir3;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed2 = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet2(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined$1 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet2(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet2;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet2;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys2(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty2) {
          defineProperty2(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined$1 : get2(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys2(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed2, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start2, end2) {
        var length = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 === undefined$1 || end2 > length ? length : toInteger(end2);
        if (end2 < 0) {
          end2 += length;
        }
        end2 = start2 > end2 ? 0 : toLength(end2);
        while (start2 < end2) {
          array[start2++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag2(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start2, end2) {
        return number >= nativeMin2(start2, end2) && number < nativeMax2(start2, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin2(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag2(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike2(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag2(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike2(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag2(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf3(seen, computed2, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end2, step, fromRight) {
        var index = -1, length = nativeMax2(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER2) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty2 ? identity2 : function(func, string) {
        return defineProperty2(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start2, end2) {
        var index = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 > length ? length : end2;
        if (end2 < 0) {
          end2 += length;
        }
        length = start2 > end2 ? 0 : end2 - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin2(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed2, seen)) {
            var seen = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes2(seen, computed2, comparator)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions2) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions2, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined$1;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start2, end2) {
        var length = array.length;
        end2 = end2 === undefined$1 ? length : end2;
        return !start2 && end2 >= length ? array : baseSlice(array, start2, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root2.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp2) {
        var result2 = new regexp2.constructor(regexp2.source, reFlags.exec(regexp2));
        result2.lastIndex = regexp2.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT2);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end2, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
            end2 = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end2 === undefined$1) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite(step);
          return baseRange(start2, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin2(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap2(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax2(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag2:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag2(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
        try {
          value[symToStringTag2] = undefined$1;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag2] = tag;
          } else {
            delete value[symToStringTag2];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag2;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag2(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start2, end2, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start2 += size2;
              break;
            case "dropRight":
              end2 -= size2;
              break;
            case "take":
              end2 = nativeMin2(end2, start2 + size2);
              break;
            case "takeRight":
              start2 = nativeMax2(start2, end2 - size2);
              break;
          }
        }
        return { "start": start2, "end": end2 };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag2:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString2.call(value);
      }
      function overRest(func, start2, transform3) {
        start2 = nativeMax2(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax2(args.length - start2, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start2 + index];
          }
          index = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index < start2) {
            otherArgs[index] = args[index];
          }
          otherArgs[start2] = transform3(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin2(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count2 = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count2 >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count2 = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax2(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start2, end2) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
          start2 = 0;
          end2 = length;
        }
        return baseFill(array, value, start2, end2);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax2(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax2(length + index, 0) : nativeMin2(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf2(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax2(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax2(length + index, 0) : nativeMin2(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse2(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice2(array, start2, end2) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end2 && typeof end2 != "number" && isIterateeCall(array, start2, end2)) {
          start2 = 0;
          end2 = length;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end2 = end2 === undefined$1 ? length : toInteger(end2);
        }
        return baseSlice(array, start2, end2);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take2(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax2(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse2],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse2);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax2(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition2 = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce2(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap2(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap2(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap2(key, bitmask, object, partials, holders);
      });
      function curry2(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap2(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry2.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap2(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax2(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap2(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin2(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap2(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap2(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap2(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      function spread(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        start2 = start2 == null ? 0 : nativeMax2(toInteger(start2), 0);
        return baseRest(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT2);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys2(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray2(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike2(value) || baseGetTag2(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign2 = value < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN2;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim2(value);
        var isBinary = reIsBinary2.test(value);
        return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike2(source)) {
          copyObject(source, keys2(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys2(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert2 = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        result2[value] = key;
      }, constant(identity2));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index])];
          if (value === undefined$1) {
            index = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number), lower, upper);
      }
      function inRange(number, start2, end2) {
        start2 = toFinite(start2);
        if (end2 === undefined$1) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        number = toNumber2(number);
        return baseInRange(number, start2, end2);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin2(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position2) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position2 = position2 === undefined$1 ? length : baseClamp(toInteger(position2), 0, length);
        var end2 = position2;
        position2 -= target.length;
        return position2 >= 0 && string.slice(position2, end2) == target;
      }
      function escape2(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad2(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart2, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split2(string, separator, limit2) {
        if (limit2 && typeof limit2 != "number" && isIterateeCall(string, separator, limit2)) {
          separator = limit2 = undefined$1;
        }
        limit2 = limit2 === undefined$1 ? MAX_ARRAY_LENGTH : limit2 >>> 0;
        if (!limit2) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit2);
          }
        }
        return string.split(separator, limit2);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position2) {
        string = toString(string);
        position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string.length);
        target = baseToString(target);
        return string.slice(position2, position2 + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim2(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end2).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex2(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end2).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart2, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end2 = length - stringSize(omission);
        if (end2 < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end2 += result2.length - end2;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end2).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end2) != end2) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT2);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin2(object, source, options) {
        var props = keys2(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys2(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                actions2.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin2(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max3(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity2);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min3(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum2(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry2;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert2;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin2;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition2;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse2;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice2;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split2;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take2;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin2(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf2;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike2;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte;
      lodash2.max = max3;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min3;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad2;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce2;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum2;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin2(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax2(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin2(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin2(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end2) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end2 !== undefined$1) {
          end2 = toInteger(end2);
          result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root2._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
const cache$1 = new Map();
const listeners$3 = {};
const setCache$1 = (key, cacheTime, data, params, staleTime = 0, loading = true) => {
  const currentCache = cache$1.get(key);
  if (currentCache == null ? void 0 : currentCache.timer) {
    clearTimeout(currentCache.timer);
  }
  let timer = void 0;
  if (cacheTime > -1) {
    timer = setTimeout(() => {
      cache$1.delete(key);
    }, cacheTime);
  }
  if (listeners$3[key]) {
    listeners$3[key].forEach((item) => item(data));
  }
  cache$1.set(key, {
    data,
    params,
    timer,
    time: new Date().getTime(),
    staleTime,
    loading
  });
};
const getCache$1 = (key) => {
  const currentCache = cache$1.get(key);
  if ((currentCache == null ? void 0 : currentCache.staleTime) === -1 || currentCache !== void 0 && typeof currentCache.time === "number" && typeof currentCache.staleTime === "number" && new Date().getTime() - currentCache.time <= currentCache.staleTime) {
    return __spreadProps(__spreadValues({}, cache$1.get(key)), {
      loading: false
    });
  }
  return cache$1.get(key);
};
const clearCache = (key) => {
  if (key) {
    const cacheKeys = Array.isArray(key) ? key : [key];
    cacheKeys.forEach((cacheKey) => cache$1.delete(cacheKey));
  } else {
    cache$1.clear();
  }
};
function useAsync(service, options = {}) {
  const {
    manual = false,
    initialData,
    defaultParams: defaultParams2 = [],
    debounceInterval,
    throttleInterval,
    pollingInterval,
    pollingWhenHidden,
    pollingSinceLastFinished,
    refreshDeps = [],
    cacheKey,
    cacheTime = 3e5,
    ready = ref(false),
    staleTime = 0,
    loadingDelay,
    fetchKey = (params2) => params2,
    onBefore,
    onSuccess,
    onError = console.log,
    onFinally,
    formatResult = (res) => res
  } = options;
  const [params, lastSuccessParams] = [
    ref(defaultParams2),
    ref(defaultParams2)
  ];
  const timerRef = ref();
  const isVisible = ref(true);
  const state = reactive({
    data: initialData || null,
    error: null,
    loading: false
  });
  const fetches = reactive({});
  const cancelTimeout = () => {
    if (timerRef.value) {
      clearTimeout(timerRef.value);
    }
  };
  const run = async (...args) => {
    var _a2, _b2, _c2, _d, _e;
    state.error = null;
    state.loading = true;
    cancelTimeout();
    onBefore == null ? void 0 : onBefore(lodash.exports.cloneDeep(args));
    params.value = lodash.exports.cloneDeep(args);
    if (loadingDelay !== void 0) {
      timerRef.value = setTimeout(() => {
        state.loading = true;
      }, loadingDelay);
      state.loading = false;
    }
    if (cacheKey !== void 0 && (typeof cacheKey === "string" || typeof cacheKey === "number")) {
      state.data = (_a2 = getCache$1(cacheKey)) == null ? void 0 : _a2.data;
      if (((_b2 = getCache$1(cacheKey)) == null ? void 0 : _b2.loading) !== void 0 && typeof ((_c2 = getCache$1(cacheKey)) == null ? void 0 : _c2.loading) === "boolean") {
        state.loading = getCache$1(cacheKey).loading;
      } else {
        state.loading = true;
      }
    }
    const fetchKeyPersist = fetchKey((_e = (_d = __spreadValues({}, args)) == null ? void 0 : _d[0]) != null ? _e : "default_key");
    if (fetchKeyPersist && typeof fetchKeyPersist === "string") {
      fetches[fetchKeyPersist] = __spreadProps(__spreadValues({}, state), {
        params: lodash.exports.cloneDeep(args)
      });
    }
    try {
      if (state.loading === true) {
        const result = await service(...args);
        state.data = result;
        state.loading = false;
        state.data = formatResult == null ? void 0 : formatResult(state.data);
        if (cacheKey) {
          setCache$1(cacheKey, cacheTime, state.data, lodash.exports.cloneDeep(args), staleTime);
        }
        onSuccess == null ? void 0 : onSuccess(state.data);
        lastSuccessParams.value = lodash.exports.cloneDeep(args);
        if (fetchKeyPersist && typeof fetchKeyPersist === "string") {
          fetches[fetchKeyPersist] = __spreadProps(__spreadValues({}, state), {
            loading: false,
            params: lodash.exports.cloneDeep(args)
          });
        }
        onFinally == null ? void 0 : onFinally(lodash.exports.cloneDeep(args), state.data, void 0);
        cancelTimeout();
      }
    } catch (err) {
      onError(err);
      state.error = err;
      state.loading = false;
      if (fetchKeyPersist) {
        fetches[fetchKeyPersist] = __spreadProps(__spreadValues({}, state), {
          data: null,
          params: lodash.exports.cloneDeep(args)
        });
      }
      clearCache(cacheKey);
      onFinally == null ? void 0 : onFinally(lodash.exports.cloneDeep(args), void 0, state.error);
      cancelTimeout();
    }
  };
  onMounted(() => {
    if (!manual)
      run(...defaultParams2);
  });
  let serviceRun = run;
  if (debounceInterval) {
    const debounceRun = lodash.exports.debounce(run, debounceInterval);
    serviceRun = (...args) => {
      state.loading = true;
      return Promise.resolve(debounceRun(...args));
    };
  }
  if (throttleInterval) {
    const throttleRun = lodash.exports.throttle(run, throttleInterval);
    serviceRun = (...args) => {
      return Promise.resolve(throttleRun(...args));
    };
  }
  let pollingTimer;
  if (pollingInterval && !pollingSinceLastFinished) {
    serviceRun = (...args) => {
      if (pollingTimer) {
        clearInterval(pollingTimer);
      }
      pollingTimer = setInterval(() => {
        if (pollingWhenHidden && !isVisible.value) {
          return;
        }
        run(...args);
      }, pollingInterval);
      return run(...args);
    };
  }
  function refresh() {
    return run(...params.value);
  }
  const cancel = () => {
    if (pollingTimer) {
      clearInterval(pollingTimer);
    }
    state.loading = false;
  };
  function mutate(newData) {
    state.data = newData;
  }
  watch(refreshDeps, (value, prevValue) => {
    var _a2;
    params.value = (_a2 = params.value) == null ? void 0 : _a2.map((item) => {
      const obj = item;
      prevValue.forEach((v, index) => {
        Object.keys(item).forEach((key) => {
          if (item[key] === v) {
            obj[key] = value[index];
          }
        });
      });
      return __spreadValues(__spreadValues({}, params.value), obj);
    });
    run(...params.value);
  });
  watch(ready, (val) => {
    if (val === true) {
      run(...params.value);
    }
  });
  return __spreadValues({
    fetches,
    lastSuccessParams,
    run: serviceRun,
    mutate,
    refresh,
    cancel,
    setCache: setCache$1,
    getCache: getCache$1,
    clearCache
  }, toRefs(state));
}
const useAutoRunPlugin = (fetchInstance, {
  manual,
  ready = ref(true),
  defaultParams: defaultParams2 = [],
  refreshDeps = [],
  refreshDepsAction
}) => {
  watch(ready, (curr) => {
    if (curr && !manual) {
      fetchInstance.run(...defaultParams2);
    }
  });
  watch([...refreshDeps], () => {
    if (!manual) {
      if (refreshDepsAction) {
        refreshDepsAction();
      } else {
        fetchInstance.refresh();
      }
    }
  });
  return {
    onBefore: () => {
      if (!ready.value) {
        return {
          stopNow: true
        };
      }
    }
  };
};
useAutoRunPlugin.onInit = ({ ready = ref(true), manual }) => {
  return {
    loading: !manual && ready.value
  };
};
const cache = new Map();
const setCache = (key, cacheTime, cachedData) => {
  const currentCache = cache.get(key);
  if (currentCache == null ? void 0 : currentCache.timer) {
    clearTimeout(currentCache.timer);
  }
  let timer = void 0;
  if (cacheTime > -1) {
    timer = setTimeout(() => {
      cache.delete(key);
    }, cacheTime);
  }
  cache.set(key, __spreadProps(__spreadValues({}, cachedData), {
    timer
  }));
};
const getCache = (key) => {
  return cache.get(key);
};
const cachePromise = new Map();
const getCachePromise = (cacheKey) => {
  return cachePromise.get(cacheKey);
};
const setCachePromise = (cacheKey, promise) => {
  cachePromise.set(cacheKey, promise);
  promise.then((res) => {
    cachePromise.delete(cacheKey);
    return res;
  }).catch((err) => {
    cachePromise.delete(cacheKey);
    throw err;
  });
};
const listeners$2 = {};
const trigger$2 = (key, data) => {
  if (listeners$2[key]) {
    listeners$2[key].forEach((item) => item(data));
  }
};
const subscribe$2 = (key, listener) => {
  if (!listeners$2[key]) {
    listeners$2[key] = [];
  }
  listeners$2[key].push(listener);
  return function unsubscribe() {
    const index = listeners$2[key].indexOf(listener);
    listeners$2[key].splice(index, 1);
  };
};
const useCachePlugin = (fetchInstance, {
  cacheKey,
  cacheTime = 5 * 60 * 1e3,
  staleTime = 0,
  setCache: customSetCache,
  getCache: customGetCache
}) => {
  const unSubscribeRef = ref();
  const currentPromiseRef = ref();
  const _setCache = (key, cachedData) => {
    if (customSetCache) {
      customSetCache(cachedData);
    } else {
      setCache(key, cacheTime, cachedData);
    }
    trigger$2(key, cachedData.data);
  };
  const _getCache = (key, params = []) => {
    if (customGetCache) {
      return customGetCache(params);
    }
    return getCache(key);
  };
  watchEffect(() => {
    if (!cacheKey) {
      return;
    }
    const cacheData = _getCache(cacheKey);
    if (cacheData && Object.hasOwnProperty.call(cacheData, "data")) {
      fetchInstance.state.data = cacheData.data;
      fetchInstance.state.params = cacheData.params;
      if (staleTime === -1 || new Date().getTime() - cacheData.time <= staleTime) {
        fetchInstance.state.loading = false;
      }
    }
    unSubscribeRef.value = subscribe$2(cacheKey, (data) => {
      fetchInstance.setState({ data });
    });
  });
  onUnmounted(() => {
    var _a2;
    (_a2 = unSubscribeRef.value) == null ? void 0 : _a2.call(unSubscribeRef);
  });
  if (!cacheKey) {
    return {};
  }
  return {
    onBefore: (params) => {
      const cacheData = _getCache(cacheKey, params);
      if (!cacheData || !Object.hasOwnProperty.call(cacheData, "data")) {
        return {};
      }
      if (staleTime === -1 || new Date().getTime() - cacheData.time <= staleTime) {
        return {
          loading: false,
          data: cacheData == null ? void 0 : cacheData.data,
          returnNow: true
        };
      } else {
        return {
          data: cacheData == null ? void 0 : cacheData.data
        };
      }
    },
    onRequest: (service, args) => {
      let servicePromise = getCachePromise(cacheKey);
      if (servicePromise && servicePromise !== currentPromiseRef.value) {
        return { servicePromise };
      }
      servicePromise = service(...args);
      currentPromiseRef.value = servicePromise;
      setCachePromise(cacheKey, servicePromise);
      return { servicePromise };
    },
    onSuccess: (data, params) => {
      var _a2;
      if (cacheKey) {
        (_a2 = unSubscribeRef.value) == null ? void 0 : _a2.call(unSubscribeRef);
        _setCache(cacheKey, {
          data,
          params,
          time: new Date().getTime()
        });
        unSubscribeRef.value = subscribe$2(cacheKey, (d) => {
          fetchInstance.setState({ data: d });
        });
      }
    },
    onMutate: (data) => {
      var _a2;
      if (cacheKey) {
        (_a2 = unSubscribeRef.value) == null ? void 0 : _a2.call(unSubscribeRef);
        _setCache(cacheKey, {
          data,
          params: fetchInstance.state.params,
          time: new Date().getTime()
        });
        unSubscribeRef.value = subscribe$2(cacheKey, (d) => {
          fetchInstance.setState({ data: d });
        });
      }
    }
  };
};
function isObject$7(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$7;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal || freeSelf || Function("return this")();
var _root = root$2;
var root$1 = _root;
var now$1 = function() {
  return root$1.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var root = _root;
var Symbol$4 = root.Symbol;
var _Symbol = Symbol$4;
var Symbol$3 = _Symbol;
var objectProto$1 = Object.prototype;
var hasOwnProperty = objectProto$1.hasOwnProperty;
var nativeObjectToString$1 = objectProto$1.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$1;
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$1;
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var isSymbol_1 = isSymbol$1;
var baseTrim = _baseTrim, isObject$6 = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$6(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$6(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var isObject$5 = isObject_1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject$5(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
const useDebouncePlugin = (fetchInstance, { debounceWait, debounceLeading, debounceTrailing, debounceMaxWait }) => {
  const debouncedRef = ref();
  const options = computed(() => {
    const ret2 = {};
    if ((debounceLeading == null ? void 0 : debounceLeading.value) !== void 0) {
      ret2.leading = debounceLeading.value;
    }
    if ((debounceTrailing == null ? void 0 : debounceTrailing.value) !== void 0) {
      ret2.trailing = debounceTrailing.value;
    }
    if ((debounceMaxWait == null ? void 0 : debounceMaxWait.value) !== void 0) {
      ret2.maxWait = debounceMaxWait.value;
    }
    return ret2;
  });
  watchEffect((onInvalidate) => {
    if (debounceWait) {
      const _originRunAsync = fetchInstance.runAsync.bind(fetchInstance);
      debouncedRef.value = debounce_1((callback) => {
        callback();
      }, debounceWait, options.value);
      fetchInstance.runAsync = (...args) => {
        return new Promise((resolve, reject) => {
          var _a2;
          (_a2 = debouncedRef.value) == null ? void 0 : _a2.call(debouncedRef, () => {
            _originRunAsync(...args).then(resolve).catch(reject);
          });
        });
      };
      onInvalidate(() => {
        var _a2;
        (_a2 = debouncedRef.value) == null ? void 0 : _a2.cancel();
        fetchInstance.runAsync = _originRunAsync;
      });
    }
  });
  if (!debounceWait) {
    return {};
  }
  return {
    onCancel: () => {
      var _a2;
      (_a2 = debouncedRef.value) == null ? void 0 : _a2.cancel();
    }
  };
};
const useLoadingDelayPlugin = (fetchInstance, { loadingDelay }) => {
  const timerRef = ref();
  if (!loadingDelay) {
    return {};
  }
  const cancelTimeout = () => {
    if (timerRef.value) {
      clearTimeout(timerRef.value);
    }
  };
  return {
    onBefore: () => {
      cancelTimeout();
      timerRef.value = setTimeout(() => {
        fetchInstance.setState({
          loading: true
        });
      }, loadingDelay);
      return {
        loading: false
      };
    },
    onFinally: () => {
      cancelTimeout();
    },
    onCancel: () => {
      cancelTimeout();
    }
  };
};
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function isDocumentVisible() {
  if (canUseDom()) {
    return document.visibilityState !== "hidden";
  }
  return true;
}
const listeners$1 = [];
function subscribe$1(listener) {
  listeners$1.push(listener);
  return function unsubscribe() {
    const index = listeners$1.indexOf(listener);
    listeners$1.splice(index, 1);
  };
}
if (canUseDom()) {
  const revalidate = () => {
    if (!isDocumentVisible())
      return;
    for (let i = 0; i < listeners$1.length; i++) {
      const listener = listeners$1[i];
      listener();
    }
  };
  window.addEventListener("visibilitychange", revalidate, false);
}
const usePollingPlugin = (fetchInstance, { pollingInterval, pollingWhenHidden = ref(true) }) => {
  const timerRef = ref();
  const unsubscribeRef = ref();
  const stopPolling = () => {
    var _a2;
    if (timerRef.value) {
      clearInterval(timerRef.value);
    }
    (_a2 = unsubscribeRef.value) == null ? void 0 : _a2.call(unsubscribeRef);
  };
  watchEffect(() => {
    if (!(pollingInterval == null ? void 0 : pollingInterval.value)) {
      stopPolling();
    }
  });
  if (!(pollingInterval == null ? void 0 : pollingInterval.value)) {
    return {};
  }
  return {
    onBefore: () => {
      stopPolling();
    },
    onFinally: () => {
      if (!pollingWhenHidden.value && !isDocumentVisible()) {
        unsubscribeRef.value = subscribe$1(() => {
          fetchInstance.refresh();
        });
        return;
      }
      timerRef.value = setInterval(() => {
        fetchInstance.refresh();
      }, pollingInterval.value);
    },
    onCancel: () => {
      stopPolling();
    }
  };
};
function limit(fn, timespan) {
  let pending = false;
  return (...args) => {
    if (pending)
      return;
    pending = true;
    fn(...args);
    setTimeout(() => {
      pending = false;
    }, timespan);
  };
}
function isOnline() {
  if (canUseDom() && typeof navigator.onLine !== "undefined") {
    return navigator.onLine;
  }
  return true;
}
const listeners = [];
function subscribe(listener) {
  listeners.push(listener);
  return function unsubscribe() {
    const index = listeners.indexOf(listener);
    listeners.splice(index, 1);
  };
}
if (canUseDom()) {
  const revalidate = () => {
    if (!isDocumentVisible() || !isOnline())
      return;
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i];
      listener();
    }
  };
  window.addEventListener("visibilitychange", revalidate, false);
  window.addEventListener("focus", revalidate, false);
}
const useRefreshOnWindowFocusPlugin = (fetchInstance, { refreshOnWindowFocus, focusTimespan = 5e3 }) => {
  const unsubscribeRef = ref();
  const stopSubscribe = () => {
    var _a2;
    (_a2 = unsubscribeRef.value) == null ? void 0 : _a2.call(unsubscribeRef);
  };
  watchEffect((onInvalidate) => {
    if (refreshOnWindowFocus == null ? void 0 : refreshOnWindowFocus.value) {
      const limitRefresh = limit(fetchInstance.refresh.bind(fetchInstance), focusTimespan);
      unsubscribeRef.value = subscribe(() => {
        limitRefresh();
      });
    }
    onInvalidate(() => {
      stopSubscribe();
    });
  });
  onUnmounted(() => {
    stopSubscribe();
  });
  return {};
};
const useRetryPlugin = (fetchInstance, { retryInterval, retryCount }) => {
  const timerRef = ref();
  const countRef = ref(0);
  const triggerByRetry = ref(false);
  if (!retryCount) {
    return {};
  }
  return {
    onBefore: () => {
      if (!triggerByRetry.value) {
        countRef.value = 0;
      }
      triggerByRetry.value = false;
      if (timerRef.value) {
        clearTimeout(timerRef.value);
      }
    },
    onSuccess: () => {
      countRef.value = 0;
    },
    onError: () => {
      countRef.value += 1;
      if (retryCount === -1 || countRef.value <= retryCount) {
        const timeout = retryInterval != null ? retryInterval : Math.min(1e3 * 2 ** countRef.value, 3e4);
        timerRef.value = setTimeout(() => {
          triggerByRetry.value = true;
          fetchInstance.refresh();
        }, timeout);
      } else {
        countRef.value = 0;
      }
    },
    onCancel: () => {
      countRef.value = 0;
      if (timerRef.value) {
        clearTimeout(timerRef.value);
      }
    }
  };
};
var debounce = debounce_1, isObject$4 = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle$1(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject$4(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle$1;
const useThrottlePlugin = (fetchInstance, { throttleWait, throttleLeading, throttleTrailing }) => {
  const throttledRef = ref();
  const options = {};
  if ((throttleLeading == null ? void 0 : throttleLeading.value) !== void 0) {
    options.leading = throttleLeading.value;
  }
  if ((throttleTrailing == null ? void 0 : throttleTrailing.value) !== void 0) {
    options.trailing = throttleTrailing.value;
  }
  watchEffect((onInvalidate) => {
    if (throttleWait) {
      const _originRunAsync = fetchInstance.runAsync.bind(fetchInstance);
      throttledRef.value = throttle_1((callback) => {
        callback();
      }, throttleWait, options);
      fetchInstance.runAsync = (...args) => {
        return new Promise((resolve, reject) => {
          var _a2;
          (_a2 = throttledRef.value) == null ? void 0 : _a2.call(throttledRef, () => {
            _originRunAsync(...args).then(resolve).catch(reject);
          });
        });
      };
      onInvalidate(() => {
        var _a2;
        fetchInstance.runAsync = _originRunAsync;
        (_a2 = throttledRef.value) == null ? void 0 : _a2.cancel();
      });
    }
  });
  if (!throttleWait) {
    return {};
  }
  return {
    onCancel: () => {
      var _a2;
      (_a2 = throttledRef.value) == null ? void 0 : _a2.cancel();
    }
  };
};
function useUpdate() {
  const update = ref({});
  const setUpdate = () => {
    update.value = Object.assign({}, __spreadValues({}, update.value));
  };
  return {
    update,
    setUpdate
  };
}
class Fetch {
  constructor(serviceRef, options, subscribe2, initState = {}) {
    __publicField(this, "pluginImpls");
    __publicField(this, "count", 0);
    __publicField(this, "state", reactive({
      loading: false,
      params: void 0,
      data: void 0,
      error: void 0
    }));
    this.serviceRef = serviceRef;
    this.options = options;
    this.subscribe = subscribe2;
    this.initState = initState;
    this.state = __spreadValues(__spreadProps(__spreadValues({}, this.state), {
      loading: !options.manual
    }), initState);
  }
  setState(s = {}) {
    this.state = __spreadValues(__spreadValues({}, this.state), s);
    this.subscribe();
  }
  runPluginHandler(event, ...rest) {
    const r = this.pluginImpls.map((i) => {
      var _a2;
      return (_a2 = i[event]) == null ? void 0 : _a2.call(i, ...rest);
    }).filter(Boolean);
    return Object.assign({}, ...r);
  }
  async runAsync(...params) {
    var _b2, _c2, _d, _e, _f, _g, _h, _i, _j, _k;
    this.count += 1;
    const currentCount = this.count;
    const _a2 = this.runPluginHandler("onBefore", params), {
      stopNow = false,
      returnNow = false
    } = _a2, state = __objRest(_a2, [
      "stopNow",
      "returnNow"
    ]);
    if (stopNow) {
      return new Promise(() => {
      });
    }
    this.setState(__spreadValues({
      loading: true,
      params
    }, state));
    if (returnNow) {
      return Promise.resolve(state.data);
    }
    (_c2 = (_b2 = this.options).onBefore) == null ? void 0 : _c2.call(_b2, params);
    try {
      let { servicePromise } = this.runPluginHandler("onRequest", this.serviceRef.value, params);
      if (!servicePromise) {
        servicePromise = this.serviceRef.value(...params);
      }
      const res = await servicePromise;
      if (currentCount !== this.count) {
        return new Promise(() => {
        });
      }
      this.setState({
        data: res,
        error: void 0,
        loading: false
      });
      (_e = (_d = this.options).onSuccess) == null ? void 0 : _e.call(_d, res, params);
      this.runPluginHandler("onSuccess", res, params);
      (_g = (_f = this.options).onFinally) == null ? void 0 : _g.call(_f, params, res, void 0);
      if (currentCount === this.count) {
        this.runPluginHandler("onFinally", params, res, void 0);
      }
      return res;
    } catch (error) {
      if (currentCount !== this.count) {
        return new Promise(() => {
        });
      }
      this.setState({
        error,
        loading: false
      });
      (_i = (_h = this.options).onError) == null ? void 0 : _i.call(_h, error, params);
      this.runPluginHandler("onError", error, params);
      (_k = (_j = this.options).onFinally) == null ? void 0 : _k.call(_j, params, void 0, error);
      if (currentCount === this.count) {
        this.runPluginHandler("onFinally", params, void 0, error);
      }
      throw error;
    }
  }
  run(...params) {
    this.runAsync(...params).catch((error) => {
      if (!this.options.onError) {
        console.error(error);
      }
    });
  }
  cancel() {
    this.count += 1;
    this.setState({
      loading: false
    });
    this.runPluginHandler("onCancel");
  }
  refresh() {
    this.run(...this.state.params || []);
  }
  refreshAsync() {
    return this.runAsync(...this.state.params || []);
  }
  mutate(data) {
    let targetData;
    if (typeof data === "function") {
      targetData = data(this.state.data);
    } else {
      targetData = data;
    }
    this.runPluginHandler("onMutate", targetData);
    this.setState({
      data: targetData
    });
  }
}
function useRequestImplement(service, options = {}, plugins = []) {
  const _a2 = options, { manual = false } = _a2, rest = __objRest(_a2, ["manual"]);
  const fetchOptions = __spreadValues({
    manual
  }, rest);
  const serviceRef = ref(service);
  const { update, setUpdate } = useUpdate();
  const state = reactive({
    data: void 0,
    loading: true,
    params: void 0,
    error: void 0
  });
  const setState = (s) => {
    state.data = s.data;
    state.loading = s.loading;
    state.error = s.error;
    state.params = s.params;
  };
  const fetchInstance = computed(() => {
    const initState = plugins.map((p) => {
      var _a3;
      return (_a3 = p == null ? void 0 : p.onInit) == null ? void 0 : _a3.call(p, fetchOptions);
    }).filter(Boolean);
    return new Fetch(serviceRef, fetchOptions, setUpdate, Object.assign({}, ...initState));
  });
  watch(update, () => {
    setState(fetchInstance.value.state);
  });
  fetchInstance.value.options = fetchOptions;
  fetchInstance.value.pluginImpls = plugins.map((p) => {
    return p(fetchInstance.value, fetchOptions);
  });
  onMounted(() => {
    if (!manual) {
      const params = fetchInstance.value.state.params || options.defaultParams || [];
      fetchInstance.value.run(...params);
    }
  });
  onUnmounted(() => {
    fetchInstance.value.cancel();
  });
  return __spreadProps(__spreadValues({}, toRefs(state)), {
    cancel: fetchInstance.value.cancel.bind(fetchInstance.value),
    refresh: fetchInstance.value.refresh.bind(fetchInstance.value),
    refreshAsync: fetchInstance.value.refreshAsync.bind(fetchInstance.value),
    run: fetchInstance.value.run.bind(fetchInstance.value),
    runAsync: fetchInstance.value.runAsync.bind(fetchInstance.value),
    mutate: fetchInstance.value.mutate.bind(fetchInstance.value)
  });
}
function useRequest(service, options, plugins) {
  return useRequestImplement(service, options, [
    ...plugins || [],
    useDebouncePlugin,
    useLoadingDelayPlugin,
    usePollingPlugin,
    useRefreshOnWindowFocusPlugin,
    useThrottlePlugin,
    useAutoRunPlugin,
    useCachePlugin,
    useRetryPlugin
  ]);
}
function useToggle(defaultValue = false, reverseValue) {
  const state = ref(defaultValue);
  const actions2 = computed(() => {
    const reverseValueOrigin = reverseValue === void 0 ? !defaultValue : reverseValue;
    const toggle = () => {
      return state.value === defaultValue ? reverseValueOrigin : defaultValue;
    };
    const set2 = (value) => state.value = value;
    const setLeft = () => state.value = defaultValue;
    const setRight = () => state.value = reverseValueOrigin;
    return {
      toggle,
      set: set2,
      setLeft,
      setRight
    };
  });
  return [state, __spreadValues({}, actions2.value)];
}
function useBoolean(defaultValue = false) {
  const [state, { set: set2 }] = useToggle(defaultValue);
  const actions2 = computed(() => {
    const setTrue = () => set2(true);
    const setFalse = () => set2(false);
    return {
      set: (v) => set2(!!v),
      setTrue,
      setFalse
    };
  });
  return [state, __spreadValues({}, actions2.value)];
}
var js_cookie = { exports: {} };
/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
(function(module, exports) {
  (function(factory) {
    var registeredInModuleLoader;
    {
      module.exports = factory();
      registeredInModuleLoader = true;
    }
    if (!registeredInModuleLoader) {
      var OldCookies = window.Cookies;
      var api = window.Cookies = factory();
      api.noConflict = function() {
        window.Cookies = OldCookies;
        return api;
      };
    }
  })(function() {
    function extend2() {
      var i = 0;
      var result = {};
      for (; i < arguments.length; i++) {
        var attributes = arguments[i];
        for (var key in attributes) {
          result[key] = attributes[key];
        }
      }
      return result;
    }
    function decode2(s) {
      return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
    }
    function init2(converter) {
      function api() {
      }
      function set2(key, value, attributes) {
        if (typeof document === "undefined") {
          return;
        }
        attributes = extend2({
          path: "/"
        }, api.defaults, attributes);
        if (typeof attributes.expires === "number") {
          attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e5);
        }
        attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
        try {
          var result = JSON.stringify(value);
          if (/^[\{\[]/.test(result)) {
            value = result;
          }
        } catch (e2) {
        }
        value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
        key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
        var stringifiedAttributes = "";
        for (var attributeName in attributes) {
          if (!attributes[attributeName]) {
            continue;
          }
          stringifiedAttributes += "; " + attributeName;
          if (attributes[attributeName] === true) {
            continue;
          }
          stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
        }
        return document.cookie = key + "=" + value + stringifiedAttributes;
      }
      function get2(key, json) {
        if (typeof document === "undefined") {
          return;
        }
        var jar = {};
        var cookies = document.cookie ? document.cookie.split("; ") : [];
        var i = 0;
        for (; i < cookies.length; i++) {
          var parts = cookies[i].split("=");
          var cookie = parts.slice(1).join("=");
          if (!json && cookie.charAt(0) === '"') {
            cookie = cookie.slice(1, -1);
          }
          try {
            var name = decode2(parts[0]);
            cookie = (converter.read || converter)(cookie, name) || decode2(cookie);
            if (json) {
              try {
                cookie = JSON.parse(cookie);
              } catch (e2) {
              }
            }
            jar[name] = cookie;
            if (key === name) {
              break;
            }
          } catch (e2) {
          }
        }
        return key ? jar[key] : jar;
      }
      api.set = set2;
      api.get = function(key) {
        return get2(key, false);
      };
      api.getJSON = function(key) {
        return get2(key, true);
      };
      api.remove = function(key, attributes) {
        set2(key, "", extend2(attributes, {
          expires: -1
        }));
      };
      api.defaults = {};
      api.withConverter = init2;
      return api;
    }
    return init2(function() {
    });
  });
})(js_cookie);
var Cookies = js_cookie.exports;
function isFunction$2(obj) {
  return typeof obj === "function";
}
function useCookieState(cookieKey, options = {}) {
  const defaultValue = () => {
    const cookieValue = Cookies.get(cookieKey);
    if (typeof cookieValue === "string")
      return cookieValue;
    if (isFunction$2(options.defaultValue)) {
      return options.defaultValue();
    }
    return options.defaultValue;
  };
  const state = ref(defaultValue());
  const updateState = (newValue, newOptions = {}) => {
    const _a2 = __spreadValues(__spreadValues({}, options), newOptions), { defaultValue: defaultValue2 } = _a2, restOptions = __objRest(_a2, ["defaultValue"]);
    const getValue = () => {
      const value = isFunction$2(newValue) ? newValue(state.value) : newValue;
      if (value === void 0) {
        Cookies.remove(cookieKey);
      } else {
        Cookies.set(cookieKey, value, restOptions);
      }
      return value;
    };
    state.value = getValue();
  };
  return [state, updateState];
}
function useDebounceFn(fn, options) {
  var _a2;
  const wait = (_a2 = options == null ? void 0 : options.wait) != null ? _a2 : 1e3;
  const run = debounce_1(fn, wait, options);
  return {
    run
  };
}
function useDebounce(value, options) {
  const debounced = ref(value.value);
  const { run } = useDebounceFn(() => debounced.value = value.value, options);
  watch(value, () => run(), { deep: true });
  return debounced;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var Browser = function() {
  function Browser2() {
    this.firefox = false;
    this.ie = false;
    this.edge = false;
    this.newEdge = false;
    this.weChat = false;
  }
  return Browser2;
}();
var Env = function() {
  function Env2() {
    this.browser = new Browser();
    this.node = false;
    this.wxa = false;
    this.worker = false;
    this.svgSupported = false;
    this.touchEventsSupported = false;
    this.pointerEventsSupported = false;
    this.domSupported = false;
    this.transformSupported = false;
    this.transform3dSupported = false;
    this.hasGlobalWindow = typeof window !== "undefined";
  }
  return Env2;
}();
var env = new Env();
if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
  env.wxa = true;
  env.touchEventsSupported = true;
} else if (typeof document === "undefined" && typeof self !== "undefined") {
  env.worker = true;
} else if (typeof navigator === "undefined") {
  env.node = true;
  env.svgSupported = true;
} else {
  detect(navigator.userAgent, env);
}
function detect(ua, env2) {
  var browser = env2.browser;
  var firefox = ua.match(/Firefox\/([\d.]+)/);
  var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge?\/([\d.]+)/);
  var weChat = /micromessenger/i.test(ua);
  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  }
  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }
  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
    browser.newEdge = +edge[1].split(".")[0] > 18;
  }
  if (weChat) {
    browser.weChat = true;
  }
  env2.svgSupported = typeof SVGRect !== "undefined";
  env2.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
  env2.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
  env2.domSupported = typeof document !== "undefined";
  var style = document.documentElement.style;
  env2.transform3dSupported = (browser.ie && "transition" in style || browser.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
  env2.transformSupported = env2.transform3dSupported || browser.ie && +browser.version >= 9;
}
var env$1 = env;
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = DEFAULT_FONT_SIZE + "px " + DEFAULT_FONT_FAMILY;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function getTextWidthMap(mapStr) {
  var map2 = {};
  if (typeof JSON === "undefined") {
    return map2;
  }
  for (var i = 0; i < mapStr.length; i++) {
    var char = String.fromCharCode(i + 32);
    var size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
    map2[char] = size;
  }
  return map2;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
  createCanvas: function() {
    return typeof document !== "undefined" && document.createElement("canvas");
  },
  measureText: function() {
    var _ctx;
    var _cachedFont;
    return function(text, font) {
      if (!_ctx) {
        var canvas = platformApi.createCanvas();
        _ctx = canvas && canvas.getContext("2d");
      }
      if (_ctx) {
        if (_cachedFont !== font) {
          _cachedFont = _ctx.font = font || DEFAULT_FONT;
        }
        return _ctx.measureText(text);
      } else {
        text = text || "";
        font = font || DEFAULT_FONT;
        var res = /^([0-9]*?)px$/.exec(font);
        var fontSize = +(res && res[1]) || DEFAULT_FONT_SIZE;
        var width = 0;
        if (font.indexOf("mono") >= 0) {
          width = fontSize * text.length;
        } else {
          for (var i = 0; i < text.length; i++) {
            var preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];
            width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
          }
        }
        return { width };
      }
    };
  }(),
  loadImage: function(src, onload, onerror) {
    var image = new Image();
    image.onload = onload;
    image.onerror = onerror;
    image.src = src;
    return image;
  }
};
var BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(obj, val) {
  obj["[object " + val + "]"] = true;
  return obj;
}, {});
var TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(obj, val) {
  obj["[object " + val + "Array]"] = true;
  return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach$1 = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var ctorFunction = function() {
}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
var idStart$1 = 2311;
function guid$1() {
  return idStart$1++;
}
function logError() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (typeof console !== "undefined") {
    console.error.apply(console, args);
  }
}
function clone$4(source) {
  if (source == null || typeof source !== "object") {
    return source;
  }
  var result = source;
  var typeStr = objToString.call(source);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source)) {
      result = [];
      for (var i = 0, len2 = source.length; i < len2; i++) {
        result[i] = clone$4(source[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      var Ctor = source.constructor;
      if (Ctor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);
        for (var i = 0, len2 = source.length; i < len2; i++) {
          result[i] = source[i];
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};
    for (var key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        result[key] = clone$4(source[key]);
      }
    }
  }
  return result;
}
function merge(target, source, overwrite) {
  if (!isObject$3(source) || !isObject$3(target)) {
    return overwrite ? clone$4(source) : target;
  }
  for (var key in source) {
    if (source.hasOwnProperty(key) && key !== protoKey) {
      var targetProp = target[key];
      var sourceProp = source[key];
      if (isObject$3(sourceProp) && isObject$3(targetProp) && !isArray$1(sourceProp) && !isArray$1(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        target[key] = clone$4(source[key]);
      }
    }
  }
  return target;
}
function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];
  for (var i = 1, len2 = targetAndSources.length; i < len2; i++) {
    result = merge(result, targetAndSources[i], overwrite);
  }
  return result;
}
function extend$1(target, source) {
  if (Object.assign) {
    Object.assign(target, source);
  } else {
    for (var key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function defaults(target, source, overlay) {
  var keysArr = keys(source);
  for (var i = 0; i < keysArr.length; i++) {
    var key = keysArr[i];
    if (overlay ? source[key] != null : target[key] == null) {
      target[key] = source[key];
    }
  }
  return target;
}
function indexOf(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }
    for (var i = 0, len2 = array.length; i < len2; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }
  return -1;
}
function inherits(clazz, baseClazz) {
  var clazzPrototype = clazz.prototype;
  function F() {
  }
  F.prototype = baseClazz.prototype;
  clazz.prototype = new F();
  for (var prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
  }
  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
function mixin(target, source, override) {
  target = "prototype" in target ? target.prototype : target;
  source = "prototype" in source ? source.prototype : source;
  if (Object.getOwnPropertyNames) {
    var keyList = Object.getOwnPropertyNames(source);
    for (var i = 0; i < keyList.length; i++) {
      var key = keyList[i];
      if (key !== "constructor") {
        if (override ? source[key] != null : target[key] == null) {
          target[key] = source[key];
        }
      }
    }
  } else {
    defaults(target, source, override);
  }
}
function isArrayLike(data) {
  if (!data) {
    return false;
  }
  if (typeof data === "string") {
    return false;
  }
  return typeof data.length === "number";
}
function each$f(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  if (arr.forEach && arr.forEach === nativeForEach$1) {
    arr.forEach(cb, context);
  } else if (arr.length === +arr.length) {
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      cb.call(context, arr[i], i, arr);
    }
  } else {
    for (var key in arr) {
      if (arr.hasOwnProperty(key)) {
        cb.call(context, arr[key], key, arr);
      }
    }
  }
}
function map$1(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.map && arr.map === nativeMap) {
    return arr.map(cb, context);
  } else {
    var result = [];
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      result.push(cb.call(context, arr[i], i, arr));
    }
    return result;
  }
}
function reduce(arr, cb, memo, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i = 0, len2 = arr.length; i < len2; i++) {
    memo = cb.call(context, memo, arr[i], i, arr);
  }
  return memo;
}
function filter(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.filter && arr.filter === nativeFilter) {
    return arr.filter(cb, context);
  } else {
    var result = [];
    for (var i = 0, len2 = arr.length; i < len2; i++) {
      if (cb.call(context, arr[i], i, arr)) {
        result.push(arr[i]);
      }
    }
    return result;
  }
}
function find(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  for (var i = 0, len2 = arr.length; i < len2; i++) {
    if (cb.call(context, arr[i], i, arr)) {
      return arr[i];
    }
  }
}
function keys(obj) {
  if (!obj) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keyList = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      keyList.push(key);
    }
  }
  return keyList;
}
function bindPolyfill(func, context) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
var bind$1 = protoFunction && isFunction$1(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry$1(func) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return function() {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
function isArray$1(value) {
  if (Array.isArray) {
    return Array.isArray(value);
  }
  return objToString.call(value) === "[object Array]";
}
function isFunction$1(value) {
  return typeof value === "function";
}
function isString(value) {
  return typeof value === "string";
}
function isStringSafe(value) {
  return objToString.call(value) === "[object String]";
}
function isNumber(value) {
  return typeof value === "number";
}
function isObject$3(value) {
  var type = typeof value;
  return type === "function" || !!value && type === "object";
}
function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
  return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
function isGradientObject(value) {
  return value.colorStops != null;
}
function isImagePatternObject(value) {
  return value.image != null;
}
function isRegExp(value) {
  return objToString.call(value) === "[object RegExp]";
}
function eqNaN(value) {
  return value !== value;
}
function retrieve$2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  for (var i = 0, len2 = args.length; i < len2; i++) {
    if (args[i] != null) {
      return args[i];
    }
  }
}
function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}
function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice(arr) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  return nativeSlice.apply(arr, args);
}
function normalizeCssArray$1(val) {
  if (typeof val === "number") {
    return [val, val, val, val];
  }
  var len2 = val.length;
  if (len2 === 2) {
    return [val[0], val[1], val[0], val[1]];
  } else if (len2 === 3) {
    return [val[0], val[1], val[2], val[1]];
  }
  return val;
}
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
function trim$1(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === "function") {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}
function isPrimitive(obj) {
  return obj[primitiveKey];
}
var HashMap = function() {
  function HashMap2(obj) {
    this.data = {};
    var isArr = isArray$1(obj);
    this.data = {};
    var thisMap = this;
    obj instanceof HashMap2 ? obj.each(visit) : obj && each$f(obj, visit);
    function visit(value, key) {
      isArr ? thisMap.set(value, key) : thisMap.set(key, value);
    }
  }
  HashMap2.prototype.get = function(key) {
    return this.data.hasOwnProperty(key) ? this.data[key] : null;
  };
  HashMap2.prototype.set = function(key, value) {
    return this.data[key] = value;
  };
  HashMap2.prototype.each = function(cb, context) {
    for (var key in this.data) {
      if (this.data.hasOwnProperty(key)) {
        cb.call(context, this.data[key], key);
      }
    }
  };
  HashMap2.prototype.keys = function() {
    return keys(this.data);
  };
  HashMap2.prototype.removeKey = function(key) {
    delete this.data[key];
  };
  return HashMap2;
}();
function createHashMap(obj) {
  return new HashMap(obj);
}
function concatArray(a, b) {
  var newArray = new a.constructor(a.length + b.length);
  for (var i = 0; i < a.length; i++) {
    newArray[i] = a[i];
  }
  var offset = a.length;
  for (var i = 0; i < b.length; i++) {
    newArray[i + offset] = b[i];
  }
  return newArray;
}
function createObject(proto, properties) {
  var obj;
  if (Object.create) {
    obj = Object.create(proto);
  } else {
    var StyleCtor = function() {
    };
    StyleCtor.prototype = proto;
    obj = new StyleCtor();
  }
  if (properties) {
    extend$1(obj, properties);
  }
  return obj;
}
function disableUserSelect(dom) {
  var domStyle = dom.style;
  domStyle.webkitUserSelect = "none";
  domStyle.userSelect = "none";
  domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
  domStyle["-webkit-touch-callout"] = "none";
}
function hasOwn(own, prop) {
  return own.hasOwnProperty(prop);
}
function noop$1() {
}
var RADIAN_TO_DEGREE = 180 / Math.PI;
function create$3(x, y) {
  if (x == null) {
    x = 0;
  }
  if (y == null) {
    y = 0;
  }
  return [x, y];
}
function copy$1(out2, v) {
  out2[0] = v[0];
  out2[1] = v[1];
  return out2;
}
function clone$3(v) {
  return [v[0], v[1]];
}
function set$1(out2, a, b) {
  out2[0] = a;
  out2[1] = b;
  return out2;
}
function add$1(out2, v12, v22) {
  out2[0] = v12[0] + v22[0];
  out2[1] = v12[1] + v22[1];
  return out2;
}
function scaleAndAdd$1(out2, v12, v22, a) {
  out2[0] = v12[0] + v22[0] * a;
  out2[1] = v12[1] + v22[1] * a;
  return out2;
}
function sub$1(out2, v12, v22) {
  out2[0] = v12[0] - v22[0];
  out2[1] = v12[1] - v22[1];
  return out2;
}
function len(v) {
  return Math.sqrt(lenSquare(v));
}
function lenSquare(v) {
  return v[0] * v[0] + v[1] * v[1];
}
function scale$2(out2, v, s) {
  out2[0] = v[0] * s;
  out2[1] = v[1] * s;
  return out2;
}
function normalize$5(out2, v) {
  var d = len(v);
  if (d === 0) {
    out2[0] = 0;
    out2[1] = 0;
  } else {
    out2[0] = v[0] / d;
    out2[1] = v[1] / d;
  }
  return out2;
}
function distance(v12, v22) {
  return Math.sqrt((v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]));
}
var dist$1 = distance;
function distanceSquare(v12, v22) {
  return (v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]);
}
var distSquare = distanceSquare;
function lerp$1(out2, v12, v22, t) {
  out2[0] = v12[0] + t * (v22[0] - v12[0]);
  out2[1] = v12[1] + t * (v22[1] - v12[1]);
  return out2;
}
function applyTransform$1(out2, v, m2) {
  var x = v[0];
  var y = v[1];
  out2[0] = m2[0] * x + m2[2] * y + m2[4];
  out2[1] = m2[1] * x + m2[3] * y + m2[5];
  return out2;
}
function min$1(out2, v12, v22) {
  out2[0] = Math.min(v12[0], v22[0]);
  out2[1] = Math.min(v12[1], v22[1]);
  return out2;
}
function max$1(out2, v12, v22) {
  out2[0] = Math.max(v12[0], v22[0]);
  out2[1] = Math.max(v12[1], v22[1]);
  return out2;
}
var Param = function() {
  function Param2(target, e2) {
    this.target = target;
    this.topTarget = e2 && e2.topTarget;
  }
  return Param2;
}();
var Draggable = function() {
  function Draggable2(handler) {
    this.handler = handler;
    handler.on("mousedown", this._dragStart, this);
    handler.on("mousemove", this._drag, this);
    handler.on("mouseup", this._dragEnd, this);
  }
  Draggable2.prototype._dragStart = function(e2) {
    var draggingTarget = e2.target;
    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
    }
    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e2.offsetX;
      this._y = e2.offsetY;
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragstart", e2.event);
    }
  };
  Draggable2.prototype._drag = function(e2) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      var x = e2.offsetX;
      var y = e2.offsetY;
      var dx = x - this._x;
      var dy = y - this._y;
      this._x = x;
      this._y = y;
      draggingTarget.drift(dx, dy, e2);
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "drag", e2.event);
      var dropTarget = this.handler.findHover(x, y, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;
      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(lastDropTarget, e2), "dragleave", e2.event);
        }
        if (dropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(dropTarget, e2), "dragenter", e2.event);
        }
      }
    }
  };
  Draggable2.prototype._dragEnd = function(e2) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      draggingTarget.dragging = false;
    }
    this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragend", e2.event);
    if (this._dropTarget) {
      this.handler.dispatchToElement(new Param(this._dropTarget, e2), "drop", e2.event);
    }
    this._draggingTarget = null;
    this._dropTarget = null;
  };
  return Draggable2;
}();
var Draggable$1 = Draggable;
var Eventful = function() {
  function Eventful2(eventProcessors) {
    if (eventProcessors) {
      this._$eventProcessor = eventProcessors;
    }
  }
  Eventful2.prototype.on = function(event, query, handler, context) {
    if (!this._$handlers) {
      this._$handlers = {};
    }
    var _h = this._$handlers;
    if (typeof query === "function") {
      context = handler;
      handler = query;
      query = null;
    }
    if (!handler || !event) {
      return this;
    }
    var eventProcessor = this._$eventProcessor;
    if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
      query = eventProcessor.normalizeQuery(query);
    }
    if (!_h[event]) {
      _h[event] = [];
    }
    for (var i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }
    var wrap = {
      h: handler,
      query,
      ctx: context || this,
      callAtLast: handler.zrEventfulCallAtLast
    };
    var lastIndex = _h[event].length - 1;
    var lastWrap = _h[event][lastIndex];
    lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
    return this;
  };
  Eventful2.prototype.isSilent = function(eventName) {
    var _h = this._$handlers;
    return !_h || !_h[eventName] || !_h[eventName].length;
  };
  Eventful2.prototype.off = function(eventType, handler) {
    var _h = this._$handlers;
    if (!_h) {
      return this;
    }
    if (!eventType) {
      this._$handlers = {};
      return this;
    }
    if (handler) {
      if (_h[eventType]) {
        var newList = [];
        for (var i = 0, l = _h[eventType].length; i < l; i++) {
          if (_h[eventType][i].h !== handler) {
            newList.push(_h[eventType][i]);
          }
        }
        _h[eventType] = newList;
      }
      if (_h[eventType] && _h[eventType].length === 0) {
        delete _h[eventType];
      }
    } else {
      delete _h[eventType];
    }
    return this;
  };
  Eventful2.prototype.trigger = function(eventType) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h = this._$handlers[eventType];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var argLen = args.length;
      var len2 = _h.length;
      for (var i = 0; i < len2; i++) {
        var hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(hItem.ctx);
            break;
          case 1:
            hItem.h.call(hItem.ctx, args[0]);
            break;
          case 2:
            hItem.h.call(hItem.ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(hItem.ctx, args);
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
    return this;
  };
  Eventful2.prototype.triggerWithContext = function(type) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!this._$handlers) {
      return this;
    }
    var _h = this._$handlers[type];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var argLen = args.length;
      var ctx = args[argLen - 1];
      var len2 = _h.length;
      for (var i = 0; i < len2; i++) {
        var hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(ctx);
            break;
          case 1:
            hItem.h.call(ctx, args[0]);
            break;
          case 2:
            hItem.h.call(ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(ctx, args.slice(1, argLen - 1));
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  };
  return Eventful2;
}();
var Eventful$1 = Eventful;
var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
  var cacheKey = rowMask + "-" + colMask;
  var fullRank = rows.length;
  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }
  if (rank === 1) {
    var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }
  var subRowMask = rowMask | 1 << rowStart;
  var subRowStart = rowStart + 1;
  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }
  var sum2 = 0;
  for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
    var colTag = 1 << j;
    if (!(colTag & colMask)) {
      sum2 += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }
  detCache[cacheKey] = sum2;
  return sum2;
}
function buildTransformer(src, dest) {
  var mA = [
    [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
    [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
    [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
    [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
    [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
    [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
    [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
    [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
  ];
  var detCache = {};
  var det = determinant(mA, 8, 0, 0, 0, detCache);
  if (det === 0) {
    return;
  }
  var vh = [];
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      vh[j] == null && (vh[j] = 0);
      vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
    }
  }
  return function(out2, srcPointX, srcPointY) {
    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
    out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
    out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
  };
}
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut$1 = [];
function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport(_calcOut$1, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport(out2, el, inX, inY, inverse) {
  if (el.getBoundingClientRect && env$1.domSupported && !isCanvasEl(el)) {
    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
    var markers = prepareCoordMarkers(el, saved);
    var transformer = preparePointerTransformer(markers, saved, inverse);
    if (transformer) {
      transformer(out2, inX, inY);
      return true;
    }
  }
  return false;
}
function prepareCoordMarkers(el, saved) {
  var markers = saved.markers;
  if (markers) {
    return markers;
  }
  markers = saved.markers = [];
  var propLR = ["left", "right"];
  var propTB = ["top", "bottom"];
  for (var i = 0; i < 4; i++) {
    var marker = document.createElement("div");
    var stl = marker.style;
    var idxLR = i % 2;
    var idxTB = (i >> 1) % 2;
    stl.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      propLR[idxLR] + ":0",
      propTB[idxTB] + ":0",
      propLR[1 - idxLR] + ":auto",
      propTB[1 - idxTB] + ":auto",
      ""
    ].join("!important;");
    el.appendChild(marker);
    markers.push(marker);
  }
  return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
  var transformerName = inverse ? "invTrans" : "trans";
  var transformer = saved[transformerName];
  var oldSrcCoords = saved.srcCoords;
  var srcCoords = [];
  var destCoords = [];
  var oldCoordTheSame = true;
  for (var i = 0; i < 4; i++) {
    var rect = markers[i].getBoundingClientRect();
    var ii = 2 * i;
    var x = rect.left;
    var y = rect.top;
    srcCoords.push(x, y);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
  }
  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el) {
  return el.nodeName.toUpperCase() === "CANVAS";
}
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut = [];
var firefoxNotSupportOffsetXY = env$1.browser.firefox && +env$1.browser.version.split(".")[0] < 39;
function clientToLocal(el, e2, out2, calculate) {
  out2 = out2 || {};
  if (calculate) {
    calculateZrXY(el, e2, out2);
  } else if (firefoxNotSupportOffsetXY && e2.layerX != null && e2.layerX !== e2.offsetX) {
    out2.zrX = e2.layerX;
    out2.zrY = e2.layerY;
  } else if (e2.offsetX != null) {
    out2.zrX = e2.offsetX;
    out2.zrY = e2.offsetY;
  } else {
    calculateZrXY(el, e2, out2);
  }
  return out2;
}
function calculateZrXY(el, e2, out2) {
  if (env$1.domSupported && el.getBoundingClientRect) {
    var ex = e2.clientX;
    var ey = e2.clientY;
    if (isCanvasEl(el)) {
      var box2 = el.getBoundingClientRect();
      out2.zrX = ex - box2.left;
      out2.zrY = ey - box2.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
        out2.zrX = _calcOut[0];
        out2.zrY = _calcOut[1];
        return;
      }
    }
  }
  out2.zrX = out2.zrY = 0;
}
function getNativeEvent(e2) {
  return e2 || window.event;
}
function normalizeEvent(el, e2, calculate) {
  e2 = getNativeEvent(e2);
  if (e2.zrX != null) {
    return e2;
  }
  var eventType = e2.type;
  var isTouch = eventType && eventType.indexOf("touch") >= 0;
  if (!isTouch) {
    clientToLocal(el, e2, e2, calculate);
    var wheelDelta = getWheelDeltaMayPolyfill(e2);
    e2.zrDelta = wheelDelta ? wheelDelta / 120 : -(e2.detail || 0) / 3;
  } else {
    var touch = eventType !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
    touch && clientToLocal(el, touch, e2, calculate);
  }
  var button = e2.button;
  if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
    e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
  return e2;
}
function getWheelDeltaMayPolyfill(e2) {
  var rawWheelDelta = e2.wheelDelta;
  if (rawWheelDelta) {
    return rawWheelDelta;
  }
  var deltaX = e2.deltaX;
  var deltaY = e2.deltaY;
  if (deltaX == null || deltaY == null) {
    return rawWheelDelta;
  }
  var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
  var sign2 = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
  return 3 * delta * sign2;
}
function addEventListener(el, name, handler, opt) {
  el.addEventListener(name, handler, opt);
}
function removeEventListener(el, name, handler, opt) {
  el.removeEventListener(name, handler, opt);
}
var stop = function(e2) {
  e2.preventDefault();
  e2.stopPropagation();
  e2.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e2) {
  return e2.which === 2 || e2.which === 3;
}
var GestureMgr = function() {
  function GestureMgr2() {
    this._track = [];
  }
  GestureMgr2.prototype.recognize = function(event, target, root2) {
    this._doTrack(event, target, root2);
    return this._recognize(event);
  };
  GestureMgr2.prototype.clear = function() {
    this._track.length = 0;
    return this;
  };
  GestureMgr2.prototype._doTrack = function(event, target, root2) {
    var touches = event.touches;
    if (!touches) {
      return;
    }
    var trackItem = {
      points: [],
      touches: [],
      target,
      event
    };
    for (var i = 0, len2 = touches.length; i < len2; i++) {
      var touch = touches[i];
      var pos = clientToLocal(root2, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }
    this._track.push(trackItem);
  };
  GestureMgr2.prototype._recognize = function(event) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event);
        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  };
  return GestureMgr2;
}();
function dist(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}
function center$1(pointPair) {
  return [
    (pointPair[0][0] + pointPair[1][0]) / 2,
    (pointPair[0][1] + pointPair[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(tracks, event) {
    var trackLen = tracks.length;
    if (!trackLen) {
      return;
    }
    var pinchEnd = (tracks[trackLen - 1] || {}).points;
    var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist(pinchEnd) / dist(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      var pinchCenter = center$1(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: "pinch",
        target: tracks[0].target,
        event
      };
    }
  }
};
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event,
    target: targetInfo.target,
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = function(_super) {
  __extends(EmptyProxy2, _super);
  function EmptyProxy2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.handler = null;
    return _this;
  }
  EmptyProxy2.prototype.dispose = function() {
  };
  EmptyProxy2.prototype.setCursor = function() {
  };
  return EmptyProxy2;
}(Eventful$1);
var HoveredResult = function() {
  function HoveredResult2(x, y) {
    this.x = x;
    this.y = y;
  }
  return HoveredResult2;
}();
var handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
];
var Handler$1 = function(_super) {
  __extends(Handler2, _super);
  function Handler2(storage2, painter, proxy, painterRoot) {
    var _this = _super.call(this) || this;
    _this._hovered = new HoveredResult(0, 0);
    _this.storage = storage2;
    _this.painter = painter;
    _this.painterRoot = painterRoot;
    proxy = proxy || new EmptyProxy();
    _this.proxy = null;
    _this.setHandlerProxy(proxy);
    _this._draggingMgr = new Draggable$1(_this);
    return _this;
  }
  Handler2.prototype.setHandlerProxy = function(proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }
    if (proxy) {
      each$f(handlerNames, function(name) {
        proxy.on && proxy.on(name, this[name], this);
      }, this);
      proxy.handler = this;
    }
    this.proxy = proxy;
  };
  Handler2.prototype.mousemove = function(event) {
    var x = event.zrX;
    var y = event.zrY;
    var isOutside = isOutsideBoundary(this, x, y);
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target;
    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }
    var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, "mouseout", event);
    }
    this.dispatchToElement(hovered, "mousemove", event);
    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, "mouseover", event);
    }
  };
  Handler2.prototype.mouseout = function(event) {
    var eventControl = event.zrEventControl;
    if (eventControl !== "only_globalout") {
      this.dispatchToElement(this._hovered, "mouseout", event);
    }
    if (eventControl !== "no_globalout") {
      this.trigger("globalout", { type: "globalout", event });
    }
  };
  Handler2.prototype.resize = function() {
    this._hovered = new HoveredResult(0, 0);
  };
  Handler2.prototype.dispatch = function(eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  };
  Handler2.prototype.dispose = function() {
    this.proxy.dispose();
    this.storage = null;
    this.proxy = null;
    this.painter = null;
  };
  Handler2.prototype.setCursorStyle = function(cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  };
  Handler2.prototype.dispatchToElement = function(targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;
    if (el && el.silent) {
      return;
    }
    var eventKey = "on" + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event);
    while (el) {
      el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.__hostTarget ? el.__hostTarget : el.parent;
      if (eventPacket.cancelBubble) {
        break;
      }
    }
    if (!eventPacket.cancelBubble) {
      this.trigger(eventName, eventPacket);
      if (this.painter && this.painter.eachOtherLayer) {
        this.painter.eachOtherLayer(function(layer) {
          if (typeof layer[eventKey] === "function") {
            layer[eventKey].call(layer, eventPacket);
          }
          if (layer.trigger) {
            layer.trigger(eventName, eventPacket);
          }
        });
      }
    }
  };
  Handler2.prototype.findHover = function(x, y, exclude) {
    var list = this.storage.getDisplayList();
    var out2 = new HoveredResult(x, y);
    for (var i = list.length - 1; i >= 0; i--) {
      var hoverCheckResult = void 0;
      if (list[i] !== exclude && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
        !out2.topTarget && (out2.topTarget = list[i]);
        if (hoverCheckResult !== SILENT) {
          out2.target = list[i];
          break;
        }
      }
    }
    return out2;
  };
  Handler2.prototype.processGesture = function(event, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr();
    }
    var gestureMgr = this._gestureMgr;
    stage === "start" && gestureMgr.clear();
    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
    stage === "end" && gestureMgr.clear();
    if (gestureInfo) {
      var type = gestureInfo.type;
      event.gestureEvent = type;
      var res = new HoveredResult();
      res.target = gestureInfo.target;
      this.dispatchToElement(res, type, gestureInfo.event);
    }
  };
  return Handler2;
}(Eventful$1);
each$f(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
  Handler$1.prototype[name] = function(event) {
    var x = event.zrX;
    var y = event.zrY;
    var isOutside = isOutsideBoundary(this, x, y);
    var hovered;
    var hoveredTarget;
    if (name !== "mouseup" || !isOutside) {
      hovered = this.findHover(x, y);
      hoveredTarget = hovered.target;
    }
    if (name === "mousedown") {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY];
      this._upEl = hoveredTarget;
    } else if (name === "mouseup") {
      this._upEl = hoveredTarget;
    } else if (name === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist$1(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }
      this._downPoint = null;
    }
    this.dispatchToElement(hovered, name, event);
  };
});
function isHover(displayable, x, y) {
  if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
    var el = displayable;
    var isSilent = void 0;
    var ignoreClip = false;
    while (el) {
      if (el.ignoreClip) {
        ignoreClip = true;
      }
      if (!ignoreClip) {
        var clipPath = el.getClipPath();
        if (clipPath && !clipPath.contain(x, y)) {
          return false;
        }
        if (el.silent) {
          isSilent = true;
        }
      }
      var hostEl = el.__hostTarget;
      el = hostEl ? hostEl : el.parent;
    }
    return isSilent ? SILENT : true;
  }
  return false;
}
function isOutsideBoundary(handlerInstance, x, y) {
  var painter = handlerInstance.painter;
  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
}
var Handler$2 = Handler$1;
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n) {
  var r = 0;
  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }
  return n + r;
}
function makeAscendingRun(array, lo, hi, compare2) {
  var runHi = lo + 1;
  if (runHi === hi) {
    return 1;
  }
  if (compare2(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo;
}
function reverseRun(array, lo, hi) {
  hi--;
  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}
function binaryInsertionSort(array, lo, hi, start2, compare2) {
  if (start2 === lo) {
    start2++;
  }
  for (; start2 < hi; start2++) {
    var pivot = array[start2];
    var left = lo;
    var right = start2;
    var mid;
    while (left < right) {
      mid = left + right >>> 1;
      if (compare2(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    var n = start2 - left;
    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];
      case 2:
        array[left + 2] = array[left + 1];
      case 1:
        array[left + 1] = array[left];
        break;
      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }
    }
    array[left] = pivot;
  }
}
function gallopLeft(value, array, start2, length, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare2(value, array[start2 + hint]) > 0) {
    maxOffset = length - hint;
    while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare2(value, array[start2 + m2]) > 0) {
      lastOffset = m2 + 1;
    } else {
      offset = m2;
    }
  }
  return offset;
}
function gallopRight(value, array, start2, length, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare2(value, array[start2 + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;
    while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare2(value, array[start2 + m2]) < 0) {
      offset = m2;
    } else {
      lastOffset = m2 + 1;
    }
  }
  return offset;
}
function TimSort(array, compare2) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var runStart;
  var runLength;
  var stackSize = 0;
  var tmp = [];
  runStart = [];
  runLength = [];
  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }
  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }
      mergeAt(n);
    }
  }
  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }
      mergeAt(n);
    }
  }
  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;
    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }
    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare2);
    start1 += k;
    length1 -= k;
    if (length1 === 0) {
      return;
    }
    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare2);
    if (length2 === 0) {
      return;
    }
    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }
  function mergeLow(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }
    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];
    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
      return;
    }
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
      return;
    }
    var _minGallop = minGallop;
    var count1;
    var count2;
    var exit;
    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;
      do {
        if (compare2(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;
          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
          exit = true;
          break;
        }
        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare2);
        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          dest += count2;
          cursor2 += count2;
          length2 -= count2;
          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        array[dest++] = tmp[cursor1++];
        if (--length1 === 1) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error();
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }
  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }
    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];
    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
      return;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
      return;
    }
    var _minGallop = minGallop;
    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;
      do {
        if (compare2(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare2);
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array[dest--] = tmp[cursor2--];
        if (--length2 === 1) {
          exit = true;
          break;
        }
        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare2);
        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }
          if (length2 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    if (minGallop < 1) {
      minGallop = 1;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error();
    } else {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }
  return {
    mergeRuns,
    forceMergeRuns,
    pushRun
  };
}
function sort$2(array, compare2, lo, hi) {
  if (!lo) {
    lo = 0;
  }
  if (!hi) {
    hi = array.length;
  }
  var remaining = hi - lo;
  if (remaining < 2) {
    return;
  }
  var runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
    return;
  }
  var ts = TimSort(array, compare2);
  var minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
      runLength = force;
    }
    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);
  ts.forceMergeRuns();
}
var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;
var invalidZErrorLogged = false;
function logInvalidZError() {
  if (invalidZErrorLogged) {
    return;
  }
  invalidZErrorLogged = true;
  console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
}
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      return a.z2 - b.z2;
    }
    return a.z - b.z;
  }
  return a.zlevel - b.zlevel;
}
var Storage = function() {
  function Storage2() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    this.displayableSortFunc = shapeCompareFunc;
  }
  Storage2.prototype.traverse = function(cb, context) {
    for (var i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  };
  Storage2.prototype.getDisplayList = function(update, includeIgnore) {
    includeIgnore = includeIgnore || false;
    var displayList = this._displayList;
    if (update || !displayList.length) {
      this.updateDisplayList(includeIgnore);
    }
    return displayList;
  };
  Storage2.prototype.updateDisplayList = function(includeIgnore) {
    this._displayListLen = 0;
    var roots2 = this._roots;
    var displayList = this._displayList;
    for (var i = 0, len2 = roots2.length; i < len2; i++) {
      this._updateAndAddDisplayable(roots2[i], null, includeIgnore);
    }
    displayList.length = this._displayListLen;
    sort$2(displayList, shapeCompareFunc);
  };
  Storage2.prototype._updateAndAddDisplayable = function(el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }
    el.beforeUpdate();
    el.update();
    el.afterUpdate();
    var userSetClipPath = el.getClipPath();
    if (el.ignoreClip) {
      clipPaths = null;
    } else if (userSetClipPath) {
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }
      var currentClipPath = userSetClipPath;
      var parentClipPath = el;
      while (currentClipPath) {
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.getClipPath();
      }
    }
    if (el.childrenRef) {
      var children = el.childrenRef();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (el.__dirty) {
          child.__dirty |= REDRAW_BIT;
        }
        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      }
      el.__dirty = 0;
    } else {
      var disp = el;
      if (clipPaths && clipPaths.length) {
        disp.__clipPaths = clipPaths;
      } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
        disp.__clipPaths = [];
      }
      if (isNaN(disp.z)) {
        logInvalidZError();
        disp.z = 0;
      }
      if (isNaN(disp.z2)) {
        logInvalidZError();
        disp.z2 = 0;
      }
      if (isNaN(disp.zlevel)) {
        logInvalidZError();
        disp.zlevel = 0;
      }
      this._displayList[this._displayListLen++] = disp;
    }
    var decalEl = el.getDecalElement && el.getDecalElement();
    if (decalEl) {
      this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
    }
    var textGuide = el.getTextGuideLine();
    if (textGuide) {
      this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
    }
    var textEl = el.getTextContent();
    if (textEl) {
      this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
    }
  };
  Storage2.prototype.addRoot = function(el) {
    if (el.__zr && el.__zr.storage === this) {
      return;
    }
    this._roots.push(el);
  };
  Storage2.prototype.delRoot = function(el) {
    if (el instanceof Array) {
      for (var i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }
      return;
    }
    var idx = indexOf(this._roots, el);
    if (idx >= 0) {
      this._roots.splice(idx, 1);
    }
  };
  Storage2.prototype.delAllRoots = function() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    return;
  };
  Storage2.prototype.getRoots = function() {
    return this._roots;
  };
  Storage2.prototype.dispose = function() {
    this._displayList = null;
    this._roots = null;
  };
  return Storage2;
}();
var Storage$1 = Storage;
var requestAnimationFrame$1;
requestAnimationFrame$1 = env$1.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
  return setTimeout(func, 16);
};
var requestAnimationFrame$2 = requestAnimationFrame$1;
var easingFuncs = {
  linear: function(k) {
    return k;
  },
  quadraticIn: function(k) {
    return k * k;
  },
  quadraticOut: function(k) {
    return k * (2 - k);
  },
  quadraticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  },
  cubicIn: function(k) {
    return k * k * k;
  },
  cubicOut: function(k) {
    return --k * k * k + 1;
  },
  cubicInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k + 2);
  },
  quarticIn: function(k) {
    return k * k * k * k;
  },
  quarticOut: function(k) {
    return 1 - --k * k * k * k;
  },
  quarticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }
    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  quinticIn: function(k) {
    return k * k * k * k * k;
  },
  quinticOut: function(k) {
    return --k * k * k * k * k + 1;
  },
  quinticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  sinusoidalIn: function(k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },
  sinusoidalOut: function(k) {
    return Math.sin(k * Math.PI / 2);
  },
  sinusoidalInOut: function(k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  exponentialIn: function(k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },
  exponentialOut: function(k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },
  exponentialInOut: function(k) {
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }
    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  circularIn: function(k) {
    return 1 - Math.sqrt(1 - k * k);
  },
  circularOut: function(k) {
    return Math.sqrt(1 - --k * k);
  },
  circularInOut: function(k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }
    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  elasticIn: function(k) {
    var s;
    var a = 0.1;
    var p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  },
  elasticOut: function(k) {
    var s;
    var a = 0.1;
    var p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
  },
  elasticInOut: function(k) {
    var s;
    var a = 0.1;
    var p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    }
    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  backIn: function(k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },
  backOut: function(k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },
  backInOut: function(k) {
    var s = 1.70158 * 1.525;
    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }
    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  bounceIn: function(k) {
    return 1 - easingFuncs.bounceOut(1 - k);
  },
  bounceOut: function(k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },
  bounceInOut: function(k) {
    if (k < 0.5) {
      return easingFuncs.bounceIn(k * 2) * 0.5;
    }
    return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var easingFuncs$1 = easingFuncs;
var mathPow$2 = Math.pow;
var mathSqrt$3 = Math.sqrt;
var EPSILON$5 = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt$3(3);
var ONE_THIRD = 1 / 3;
var _v0 = create$3();
var _v1 = create$3();
var _v2 = create$3();
function isAroundZero$1(val) {
  return val > -EPSILON$5 && val < EPSILON$5;
}
function isNotAroundZero$1(val) {
  return val > EPSILON$5 || val < -EPSILON$5;
}
function cubicAt(p02, p12, p22, p3, t) {
  var onet = 1 - t;
  return onet * onet * (onet * p02 + 3 * t * p12) + t * t * (t * p3 + 3 * onet * p22);
}
function cubicDerivativeAt(p02, p12, p22, p3, t) {
  var onet = 1 - t;
  return 3 * (((p12 - p02) * onet + 2 * (p22 - p12) * t) * onet + (p3 - p22) * t * t);
}
function cubicRootAt(p02, p12, p22, p3, val, roots2) {
  var a = p3 + 3 * (p12 - p22) - p02;
  var b = 3 * (p22 - p12 * 2 + p02);
  var c = 3 * (p12 - p02);
  var d = p02 - val;
  var A = b * b - 3 * a * c;
  var B = b * c - 9 * a * d;
  var C = c * c - 3 * b * d;
  var n = 0;
  if (isAroundZero$1(A) && isAroundZero$1(B)) {
    if (isAroundZero$1(b)) {
      roots2[0] = 0;
    } else {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    var disc = B * B - 4 * A * C;
    if (isAroundZero$1(disc)) {
      var K = B / A;
      var t1 = -b / a + K;
      var t2 = -K / 2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
      var Y2 = A * b + 1.5 * a * (-B - discSqrt);
      if (Y1 < 0) {
        Y1 = -mathPow$2(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow$2(Y1, ONE_THIRD);
      }
      if (Y2 < 0) {
        Y2 = -mathPow$2(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow$2(Y2, ONE_THIRD);
      }
      var t1 = (-b - (Y1 + Y2)) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else {
      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt$3(A * A * A));
      var theta = Math.acos(T) / 3;
      var ASqrt = mathSqrt$3(A);
      var tmp = Math.cos(theta);
      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
      if (t3 >= 0 && t3 <= 1) {
        roots2[n++] = t3;
      }
    }
  }
  return n;
}
function cubicExtrema(p02, p12, p22, p3, extrema2) {
  var b = 6 * p22 - 12 * p12 + 6 * p02;
  var a = 9 * p12 + 3 * p3 - 3 * p02 - 9 * p22;
  var c = 3 * p12 - 3 * p02;
  var n = 0;
  if (isAroundZero$1(a)) {
    if (isNotAroundZero$1(b)) {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isAroundZero$1(disc)) {
      extrema2[0] = -b / (2 * a);
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        extrema2[n++] = t2;
      }
    }
  }
  return n;
}
function cubicSubdivide(p02, p12, p22, p3, t, out2) {
  var p01 = (p12 - p02) * t + p02;
  var p122 = (p22 - p12) * t + p12;
  var p23 = (p3 - p22) * t + p22;
  var p012 = (p122 - p01) * t + p01;
  var p123 = (p23 - p122) * t + p122;
  var p0123 = (p123 - p012) * t + p012;
  out2[0] = p02;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p0123;
  out2[4] = p0123;
  out2[5] = p123;
  out2[6] = p23;
  out2[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out2) {
  var t;
  var interval = 5e-3;
  var d = Infinity;
  var prev;
  var next;
  var d1;
  var d2;
  _v0[0] = x;
  _v0[1] = y;
  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
    d1 = distSquare(_v0, _v1);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    prev = t - interval;
    next = t + interval;
    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
    d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      _v2[0] = cubicAt(x0, x1, x2, x3, next);
      _v2[1] = cubicAt(y0, y1, y2, y3, next);
      d2 = distSquare(_v2, _v0);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = cubicAt(x0, x1, x2, x3, t);
    out2[1] = cubicAt(y0, y1, y2, y3, t);
  }
  return mathSqrt$3(d);
}
function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
  var px = x0;
  var py = y0;
  var d = 0;
  var step = 1 / iteration;
  for (var i = 1; i <= iteration; i++) {
    var t = i * step;
    var x = cubicAt(x0, x1, x2, x3, t);
    var y = cubicAt(y0, y1, y2, y3, t);
    var dx = x - px;
    var dy = y - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x;
    py = y;
  }
  return d;
}
function quadraticAt$1(p02, p12, p22, t) {
  var onet = 1 - t;
  return onet * (onet * p02 + 2 * t * p12) + t * t * p22;
}
function quadraticDerivativeAt(p02, p12, p22, t) {
  return 2 * ((1 - t) * (p12 - p02) + t * (p22 - p12));
}
function quadraticRootAt(p02, p12, p22, val, roots2) {
  var a = p02 - 2 * p12 + p22;
  var b = 2 * (p12 - p02);
  var c = p02 - val;
  var n = 0;
  if (isAroundZero$1(a)) {
    if (isNotAroundZero$1(b)) {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isAroundZero$1(disc)) {
      var t1 = -b / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    }
  }
  return n;
}
function quadraticExtremum(p02, p12, p22) {
  var divider = p02 + p22 - 2 * p12;
  if (divider === 0) {
    return 0.5;
  } else {
    return (p02 - p12) / divider;
  }
}
function quadraticSubdivide(p02, p12, p22, t, out2) {
  var p01 = (p12 - p02) * t + p02;
  var p122 = (p22 - p12) * t + p12;
  var p012 = (p122 - p01) * t + p01;
  out2[0] = p02;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p012;
  out2[4] = p122;
  out2[5] = p22;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out2) {
  var t;
  var interval = 5e-3;
  var d = Infinity;
  _v0[0] = x;
  _v0[1] = y;
  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt$1(x0, x1, x2, _t);
    _v1[1] = quadraticAt$1(y0, y1, y2, _t);
    var d1 = distSquare(_v0, _v1);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    var prev = t - interval;
    var next = t + interval;
    _v1[0] = quadraticAt$1(x0, x1, x2, prev);
    _v1[1] = quadraticAt$1(y0, y1, y2, prev);
    var d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      _v2[0] = quadraticAt$1(x0, x1, x2, next);
      _v2[1] = quadraticAt$1(y0, y1, y2, next);
      var d2 = distSquare(_v2, _v0);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = quadraticAt$1(x0, x1, x2, t);
    out2[1] = quadraticAt$1(y0, y1, y2, t);
  }
  return mathSqrt$3(d);
}
function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
  var px = x0;
  var py = y0;
  var d = 0;
  var step = 1 / iteration;
  for (var i = 1; i <= iteration; i++) {
    var t = i * step;
    var x = quadraticAt$1(x0, x1, x2, t);
    var y = quadraticAt$1(y0, y1, y2, t);
    var dx = x - px;
    var dy = y - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x;
    py = y;
  }
  return d;
}
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
  var cubic = cubicEasingStr && regexp.exec(cubicEasingStr);
  if (cubic) {
    var points2 = cubic[1].split(",");
    var a_1 = +trim$1(points2[0]);
    var b_1 = +trim$1(points2[1]);
    var c_1 = +trim$1(points2[2]);
    var d_1 = +trim$1(points2[3]);
    if (isNaN(a_1 + b_1 + c_1 + d_1)) {
      return;
    }
    var roots_1 = [];
    return function(p) {
      return p <= 0 ? 0 : p >= 1 ? 1 : cubicRootAt(0, a_1, c_1, 1, p, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0]);
    };
  }
}
var Clip = function() {
  function Clip2(opts) {
    this._inited = false;
    this._startTime = 0;
    this._pausedTime = 0;
    this._paused = false;
    this._life = opts.life || 1e3;
    this._delay = opts.delay || 0;
    this.loop = opts.loop || false;
    this.onframe = opts.onframe || noop$1;
    this.ondestroy = opts.ondestroy || noop$1;
    this.onrestart = opts.onrestart || noop$1;
    opts.easing && this.setEasing(opts.easing);
  }
  Clip2.prototype.step = function(globalTime, deltaTime) {
    if (!this._inited) {
      this._startTime = globalTime + this._delay;
      this._inited = true;
    }
    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }
    var life = this._life;
    var elapsedTime = globalTime - this._startTime - this._pausedTime;
    var percent = elapsedTime / life;
    if (percent < 0) {
      percent = 0;
    }
    percent = Math.min(percent, 1);
    var easingFunc = this.easingFunc;
    var schedule = easingFunc ? easingFunc(percent) : percent;
    this.onframe(schedule);
    if (percent === 1) {
      if (this.loop) {
        var remainder = elapsedTime % life;
        this._startTime = globalTime - remainder;
        this._pausedTime = 0;
        this.onrestart();
      } else {
        return true;
      }
    }
    return false;
  };
  Clip2.prototype.pause = function() {
    this._paused = true;
  };
  Clip2.prototype.resume = function() {
    this._paused = false;
  };
  Clip2.prototype.setEasing = function(easing) {
    this.easing = easing;
    this.easingFunc = isFunction$1(easing) ? easing : easingFuncs$1[easing] || createCubicEasingFunc(easing);
  };
  return Clip2;
}();
var Clip$1 = Clip;
var Entry = function() {
  function Entry2(val) {
    this.value = val;
  }
  return Entry2;
}();
var LinkedList$2 = function() {
  function LinkedList2() {
    this._len = 0;
  }
  LinkedList2.prototype.insert = function(val) {
    var entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
  };
  LinkedList2.prototype.insertEntry = function(entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      entry.next = null;
      this.tail = entry;
    }
    this._len++;
  };
  LinkedList2.prototype.remove = function(entry) {
    var prev = entry.prev;
    var next = entry.next;
    if (prev) {
      prev.next = next;
    } else {
      this.head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
  };
  LinkedList2.prototype.len = function() {
    return this._len;
  };
  LinkedList2.prototype.clear = function() {
    this.head = this.tail = null;
    this._len = 0;
  };
  return LinkedList2;
}();
var LRU$1 = function() {
  function LRU2(maxSize) {
    this._list = new LinkedList$2();
    this._maxSize = 10;
    this._map = {};
    this._maxSize = maxSize;
  }
  LRU2.prototype.put = function(key, value) {
    var list = this._list;
    var map2 = this._map;
    var removed = null;
    if (map2[key] == null) {
      var len2 = list.len();
      var entry = this._lastRemovedEntry;
      if (len2 >= this._maxSize && len2 > 0) {
        var leastUsedEntry = list.head;
        list.remove(leastUsedEntry);
        delete map2[leastUsedEntry.key];
        removed = leastUsedEntry.value;
        this._lastRemovedEntry = leastUsedEntry;
      }
      if (entry) {
        entry.value = value;
      } else {
        entry = new Entry(value);
      }
      entry.key = key;
      list.insertEntry(entry);
      map2[key] = entry;
    }
    return removed;
  };
  LRU2.prototype.get = function(key) {
    var entry = this._map[key];
    var list = this._list;
    if (entry != null) {
      if (entry !== list.tail) {
        list.remove(entry);
        list.insertEntry(entry);
      }
      return entry.value;
    }
  };
  LRU2.prototype.clear = function() {
    this._list.clear();
    this._map = {};
  };
  LRU2.prototype.len = function() {
    return this._list.len();
  };
  return LRU2;
}();
var LRUCache$1 = LRU$1;
var kCSSColorTable$1 = {
  "transparent": [0, 0, 0, 0],
  "aliceblue": [240, 248, 255, 1],
  "antiquewhite": [250, 235, 215, 1],
  "aqua": [0, 255, 255, 1],
  "aquamarine": [127, 255, 212, 1],
  "azure": [240, 255, 255, 1],
  "beige": [245, 245, 220, 1],
  "bisque": [255, 228, 196, 1],
  "black": [0, 0, 0, 1],
  "blanchedalmond": [255, 235, 205, 1],
  "blue": [0, 0, 255, 1],
  "blueviolet": [138, 43, 226, 1],
  "brown": [165, 42, 42, 1],
  "burlywood": [222, 184, 135, 1],
  "cadetblue": [95, 158, 160, 1],
  "chartreuse": [127, 255, 0, 1],
  "chocolate": [210, 105, 30, 1],
  "coral": [255, 127, 80, 1],
  "cornflowerblue": [100, 149, 237, 1],
  "cornsilk": [255, 248, 220, 1],
  "crimson": [220, 20, 60, 1],
  "cyan": [0, 255, 255, 1],
  "darkblue": [0, 0, 139, 1],
  "darkcyan": [0, 139, 139, 1],
  "darkgoldenrod": [184, 134, 11, 1],
  "darkgray": [169, 169, 169, 1],
  "darkgreen": [0, 100, 0, 1],
  "darkgrey": [169, 169, 169, 1],
  "darkkhaki": [189, 183, 107, 1],
  "darkmagenta": [139, 0, 139, 1],
  "darkolivegreen": [85, 107, 47, 1],
  "darkorange": [255, 140, 0, 1],
  "darkorchid": [153, 50, 204, 1],
  "darkred": [139, 0, 0, 1],
  "darksalmon": [233, 150, 122, 1],
  "darkseagreen": [143, 188, 143, 1],
  "darkslateblue": [72, 61, 139, 1],
  "darkslategray": [47, 79, 79, 1],
  "darkslategrey": [47, 79, 79, 1],
  "darkturquoise": [0, 206, 209, 1],
  "darkviolet": [148, 0, 211, 1],
  "deeppink": [255, 20, 147, 1],
  "deepskyblue": [0, 191, 255, 1],
  "dimgray": [105, 105, 105, 1],
  "dimgrey": [105, 105, 105, 1],
  "dodgerblue": [30, 144, 255, 1],
  "firebrick": [178, 34, 34, 1],
  "floralwhite": [255, 250, 240, 1],
  "forestgreen": [34, 139, 34, 1],
  "fuchsia": [255, 0, 255, 1],
  "gainsboro": [220, 220, 220, 1],
  "ghostwhite": [248, 248, 255, 1],
  "gold": [255, 215, 0, 1],
  "goldenrod": [218, 165, 32, 1],
  "gray": [128, 128, 128, 1],
  "green": [0, 128, 0, 1],
  "greenyellow": [173, 255, 47, 1],
  "grey": [128, 128, 128, 1],
  "honeydew": [240, 255, 240, 1],
  "hotpink": [255, 105, 180, 1],
  "indianred": [205, 92, 92, 1],
  "indigo": [75, 0, 130, 1],
  "ivory": [255, 255, 240, 1],
  "khaki": [240, 230, 140, 1],
  "lavender": [230, 230, 250, 1],
  "lavenderblush": [255, 240, 245, 1],
  "lawngreen": [124, 252, 0, 1],
  "lemonchiffon": [255, 250, 205, 1],
  "lightblue": [173, 216, 230, 1],
  "lightcoral": [240, 128, 128, 1],
  "lightcyan": [224, 255, 255, 1],
  "lightgoldenrodyellow": [250, 250, 210, 1],
  "lightgray": [211, 211, 211, 1],
  "lightgreen": [144, 238, 144, 1],
  "lightgrey": [211, 211, 211, 1],
  "lightpink": [255, 182, 193, 1],
  "lightsalmon": [255, 160, 122, 1],
  "lightseagreen": [32, 178, 170, 1],
  "lightskyblue": [135, 206, 250, 1],
  "lightslategray": [119, 136, 153, 1],
  "lightslategrey": [119, 136, 153, 1],
  "lightsteelblue": [176, 196, 222, 1],
  "lightyellow": [255, 255, 224, 1],
  "lime": [0, 255, 0, 1],
  "limegreen": [50, 205, 50, 1],
  "linen": [250, 240, 230, 1],
  "magenta": [255, 0, 255, 1],
  "maroon": [128, 0, 0, 1],
  "mediumaquamarine": [102, 205, 170, 1],
  "mediumblue": [0, 0, 205, 1],
  "mediumorchid": [186, 85, 211, 1],
  "mediumpurple": [147, 112, 219, 1],
  "mediumseagreen": [60, 179, 113, 1],
  "mediumslateblue": [123, 104, 238, 1],
  "mediumspringgreen": [0, 250, 154, 1],
  "mediumturquoise": [72, 209, 204, 1],
  "mediumvioletred": [199, 21, 133, 1],
  "midnightblue": [25, 25, 112, 1],
  "mintcream": [245, 255, 250, 1],
  "mistyrose": [255, 228, 225, 1],
  "moccasin": [255, 228, 181, 1],
  "navajowhite": [255, 222, 173, 1],
  "navy": [0, 0, 128, 1],
  "oldlace": [253, 245, 230, 1],
  "olive": [128, 128, 0, 1],
  "olivedrab": [107, 142, 35, 1],
  "orange": [255, 165, 0, 1],
  "orangered": [255, 69, 0, 1],
  "orchid": [218, 112, 214, 1],
  "palegoldenrod": [238, 232, 170, 1],
  "palegreen": [152, 251, 152, 1],
  "paleturquoise": [175, 238, 238, 1],
  "palevioletred": [219, 112, 147, 1],
  "papayawhip": [255, 239, 213, 1],
  "peachpuff": [255, 218, 185, 1],
  "peru": [205, 133, 63, 1],
  "pink": [255, 192, 203, 1],
  "plum": [221, 160, 221, 1],
  "powderblue": [176, 224, 230, 1],
  "purple": [128, 0, 128, 1],
  "red": [255, 0, 0, 1],
  "rosybrown": [188, 143, 143, 1],
  "royalblue": [65, 105, 225, 1],
  "saddlebrown": [139, 69, 19, 1],
  "salmon": [250, 128, 114, 1],
  "sandybrown": [244, 164, 96, 1],
  "seagreen": [46, 139, 87, 1],
  "seashell": [255, 245, 238, 1],
  "sienna": [160, 82, 45, 1],
  "silver": [192, 192, 192, 1],
  "skyblue": [135, 206, 235, 1],
  "slateblue": [106, 90, 205, 1],
  "slategray": [112, 128, 144, 1],
  "slategrey": [112, 128, 144, 1],
  "snow": [255, 250, 250, 1],
  "springgreen": [0, 255, 127, 1],
  "steelblue": [70, 130, 180, 1],
  "tan": [210, 180, 140, 1],
  "teal": [0, 128, 128, 1],
  "thistle": [216, 191, 216, 1],
  "tomato": [255, 99, 71, 1],
  "turquoise": [64, 224, 208, 1],
  "violet": [238, 130, 238, 1],
  "wheat": [245, 222, 179, 1],
  "white": [255, 255, 255, 1],
  "whitesmoke": [245, 245, 245, 1],
  "yellow": [255, 255, 0, 1],
  "yellowgreen": [154, 205, 50, 1]
};
function clampCssByte$1(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clampCssAngle$1(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 360 ? 360 : i;
}
function clampCssFloat$1(f) {
  return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parseCssInt$1(val) {
  var str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte$1(parseFloat(str) / 100 * 255);
  }
  return clampCssByte$1(parseInt(str, 10));
}
function parseCssFloat$1(val) {
  var str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat$1(parseFloat(str) / 100);
  }
  return clampCssFloat$1(parseFloat(str));
}
function cssHueToRgb$1(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }
  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }
  if (h * 2 < 1) {
    return m2;
  }
  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }
  return m1;
}
function lerpNumber$1(a, b, p) {
  return a + (b - a) * p;
}
function setRgba$1(out2, r, g2, b, a) {
  out2[0] = r;
  out2[1] = g2;
  out2[2] = b;
  out2[3] = a;
  return out2;
}
function copyRgba$1(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
}
var colorCache$1 = new LRUCache$1(20);
var lastRemovedArr$1 = null;
function putToCache$1(colorStr, rgbaArr) {
  if (lastRemovedArr$1) {
    copyRgba$1(lastRemovedArr$1, rgbaArr);
  }
  lastRemovedArr$1 = colorCache$1.put(colorStr, lastRemovedArr$1 || rgbaArr.slice());
}
function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  var cached = colorCache$1.get(colorStr);
  if (cached) {
    return copyRgba$1(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  var str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable$1) {
    copyRgba$1(rgbaArr, kCSSColorTable$1[str]);
    putToCache$1(colorStr, rgbaArr);
    return rgbaArr;
  }
  var strLen = str.length;
  if (str.charAt(0) === "#") {
    if (strLen === 4 || strLen === 5) {
      var iv = parseInt(str.slice(1, 4), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba$1(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba$1(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
      putToCache$1(colorStr, rgbaArr);
      return rgbaArr;
    } else if (strLen === 7 || strLen === 9) {
      var iv = parseInt(str.slice(1, 7), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba$1(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba$1(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
      putToCache$1(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  var op = str.indexOf("(");
  var ep = str.indexOf(")");
  if (op !== -1 && ep + 1 === strLen) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(",");
    var alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          return params.length === 3 ? setRgba$1(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba$1(rgbaArr, 0, 0, 0, 1);
        }
        alpha = parseCssFloat$1(params.pop());
      case "rgb":
        if (params.length !== 3) {
          setRgba$1(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba$1(rgbaArr, parseCssInt$1(params[0]), parseCssInt$1(params[1]), parseCssInt$1(params[2]), alpha);
        putToCache$1(colorStr, rgbaArr);
        return rgbaArr;
      case "hsla":
        if (params.length !== 4) {
          setRgba$1(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat$1(params[3]);
        hsla2rgba$1(params, rgbaArr);
        putToCache$1(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba$1(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba$1(params, rgbaArr);
        putToCache$1(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba$1(rgbaArr, 0, 0, 0, 1);
  return;
}
function hsla2rgba$1(hsla, rgba) {
  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  var s = parseCssFloat$1(hsla[1]);
  var l = parseCssFloat$1(hsla[2]);
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba$1(rgba, clampCssByte$1(cssHueToRgb$1(m1, m2, h + 1 / 3) * 255), clampCssByte$1(cssHueToRgb$1(m1, m2, h) * 255), clampCssByte$1(cssHueToRgb$1(m1, m2, h - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function rgba2hsla$1(rgba) {
  if (!rgba) {
    return;
  }
  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B = rgba[2] / 255;
  var vMin = Math.min(R, G, B);
  var vMax = Math.max(R, G, B);
  var delta = vMax - vMin;
  var L = (vMax + vMin) / 2;
  var H;
  var S;
  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }
    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }
    if (H < 0) {
      H += 1;
    }
    if (H > 1) {
      H -= 1;
    }
  }
  var hsla = [H * 360, S, L];
  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }
  return hsla;
}
function lift(color, level) {
  var colorArr = parse(color);
  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
      if (colorArr[i] > 255) {
        colorArr[i] = 255;
      } else if (colorArr[i] < 0) {
        colorArr[i] = 0;
      }
    }
    return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
}
function fastLerp(normalizedValue, colors, out2) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  out2 = out2 || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out2[0] = clampCssByte$1(lerpNumber$1(leftColor[0], rightColor[0], dv));
  out2[1] = clampCssByte$1(lerpNumber$1(leftColor[1], rightColor[1], dv));
  out2[2] = clampCssByte$1(lerpNumber$1(leftColor[2], rightColor[2], dv));
  out2[3] = clampCssFloat$1(lerpNumber$1(leftColor[3], rightColor[3], dv));
  return out2;
}
function lerp(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse(colors[leftIndex]);
  var rightColor = parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color = stringify([
    clampCssByte$1(lerpNumber$1(leftColor[0], rightColor[0], dv)),
    clampCssByte$1(lerpNumber$1(leftColor[1], rightColor[1], dv)),
    clampCssByte$1(lerpNumber$1(leftColor[2], rightColor[2], dv)),
    clampCssFloat$1(lerpNumber$1(leftColor[3], rightColor[3], dv))
  ], "rgba");
  return fullOutput ? {
    color,
    leftIndex,
    rightIndex,
    value
  } : color;
}
function modifyHSL(color, h, s, l) {
  var colorArr = parse(color);
  if (color) {
    colorArr = rgba2hsla$1(colorArr);
    h != null && (colorArr[0] = clampCssAngle$1(h));
    s != null && (colorArr[1] = parseCssFloat$1(s));
    l != null && (colorArr[2] = parseCssFloat$1(l));
    return stringify(hsla2rgba$1(colorArr), "rgba");
  }
}
function modifyAlpha(color, alpha) {
  var colorArr = parse(color);
  if (colorArr && alpha != null) {
    colorArr[3] = clampCssFloat$1(alpha);
    return stringify(colorArr, "rgba");
  }
}
function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type === "rgba" || type === "hsva" || type === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type + "(" + colorStr + ")";
}
function lum(color, backgroundLum) {
  var arr = parse(color);
  return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
}
var mathRound$1 = Math.round;
function normalizeColor(color) {
  var opacity;
  if (!color || color === "transparent") {
    color = "none";
  } else if (typeof color === "string" && color.indexOf("rgba") > -1) {
    var arr = parse(color);
    if (arr) {
      color = "rgb(" + arr[0] + "," + arr[1] + "," + arr[2] + ")";
      opacity = arr[3];
    }
  }
  return {
    color,
    opacity: opacity == null ? 1 : opacity
  };
}
var EPSILON$4 = 1e-4;
function isAroundZero(transform2) {
  return transform2 < EPSILON$4 && transform2 > -EPSILON$4;
}
function round3(transform2) {
  return mathRound$1(transform2 * 1e3) / 1e3;
}
function round4(transform2) {
  return mathRound$1(transform2 * 1e4) / 1e4;
}
function getMatrixStr(m2) {
  return "matrix(" + round3(m2[0]) + "," + round3(m2[1]) + "," + round3(m2[2]) + "," + round3(m2[3]) + "," + round4(m2[4]) + "," + round4(m2[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function adjustTextY$1(y, lineHeight, textBaseline) {
  if (textBaseline === "top") {
    y += lineHeight / 2;
  } else if (textBaseline === "bottom") {
    y -= lineHeight / 2;
  }
  return y;
}
function hasShadow(style) {
  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);
}
function getShadowKey(displayable) {
  var style = displayable.style;
  var globalScale = displayable.getGlobalScale();
  return [
    style.shadowColor,
    (style.shadowBlur || 0).toFixed(2),
    (style.shadowOffsetX || 0).toFixed(2),
    (style.shadowOffsetY || 0).toFixed(2),
    globalScale[0],
    globalScale[1]
  ].join(",");
}
function isImagePattern(val) {
  return val && !!val.image;
}
function isSVGPattern(val) {
  return val && !!val.svgElement;
}
function isPattern(val) {
  return isImagePattern(val) || isSVGPattern(val);
}
function isLinearGradient(val) {
  return val.type === "linear";
}
function isRadialGradient(val) {
  return val.type === "radial";
}
function isGradient(val) {
  return val && (val.type === "linear" || val.type === "radial");
}
function getIdURL(id) {
  return "url(#" + id + ")";
}
function getPathPrecision(el) {
  var scale2 = el.getGlobalScale();
  var size = Math.max(scale2[0], scale2[1]);
  return Math.max(Math.ceil(Math.log(size) / Math.log(10)), 1);
}
function getSRTTransformString(transform2) {
  var x = transform2.x || 0;
  var y = transform2.y || 0;
  var rotation = (transform2.rotation || 0) * RADIAN_TO_DEGREE;
  var scaleX = retrieve2(transform2.scaleX, 1);
  var scaleY = retrieve2(transform2.scaleY, 1);
  var skewX = transform2.skewX || 0;
  var skewY = transform2.skewY || 0;
  var res = [];
  if (x || y) {
    res.push("translate(" + x + "px," + y + "px)");
  }
  if (rotation) {
    res.push("rotate(" + rotation + ")");
  }
  if (scaleX !== 1 || scaleY !== 1) {
    res.push("scale(" + scaleX + "," + scaleY + ")");
  }
  if (skewX || skewY) {
    res.push("skew(" + mathRound$1(skewX * RADIAN_TO_DEGREE) + "deg, " + mathRound$1(skewY * RADIAN_TO_DEGREE) + "deg)");
  }
  return res.join(" ");
}
var encodeBase64 = function() {
  if (env$1.hasGlobalWindow && isFunction$1(window.btoa)) {
    return function(str) {
      return window.btoa(unescape(str));
    };
  }
  if (typeof Buffer !== "undefined") {
    return function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
  return function(str) {
    return null;
  };
}();
var arraySlice = Array.prototype.slice;
function interpolateNumber$1(p02, p12, percent) {
  return (p12 - p02) * percent + p02;
}
function interpolate1DArray(out2, p02, p12, percent) {
  var len2 = p02.length;
  for (var i = 0; i < len2; i++) {
    out2[i] = interpolateNumber$1(p02[i], p12[i], percent);
  }
  return out2;
}
function interpolate2DArray(out2, p02, p12, percent) {
  var len2 = p02.length;
  var len22 = len2 && p02[0].length;
  for (var i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (var j = 0; j < len22; j++) {
      out2[i][j] = interpolateNumber$1(p02[i][j], p12[i][j], percent);
    }
  }
  return out2;
}
function add1DArray(out2, p02, p12, sign2) {
  var len2 = p02.length;
  for (var i = 0; i < len2; i++) {
    out2[i] = p02[i] + p12[i] * sign2;
  }
  return out2;
}
function add2DArray(out2, p02, p12, sign2) {
  var len2 = p02.length;
  var len22 = len2 && p02[0].length;
  for (var i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (var j = 0; j < len22; j++) {
      out2[i][j] = p02[i][j] + p12[i][j] * sign2;
    }
  }
  return out2;
}
function fillColorStops(val0, val1) {
  var len0 = val0.length;
  var len1 = val1.length;
  var shorterArr = len0 > len1 ? val1 : val0;
  var shorterLen = Math.min(len0, len1);
  var last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 };
  for (var i = shorterLen; i < Math.max(len0, len1); i++) {
    shorterArr.push({
      offset: last.offset,
      color: last.color.slice()
    });
  }
}
function fillArray(val0, val1, arrDim) {
  var arr0 = val0;
  var arr1 = val1;
  if (!arr0.push || !arr1.push) {
    return;
  }
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;
  if (arr0Len !== arr1Len) {
    var isPreviousLarger = arr0Len > arr1Len;
    if (isPreviousLarger) {
      arr0.length = arr1Len;
    } else {
      for (var i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  }
  var len2 = arr0[0] && arr0[0].length;
  for (var i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (var j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
function cloneValue(value) {
  if (isArrayLike(value)) {
    var len2 = value.length;
    if (isArrayLike(value[0])) {
      var ret2 = [];
      for (var i = 0; i < len2; i++) {
        ret2.push(arraySlice.call(value[i]));
      }
      return ret2;
    }
    return arraySlice.call(value);
  }
  return value;
}
function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]) || 0;
  rgba[1] = Math.floor(rgba[1]) || 0;
  rgba[2] = Math.floor(rgba[2]) || 0;
  rgba[3] = rgba[3] == null ? 1 : rgba[3];
  return "rgba(" + rgba.join(",") + ")";
}
function guessArrayDim(value) {
  return isArrayLike(value && value[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
  return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
  return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0];
var Track = function() {
  function Track2(propName) {
    this.keyframes = [];
    this.discrete = false;
    this._invalid = false;
    this._needsSort = false;
    this._lastFr = 0;
    this._lastFrP = 0;
    this.propName = propName;
  }
  Track2.prototype.isFinished = function() {
    return this._finished;
  };
  Track2.prototype.setFinished = function() {
    this._finished = true;
    if (this._additiveTrack) {
      this._additiveTrack.setFinished();
    }
  };
  Track2.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  };
  Track2.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  };
  Track2.prototype.addKeyframe = function(time, rawValue, easing) {
    this._needsSort = true;
    var keyframes = this.keyframes;
    var len2 = keyframes.length;
    var discrete = false;
    var valType = VALUE_TYPE_UNKOWN;
    var value = rawValue;
    if (isArrayLike(rawValue)) {
      var arrayDim = guessArrayDim(rawValue);
      valType = arrayDim;
      if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) {
        discrete = true;
      }
    } else {
      if (isNumber(rawValue) && !eqNaN(rawValue)) {
        valType = VALUE_TYPE_NUMBER;
      } else if (isString(rawValue)) {
        if (!isNaN(+rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else {
          var colorArray = parse(rawValue);
          if (colorArray) {
            value = colorArray;
            valType = VALUE_TYPE_COLOR;
          }
        }
      } else if (isGradientObject(rawValue)) {
        var parsedGradient = extend$1({}, value);
        parsedGradient.colorStops = map$1(rawValue.colorStops, function(colorStop) {
          return {
            offset: colorStop.offset,
            color: parse(colorStop.color)
          };
        });
        if (isLinearGradient(rawValue)) {
          valType = VALUE_TYPE_LINEAR_GRADIENT;
        } else if (isRadialGradient(rawValue)) {
          valType = VALUE_TYPE_RADIAL_GRADIENT;
        }
        value = parsedGradient;
      }
    }
    if (len2 === 0) {
      this.valType = valType;
    } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
      discrete = true;
    }
    this.discrete = this.discrete || discrete;
    var kf = {
      time,
      value,
      rawValue,
      percent: 0
    };
    if (easing) {
      kf.easing = easing;
      kf.easingFunc = isFunction$1(easing) ? easing : easingFuncs$1[easing] || createCubicEasingFunc(easing);
    }
    keyframes.push(kf);
    return kf;
  };
  Track2.prototype.prepare = function(maxTime, additiveTrack) {
    var kfs = this.keyframes;
    if (this._needsSort) {
      kfs.sort(function(a, b) {
        return a.time - b.time;
      });
    }
    var valType = this.valType;
    var kfsLen = kfs.length;
    var lastKf = kfs[kfsLen - 1];
    var isDiscrete = this.discrete;
    var isArr = isArrayValueType(valType);
    var isGradient2 = isGradientValueType(valType);
    for (var i = 0; i < kfsLen; i++) {
      var kf = kfs[i];
      var value = kf.value;
      var lastValue = lastKf.value;
      kf.percent = kf.time / maxTime;
      if (!isDiscrete) {
        if (isArr && i !== kfsLen - 1) {
          fillArray(value, lastValue, valType);
        } else if (isGradient2) {
          fillColorStops(value.colorStops, lastValue.colorStops);
        }
      }
    }
    if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
      this._additiveTrack = additiveTrack;
      var startValue = kfs[0].value;
      for (var i = 0; i < kfsLen; i++) {
        if (valType === VALUE_TYPE_NUMBER) {
          kfs[i].additiveValue = kfs[i].value - startValue;
        } else if (valType === VALUE_TYPE_COLOR) {
          kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);
        } else if (isArrayValueType(valType)) {
          kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i].value, startValue, -1) : add2DArray([], kfs[i].value, startValue, -1);
        }
      }
    }
  };
  Track2.prototype.step = function(target, percent) {
    if (this._finished) {
      return;
    }
    if (this._additiveTrack && this._additiveTrack._finished) {
      this._additiveTrack = null;
    }
    var isAdditive = this._additiveTrack != null;
    var valueKey = isAdditive ? "additiveValue" : "value";
    var valType = this.valType;
    var keyframes = this.keyframes;
    var kfsNum = keyframes.length;
    var propName = this.propName;
    var isValueColor = valType === VALUE_TYPE_COLOR;
    var frameIdx;
    var lastFrame = this._lastFr;
    var mathMin2 = Math.min;
    var frame;
    var nextFrame;
    if (kfsNum === 1) {
      frame = nextFrame = keyframes[0];
    } else {
      if (percent < 0) {
        frameIdx = 0;
      } else if (percent < this._lastFrP) {
        var start2 = mathMin2(lastFrame + 1, kfsNum - 1);
        for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
          if (keyframes[frameIdx].percent <= percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx, kfsNum - 2);
      } else {
        for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
          if (keyframes[frameIdx].percent > percent) {
            break;
          }
        }
        frameIdx = mathMin2(frameIdx - 1, kfsNum - 2);
      }
      nextFrame = keyframes[frameIdx + 1];
      frame = keyframes[frameIdx];
    }
    if (!(frame && nextFrame)) {
      return;
    }
    this._lastFr = frameIdx;
    this._lastFrP = percent;
    var interval = nextFrame.percent - frame.percent;
    var w = interval === 0 ? 1 : mathMin2((percent - frame.percent) / interval, 1);
    if (nextFrame.easingFunc) {
      w = nextFrame.easingFunc(w);
    }
    var targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
    if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
      targetArr = this._additiveValue = [];
    }
    if (this.discrete) {
      target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;
    } else if (isArrayValueType(valType)) {
      valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
    } else if (isGradientValueType(valType)) {
      var val = frame[valueKey];
      var nextVal_1 = nextFrame[valueKey];
      var isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT;
      target[propName] = {
        type: isLinearGradient_1 ? "linear" : "radial",
        x: interpolateNumber$1(val.x, nextVal_1.x, w),
        y: interpolateNumber$1(val.y, nextVal_1.y, w),
        colorStops: map$1(val.colorStops, function(colorStop, idx) {
          var nextColorStop = nextVal_1.colorStops[idx];
          return {
            offset: interpolateNumber$1(colorStop.offset, nextColorStop.offset, w),
            color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
          };
        }),
        global: nextVal_1.global
      };
      if (isLinearGradient_1) {
        target[propName].x2 = interpolateNumber$1(val.x2, nextVal_1.x2, w);
        target[propName].y2 = interpolateNumber$1(val.y2, nextVal_1.y2, w);
      } else {
        target[propName].r = interpolateNumber$1(val.r, nextVal_1.r, w);
      }
    } else if (isValueColor) {
      interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
      if (!isAdditive) {
        target[propName] = rgba2String(targetArr);
      }
    } else {
      var value = interpolateNumber$1(frame[valueKey], nextFrame[valueKey], w);
      if (isAdditive) {
        this._additiveValue = value;
      } else {
        target[propName] = value;
      }
    }
    if (isAdditive) {
      this._addToTarget(target);
    }
  };
  Track2.prototype._addToTarget = function(target) {
    var valType = this.valType;
    var propName = this.propName;
    var additiveValue = this._additiveValue;
    if (valType === VALUE_TYPE_NUMBER) {
      target[propName] = target[propName] + additiveValue;
    } else if (valType === VALUE_TYPE_COLOR) {
      parse(target[propName], tmpRgba);
      add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
      target[propName] = rgba2String(tmpRgba);
    } else if (valType === VALUE_TYPE_1D_ARRAY) {
      add1DArray(target[propName], target[propName], additiveValue, 1);
    } else if (valType === VALUE_TYPE_2D_ARRAY) {
      add2DArray(target[propName], target[propName], additiveValue, 1);
    }
  };
  return Track2;
}();
var Animator = function() {
  function Animator2(target, loop, allowDiscreteAnimation, additiveTo) {
    this._tracks = {};
    this._trackKeys = [];
    this._maxTime = 0;
    this._started = 0;
    this._clip = null;
    this._target = target;
    this._loop = loop;
    if (loop && additiveTo) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = additiveTo;
    this._allowDiscrete = allowDiscreteAnimation;
  }
  Animator2.prototype.getMaxTime = function() {
    return this._maxTime;
  };
  Animator2.prototype.getDelay = function() {
    return this._delay;
  };
  Animator2.prototype.getLoop = function() {
    return this._loop;
  };
  Animator2.prototype.getTarget = function() {
    return this._target;
  };
  Animator2.prototype.changeTarget = function(target) {
    this._target = target;
  };
  Animator2.prototype.when = function(time, props, easing) {
    return this.whenWithKeys(time, props, keys(props), easing);
  };
  Animator2.prototype.whenWithKeys = function(time, props, propNames, easing) {
    var tracks = this._tracks;
    for (var i = 0; i < propNames.length; i++) {
      var propName = propNames[i];
      var track = tracks[propName];
      if (!track) {
        track = tracks[propName] = new Track(propName);
        var initialValue = void 0;
        var additiveTrack = this._getAdditiveTrack(propName);
        if (additiveTrack) {
          var addtiveTrackKfs = additiveTrack.keyframes;
          var lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
          initialValue = lastFinalKf && lastFinalKf.value;
          if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
            initialValue = rgba2String(initialValue);
          }
        } else {
          initialValue = this._target[propName];
        }
        if (initialValue == null) {
          continue;
        }
        if (time > 0) {
          track.addKeyframe(0, cloneValue(initialValue), easing);
        }
        this._trackKeys.push(propName);
      }
      track.addKeyframe(time, cloneValue(props[propName]), easing);
    }
    this._maxTime = Math.max(this._maxTime, time);
    return this;
  };
  Animator2.prototype.pause = function() {
    this._clip.pause();
    this._paused = true;
  };
  Animator2.prototype.resume = function() {
    this._clip.resume();
    this._paused = false;
  };
  Animator2.prototype.isPaused = function() {
    return !!this._paused;
  };
  Animator2.prototype.duration = function(duration) {
    this._maxTime = duration;
    this._force = true;
    return this;
  };
  Animator2.prototype._doneCallback = function() {
    this._setTracksFinished();
    this._clip = null;
    var doneList = this._doneCbs;
    if (doneList) {
      var len2 = doneList.length;
      for (var i = 0; i < len2; i++) {
        doneList[i].call(this);
      }
    }
  };
  Animator2.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var animation = this.animation;
    var abortedList = this._abortedCbs;
    if (animation) {
      animation.removeClip(this._clip);
    }
    this._clip = null;
    if (abortedList) {
      for (var i = 0; i < abortedList.length; i++) {
        abortedList[i].call(this);
      }
    }
  };
  Animator2.prototype._setTracksFinished = function() {
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i = 0; i < tracksKeys.length; i++) {
      tracks[tracksKeys[i]].setFinished();
    }
  };
  Animator2.prototype._getAdditiveTrack = function(trackName) {
    var additiveTrack;
    var additiveAnimators = this._additiveAnimators;
    if (additiveAnimators) {
      for (var i = 0; i < additiveAnimators.length; i++) {
        var track = additiveAnimators[i].getTrack(trackName);
        if (track) {
          additiveTrack = track;
        }
      }
    }
    return additiveTrack;
  };
  Animator2.prototype.start = function(easing) {
    if (this._started > 0) {
      return;
    }
    this._started = 1;
    var self2 = this;
    var tracks = [];
    var maxTime = this._maxTime || 0;
    for (var i = 0; i < this._trackKeys.length; i++) {
      var propName = this._trackKeys[i];
      var track = this._tracks[propName];
      var additiveTrack = this._getAdditiveTrack(propName);
      var kfs = track.keyframes;
      var kfsNum = kfs.length;
      track.prepare(maxTime, additiveTrack);
      if (track.needsAnimate()) {
        if (!this._allowDiscrete && track.discrete) {
          var lastKf = kfs[kfsNum - 1];
          if (lastKf) {
            self2._target[track.propName] = lastKf.rawValue;
          }
          track.setFinished();
        } else {
          tracks.push(track);
        }
      }
    }
    if (tracks.length || this._force) {
      var clip2 = new Clip$1({
        life: maxTime,
        loop: this._loop,
        delay: this._delay || 0,
        onframe: function(percent) {
          self2._started = 2;
          var additiveAnimators = self2._additiveAnimators;
          if (additiveAnimators) {
            var stillHasAdditiveAnimator = false;
            for (var i2 = 0; i2 < additiveAnimators.length; i2++) {
              if (additiveAnimators[i2]._clip) {
                stillHasAdditiveAnimator = true;
                break;
              }
            }
            if (!stillHasAdditiveAnimator) {
              self2._additiveAnimators = null;
            }
          }
          for (var i2 = 0; i2 < tracks.length; i2++) {
            tracks[i2].step(self2._target, percent);
          }
          var onframeList = self2._onframeCbs;
          if (onframeList) {
            for (var i2 = 0; i2 < onframeList.length; i2++) {
              onframeList[i2](self2._target, percent);
            }
          }
        },
        ondestroy: function() {
          self2._doneCallback();
        }
      });
      this._clip = clip2;
      if (this.animation) {
        this.animation.addClip(clip2);
      }
      if (easing) {
        clip2.setEasing(easing);
      }
    } else {
      this._doneCallback();
    }
    return this;
  };
  Animator2.prototype.stop = function(forwardToLast) {
    if (!this._clip) {
      return;
    }
    var clip2 = this._clip;
    if (forwardToLast) {
      clip2.onframe(1);
    }
    this._abortedCallback();
  };
  Animator2.prototype.delay = function(time) {
    this._delay = time;
    return this;
  };
  Animator2.prototype.during = function(cb) {
    if (cb) {
      if (!this._onframeCbs) {
        this._onframeCbs = [];
      }
      this._onframeCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.done = function(cb) {
    if (cb) {
      if (!this._doneCbs) {
        this._doneCbs = [];
      }
      this._doneCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.aborted = function(cb) {
    if (cb) {
      if (!this._abortedCbs) {
        this._abortedCbs = [];
      }
      this._abortedCbs.push(cb);
    }
    return this;
  };
  Animator2.prototype.getClip = function() {
    return this._clip;
  };
  Animator2.prototype.getTrack = function(propName) {
    return this._tracks[propName];
  };
  Animator2.prototype.getTracks = function() {
    var _this = this;
    return map$1(this._trackKeys, function(key) {
      return _this._tracks[key];
    });
  };
  Animator2.prototype.stopTracks = function(propNames, forwardToLast) {
    if (!propNames.length || !this._clip) {
      return true;
    }
    var tracks = this._tracks;
    var tracksKeys = this._trackKeys;
    for (var i = 0; i < propNames.length; i++) {
      var track = tracks[propNames[i]];
      if (track && !track.isFinished()) {
        if (forwardToLast) {
          track.step(this._target, 1);
        } else if (this._started === 1) {
          track.step(this._target, 0);
        }
        track.setFinished();
      }
    }
    var allAborted = true;
    for (var i = 0; i < tracksKeys.length; i++) {
      if (!tracks[tracksKeys[i]].isFinished()) {
        allAborted = false;
        break;
      }
    }
    if (allAborted) {
      this._abortedCallback();
    }
    return allAborted;
  };
  Animator2.prototype.saveTo = function(target, trackKeys, firstOrLast) {
    if (!target) {
      return;
    }
    trackKeys = trackKeys || this._trackKeys;
    for (var i = 0; i < trackKeys.length; i++) {
      var propName = trackKeys[i];
      var track = this._tracks[propName];
      if (!track || track.isFinished()) {
        continue;
      }
      var kfs = track.keyframes;
      var kf = kfs[firstOrLast ? 0 : kfs.length - 1];
      if (kf) {
        target[propName] = cloneValue(kf.rawValue);
      }
    }
  };
  Animator2.prototype.__changeFinalValue = function(finalProps, trackKeys) {
    trackKeys = trackKeys || keys(finalProps);
    for (var i = 0; i < trackKeys.length; i++) {
      var propName = trackKeys[i];
      var track = this._tracks[propName];
      if (!track) {
        continue;
      }
      var kfs = track.keyframes;
      if (kfs.length > 1) {
        var lastKf = kfs.pop();
        track.addKeyframe(lastKf.time, finalProps[propName]);
        track.prepare(this._maxTime, track.getAdditiveTrack());
      }
    }
  };
  return Animator2;
}();
var Animator$1 = Animator;
function getTime() {
  return new Date().getTime();
}
var Animation = function(_super) {
  __extends(Animation2, _super);
  function Animation2(opts) {
    var _this = _super.call(this) || this;
    _this._running = false;
    _this._time = 0;
    _this._pausedTime = 0;
    _this._pauseStart = 0;
    _this._paused = false;
    opts = opts || {};
    _this.stage = opts.stage || {};
    return _this;
  }
  Animation2.prototype.addClip = function(clip2) {
    if (clip2.animation) {
      this.removeClip(clip2);
    }
    if (!this._head) {
      this._head = this._tail = clip2;
    } else {
      this._tail.next = clip2;
      clip2.prev = this._tail;
      clip2.next = null;
      this._tail = clip2;
    }
    clip2.animation = this;
  };
  Animation2.prototype.addAnimator = function(animator) {
    animator.animation = this;
    var clip2 = animator.getClip();
    if (clip2) {
      this.addClip(clip2);
    }
  };
  Animation2.prototype.removeClip = function(clip2) {
    if (!clip2.animation) {
      return;
    }
    var prev = clip2.prev;
    var next = clip2.next;
    if (prev) {
      prev.next = next;
    } else {
      this._head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this._tail = prev;
    }
    clip2.next = clip2.prev = clip2.animation = null;
  };
  Animation2.prototype.removeAnimator = function(animator) {
    var clip2 = animator.getClip();
    if (clip2) {
      this.removeClip(clip2);
    }
    animator.animation = null;
  };
  Animation2.prototype.update = function(notTriggerFrameAndStageUpdate) {
    var time = getTime() - this._pausedTime;
    var delta = time - this._time;
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      var finished = clip2.step(time, delta);
      if (finished) {
        clip2.ondestroy();
        this.removeClip(clip2);
        clip2 = nextClip;
      } else {
        clip2 = nextClip;
      }
    }
    this._time = time;
    if (!notTriggerFrameAndStageUpdate) {
      this.trigger("frame", delta);
      this.stage.update && this.stage.update();
    }
  };
  Animation2.prototype._startLoop = function() {
    var self2 = this;
    this._running = true;
    function step() {
      if (self2._running) {
        requestAnimationFrame$2(step);
        !self2._paused && self2.update();
      }
    }
    requestAnimationFrame$2(step);
  };
  Animation2.prototype.start = function() {
    if (this._running) {
      return;
    }
    this._time = getTime();
    this._pausedTime = 0;
    this._startLoop();
  };
  Animation2.prototype.stop = function() {
    this._running = false;
  };
  Animation2.prototype.pause = function() {
    if (!this._paused) {
      this._pauseStart = getTime();
      this._paused = true;
    }
  };
  Animation2.prototype.resume = function() {
    if (this._paused) {
      this._pausedTime += getTime() - this._pauseStart;
      this._paused = false;
    }
  };
  Animation2.prototype.clear = function() {
    var clip2 = this._head;
    while (clip2) {
      var nextClip = clip2.next;
      clip2.prev = clip2.next = clip2.animation = null;
      clip2 = nextClip;
    }
    this._head = this._tail = null;
  };
  Animation2.prototype.isFinished = function() {
    return this._head == null;
  };
  Animation2.prototype.animate = function(target, options) {
    options = options || {};
    this.start();
    var animator = new Animator$1(target, options.loop);
    this.addAnimator(animator);
    return animator;
  };
  return Animation2;
}(Eventful$1);
var Animation$1 = Animation;
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env$1.domSupported;
var localNativeListenerNames = function() {
  var mouseHandlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  var touchHandlerNames = [
    "touchstart",
    "touchend",
    "touchmove"
  ];
  var pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  var pointerHandlerNames = map$1(mouseHandlerNames, function(name) {
    var nm = name.replace("mouse", "pointer");
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();
var globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
  var pointerType = event.pointerType;
  return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
  scope.touching = true;
  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }
  scope.touchTimer = setTimeout(function() {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
}
function markTouch(event) {
  event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance, event) {
  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
}
function isLocalEl(instance, el) {
  var elTmp = el;
  var isLocal = false;
  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
    elTmp = elTmp.parentNode;
  }
  return isLocal;
}
var FakeGlobalEvent = function() {
  function FakeGlobalEvent2(instance, event) {
    this.stopPropagation = noop$1;
    this.stopImmediatePropagation = noop$1;
    this.preventDefault = noop$1;
    this.type = event.type;
    this.target = this.currentTarget = instance.dom;
    this.pointerType = event.pointerType;
    this.clientX = event.clientX;
    this.clientY = event.clientY;
  }
  return FakeGlobalEvent2;
}();
var localDOMHandlers = {
  mousedown: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__mayPointerCapture = [event.zrX, event.zrY];
    this.trigger("mousedown", event);
  },
  mousemove: function(event) {
    event = normalizeEvent(this.dom, event);
    var downPoint = this.__mayPointerCapture;
    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
      this.__togglePointerCapture(true);
    }
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    event = normalizeEvent(this.dom, event);
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
  },
  mouseout: function(event) {
    event = normalizeEvent(this.dom, event);
    var element = event.toElement || event.relatedTarget;
    if (!isLocalEl(this, element)) {
      if (this.__pointerCapturing) {
        event.zrEventControl = "no_globalout";
      }
      this.trigger("mouseout", event);
    }
  },
  wheel: function(event) {
    wheelEventSupported = true;
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  mousewheel: function(event) {
    if (wheelEventSupported) {
      return;
    }
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  touchstart: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.__lastTouchMoment = new Date();
    this.handler.processGesture(event, "start");
    localDOMHandlers.mousemove.call(this, event);
    localDOMHandlers.mousedown.call(this, event);
  },
  touchmove: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "change");
    localDOMHandlers.mousemove.call(this, event);
  },
  touchend: function(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "end");
    localDOMHandlers.mouseup.call(this, event);
    if (+new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event);
    }
  },
  pointerdown: function(event) {
    localDOMHandlers.mousedown.call(this, event);
  },
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    localDOMHandlers.mouseup.call(this, event);
  },
  pointerout: function(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mouseout.call(this, event);
    }
  }
};
each$f(["click", "dblclick", "contextmenu"], function(name) {
  localDOMHandlers[name] = function(event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
var globalDOMHandlers = {
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      globalDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    globalDOMHandlers.mouseup.call(this, event);
  },
  mousemove: function(event) {
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    var pointerCaptureReleasing = this.__pointerCapturing;
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
    if (pointerCaptureReleasing) {
      event.zrEventControl = "only_globalout";
      this.trigger("mouseout", event);
    }
  }
};
function mountLocalDOMEventListeners(instance, scope) {
  var domHandlers = scope.domHandlers;
  if (env$1.pointerEventsSupported) {
    each$f(localNativeListenerNames.pointer, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        domHandlers[nativeEventName].call(instance, event);
      });
    });
  } else {
    if (env$1.touchEventsSupported) {
      each$f(localNativeListenerNames.touch, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance, event);
          setTouchTimer(scope);
        });
      });
    }
    each$f(localNativeListenerNames.mouse, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        event = getNativeEvent(event);
        if (!scope.touching) {
          domHandlers[nativeEventName].call(instance, event);
        }
      });
    });
  }
}
function mountGlobalDOMEventListeners(instance, scope) {
  if (env$1.pointerEventsSupported) {
    each$f(globalNativeListenerNames.pointer, mount);
  } else if (!env$1.touchEventsSupported) {
    each$f(globalNativeListenerNames.mouse, mount);
  }
  function mount(nativeEventName) {
    function nativeEventListener(event) {
      event = getNativeEvent(event);
      if (!isLocalEl(instance, event.target)) {
        event = normalizeGlobalEvent(instance, event);
        scope.domHandlers[nativeEventName].call(instance, event);
      }
    }
    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
  }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
  var mounted = scope.mounted;
  for (var nativeEventName in mounted) {
    if (mounted.hasOwnProperty(nativeEventName)) {
      removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }
  scope.mounted = {};
}
var DOMHandlerScope = function() {
  function DOMHandlerScope2(domTarget, domHandlers) {
    this.mounted = {};
    this.listenerOpts = {};
    this.touching = false;
    this.domTarget = domTarget;
    this.domHandlers = domHandlers;
  }
  return DOMHandlerScope2;
}();
var HandlerDomProxy = function(_super) {
  __extends(HandlerDomProxy2, _super);
  function HandlerDomProxy2(dom, painterRoot) {
    var _this = _super.call(this) || this;
    _this.__pointerCapturing = false;
    _this.dom = dom;
    _this.painterRoot = painterRoot;
    _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
    if (globalEventSupported) {
      _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
    }
    mountLocalDOMEventListeners(_this, _this._localHandlerScope);
    return _this;
  }
  HandlerDomProxy2.prototype.dispose = function() {
    unmountDOMEventListeners(this._localHandlerScope);
    if (globalEventSupported) {
      unmountDOMEventListeners(this._globalHandlerScope);
    }
  };
  HandlerDomProxy2.prototype.setCursor = function(cursorStyle) {
    this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
  };
  HandlerDomProxy2.prototype.__togglePointerCapture = function(isPointerCapturing) {
    this.__mayPointerCapture = null;
    if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
      this.__pointerCapturing = isPointerCapturing;
      var globalHandlerScope = this._globalHandlerScope;
      isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
    }
  };
  return HandlerDomProxy2;
}(Eventful$1);
var HandlerProxy = HandlerDomProxy;
var dpr = 1;
if (env$1.hasGlobalWindow) {
  dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
}
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = 0.4;
var DARK_LABEL_COLOR = "#333";
var LIGHT_LABEL_COLOR = "#ccc";
var LIGHTER_LABEL_COLOR = "#eee";
function create$2() {
  return [1, 0, 0, 1, 0, 0];
}
function identity(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  out2[4] = 0;
  out2[5] = 0;
  return out2;
}
function copy(out2, m2) {
  out2[0] = m2[0];
  out2[1] = m2[1];
  out2[2] = m2[2];
  out2[3] = m2[3];
  out2[4] = m2[4];
  out2[5] = m2[5];
  return out2;
}
function mul(out2, m1, m2) {
  var out0 = m1[0] * m2[0] + m1[2] * m2[1];
  var out1 = m1[1] * m2[0] + m1[3] * m2[1];
  var out22 = m1[0] * m2[2] + m1[2] * m2[3];
  var out3 = m1[1] * m2[2] + m1[3] * m2[3];
  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out2[0] = out0;
  out2[1] = out1;
  out2[2] = out22;
  out2[3] = out3;
  out2[4] = out4;
  out2[5] = out5;
  return out2;
}
function translate(out2, a, v) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4] + v[0];
  out2[5] = a[5] + v[1];
  return out2;
}
function rotate(out2, a, rad2) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var st = Math.sin(rad2);
  var ct = Math.cos(rad2);
  out2[0] = aa * ct + ab * st;
  out2[1] = -aa * st + ab * ct;
  out2[2] = ac * ct + ad * st;
  out2[3] = -ac * st + ct * ad;
  out2[4] = ct * atx + st * aty;
  out2[5] = ct * aty - st * atx;
  return out2;
}
function scale$1(out2, a, v) {
  var vx = v[0];
  var vy = v[1];
  out2[0] = a[0] * vx;
  out2[1] = a[1] * vy;
  out2[2] = a[2] * vx;
  out2[3] = a[3] * vy;
  out2[4] = a[4] * vx;
  out2[5] = a[5] * vy;
  return out2;
}
function invert(out2, a) {
  var aa = a[0];
  var ac = a[2];
  var atx = a[4];
  var ab = a[1];
  var ad = a[3];
  var aty = a[5];
  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = ad * det;
  out2[1] = -ab * det;
  out2[2] = -ac * det;
  out2[3] = aa * det;
  out2[4] = (ac * aty - ad * atx) * det;
  out2[5] = (ab * atx - aa * aty) * det;
  return out2;
}
function clone$2(a) {
  var b = create$2();
  copy(b, a);
  return b;
}
var mIdentity = identity;
var EPSILON$3 = 5e-5;
function isNotAroundZero(val) {
  return val > EPSILON$3 || val < -EPSILON$3;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create$2();
var abs$1 = Math.abs;
var Transformable = function() {
  function Transformable2() {
  }
  Transformable2.prototype.getLocalTransform = function(m2) {
    return Transformable2.getLocalTransform(this, m2);
  };
  Transformable2.prototype.setPosition = function(arr) {
    this.x = arr[0];
    this.y = arr[1];
  };
  Transformable2.prototype.setScale = function(arr) {
    this.scaleX = arr[0];
    this.scaleY = arr[1];
  };
  Transformable2.prototype.setSkew = function(arr) {
    this.skewX = arr[0];
    this.skewY = arr[1];
  };
  Transformable2.prototype.setOrigin = function(arr) {
    this.originX = arr[0];
    this.originY = arr[1];
  };
  Transformable2.prototype.needLocalTransform = function() {
    return isNotAroundZero(this.rotation) || isNotAroundZero(this.x) || isNotAroundZero(this.y) || isNotAroundZero(this.scaleX - 1) || isNotAroundZero(this.scaleY - 1) || isNotAroundZero(this.skewX) || isNotAroundZero(this.skewY);
  };
  Transformable2.prototype.updateTransform = function() {
    var parentTransform = this.parent && this.parent.transform;
    var needLocalTransform = this.needLocalTransform();
    var m2 = this.transform;
    if (!(needLocalTransform || parentTransform)) {
      m2 && mIdentity(m2);
      return;
    }
    m2 = m2 || create$2();
    if (needLocalTransform) {
      this.getLocalTransform(m2);
    } else {
      mIdentity(m2);
    }
    if (parentTransform) {
      if (needLocalTransform) {
        mul(m2, parentTransform, m2);
      } else {
        copy(m2, parentTransform);
      }
    }
    this.transform = m2;
    this._resolveGlobalScaleRatio(m2);
  };
  Transformable2.prototype._resolveGlobalScaleRatio = function(m2) {
    var globalScaleRatio = this.globalScaleRatio;
    if (globalScaleRatio != null && globalScaleRatio !== 1) {
      this.getGlobalScale(scaleTmp);
      var relX = scaleTmp[0] < 0 ? -1 : 1;
      var relY = scaleTmp[1] < 0 ? -1 : 1;
      var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
      var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
      m2[0] *= sx;
      m2[1] *= sx;
      m2[2] *= sy;
      m2[3] *= sy;
    }
    this.invTransform = this.invTransform || create$2();
    invert(this.invTransform, m2);
  };
  Transformable2.prototype.getComputedTransform = function() {
    var transformNode = this;
    var ancestors = [];
    while (transformNode) {
      ancestors.push(transformNode);
      transformNode = transformNode.parent;
    }
    while (transformNode = ancestors.pop()) {
      transformNode.updateTransform();
    }
    return this.transform;
  };
  Transformable2.prototype.setLocalTransform = function(m2) {
    if (!m2) {
      return;
    }
    var sx = m2[0] * m2[0] + m2[1] * m2[1];
    var sy = m2[2] * m2[2] + m2[3] * m2[3];
    var rotation = Math.atan2(m2[1], m2[0]);
    var shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
    sy = Math.sqrt(sy) * Math.cos(shearX);
    sx = Math.sqrt(sx);
    this.skewX = shearX;
    this.skewY = 0;
    this.rotation = -rotation;
    this.x = +m2[4];
    this.y = +m2[5];
    this.scaleX = sx;
    this.scaleY = sy;
    this.originX = 0;
    this.originY = 0;
  };
  Transformable2.prototype.decomposeTransform = function() {
    if (!this.transform) {
      return;
    }
    var parent = this.parent;
    var m2 = this.transform;
    if (parent && parent.transform) {
      mul(tmpTransform, parent.invTransform, m2);
      m2 = tmpTransform;
    }
    var ox = this.originX;
    var oy = this.originY;
    if (ox || oy) {
      originTransform[4] = ox;
      originTransform[5] = oy;
      mul(tmpTransform, m2, originTransform);
      tmpTransform[4] -= ox;
      tmpTransform[5] -= oy;
      m2 = tmpTransform;
    }
    this.setLocalTransform(m2);
  };
  Transformable2.prototype.getGlobalScale = function(out2) {
    var m2 = this.transform;
    out2 = out2 || [];
    if (!m2) {
      out2[0] = 1;
      out2[1] = 1;
      return out2;
    }
    out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
    out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
    if (m2[0] < 0) {
      out2[0] = -out2[0];
    }
    if (m2[3] < 0) {
      out2[1] = -out2[1];
    }
    return out2;
  };
  Transformable2.prototype.transformCoordToLocal = function(x, y) {
    var v22 = [x, y];
    var invTransform = this.invTransform;
    if (invTransform) {
      applyTransform$1(v22, v22, invTransform);
    }
    return v22;
  };
  Transformable2.prototype.transformCoordToGlobal = function(x, y) {
    var v22 = [x, y];
    var transform2 = this.transform;
    if (transform2) {
      applyTransform$1(v22, v22, transform2);
    }
    return v22;
  };
  Transformable2.prototype.getLineScale = function() {
    var m2 = this.transform;
    return m2 && abs$1(m2[0] - 1) > 1e-10 && abs$1(m2[3] - 1) > 1e-10 ? Math.sqrt(abs$1(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
  };
  Transformable2.prototype.copyTransform = function(source) {
    copyTransform(this, source);
  };
  Transformable2.getLocalTransform = function(target, m2) {
    m2 = m2 || [];
    var ox = target.originX || 0;
    var oy = target.originY || 0;
    var sx = target.scaleX;
    var sy = target.scaleY;
    var ax = target.anchorX;
    var ay = target.anchorY;
    var rotation = target.rotation || 0;
    var x = target.x;
    var y = target.y;
    var skewX = target.skewX ? Math.tan(target.skewX) : 0;
    var skewY = target.skewY ? Math.tan(-target.skewY) : 0;
    if (ox || oy || ax || ay) {
      var dx = ox + ax;
      var dy = oy + ay;
      m2[4] = -dx * sx - skewX * dy * sy;
      m2[5] = -dy * sy - skewY * dx * sx;
    } else {
      m2[4] = m2[5] = 0;
    }
    m2[0] = sx;
    m2[3] = sy;
    m2[1] = skewY * sx;
    m2[2] = skewX * sy;
    rotation && rotate(m2, m2, rotation);
    m2[4] += ox + x;
    m2[5] += oy + y;
    return m2;
  };
  Transformable2.initDefaultProps = function() {
    var proto = Transformable2.prototype;
    proto.scaleX = proto.scaleY = proto.globalScaleRatio = 1;
    proto.x = proto.y = proto.originX = proto.originY = proto.skewX = proto.skewY = proto.rotation = proto.anchorX = proto.anchorY = 0;
  }();
  return Transformable2;
}();
var TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(target, source) {
  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    var propName = TRANSFORMABLE_PROPS[i];
    target[propName] = source[propName];
  }
}
var Point = function() {
  function Point2(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  }
  Point2.prototype.copy = function(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  };
  Point2.prototype.clone = function() {
    return new Point2(this.x, this.y);
  };
  Point2.prototype.set = function(x, y) {
    this.x = x;
    this.y = y;
    return this;
  };
  Point2.prototype.equal = function(other) {
    return other.x === this.x && other.y === this.y;
  };
  Point2.prototype.add = function(other) {
    this.x += other.x;
    this.y += other.y;
    return this;
  };
  Point2.prototype.scale = function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  };
  Point2.prototype.scaleAndAdd = function(other, scalar) {
    this.x += other.x * scalar;
    this.y += other.y * scalar;
  };
  Point2.prototype.sub = function(other) {
    this.x -= other.x;
    this.y -= other.y;
    return this;
  };
  Point2.prototype.dot = function(other) {
    return this.x * other.x + this.y * other.y;
  };
  Point2.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  Point2.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  };
  Point2.prototype.normalize = function() {
    var len2 = this.len();
    this.x /= len2;
    this.y /= len2;
    return this;
  };
  Point2.prototype.distance = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point2.prototype.distanceSquare = function(other) {
    var dx = this.x - other.x;
    var dy = this.y - other.y;
    return dx * dx + dy * dy;
  };
  Point2.prototype.negate = function() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  };
  Point2.prototype.transform = function(m2) {
    if (!m2) {
      return;
    }
    var x = this.x;
    var y = this.y;
    this.x = m2[0] * x + m2[2] * y + m2[4];
    this.y = m2[1] * x + m2[3] * y + m2[5];
    return this;
  };
  Point2.prototype.toArray = function(out2) {
    out2[0] = this.x;
    out2[1] = this.y;
    return out2;
  };
  Point2.prototype.fromArray = function(input) {
    this.x = input[0];
    this.y = input[1];
  };
  Point2.set = function(p, x, y) {
    p.x = x;
    p.y = y;
  };
  Point2.copy = function(p, p22) {
    p.x = p22.x;
    p.y = p22.y;
  };
  Point2.len = function(p) {
    return Math.sqrt(p.x * p.x + p.y * p.y);
  };
  Point2.lenSquare = function(p) {
    return p.x * p.x + p.y * p.y;
  };
  Point2.dot = function(p02, p12) {
    return p02.x * p12.x + p02.y * p12.y;
  };
  Point2.add = function(out2, p02, p12) {
    out2.x = p02.x + p12.x;
    out2.y = p02.y + p12.y;
  };
  Point2.sub = function(out2, p02, p12) {
    out2.x = p02.x - p12.x;
    out2.y = p02.y - p12.y;
  };
  Point2.scale = function(out2, p02, scalar) {
    out2.x = p02.x * scalar;
    out2.y = p02.y * scalar;
  };
  Point2.scaleAndAdd = function(out2, p02, p12, scalar) {
    out2.x = p02.x + p12.x * scalar;
    out2.y = p02.y + p12.y * scalar;
  };
  Point2.lerp = function(out2, p02, p12, t) {
    var onet = 1 - t;
    out2.x = onet * p02.x + t * p12.x;
    out2.y = onet * p02.y + t * p12.y;
  };
  return Point2;
}();
var Point$1 = Point;
var mathMin$b = Math.min;
var mathMax$b = Math.max;
var lt = new Point$1();
var rb = new Point$1();
var lb = new Point$1();
var rt = new Point$1();
var minTv$1 = new Point$1();
var maxTv$1 = new Point$1();
var BoundingRect = function() {
  function BoundingRect2(x, y, width, height) {
    if (width < 0) {
      x = x + width;
      width = -width;
    }
    if (height < 0) {
      y = y + height;
      height = -height;
    }
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  BoundingRect2.prototype.union = function(other) {
    var x = mathMin$b(other.x, this.x);
    var y = mathMin$b(other.y, this.y);
    if (isFinite(this.x) && isFinite(this.width)) {
      this.width = mathMax$b(other.x + other.width, this.x + this.width) - x;
    } else {
      this.width = other.width;
    }
    if (isFinite(this.y) && isFinite(this.height)) {
      this.height = mathMax$b(other.y + other.height, this.y + this.height) - y;
    } else {
      this.height = other.height;
    }
    this.x = x;
    this.y = y;
  };
  BoundingRect2.prototype.applyTransform = function(m2) {
    BoundingRect2.applyTransform(this, this, m2);
  };
  BoundingRect2.prototype.calculateTransform = function(b) {
    var a = this;
    var sx = b.width / a.width;
    var sy = b.height / a.height;
    var m2 = create$2();
    translate(m2, m2, [-a.x, -a.y]);
    scale$1(m2, m2, [sx, sy]);
    translate(m2, m2, [b.x, b.y]);
    return m2;
  };
  BoundingRect2.prototype.intersect = function(b, mtv) {
    if (!b) {
      return false;
    }
    if (!(b instanceof BoundingRect2)) {
      b = BoundingRect2.create(b);
    }
    var a = this;
    var ax0 = a.x;
    var ax1 = a.x + a.width;
    var ay0 = a.y;
    var ay1 = a.y + a.height;
    var bx0 = b.x;
    var bx1 = b.x + b.width;
    var by0 = b.y;
    var by1 = b.y + b.height;
    var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    if (mtv) {
      var dMin = Infinity;
      var dMax = 0;
      var d0 = Math.abs(ax1 - bx0);
      var d1 = Math.abs(bx1 - ax0);
      var d2 = Math.abs(ay1 - by0);
      var d3 = Math.abs(by1 - ay0);
      var dx = Math.min(d0, d1);
      var dy = Math.min(d2, d3);
      if (ax1 < bx0 || bx1 < ax0) {
        if (dx > dMax) {
          dMax = dx;
          if (d0 < d1) {
            Point$1.set(maxTv$1, -d0, 0);
          } else {
            Point$1.set(maxTv$1, d1, 0);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d0 < d1) {
            Point$1.set(minTv$1, d0, 0);
          } else {
            Point$1.set(minTv$1, -d1, 0);
          }
        }
      }
      if (ay1 < by0 || by1 < ay0) {
        if (dy > dMax) {
          dMax = dy;
          if (d2 < d3) {
            Point$1.set(maxTv$1, 0, -d2);
          } else {
            Point$1.set(maxTv$1, 0, d3);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d2 < d3) {
            Point$1.set(minTv$1, 0, d2);
          } else {
            Point$1.set(minTv$1, 0, -d3);
          }
        }
      }
    }
    if (mtv) {
      Point$1.copy(mtv, overlap ? minTv$1 : maxTv$1);
    }
    return overlap;
  };
  BoundingRect2.prototype.contain = function(x, y) {
    var rect = this;
    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  };
  BoundingRect2.prototype.clone = function() {
    return new BoundingRect2(this.x, this.y, this.width, this.height);
  };
  BoundingRect2.prototype.copy = function(other) {
    BoundingRect2.copy(this, other);
  };
  BoundingRect2.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  };
  BoundingRect2.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  };
  BoundingRect2.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  };
  BoundingRect2.create = function(rect) {
    return new BoundingRect2(rect.x, rect.y, rect.width, rect.height);
  };
  BoundingRect2.copy = function(target, source) {
    target.x = source.x;
    target.y = source.y;
    target.width = source.width;
    target.height = source.height;
  };
  BoundingRect2.applyTransform = function(target, source, m2) {
    if (!m2) {
      if (target !== source) {
        BoundingRect2.copy(target, source);
      }
      return;
    }
    if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
      var sx = m2[0];
      var sy = m2[3];
      var tx = m2[4];
      var ty = m2[5];
      target.x = source.x * sx + tx;
      target.y = source.y * sy + ty;
      target.width = source.width * sx;
      target.height = source.height * sy;
      if (target.width < 0) {
        target.x += target.width;
        target.width = -target.width;
      }
      if (target.height < 0) {
        target.y += target.height;
        target.height = -target.height;
      }
      return;
    }
    lt.x = lb.x = source.x;
    lt.y = rt.y = source.y;
    rb.x = rt.x = source.x + source.width;
    rb.y = lb.y = source.y + source.height;
    lt.transform(m2);
    rt.transform(m2);
    rb.transform(m2);
    lb.transform(m2);
    target.x = mathMin$b(lt.x, rb.x, lb.x, rt.x);
    target.y = mathMin$b(lt.y, rb.y, lb.y, rt.y);
    var maxX = mathMax$b(lt.x, rb.x, lb.x, rt.x);
    var maxY = mathMax$b(lt.y, rb.y, lb.y, rt.y);
    target.width = maxX - target.x;
    target.height = maxY - target.y;
  };
  return BoundingRect2;
}();
var BoundingRect$1 = BoundingRect;
var textWidthCache = {};
function getWidth(text, font) {
  font = font || DEFAULT_FONT;
  var cacheOfFont = textWidthCache[font];
  if (!cacheOfFont) {
    cacheOfFont = textWidthCache[font] = new LRUCache$1(500);
  }
  var width = cacheOfFont.get(text);
  if (width == null) {
    width = platformApi.measureText(text, font).width;
    cacheOfFont.put(text, width);
  }
  return width;
}
function innerGetBoundingRect(text, font, textAlign, textBaseline) {
  var width = getWidth(text, font);
  var height = getLineHeight(font);
  var x = adjustTextX(0, width, textAlign);
  var y = adjustTextY(0, height, textBaseline);
  var rect = new BoundingRect$1(x, y, width, height);
  return rect;
}
function getBoundingRect(text, font, textAlign, textBaseline) {
  var textLines = ((text || "") + "").split("\n");
  var len2 = textLines.length;
  if (len2 === 1) {
    return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
  } else {
    var uniondRect = new BoundingRect$1(0, 0, 0, 0);
    for (var i = 0; i < textLines.length; i++) {
      var rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
      i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
    }
    return uniondRect;
  }
}
function adjustTextX(x, width, textAlign) {
  if (textAlign === "right") {
    x -= width;
  } else if (textAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function adjustTextY(y, height, verticalAlign) {
  if (verticalAlign === "middle") {
    y -= height / 2;
  } else if (verticalAlign === "bottom") {
    y -= height;
  }
  return y;
}
function getLineHeight(font) {
  return getWidth("\u56FD", font);
}
function parsePercent$2(value, maxValue) {
  if (typeof value === "string") {
    if (value.lastIndexOf("%") >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }
    return parseFloat(value);
  }
  return value;
}
function calculateTextPosition(out2, opts, rect) {
  var textPosition = opts.position || "inside";
  var distance2 = opts.distance != null ? opts.distance : 5;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var x = rect.x;
  var y = rect.y;
  var textAlign = "left";
  var textVerticalAlign = "top";
  if (textPosition instanceof Array) {
    x += parsePercent$2(textPosition[0], rect.width);
    y += parsePercent$2(textPosition[1], rect.height);
    textAlign = null;
    textVerticalAlign = null;
  } else {
    switch (textPosition) {
      case "left":
        x -= distance2;
        y += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "right":
        x += distance2 + width;
        y += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "top":
        x += width / 2;
        y -= distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "bottom":
        x += width / 2;
        y += height + distance2;
        textAlign = "center";
        break;
      case "inside":
        x += width / 2;
        y += halfHeight;
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "insideLeft":
        x += distance2;
        y += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "insideRight":
        x += width - distance2;
        y += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideTop":
        x += width / 2;
        y += distance2;
        textAlign = "center";
        break;
      case "insideBottom":
        x += width / 2;
        y += height - distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideTopLeft":
        x += distance2;
        y += distance2;
        break;
      case "insideTopRight":
        x += width - distance2;
        y += distance2;
        textAlign = "right";
        break;
      case "insideBottomLeft":
        x += distance2;
        y += height - distance2;
        textVerticalAlign = "bottom";
        break;
      case "insideBottomRight":
        x += width - distance2;
        y += height - distance2;
        textAlign = "right";
        textVerticalAlign = "bottom";
        break;
    }
  }
  out2 = out2 || {};
  out2.x = x;
  out2.y = y;
  out2.align = textAlign;
  out2.verticalAlign = textVerticalAlign;
  return out2;
}
var PRESERVED_NORMAL_STATE = "__zr_normal__";
var PRIMARY_STATES_KEYS$1 = TRANSFORMABLE_PROPS.concat(["ignore"]);
var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function(obj, key) {
  obj[key] = true;
  return obj;
}, { ignore: false });
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect$1(0, 0, 0, 0);
var Element = function() {
  function Element2(props) {
    this.id = guid$1();
    this.animators = [];
    this.currentStates = [];
    this.states = {};
    this._init(props);
  }
  Element2.prototype._init = function(props) {
    this.attr(props);
  };
  Element2.prototype.drift = function(dx, dy, e2) {
    switch (this.draggable) {
      case "horizontal":
        dy = 0;
        break;
      case "vertical":
        dx = 0;
        break;
    }
    var m2 = this.transform;
    if (!m2) {
      m2 = this.transform = [1, 0, 0, 1, 0, 0];
    }
    m2[4] += dx;
    m2[5] += dy;
    this.decomposeTransform();
    this.markRedraw();
  };
  Element2.prototype.beforeUpdate = function() {
  };
  Element2.prototype.afterUpdate = function() {
  };
  Element2.prototype.update = function() {
    this.updateTransform();
    if (this.__dirty) {
      this.updateInnerText();
    }
  };
  Element2.prototype.updateInnerText = function(forceUpdate) {
    var textEl = this._textContent;
    if (textEl && (!textEl.ignore || forceUpdate)) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      var textConfig = this.textConfig;
      var isLocal = textConfig.local;
      var innerTransformable = textEl.innerTransformable;
      var textAlign = void 0;
      var textVerticalAlign = void 0;
      var textStyleChanged = false;
      innerTransformable.parent = isLocal ? this : null;
      var innerOrigin = false;
      innerTransformable.copyTransform(textEl);
      if (textConfig.position != null) {
        var layoutRect = tmpBoundingRect;
        if (textConfig.layoutRect) {
          layoutRect.copy(textConfig.layoutRect);
        } else {
          layoutRect.copy(this.getBoundingRect());
        }
        if (!isLocal) {
          layoutRect.applyTransform(this.transform);
        }
        if (this.calculateTextPosition) {
          this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        } else {
          calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        }
        innerTransformable.x = tmpTextPosCalcRes.x;
        innerTransformable.y = tmpTextPosCalcRes.y;
        textAlign = tmpTextPosCalcRes.align;
        textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
        var textOrigin = textConfig.origin;
        if (textOrigin && textConfig.rotation != null) {
          var relOriginX = void 0;
          var relOriginY = void 0;
          if (textOrigin === "center") {
            relOriginX = layoutRect.width * 0.5;
            relOriginY = layoutRect.height * 0.5;
          } else {
            relOriginX = parsePercent$2(textOrigin[0], layoutRect.width);
            relOriginY = parsePercent$2(textOrigin[1], layoutRect.height);
          }
          innerOrigin = true;
          innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
          innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
        }
      }
      if (textConfig.rotation != null) {
        innerTransformable.rotation = textConfig.rotation;
      }
      var textOffset = textConfig.offset;
      if (textOffset) {
        innerTransformable.x += textOffset[0];
        innerTransformable.y += textOffset[1];
        if (!innerOrigin) {
          innerTransformable.originX = -textOffset[0];
          innerTransformable.originY = -textOffset[1];
        }
      }
      var isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
      var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      var textFill = void 0;
      var textStroke = void 0;
      var autoStroke = void 0;
      if (isInside && this.canBeInsideText()) {
        textFill = textConfig.insideFill;
        textStroke = textConfig.insideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getInsideTextFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getInsideTextStroke(textFill);
          autoStroke = true;
        }
      } else {
        textFill = textConfig.outsideFill;
        textStroke = textConfig.outsideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getOutsideFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getOutsideStroke(textFill);
          autoStroke = true;
        }
      }
      textFill = textFill || "#000";
      if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
        textStyleChanged = true;
        innerTextDefaultStyle.fill = textFill;
        innerTextDefaultStyle.stroke = textStroke;
        innerTextDefaultStyle.autoStroke = autoStroke;
        innerTextDefaultStyle.align = textAlign;
        innerTextDefaultStyle.verticalAlign = textVerticalAlign;
        textEl.setDefaultTextStyle(innerTextDefaultStyle);
      }
      textEl.__dirty |= REDRAW_BIT;
      if (textStyleChanged) {
        textEl.dirtyStyle(true);
      }
    }
  };
  Element2.prototype.canBeInsideText = function() {
    return true;
  };
  Element2.prototype.getInsideTextFill = function() {
    return "#fff";
  };
  Element2.prototype.getInsideTextStroke = function(textFill) {
    return "#000";
  };
  Element2.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  };
  Element2.prototype.getOutsideStroke = function(textFill) {
    var backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
    var colorArr = typeof backgroundColor2 === "string" && parse(backgroundColor2);
    if (!colorArr) {
      colorArr = [255, 255, 255, 1];
    }
    var alpha = colorArr[3];
    var isDark = this.__zr.isDarkMode();
    for (var i = 0; i < 3; i++) {
      colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
    }
    colorArr[3] = 1;
    return stringify(colorArr, "rgba");
  };
  Element2.prototype.traverse = function(cb, context) {
  };
  Element2.prototype.attrKV = function(key, value) {
    if (key === "textConfig") {
      this.setTextConfig(value);
    } else if (key === "textContent") {
      this.setTextContent(value);
    } else if (key === "clipPath") {
      this.setClipPath(value);
    } else if (key === "extra") {
      this.extra = this.extra || {};
      extend$1(this.extra, value);
    } else {
      this[key] = value;
    }
  };
  Element2.prototype.hide = function() {
    this.ignore = true;
    this.markRedraw();
  };
  Element2.prototype.show = function() {
    this.ignore = false;
    this.markRedraw();
  };
  Element2.prototype.attr = function(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.attrKV(keyOrObj, value);
    } else if (isObject$3(keyOrObj)) {
      var obj = keyOrObj;
      var keysArr = keys(obj);
      for (var i = 0; i < keysArr.length; i++) {
        var key = keysArr[i];
        this.attrKV(key, keyOrObj[key]);
      }
    }
    this.markRedraw();
    return this;
  };
  Element2.prototype.saveCurrentToNormalState = function(toState) {
    this._innerSaveToNormal(toState);
    var normalState = this._normalState;
    for (var i = 0; i < this.animators.length; i++) {
      var animator = this.animators[i];
      var fromStateTransition = animator.__fromStateTransition;
      if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
        continue;
      }
      var targetName = animator.targetName;
      var target = targetName ? normalState[targetName] : normalState;
      animator.saveTo(target);
    }
  };
  Element2.prototype._innerSaveToNormal = function(toState) {
    var normalState = this._normalState;
    if (!normalState) {
      normalState = this._normalState = {};
    }
    if (toState.textConfig && !normalState.textConfig) {
      normalState.textConfig = this.textConfig;
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);
  };
  Element2.prototype._savePrimaryToNormal = function(toState, normalState, primaryKeys) {
    for (var i = 0; i < primaryKeys.length; i++) {
      var key = primaryKeys[i];
      if (toState[key] != null && !(key in normalState)) {
        normalState[key] = this[key];
      }
    }
  };
  Element2.prototype.hasState = function() {
    return this.currentStates.length > 0;
  };
  Element2.prototype.getState = function(name) {
    return this.states[name];
  };
  Element2.prototype.ensureState = function(name) {
    var states = this.states;
    if (!states[name]) {
      states[name] = {};
    }
    return states[name];
  };
  Element2.prototype.clearStates = function(noAnimation) {
    this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
  };
  Element2.prototype.useState = function(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
    var toNormalState = stateName === PRESERVED_NORMAL_STATE;
    var hasStates = this.hasState();
    if (!hasStates && toNormalState) {
      return;
    }
    var currentStates = this.currentStates;
    var animationCfg = this.stateTransition;
    if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
      return;
    }
    var state;
    if (this.stateProxy && !toNormalState) {
      state = this.stateProxy(stateName);
    }
    if (!state) {
      state = this.states && this.states[stateName];
    }
    if (!state && !toNormalState) {
      logError("State " + stateName + " not exists.");
      return;
    }
    if (!toNormalState) {
      this.saveCurrentToNormalState(state);
    }
    var useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
    if (useHoverLayer) {
      this._toggleHoverLayerFlag(true);
    }
    this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (textGuide) {
      textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (toNormalState) {
      this.currentStates = [];
      this._normalState = {};
    } else {
      if (!keepCurrentStates) {
        this.currentStates = [stateName];
      } else {
        this.currentStates.push(stateName);
      }
    }
    this._updateAnimationTargets();
    this.markRedraw();
    if (!useHoverLayer && this.__inHover) {
      this._toggleHoverLayerFlag(false);
      this.__dirty &= ~REDRAW_BIT;
    }
    return state;
  };
  Element2.prototype.useStates = function(states, noAnimation, forceUseHoverLayer) {
    if (!states.length) {
      this.clearStates();
    } else {
      var stateObjects = [];
      var currentStates = this.currentStates;
      var len2 = states.length;
      var notChange = len2 === currentStates.length;
      if (notChange) {
        for (var i = 0; i < len2; i++) {
          if (states[i] !== currentStates[i]) {
            notChange = false;
            break;
          }
        }
      }
      if (notChange) {
        return;
      }
      for (var i = 0; i < len2; i++) {
        var stateName = states[i];
        var stateObj = void 0;
        if (this.stateProxy) {
          stateObj = this.stateProxy(stateName, states);
        }
        if (!stateObj) {
          stateObj = this.states[stateName];
        }
        if (stateObj) {
          stateObjects.push(stateObj);
        }
      }
      var lastStateObj = stateObjects[len2 - 1];
      var useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      var mergedState = this._mergeStates(stateObjects);
      var animationCfg = this.stateTransition;
      this.saveCurrentToNormalState(mergedState);
      this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      var textContent = this._textContent;
      var textGuide = this._textGuide;
      if (textContent) {
        textContent.useStates(states, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useStates(states, noAnimation, useHoverLayer);
      }
      this._updateAnimationTargets();
      this.currentStates = states.slice();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
    }
  };
  Element2.prototype._updateAnimationTargets = function() {
    for (var i = 0; i < this.animators.length; i++) {
      var animator = this.animators[i];
      if (animator.targetName) {
        animator.changeTarget(this[animator.targetName]);
      }
    }
  };
  Element2.prototype.removeState = function(state) {
    var idx = indexOf(this.currentStates, state);
    if (idx >= 0) {
      var currentStates = this.currentStates.slice();
      currentStates.splice(idx, 1);
      this.useStates(currentStates);
    }
  };
  Element2.prototype.replaceState = function(oldState, newState, forceAdd) {
    var currentStates = this.currentStates.slice();
    var idx = indexOf(currentStates, oldState);
    var newStateExists = indexOf(currentStates, newState) >= 0;
    if (idx >= 0) {
      if (!newStateExists) {
        currentStates[idx] = newState;
      } else {
        currentStates.splice(idx, 1);
      }
    } else if (forceAdd && !newStateExists) {
      currentStates.push(newState);
    }
    this.useStates(currentStates);
  };
  Element2.prototype.toggleState = function(state, enable) {
    if (enable) {
      this.useState(state, true);
    } else {
      this.removeState(state);
    }
  };
  Element2.prototype._mergeStates = function(states) {
    var mergedState = {};
    var mergedTextConfig;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      extend$1(mergedState, state);
      if (state.textConfig) {
        mergedTextConfig = mergedTextConfig || {};
        extend$1(mergedTextConfig, state.textConfig);
      }
    }
    if (mergedTextConfig) {
      mergedState.textConfig = mergedTextConfig;
    }
    return mergedState;
  };
  Element2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    var needsRestoreToNormal = !(state && keepCurrentStates);
    if (state && state.textConfig) {
      this.textConfig = extend$1({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
      extend$1(this.textConfig, state.textConfig);
    } else if (needsRestoreToNormal) {
      if (normalState.textConfig) {
        this.textConfig = normalState.textConfig;
      }
    }
    var transitionTarget = {};
    var hasTransition = false;
    for (var i = 0; i < PRIMARY_STATES_KEYS$1.length; i++) {
      var key = PRIMARY_STATES_KEYS$1[i];
      var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
      if (state && state[key] != null) {
        if (propNeedsTransition) {
          hasTransition = true;
          transitionTarget[key] = state[key];
        } else {
          this[key] = state[key];
        }
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key] = normalState[key];
          } else {
            this[key] = normalState[key];
          }
        }
      }
    }
    if (!transition) {
      for (var i = 0; i < this.animators.length; i++) {
        var animator = this.animators[i];
        var targetName = animator.targetName;
        if (!animator.getLoop()) {
          animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
        }
      }
    }
    if (hasTransition) {
      this._transitionState(stateName, transitionTarget, animationCfg);
    }
  };
  Element2.prototype._attachComponent = function(componentEl) {
    if (componentEl.__zr && !componentEl.__hostTarget) {
      return;
    }
    if (componentEl === this) {
      return;
    }
    var zr = this.__zr;
    if (zr) {
      componentEl.addSelfToZr(zr);
    }
    componentEl.__zr = zr;
    componentEl.__hostTarget = this;
  };
  Element2.prototype._detachComponent = function(componentEl) {
    if (componentEl.__zr) {
      componentEl.removeSelfFromZr(componentEl.__zr);
    }
    componentEl.__zr = null;
    componentEl.__hostTarget = null;
  };
  Element2.prototype.getClipPath = function() {
    return this._clipPath;
  };
  Element2.prototype.setClipPath = function(clipPath) {
    if (this._clipPath && this._clipPath !== clipPath) {
      this.removeClipPath();
    }
    this._attachComponent(clipPath);
    this._clipPath = clipPath;
    this.markRedraw();
  };
  Element2.prototype.removeClipPath = function() {
    var clipPath = this._clipPath;
    if (clipPath) {
      this._detachComponent(clipPath);
      this._clipPath = null;
      this.markRedraw();
    }
  };
  Element2.prototype.getTextContent = function() {
    return this._textContent;
  };
  Element2.prototype.setTextContent = function(textEl) {
    var previousTextContent = this._textContent;
    if (previousTextContent === textEl) {
      return;
    }
    if (previousTextContent && previousTextContent !== textEl) {
      this.removeTextContent();
    }
    textEl.innerTransformable = new Transformable();
    this._attachComponent(textEl);
    this._textContent = textEl;
    this.markRedraw();
  };
  Element2.prototype.setTextConfig = function(cfg) {
    if (!this.textConfig) {
      this.textConfig = {};
    }
    extend$1(this.textConfig, cfg);
    this.markRedraw();
  };
  Element2.prototype.removeTextConfig = function() {
    this.textConfig = null;
    this.markRedraw();
  };
  Element2.prototype.removeTextContent = function() {
    var textEl = this._textContent;
    if (textEl) {
      textEl.innerTransformable = null;
      this._detachComponent(textEl);
      this._textContent = null;
      this._innerTextDefaultStyle = null;
      this.markRedraw();
    }
  };
  Element2.prototype.getTextGuideLine = function() {
    return this._textGuide;
  };
  Element2.prototype.setTextGuideLine = function(guideLine) {
    if (this._textGuide && this._textGuide !== guideLine) {
      this.removeTextGuideLine();
    }
    this._attachComponent(guideLine);
    this._textGuide = guideLine;
    this.markRedraw();
  };
  Element2.prototype.removeTextGuideLine = function() {
    var textGuide = this._textGuide;
    if (textGuide) {
      this._detachComponent(textGuide);
      this._textGuide = null;
      this.markRedraw();
    }
  };
  Element2.prototype.markRedraw = function() {
    this.__dirty |= REDRAW_BIT;
    var zr = this.__zr;
    if (zr) {
      if (this.__inHover) {
        zr.refreshHover();
      } else {
        zr.refresh();
      }
    }
    if (this.__hostTarget) {
      this.__hostTarget.markRedraw();
    }
  };
  Element2.prototype.dirty = function() {
    this.markRedraw();
  };
  Element2.prototype._toggleHoverLayerFlag = function(inHover) {
    this.__inHover = inHover;
    var textContent = this._textContent;
    var textGuide = this._textGuide;
    if (textContent) {
      textContent.__inHover = inHover;
    }
    if (textGuide) {
      textGuide.__inHover = inHover;
    }
  };
  Element2.prototype.addSelfToZr = function(zr) {
    if (this.__zr === zr) {
      return;
    }
    this.__zr = zr;
    var animators = this.animators;
    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.addSelfToZr(zr);
    }
    if (this._textContent) {
      this._textContent.addSelfToZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.addSelfToZr(zr);
    }
  };
  Element2.prototype.removeSelfFromZr = function(zr) {
    if (!this.__zr) {
      return;
    }
    this.__zr = null;
    var animators = this.animators;
    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.removeSelfFromZr(zr);
    }
    if (this._textContent) {
      this._textContent.removeSelfFromZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.removeSelfFromZr(zr);
    }
  };
  Element2.prototype.animate = function(key, loop, allowDiscreteAnimation) {
    var target = key ? this[key] : this;
    var animator = new Animator$1(target, loop, allowDiscreteAnimation);
    key && (animator.targetName = key);
    this.addAnimator(animator, key);
    return animator;
  };
  Element2.prototype.addAnimator = function(animator, key) {
    var zr = this.__zr;
    var el = this;
    animator.during(function() {
      el.updateDuringAnimation(key);
    }).done(function() {
      var animators = el.animators;
      var idx = indexOf(animators, animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    this.animators.push(animator);
    if (zr) {
      zr.animation.addAnimator(animator);
    }
    zr && zr.wakeUp();
  };
  Element2.prototype.updateDuringAnimation = function(key) {
    this.markRedraw();
  };
  Element2.prototype.stopAnimation = function(scope, forwardToLast) {
    var animators = this.animators;
    var len2 = animators.length;
    var leftAnimators = [];
    for (var i = 0; i < len2; i++) {
      var animator = animators[i];
      if (!scope || scope === animator.scope) {
        animator.stop(forwardToLast);
      } else {
        leftAnimators.push(animator);
      }
    }
    this.animators = leftAnimators;
    return this;
  };
  Element2.prototype.animateTo = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps);
  };
  Element2.prototype.animateFrom = function(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps, true);
  };
  Element2.prototype._transitionState = function(stateName, target, cfg, animationProps) {
    var animators = animateTo(this, target, cfg, animationProps);
    for (var i = 0; i < animators.length; i++) {
      animators[i].__fromStateTransition = stateName;
    }
  };
  Element2.prototype.getBoundingRect = function() {
    return null;
  };
  Element2.prototype.getPaintRect = function() {
    return null;
  };
  Element2.initDefaultProps = function() {
    var elProto = Element2.prototype;
    elProto.type = "element";
    elProto.name = "";
    elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
    elProto.__dirty = REDRAW_BIT;
    function createLegacyProperty(key, privateKey, xKey, yKey) {
      Object.defineProperty(elProto, key, {
        get: function() {
          if (!this[privateKey]) {
            var pos = this[privateKey] = [];
            enhanceArray(this, pos);
          }
          return this[privateKey];
        },
        set: function(pos) {
          this[xKey] = pos[0];
          this[yKey] = pos[1];
          this[privateKey] = pos;
          enhanceArray(this, pos);
        }
      });
      function enhanceArray(self2, pos) {
        Object.defineProperty(pos, 0, {
          get: function() {
            return self2[xKey];
          },
          set: function(val) {
            self2[xKey] = val;
          }
        });
        Object.defineProperty(pos, 1, {
          get: function() {
            return self2[yKey];
          },
          set: function(val) {
            self2[yKey] = val;
          }
        });
      }
    }
    if (Object.defineProperty) {
      createLegacyProperty("position", "_legacyPos", "x", "y");
      createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
      createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
    }
  }();
  return Element2;
}();
mixin(Element, Eventful$1);
mixin(Element, Transformable);
function animateTo(animatable, target, cfg, animationProps, reverse2) {
  cfg = cfg || {};
  var animators = [];
  animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse2);
  var finishCount = animators.length;
  var doneHappened = false;
  var cfgDone = cfg.done;
  var cfgAborted = cfg.aborted;
  var doneCb = function() {
    doneHappened = true;
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  var abortedCb = function() {
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  if (!finishCount) {
    cfgDone && cfgDone();
  }
  if (animators.length > 0 && cfg.during) {
    animators[0].during(function(target2, percent) {
      cfg.during(percent);
    });
  }
  for (var i = 0; i < animators.length; i++) {
    var animator = animators[i];
    if (doneCb) {
      animator.done(doneCb);
    }
    if (abortedCb) {
      animator.aborted(abortedCb);
    }
    if (cfg.force) {
      animator.duration(cfg.duration);
    }
    animator.start(cfg.easing);
  }
  return animators;
}
function copyArrShallow(source, target, len2) {
  for (var i = 0; i < len2; i++) {
    source[i] = target[i];
  }
}
function is2DArray(value) {
  return isArrayLike(value[0]);
}
function copyValue(target, source, key) {
  if (isArrayLike(source[key])) {
    if (!isArrayLike(target[key])) {
      target[key] = [];
    }
    if (isTypedArray(source[key])) {
      var len2 = source[key].length;
      if (target[key].length !== len2) {
        target[key] = new source[key].constructor(len2);
        copyArrShallow(target[key], source[key], len2);
      }
    } else {
      var sourceArr = source[key];
      var targetArr = target[key];
      var len0 = sourceArr.length;
      if (is2DArray(sourceArr)) {
        var len1 = sourceArr[0].length;
        for (var i = 0; i < len0; i++) {
          if (!targetArr[i]) {
            targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
          } else {
            copyArrShallow(targetArr[i], sourceArr[i], len1);
          }
        }
      } else {
        copyArrShallow(targetArr, sourceArr, len0);
      }
      targetArr.length = sourceArr.length;
    }
  } else {
    target[key] = source[key];
  }
}
function isValueSame(val1, val2) {
  return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
  var len2 = arr0.length;
  if (len2 !== arr1.length) {
    return false;
  }
  for (var i = 0; i < len2; i++) {
    if (arr0[i] !== arr1[i]) {
      return false;
    }
  }
  return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse2) {
  var targetKeys = keys(target);
  var duration = cfg.duration;
  var delay = cfg.delay;
  var additive = cfg.additive;
  var setToFinal = cfg.setToFinal;
  var animateAll = !isObject$3(animationProps);
  var existsAnimators = animatable.animators;
  var animationKeys = [];
  for (var k = 0; k < targetKeys.length; k++) {
    var innerKey = targetKeys[k];
    var targetVal = target[innerKey];
    if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
      if (isObject$3(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
        if (topKey) {
          if (!reverse2) {
            animateObj[innerKey] = targetVal;
            animatable.updateDuringAnimation(topKey);
          }
          continue;
        }
        animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse2);
      } else {
        animationKeys.push(innerKey);
      }
    } else if (!reverse2) {
      animateObj[innerKey] = targetVal;
      animatable.updateDuringAnimation(topKey);
      animationKeys.push(innerKey);
    }
  }
  var keyLen = animationKeys.length;
  if (!additive && keyLen) {
    for (var i = 0; i < existsAnimators.length; i++) {
      var animator = existsAnimators[i];
      if (animator.targetName === topKey) {
        var allAborted = animator.stopTracks(animationKeys);
        if (allAborted) {
          var idx = indexOf(existsAnimators, animator);
          existsAnimators.splice(idx, 1);
        }
      }
    }
  }
  if (!cfg.force) {
    animationKeys = filter(animationKeys, function(key) {
      return !isValueSame(target[key], animateObj[key]);
    });
    keyLen = animationKeys.length;
  }
  if (keyLen > 0 || cfg.force && !animators.length) {
    var revertedSource = void 0;
    var reversedTarget = void 0;
    var sourceClone = void 0;
    if (reverse2) {
      reversedTarget = {};
      if (setToFinal) {
        revertedSource = {};
      }
      for (var i = 0; i < keyLen; i++) {
        var innerKey = animationKeys[i];
        reversedTarget[innerKey] = animateObj[innerKey];
        if (setToFinal) {
          revertedSource[innerKey] = target[innerKey];
        } else {
          animateObj[innerKey] = target[innerKey];
        }
      }
    } else if (setToFinal) {
      sourceClone = {};
      for (var i = 0; i < keyLen; i++) {
        var innerKey = animationKeys[i];
        sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
        copyValue(animateObj, target, innerKey);
      }
    }
    var animator = new Animator$1(animateObj, false, false, additive ? filter(existsAnimators, function(animator2) {
      return animator2.targetName === topKey;
    }) : null);
    animator.targetName = topKey;
    if (cfg.scope) {
      animator.scope = cfg.scope;
    }
    if (setToFinal && revertedSource) {
      animator.whenWithKeys(0, revertedSource, animationKeys);
    }
    if (sourceClone) {
      animator.whenWithKeys(0, sourceClone, animationKeys);
    }
    animator.whenWithKeys(duration == null ? 500 : duration, reverse2 ? reversedTarget : target, animationKeys).delay(delay || 0);
    animatable.addAnimator(animator, topKey);
    animators.push(animator);
  }
}
var Element$1 = Element;
var Group$3 = function(_super) {
  __extends(Group2, _super);
  function Group2(opts) {
    var _this = _super.call(this) || this;
    _this.isGroup = true;
    _this._children = [];
    _this.attr(opts);
    return _this;
  }
  Group2.prototype.childrenRef = function() {
    return this._children;
  };
  Group2.prototype.children = function() {
    return this._children.slice();
  };
  Group2.prototype.childAt = function(idx) {
    return this._children[idx];
  };
  Group2.prototype.childOfName = function(name) {
    var children = this._children;
    for (var i = 0; i < children.length; i++) {
      if (children[i].name === name) {
        return children[i];
      }
    }
  };
  Group2.prototype.childCount = function() {
    return this._children.length;
  };
  Group2.prototype.add = function(child) {
    if (child) {
      if (child !== this && child.parent !== this) {
        this._children.push(child);
        this._doAdd(child);
      }
    }
    return this;
  };
  Group2.prototype.addBefore = function(child, nextSibling2) {
    if (child && child !== this && child.parent !== this && nextSibling2 && nextSibling2.parent === this) {
      var children = this._children;
      var idx = children.indexOf(nextSibling2);
      if (idx >= 0) {
        children.splice(idx, 0, child);
        this._doAdd(child);
      }
    }
    return this;
  };
  Group2.prototype.replace = function(oldChild, newChild) {
    var idx = indexOf(this._children, oldChild);
    if (idx >= 0) {
      this.replaceAt(newChild, idx);
    }
    return this;
  };
  Group2.prototype.replaceAt = function(child, index) {
    var children = this._children;
    var old = children[index];
    if (child && child !== this && child.parent !== this && child !== old) {
      children[index] = child;
      old.parent = null;
      var zr = this.__zr;
      if (zr) {
        old.removeSelfFromZr(zr);
      }
      this._doAdd(child);
    }
    return this;
  };
  Group2.prototype._doAdd = function(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    var zr = this.__zr;
    if (zr && zr !== child.__zr) {
      child.addSelfToZr(zr);
    }
    zr && zr.refresh();
  };
  Group2.prototype.remove = function(child) {
    var zr = this.__zr;
    var children = this._children;
    var idx = indexOf(children, child);
    if (idx < 0) {
      return this;
    }
    children.splice(idx, 1);
    child.parent = null;
    if (zr) {
      child.removeSelfFromZr(zr);
    }
    zr && zr.refresh();
    return this;
  };
  Group2.prototype.removeAll = function() {
    var children = this._children;
    var zr = this.__zr;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      child.parent = null;
    }
    children.length = 0;
    return this;
  };
  Group2.prototype.eachChild = function(cb, context) {
    var children = this._children;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      cb.call(context, child, i);
    }
    return this;
  };
  Group2.prototype.traverse = function(cb, context) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      var stopped = cb.call(context, child);
      if (child.isGroup && !stopped) {
        child.traverse(cb, context);
      }
    }
    return this;
  };
  Group2.prototype.addSelfToZr = function(zr) {
    _super.prototype.addSelfToZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.addSelfToZr(zr);
    }
  };
  Group2.prototype.removeSelfFromZr = function(zr) {
    _super.prototype.removeSelfFromZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.removeSelfFromZr(zr);
    }
  };
  Group2.prototype.getBoundingRect = function(includeChildren) {
    var tmpRect2 = new BoundingRect$1(0, 0, 0, 0);
    var children = includeChildren || this._children;
    var tmpMat = [];
    var rect = null;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.ignore || child.invisible) {
        continue;
      }
      var childRect = child.getBoundingRect();
      var transform2 = child.getLocalTransform(tmpMat);
      if (transform2) {
        BoundingRect$1.applyTransform(tmpRect2, childRect, transform2);
        rect = rect || tmpRect2.clone();
        rect.union(tmpRect2);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }
    return rect || tmpRect2;
  };
  return Group2;
}(Element$1);
Group$3.prototype.type = "group";
var Group$4 = Group$3;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {};
var instances$1 = {};
function delInstance(id) {
  delete instances$1[id];
}
function isDarkMode(backgroundColor2) {
  if (!backgroundColor2) {
    return false;
  }
  if (typeof backgroundColor2 === "string") {
    return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
  } else if (backgroundColor2.colorStops) {
    var colorStops = backgroundColor2.colorStops;
    var totalLum = 0;
    var len2 = colorStops.length;
    for (var i = 0; i < len2; i++) {
      totalLum += lum(colorStops[i].color, 1);
    }
    totalLum /= len2;
    return totalLum < DARK_MODE_THRESHOLD;
  }
  return false;
}
var ZRender = function() {
  function ZRender2(id, dom, opts) {
    var _this = this;
    this._sleepAfterStill = 10;
    this._stillFrameAccum = 0;
    this._needsRefresh = true;
    this._needsRefreshHover = true;
    this._darkMode = false;
    opts = opts || {};
    this.dom = dom;
    this.id = id;
    var storage2 = new Storage$1();
    var rendererType = opts.renderer || "canvas";
    if (!painterCtors[rendererType]) {
      rendererType = keys(painterCtors)[0];
    }
    opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
    var painter = new painterCtors[rendererType](dom, storage2, opts, id);
    var ssrMode = opts.ssr || painter.ssrOnly;
    this.storage = storage2;
    this.painter = painter;
    var handerProxy = !env$1.node && !env$1.worker && !ssrMode ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
    this.handler = new Handler$2(storage2, painter, handerProxy, painter.root);
    this.animation = new Animation$1({
      stage: {
        update: ssrMode ? null : function() {
          return _this._flush(true);
        }
      }
    });
    if (!ssrMode) {
      this.animation.start();
    }
  }
  ZRender2.prototype.add = function(el) {
    if (!el) {
      return;
    }
    this.storage.addRoot(el);
    el.addSelfToZr(this);
    this.refresh();
  };
  ZRender2.prototype.remove = function(el) {
    if (!el) {
      return;
    }
    this.storage.delRoot(el);
    el.removeSelfFromZr(this);
    this.refresh();
  };
  ZRender2.prototype.configLayer = function(zLevel, config) {
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config);
    }
    this.refresh();
  };
  ZRender2.prototype.setBackgroundColor = function(backgroundColor2) {
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor2);
    }
    this.refresh();
    this._backgroundColor = backgroundColor2;
    this._darkMode = isDarkMode(backgroundColor2);
  };
  ZRender2.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  };
  ZRender2.prototype.setDarkMode = function(darkMode) {
    this._darkMode = darkMode;
  };
  ZRender2.prototype.isDarkMode = function() {
    return this._darkMode;
  };
  ZRender2.prototype.refreshImmediately = function(fromInside) {
    if (!fromInside) {
      this.animation.update(true);
    }
    this._needsRefresh = false;
    this.painter.refresh();
    this._needsRefresh = false;
  };
  ZRender2.prototype.refresh = function() {
    this._needsRefresh = true;
    this.animation.start();
  };
  ZRender2.prototype.flush = function() {
    this._flush(false);
  };
  ZRender2.prototype._flush = function(fromInside) {
    var triggerRendered;
    var start2 = getTime();
    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately(fromInside);
    }
    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }
    var end2 = getTime();
    if (triggerRendered) {
      this._stillFrameAccum = 0;
      this.trigger("rendered", {
        elapsedTime: end2 - start2
      });
    } else if (this._sleepAfterStill > 0) {
      this._stillFrameAccum++;
      if (this._stillFrameAccum > this._sleepAfterStill) {
        this.animation.stop();
      }
    }
  };
  ZRender2.prototype.setSleepAfterStill = function(stillFramesCount) {
    this._sleepAfterStill = stillFramesCount;
  };
  ZRender2.prototype.wakeUp = function() {
    this.animation.start();
    this._stillFrameAccum = 0;
  };
  ZRender2.prototype.refreshHover = function() {
    this._needsRefreshHover = true;
  };
  ZRender2.prototype.refreshHoverImmediately = function() {
    this._needsRefreshHover = false;
    if (this.painter.refreshHover && this.painter.getType() === "canvas") {
      this.painter.refreshHover();
    }
  };
  ZRender2.prototype.resize = function(opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  };
  ZRender2.prototype.clearAnimation = function() {
    this.animation.clear();
  };
  ZRender2.prototype.getWidth = function() {
    return this.painter.getWidth();
  };
  ZRender2.prototype.getHeight = function() {
    return this.painter.getHeight();
  };
  ZRender2.prototype.setCursorStyle = function(cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  };
  ZRender2.prototype.findHover = function(x, y) {
    return this.handler.findHover(x, y);
  };
  ZRender2.prototype.on = function(eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
    return this;
  };
  ZRender2.prototype.off = function(eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  };
  ZRender2.prototype.trigger = function(eventName, event) {
    this.handler.trigger(eventName, event);
  };
  ZRender2.prototype.clear = function() {
    var roots2 = this.storage.getRoots();
    for (var i = 0; i < roots2.length; i++) {
      if (roots2[i] instanceof Group$4) {
        roots2[i].removeSelfFromZr(this);
      }
    }
    this.storage.delAllRoots();
    this.painter.clear();
  };
  ZRender2.prototype.dispose = function() {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  };
  return ZRender2;
}();
function init$2(dom, opts) {
  var zr = new ZRender(guid$1(), dom, opts);
  instances$1[zr.id] = zr;
  return zr;
}
function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}
var RADIAN_EPSILON = 1e-4;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}
function linearMap$2(val, domain, range, clamp2) {
  var d0 = domain[0];
  var d1 = domain[1];
  var r0 = range[0];
  var r1 = range[1];
  var subDomain = d1 - d0;
  var subRange = r1 - r0;
  if (subDomain === 0) {
    return subRange === 0 ? r0 : (r0 + r1) / 2;
  }
  if (clamp2) {
    if (subDomain > 0) {
      if (val <= d0) {
        return r0;
      } else if (val >= d1) {
        return r1;
      }
    } else {
      if (val >= d0) {
        return r0;
      } else if (val <= d1) {
        return r1;
      }
    }
  } else {
    if (val === d0) {
      return r0;
    }
    if (val === d1) {
      return r1;
    }
  }
  return (val - d0) / subDomain * subRange + r0;
}
function parsePercent$1(percent, all) {
  switch (percent) {
    case "center":
    case "middle":
      percent = "50%";
      break;
    case "left":
    case "top":
      percent = "0%";
      break;
    case "right":
    case "bottom":
      percent = "100%";
      break;
  }
  if (isString(percent)) {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }
    return parseFloat(percent);
  }
  return percent == null ? NaN : +percent;
}
function round$3(x, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  }
  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
  x = (+x).toFixed(precision);
  return returnStr ? x : +x;
}
function asc$2(arr) {
  arr.sort(function(a, b) {
    return a - b;
  });
  return arr;
}
function getPrecision(val) {
  val = +val;
  if (isNaN(val)) {
    return 0;
  }
  if (val > 1e-14) {
    var e2 = 1;
    for (var i = 0; i < 15; i++, e2 *= 10) {
      if (Math.round(val * e2) / e2 === val) {
        return i;
      }
    }
  }
  return getPrecisionSafe(val);
}
function getPrecisionSafe(val) {
  var str = val.toString().toLowerCase();
  var eIndex = str.indexOf("e");
  var exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
  var significandPartLen = eIndex > 0 ? eIndex : str.length;
  var dotIndex = str.indexOf(".");
  var decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
  return Math.max(0, decimalPartLen - exp);
}
function getPixelPrecision(dataExtent, pixelExtent) {
  var log = Math.log;
  var LN10 = Math.LN10;
  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }
  var sum2 = reduce(valueList, function(acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);
  if (sum2 === 0) {
    return 0;
  }
  var digits = Math.pow(10, precision);
  var votesPerQuota = map$1(valueList, function(val) {
    return (isNaN(val) ? 0 : val) / sum2 * digits * 100;
  });
  var targetSeats = digits * 100;
  var seats = map$1(votesPerQuota, function(votes) {
    return Math.floor(votes);
  });
  var currentSum = reduce(seats, function(acc, val) {
    return acc + val;
  }, 0);
  var remainder = map$1(votesPerQuota, function(votes, idx2) {
    return votes - seats[idx2];
  });
  while (currentSum < targetSeats) {
    var max3 = Number.NEGATIVE_INFINITY;
    var maxId = null;
    for (var i = 0, len2 = remainder.length; i < len2; ++i) {
      if (remainder[i] > max3) {
        max3 = remainder[i];
        maxId = i;
      }
    }
    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }
  return seats[idx] / digits;
}
function addSafe(val0, val1) {
  var maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
  var sum2 = val0 + val1;
  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum2 : round$3(sum2, maxPrecision);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function remRadian(radian) {
  var pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (isString(value)) {
    var match = TIME_REG.exec(value);
    if (!match) {
      return new Date(NaN);
    }
    if (!match[8]) {
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
    } else {
      var hour = +match[4] || 0;
      if (match[8].toUpperCase() !== "Z") {
        hour -= +match[8].slice(0, 3);
      }
      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
    }
  } else if (value == null) {
    return new Date(NaN);
  }
  return new Date(Math.round(value));
}
function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}
function quantityExponent(val) {
  if (val === 0) {
    return 0;
  }
  var exp = Math.floor(Math.log(val) / Math.LN10);
  if (val / Math.pow(10, exp) >= 10) {
    exp++;
  }
  return exp;
}
function nice(val, round2) {
  var exponent = quantityExponent(val);
  var exp10 = Math.pow(10, exponent);
  var f = val / exp10;
  var nf;
  if (round2) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }
  val = nf * exp10;
  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
function quantile(ascArr, p) {
  var H = (ascArr.length - 1) * p + 1;
  var h = Math.floor(H);
  var v = +ascArr[h - 1];
  var e2 = H - h;
  return e2 ? v + e2 * (ascArr[h] - v) : v;
}
function reformIntervals(list) {
  list.sort(function(a, b) {
    return littleThan2(a, b, 0) ? -1 : 1;
  });
  var curr = -Infinity;
  var currClose = 1;
  for (var i = 0; i < list.length; ) {
    var interval = list[i].interval;
    var close_1 = list[i].close;
    for (var lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close_1[lg] = !lg ? 1 - currClose : 1;
      }
      curr = interval[lg];
      currClose = close_1[lg];
    }
    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
      list.splice(i, 1);
    } else {
      i++;
    }
  }
  return list;
  function littleThan2(a, b, lg2) {
    return a.interval[lg2] < b.interval[lg2] || a.interval[lg2] === b.interval[lg2] && (a.close[lg2] - b.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan2(a, b, 1));
  }
}
function numericToNumber(val) {
  var valFloat = parseFloat(val);
  return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
}
function isNumeric(val) {
  return !isNaN(numericToNumber(val));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(a, b) {
  if (b === 0) {
    return a;
  }
  return getGreatestCommonDividor(b, a % b);
}
function getLeastCommonMultiple(a, b) {
  if (a == null) {
    return b;
  }
  if (b == null) {
    return a;
  }
  return a * b / getGreatestCommonDividor(a, b);
}
function throwError(msg) {
  throw new Error(msg);
}
function interpolateNumber(p02, p12, percent) {
  return (p12 - p02) * percent + p02;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
function defaultEmphasis(opt, key, subOpts) {
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {};
    for (var i = 0, len2 = subOpts.length; i < len2; i++) {
      var subOptName = subOpts[i];
      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function getDataItemValue(dataItem) {
  return isObject$3(dataItem) && !isArray$1(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
function isDataItemOption(dataItem) {
  return isObject$3(dataItem) && !(dataItem instanceof Array);
}
function mappingToExists(existings, newCmptOptions, mode) {
  var isNormalMergeMode = mode === "normalMerge";
  var isReplaceMergeMode = mode === "replaceMerge";
  var isReplaceAllMode = mode === "replaceAll";
  existings = existings || [];
  newCmptOptions = (newCmptOptions || []).slice();
  var existingIdIdxMap = createHashMap();
  each$f(newCmptOptions, function(cmptOption, index) {
    if (!isObject$3(cmptOption)) {
      newCmptOptions[index] = null;
      return;
    }
  });
  var result = prepareResult(existings, existingIdIdxMap, mode);
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
  }
  if (isNormalMergeMode) {
    mappingByName(result, newCmptOptions);
  }
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
  } else if (isReplaceAllMode) {
    mappingInReplaceAllMode(result, newCmptOptions);
  }
  makeIdAndName(result);
  return result;
}
function prepareResult(existings, existingIdIdxMap, mode) {
  var result = [];
  if (mode === "replaceAll") {
    return result;
  }
  for (var index = 0; index < existings.length; index++) {
    var existing = existings[index];
    if (existing && existing.id != null) {
      existingIdIdxMap.set(existing.id, index);
    }
    result.push({
      existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
  each$f(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.id == null) {
      return;
    }
    var optionId = makeComparableKey(cmptOption.id);
    var existingIdx = existingIdIdxMap.get(optionId);
    if (existingIdx != null) {
      var resultItem = result[existingIdx];
      assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
      resultItem.newOption = cmptOption;
      resultItem.existing = existings[existingIdx];
      newCmptOptions[index] = null;
    }
  });
}
function mappingByName(result, newCmptOptions) {
  each$f(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.name == null) {
      return;
    }
    for (var i = 0; i < result.length; i++) {
      var existing = result[i].existing;
      if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
        result[i].newOption = cmptOption;
        newCmptOptions[index] = null;
        return;
      }
    }
  });
}
function mappingByIndex(result, newCmptOptions, brandNew) {
  each$f(newCmptOptions, function(cmptOption) {
    if (!cmptOption) {
      return;
    }
    var resultItem;
    var nextIdx = 0;
    while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) {
      nextIdx++;
    }
    if (resultItem) {
      resultItem.newOption = cmptOption;
      resultItem.brandNew = brandNew;
    } else {
      result.push({
        newOption: cmptOption,
        brandNew,
        existing: null,
        keyInfo: null
      });
    }
    nextIdx++;
  });
}
function mappingInReplaceAllMode(result, newCmptOptions) {
  each$f(newCmptOptions, function(cmptOption) {
    result.push({
      newOption: cmptOption,
      brandNew: true,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(mapResult) {
  var idMap = createHashMap();
  each$f(mapResult, function(item) {
    var existing = item.existing;
    existing && idMap.set(existing.id, item);
  });
  each$f(mapResult, function(item) {
    var opt = item.newOption;
    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  });
  each$f(mapResult, function(item, index) {
    var existing = item.existing;
    var opt = item.newOption;
    var keyInfo = item.keyInfo;
    if (!isObject$3(opt)) {
      return;
    }
    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
    if (existing) {
      keyInfo.id = makeComparableKey(existing.id);
    } else if (opt.id != null) {
      keyInfo.id = makeComparableKey(opt.id);
    } else {
      var idNum = 0;
      do {
        keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
      } while (idMap.get(keyInfo.id));
    }
    idMap.set(keyInfo.id, item);
  });
}
function keyExistAndEqual(attr, obj1, obj2) {
  var key1 = convertOptionIdName(obj1[attr], null);
  var key2 = convertOptionIdName(obj2[attr], null);
  return key1 != null && key2 != null && key1 === key2;
}
function makeComparableKey(val) {
  return convertOptionIdName(val, "");
}
function convertOptionIdName(idOrName, defaultValue) {
  if (idOrName == null) {
    return defaultValue;
  }
  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function isNameSpecified(componentModel) {
  var name = componentModel.name;
  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(cmptOption) {
  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(idSuffix) {
  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
  each$f(mappingResult, function(item) {
    var newOption = item.newOption;
    if (isObject$3(newOption)) {
      item.keyInfo.mainType = mainType;
      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
    }
  });
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
  return subType;
}
function compressBatches(batchA, batchB) {
  var mapA = {};
  var mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];
  function makeMap(sourceBatch, map2, otherMap) {
    for (var i = 0, len2 = sourceBatch.length; i < len2; i++) {
      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);
      if (seriesId == null) {
        return;
      }
      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      var otherDataIndices = otherMap && otherMap[seriesId];
      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
        var dataIndex = dataIndices[j];
        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map2[seriesId] || (map2[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }
  function mapToArray(map2, isData) {
    var result = [];
    for (var i in map2) {
      if (map2.hasOwnProperty(i) && map2[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          var dataIndices = mapToArray(map2[i], true);
          dataIndices.length && result.push({
            seriesId: i,
            dataIndex: dataIndices
          });
        }
      }
    }
    return result;
  }
}
function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return isArray$1(payload.dataIndex) ? map$1(payload.dataIndex, function(value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return isArray$1(payload.name) ? map$1(payload.name, function(value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
function makeInner() {
  var key = "__ec_inner_" + innerUniqueIndex++;
  return function(hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder$1(ecModel, finderInput, opt) {
  var _a2 = preParseFinder(finderInput, opt), mainTypeSpecified = _a2.mainTypeSpecified, queryOptionMap = _a2.queryOptionMap, others = _a2.others;
  var result = others;
  var defaultMainType = opt ? opt.defaultMainType : null;
  if (!mainTypeSpecified && defaultMainType) {
    queryOptionMap.set(defaultMainType, {});
  }
  queryOptionMap.each(function(queryOption, mainType) {
    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
      useDefault: defaultMainType === mainType,
      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
    });
    result[mainType + "Models"] = queryResult.models;
    result[mainType + "Model"] = queryResult.models[0];
  });
  return result;
}
function preParseFinder(finderInput, opt) {
  var finder;
  if (isString(finderInput)) {
    var obj = {};
    obj[finderInput + "Index"] = 0;
    finder = obj;
  } else {
    finder = finderInput;
  }
  var queryOptionMap = createHashMap();
  var others = {};
  var mainTypeSpecified = false;
  each$f(finder, function(value, key) {
    if (key === "dataIndex" || key === "dataIndexInside") {
      others[key] = value;
      return;
    }
    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || "").toLowerCase();
    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }
    mainTypeSpecified = mainTypeSpecified || !!mainType;
    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
    queryOption[queryType] = value;
  });
  return {
    mainTypeSpecified,
    queryOptionMap,
    others
  };
}
var SINGLE_REFERRING = {
  useDefault: true,
  enableAll: false,
  enableNone: false
};
var MULTIPLE_REFERRING = {
  useDefault: false,
  enableAll: true,
  enableNone: true
};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
  opt = opt || SINGLE_REFERRING;
  var indexOption = userOption.index;
  var idOption = userOption.id;
  var nameOption = userOption.name;
  var result = {
    models: null,
    specified: indexOption != null || idOption != null || nameOption != null
  };
  if (!result.specified) {
    var firstCmpt = void 0;
    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
    return result;
  }
  if (indexOption === "none" || indexOption === false) {
    assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
    result.models = [];
    return result;
  }
  if (indexOption === "all") {
    assert(opt.enableAll, '`"all"` is not a valid value on index option.');
    indexOption = idOption = nameOption = null;
  }
  result.models = ecModel.queryComponents({
    mainType,
    index: indexOption,
    id: idOption,
    name: nameOption
  });
  return result;
}
function setAttribute(dom, key, value) {
  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
}
function getAttribute(dom, key) {
  return dom.getAttribute ? dom.getAttribute(key) : dom[key];
}
function getTooltipRenderMode(renderModeOption) {
  if (renderModeOption === "auto") {
    return env$1.domSupported ? "html" : "richText";
  } else {
    return renderModeOption || "html";
  }
}
function groupData(array, getKey2) {
  var buckets = createHashMap();
  var keys2 = [];
  each$f(array, function(item) {
    var key = getKey2(item);
    (buckets.get(key) || (keys2.push(key), buckets.set(key, []))).push(item);
  });
  return {
    keys: keys2,
    buckets
  };
}
function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
  var isAutoPrecision = precision == null || precision === "auto";
  if (targetValue == null) {
    return targetValue;
  }
  if (isNumber(targetValue)) {
    var value = interpolateNumber(sourceValue || 0, targetValue, percent);
    return round$3(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
  } else if (isString(targetValue)) {
    return percent < 1 ? sourceValue : targetValue;
  } else {
    var interpolated = [];
    var leftArr = sourceValue;
    var rightArr = targetValue;
    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
    for (var i = 0; i < length_1; ++i) {
      var info = data.getDimensionInfo(i);
      if (info && info.type === "ordinal") {
        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
      } else {
        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
        var rightVal = rightArr[i];
        var value = interpolateNumber(leftVal, rightVal, percent);
        interpolated[i] = round$3(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
      }
    }
    return interpolated;
  }
}
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(componentType) {
  var ret2 = {
    main: "",
    sub: ""
  };
  if (componentType) {
    var typeArr = componentType.split(TYPE_DELIMITER);
    ret2.main = typeArr[0] || "";
    ret2.sub = typeArr[1] || "";
  }
  return ret2;
}
function checkClassType(componentType) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
function isExtendedClass(clz) {
  return !!(clz && clz[IS_EXTENDED_CLASS]);
}
function enableClassExtend(rootClz, mandatoryMethods) {
  rootClz.$constructor = rootClz;
  rootClz.extend = function(proto) {
    var superClass = this;
    var ExtendedClass;
    if (isESClass(superClass)) {
      ExtendedClass = function(_super) {
        __extends(class_1, _super);
        function class_1() {
          return _super.apply(this, arguments) || this;
        }
        return class_1;
      }(superClass);
    } else {
      ExtendedClass = function() {
        (proto.$constructor || superClass).apply(this, arguments);
      };
      inherits(ExtendedClass, this);
    }
    extend$1(ExtendedClass.prototype, proto);
    ExtendedClass[IS_EXTENDED_CLASS] = true;
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}
function isESClass(fn) {
  return isFunction$1(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
}
function mountExtend(SubClz, SupperClz) {
  SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(target) {
  var classAttr = ["__\0is_clz", classBase++].join("_");
  target.prototype[classAttr] = true;
  target.isInstance = function(obj) {
    return !!(obj && obj[classAttr]);
  };
}
function superCall(context, methodName) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function enableClassManagement(target) {
  var storage2 = {};
  target.registerClass = function(clz) {
    var componentFullType = clz.type || clz.prototype.type;
    if (componentFullType) {
      checkClassType(componentFullType);
      clz.prototype.type = componentFullType;
      var componentTypeInfo = parseClassType(componentFullType);
      if (!componentTypeInfo.sub) {
        storage2[componentTypeInfo.main] = clz;
      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
        var container = makeContainer(componentTypeInfo);
        container[componentTypeInfo.sub] = clz;
      }
    }
    return clz;
  };
  target.getClass = function(mainType, subType, throwWhenNotFound) {
    var clz = storage2[mainType];
    if (clz && clz[IS_CONTAINER]) {
      clz = subType ? clz[subType] : null;
    }
    if (throwWhenNotFound && !clz) {
      throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
    }
    return clz;
  };
  target.getClassesByMainType = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var result = [];
    var obj = storage2[componentTypeInfo.main];
    if (obj && obj[IS_CONTAINER]) {
      each$f(obj, function(o, type) {
        type !== IS_CONTAINER && result.push(o);
      });
    } else {
      result.push(obj);
    }
    return result;
  };
  target.hasClass = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    return !!storage2[componentTypeInfo.main];
  };
  target.getAllClassMainTypes = function() {
    var types = [];
    each$f(storage2, function(obj, type) {
      types.push(type);
    });
    return types;
  };
  target.hasSubTypes = function(componentType) {
    var componentTypeInfo = parseClassType(componentType);
    var obj = storage2[componentTypeInfo.main];
    return obj && obj[IS_CONTAINER];
  };
  function makeContainer(componentTypeInfo) {
    var container = storage2[componentTypeInfo.main];
    if (!container || !container[IS_CONTAINER]) {
      container = storage2[componentTypeInfo.main] = {};
      container[IS_CONTAINER] = true;
    }
    return container;
  }
}
function makeStyleMapper(properties, ignoreParent) {
  for (var i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }
  ignoreParent = ignoreParent || false;
  return function(model, excludes, includes) {
    var style = {};
    for (var i2 = 0; i2 < properties.length; i2++) {
      var propName = properties[i2][1];
      if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
        continue;
      }
      var val = model.getShallow(propName, ignoreParent);
      if (val != null) {
        style[properties[i2][0]] = val;
      }
    }
    return style;
  };
}
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = function() {
  function AreaStyleMixin2() {
  }
  AreaStyleMixin2.prototype.getAreaStyle = function(excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  };
  return AreaStyleMixin2;
}();
var globalImageCache = new LRUCache$1(50);
function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === "string") {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === "string") {
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    }
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = { hostEl, cb: onload, cbPayload };
    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      var image_1 = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
      image_1.__zrImageSrc = newImageOrSrc;
      globalImageCache.put(newImageOrSrc, image_1.__cachedImgObj = {
        image: image_1,
        pending: [pendingWrap]
      });
    }
    return image;
  } else {
    return newImageOrSrc;
  }
}
function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var i = 0; i < cachedImgObj.pending.length; i++) {
    var pendingWrap = cachedImgObj.pending[i];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }
  cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
  return image && image.width && image.height;
}
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return "";
  }
  var textLines = (text + "").split("\n");
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
  for (var i = 0, len2 = textLines.length; i < len2; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }
  return textLines.join("\n");
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = options || {};
  var preparedOpts = extend$1({}, options);
  preparedOpts.font = font;
  ellipsis = retrieve2(ellipsis, "...");
  preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
  var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
  preparedOpts.cnCharWidth = getWidth("\u56FD", font);
  var ascCharWidth = preparedOpts.ascCharWidth = getWidth("a", font);
  preparedOpts.placeholder = retrieve2(options.placeholder, "");
  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }
  var ellipsisWidth = getWidth(ellipsis, font);
  if (ellipsisWidth > contentWidth) {
    ellipsis = "";
    ellipsisWidth = 0;
  }
  contentWidth = containerWidth - ellipsisWidth;
  preparedOpts.ellipsis = ellipsis;
  preparedOpts.ellipsisWidth = ellipsisWidth;
  preparedOpts.contentWidth = contentWidth;
  preparedOpts.containerWidth = containerWidth;
  return preparedOpts;
}
function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;
  if (!containerWidth) {
    return "";
  }
  var lineWidth = getWidth(textLine, font);
  if (lineWidth <= containerWidth) {
    return textLine;
  }
  for (var j = 0; ; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }
    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }
  if (textLine === "") {
    textLine = options.placeholder;
  }
  return textLine;
}
function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i = 0;
  for (var len2 = text.length; i < len2 && width < contentWidth; i++) {
    var charCode = text.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }
  return i;
}
function parsePlainText(text, style) {
  text != null && (text += "");
  var overflow = style.overflow;
  var padding = style.padding;
  var font = style.font;
  var truncate = overflow === "truncate";
  var calculatedLineHeight = getLineHeight(font);
  var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
  var bgColorDrawn = !!style.backgroundColor;
  var truncateLineOverflow = style.lineOverflow === "truncate";
  var width = style.width;
  var lines;
  if (width != null && (overflow === "break" || overflow === "breakAll")) {
    lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
  } else {
    lines = text ? text.split("\n") : [];
  }
  var contentHeight = lines.length * lineHeight;
  var height = retrieve2(style.height, contentHeight);
  if (contentHeight > height && truncateLineOverflow) {
    var lineCount = Math.floor(height / lineHeight);
    lines = lines.slice(0, lineCount);
  }
  if (text && truncate && width != null) {
    var options = prepareTruncateOptions(width, font, style.ellipsis, {
      minChar: style.truncateMinChar,
      placeholder: style.placeholder
    });
    for (var i = 0; i < lines.length; i++) {
      lines[i] = truncateSingleLine(lines[i], options);
    }
  }
  var outerHeight = height;
  var contentWidth = 0;
  for (var i = 0; i < lines.length; i++) {
    contentWidth = Math.max(getWidth(lines[i], font), contentWidth);
  }
  if (width == null) {
    width = contentWidth;
  }
  var outerWidth = contentWidth;
  if (padding) {
    outerHeight += padding[0] + padding[2];
    outerWidth += padding[1] + padding[3];
    width += padding[1] + padding[3];
  }
  if (bgColorDrawn) {
    outerWidth = width;
  }
  return {
    lines,
    height,
    outerWidth,
    outerHeight,
    lineHeight,
    calculatedLineHeight,
    contentWidth,
    contentHeight,
    width
  };
}
var RichTextToken = function() {
  function RichTextToken2() {
  }
  return RichTextToken2;
}();
var RichTextLine = function() {
  function RichTextLine2(tokens) {
    this.tokens = [];
    if (tokens) {
      this.tokens = tokens;
    }
  }
  return RichTextLine2;
}();
var RichTextContentBlock = function() {
  function RichTextContentBlock2() {
    this.width = 0;
    this.height = 0;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.outerWidth = 0;
    this.outerHeight = 0;
    this.lines = [];
  }
  return RichTextContentBlock2;
}();
function parseRichText(text, style) {
  var contentBlock = new RichTextContentBlock();
  text != null && (text += "");
  if (!text) {
    return contentBlock;
  }
  var topWidth = style.width;
  var topHeight = style.height;
  var overflow = style.overflow;
  var wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? { width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll" } : null;
  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;
  while ((result = STYLE_REG.exec(text)) != null) {
    var matchedIndex = result.index;
    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
    }
    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }
  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
  }
  var pendingList = [];
  var calculatedHeight = 0;
  var calculatedWidth = 0;
  var stlPadding = style.padding;
  var truncate = overflow === "truncate";
  var truncateLine = style.lineOverflow === "truncate";
  function finishLine(line2, lineWidth2, lineHeight2) {
    line2.width = lineWidth2;
    line2.lineHeight = lineHeight2;
    calculatedHeight += lineHeight2;
    calculatedWidth = Math.max(calculatedWidth, lineWidth2);
  }
  outer:
    for (var i = 0; i < contentBlock.lines.length; i++) {
      var line = contentBlock.lines[i];
      var lineHeight = 0;
      var lineWidth = 0;
      for (var j = 0; j < line.tokens.length; j++) {
        var token2 = line.tokens[j];
        var tokenStyle = token2.styleName && style.rich[token2.styleName] || {};
        var textPadding = token2.textPadding = tokenStyle.padding;
        var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        var font = token2.font = tokenStyle.font || style.font;
        token2.contentHeight = getLineHeight(font);
        var tokenHeight = retrieve2(tokenStyle.height, token2.contentHeight);
        token2.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token2.height = tokenHeight;
        token2.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token2.align = tokenStyle && tokenStyle.align || style.align;
        token2.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token2.lineHeight > topHeight) {
          if (j > 0) {
            line.tokens = line.tokens.slice(0, j);
            finishLine(line, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i);
          }
          break outer;
        }
        var styleTokenWidth = tokenStyle.width;
        var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token2.percentWidth = styleTokenWidth;
          pendingList.push(token2);
          token2.contentWidth = getWidth(token2.text, font);
        } else {
          if (tokenWidthNotSpecified) {
            var textBackgroundColor = tokenStyle.backgroundColor;
            var bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token2.width = Math.max(token2.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token2.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token2.text = "";
              token2.width = token2.contentWidth = 0;
            } else {
              token2.text = truncateText(token2.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
              token2.width = token2.contentWidth = getWidth(token2.text, font);
            }
          } else {
            token2.contentWidth = getWidth(token2.text, font);
          }
        }
        token2.width += paddingH;
        lineWidth += token2.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token2.lineHeight));
      }
      finishLine(line, lineWidth, lineHeight);
    }
  contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
  contentBlock.contentHeight = calculatedHeight;
  contentBlock.contentWidth = calculatedWidth;
  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }
  for (var i = 0; i < pendingList.length; i++) {
    var token2 = pendingList[i];
    var percentWidth = token2.percentWidth;
    token2.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
  }
  return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
  var isEmptyStr = str === "";
  var tokenStyle = styleName && style.rich[styleName] || {};
  var lines = block.lines;
  var font = tokenStyle.font || style.font;
  var newLine = false;
  var strLines;
  var linesWidths;
  if (wrapInfo) {
    var tokenPadding = tokenStyle.padding;
    var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
    if (tokenStyle.width != null && tokenStyle.width !== "auto") {
      var outerWidth_1 = parsePercent$2(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
      if (lines.length > 0) {
        if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
          strLines = str.split("\n");
          newLine = true;
        }
      }
      wrapInfo.accumWidth = outerWidth_1;
    } else {
      var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
      linesWidths = res.linesWidths;
      strLines = res.lines;
    }
  } else {
    strLines = str.split("\n");
  }
  for (var i = 0; i < strLines.length; i++) {
    var text = strLines[i];
    var token2 = new RichTextToken();
    token2.styleName = styleName;
    token2.text = text;
    token2.isLineHolder = !text && !isEmptyStr;
    if (typeof tokenStyle.width === "number") {
      token2.width = tokenStyle.width;
    } else {
      token2.width = linesWidths ? linesWidths[i] : getWidth(text, font);
    }
    if (!i && !newLine) {
      var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token2 : (text || !tokensLen || isEmptyStr) && tokens.push(token2);
    } else {
      lines.push(new RichTextLine([token2]));
    }
  }
}
function isLatin(ch) {
  var code = ch.charCodeAt(0);
  return code >= 33 && code <= 383;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
  obj[ch] = true;
  return obj;
}, {});
function isWordBreakChar(ch) {
  if (isLatin(ch)) {
    if (breakCharMap[ch]) {
      return true;
    }
    return false;
  }
  return true;
}
function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
  var lines = [];
  var linesWidths = [];
  var line = "";
  var currentWord = "";
  var currentWordWidth = 0;
  var accumWidth = 0;
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch === "\n") {
      if (currentWord) {
        line += currentWord;
        accumWidth += currentWordWidth;
      }
      lines.push(line);
      linesWidths.push(accumWidth);
      line = "";
      currentWord = "";
      currentWordWidth = 0;
      accumWidth = 0;
      continue;
    }
    var chWidth = getWidth(ch, font);
    var inWord = isBreakAll ? false : !isWordBreakChar(ch);
    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
      if (!accumWidth) {
        if (inWord) {
          lines.push(currentWord);
          linesWidths.push(currentWordWidth);
          currentWord = ch;
          currentWordWidth = chWidth;
        } else {
          lines.push(ch);
          linesWidths.push(chWidth);
        }
      } else if (line || currentWord) {
        if (inWord) {
          if (!line) {
            line = currentWord;
            currentWord = "";
            currentWordWidth = 0;
            accumWidth = currentWordWidth;
          }
          lines.push(line);
          linesWidths.push(accumWidth - currentWordWidth);
          currentWord += ch;
          currentWordWidth += chWidth;
          line = "";
          accumWidth = currentWordWidth;
        } else {
          if (currentWord) {
            line += currentWord;
            currentWord = "";
            currentWordWidth = 0;
          }
          lines.push(line);
          linesWidths.push(accumWidth);
          line = ch;
          accumWidth = chWidth;
        }
      }
      continue;
    }
    accumWidth += chWidth;
    if (inWord) {
      currentWord += ch;
      currentWordWidth += chWidth;
    } else {
      if (currentWord) {
        line += currentWord;
        currentWord = "";
        currentWordWidth = 0;
      }
      line += ch;
    }
  }
  if (!lines.length && !line) {
    line = text;
    currentWord = "";
    currentWordWidth = 0;
  }
  if (currentWord) {
    line += currentWord;
  }
  if (line) {
    lines.push(line);
    linesWidths.push(accumWidth);
  }
  if (lines.length === 1) {
    accumWidth += lastAccumWidth;
  }
  return {
    accumWidth,
    lines,
    linesWidths
  };
}
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
var DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
};
var DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: true,
    shadowOffsetX: true,
    shadowOffsetY: true,
    shadowColor: true,
    opacity: true
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS = ["z", "z2", "invisible"];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
var Displayable = function(_super) {
  __extends(Displayable2, _super);
  function Displayable2(props) {
    return _super.call(this, props) || this;
  }
  Displayable2.prototype._init = function(props) {
    var keysArr = keys(props);
    for (var i = 0; i < keysArr.length; i++) {
      var key = keysArr[i];
      if (key === "style") {
        this.useStyle(props[key]);
      } else {
        _super.prototype.attrKV.call(this, key, props[key]);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Displayable2.prototype.beforeBrush = function() {
  };
  Displayable2.prototype.afterBrush = function() {
  };
  Displayable2.prototype.innerBeforeBrush = function() {
  };
  Displayable2.prototype.innerAfterBrush = function() {
  };
  Displayable2.prototype.shouldBePainted = function(viewWidth, viewHeight, considerClipPath, considerAncestors) {
    var m2 = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
      return false;
    }
    if (considerClipPath && this.__clipPaths) {
      for (var i = 0; i < this.__clipPaths.length; ++i) {
        if (this.__clipPaths[i].isZeroArea()) {
          return false;
        }
      }
    }
    if (considerAncestors && this.parent) {
      var parent_1 = this.parent;
      while (parent_1) {
        if (parent_1.ignore) {
          return false;
        }
        parent_1 = parent_1.parent;
      }
    }
    return true;
  };
  Displayable2.prototype.contain = function(x, y) {
    return this.rectContain(x, y);
  };
  Displayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  Displayable2.prototype.rectContain = function(x, y) {
    var coord = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  };
  Displayable2.prototype.getPaintRect = function() {
    var rect = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var transform2 = this.transform;
      var elRect = this.getBoundingRect();
      var style = this.style;
      var shadowSize = style.shadowBlur || 0;
      var shadowOffsetX = style.shadowOffsetX || 0;
      var shadowOffsetY = style.shadowOffsetY || 0;
      rect = this._paintRect || (this._paintRect = new BoundingRect$1(0, 0, 0, 0));
      if (transform2) {
        BoundingRect$1.applyTransform(rect, elRect, transform2);
      } else {
        rect.copy(elRect);
      }
      if (shadowSize || shadowOffsetX || shadowOffsetY) {
        rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
        rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
        rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
        rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
      }
      var tolerance = this.dirtyRectTolerance;
      if (!rect.isZero()) {
        rect.x = Math.floor(rect.x - tolerance);
        rect.y = Math.floor(rect.y - tolerance);
        rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
        rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
      }
    }
    return rect;
  };
  Displayable2.prototype.setPrevPaintRect = function(paintRect) {
    if (paintRect) {
      this._prevPaintRect = this._prevPaintRect || new BoundingRect$1(0, 0, 0, 0);
      this._prevPaintRect.copy(paintRect);
    } else {
      this._prevPaintRect = null;
    }
  };
  Displayable2.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  };
  Displayable2.prototype.animateStyle = function(loop) {
    return this.animate("style", loop);
  };
  Displayable2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else {
      this.markRedraw();
    }
  };
  Displayable2.prototype.attrKV = function(key, value) {
    if (key !== "style") {
      _super.prototype.attrKV.call(this, key, value);
    } else {
      if (!this.style) {
        this.useStyle(value);
      } else {
        this.setStyle(value);
      }
    }
  };
  Displayable2.prototype.setStyle = function(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.style[keyOrObj] = value;
    } else {
      extend$1(this.style, keyOrObj);
    }
    this.dirtyStyle();
    return this;
  };
  Displayable2.prototype.dirtyStyle = function(notRedraw) {
    if (!notRedraw) {
      this.markRedraw();
    }
    this.__dirty |= STYLE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
  };
  Displayable2.prototype.dirty = function() {
    this.dirtyStyle();
  };
  Displayable2.prototype.styleChanged = function() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  };
  Displayable2.prototype.styleUpdated = function() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  };
  Displayable2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_COMMON_STYLE, obj);
  };
  Displayable2.prototype.useStyle = function(obj) {
    if (!obj[STYLE_MAGIC_KEY]) {
      obj = this.createStyle(obj);
    }
    if (this.__inHover) {
      this.__hoverStyle = obj;
    } else {
      this.style = obj;
    }
    this.dirtyStyle();
  };
  Displayable2.prototype.isStyleObject = function(obj) {
    return obj[STYLE_MAGIC_KEY];
  };
  Displayable2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.style && !normalState.style) {
      normalState.style = this._mergeStyle(this.createStyle(), this.style);
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
  };
  Displayable2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetStyle;
    if (state && state.style) {
      if (transition) {
        if (keepCurrentStates) {
          targetStyle = state.style;
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else {
        targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
        this._mergeStyle(targetStyle, state.style);
      }
    } else if (needsRestoreToNormal) {
      targetStyle = normalState.style;
    }
    if (targetStyle) {
      if (transition) {
        var sourceStyle = this.style;
        this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
        if (needsRestoreToNormal) {
          var changedKeys = keys(sourceStyle);
          for (var i = 0; i < changedKeys.length; i++) {
            var key = changedKeys[i];
            if (key in targetStyle) {
              targetStyle[key] = targetStyle[key];
              this.style[key] = sourceStyle[key];
            }
          }
        }
        var targetKeys = keys(targetStyle);
        for (var i = 0; i < targetKeys.length; i++) {
          var key = targetKeys[i];
          this.style[key] = this.style[key];
        }
        this._transitionState(stateName, {
          style: targetStyle
        }, animationCfg, this.getAnimationStyleProps());
      } else {
        this.useStyle(targetStyle);
      }
    }
    var statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS;
    for (var i = 0; i < statesKeys.length; i++) {
      var key = statesKeys[i];
      if (state && state[key] != null) {
        this[key] = state[key];
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          this[key] = normalState[key];
        }
      }
    }
  };
  Displayable2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedStyle;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      if (state.style) {
        mergedStyle = mergedStyle || {};
        this._mergeStyle(mergedStyle, state.style);
      }
    }
    if (mergedStyle) {
      mergedState.style = mergedStyle;
    }
    return mergedState;
  };
  Displayable2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    extend$1(targetStyle, sourceStyle);
    return targetStyle;
  };
  Displayable2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  };
  Displayable2.initDefaultProps = function() {
    var dispProto = Displayable2.prototype;
    dispProto.type = "displayable";
    dispProto.invisible = false;
    dispProto.z = 0;
    dispProto.z2 = 0;
    dispProto.zlevel = 0;
    dispProto.culling = false;
    dispProto.cursor = "pointer";
    dispProto.rectHover = false;
    dispProto.incremental = false;
    dispProto._rect = null;
    dispProto.dirtyRectTolerance = 0;
    dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
  }();
  return Displayable2;
}(Element$1);
var tmpRect = new BoundingRect$1(0, 0, 0, 0);
var viewRect = new BoundingRect$1(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());
  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }
  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}
var Displayable$1 = Displayable;
var mathMin$a = Math.min;
var mathMax$a = Math.max;
var mathSin$4 = Math.sin;
var mathCos$4 = Math.cos;
var PI2$9 = Math.PI * 2;
var start = create$3();
var end = create$3();
var extremity = create$3();
function fromPoints(points2, min3, max3) {
  if (points2.length === 0) {
    return;
  }
  var p = points2[0];
  var left = p[0];
  var right = p[0];
  var top = p[1];
  var bottom = p[1];
  for (var i = 1; i < points2.length; i++) {
    p = points2[i];
    left = mathMin$a(left, p[0]);
    right = mathMax$a(right, p[0]);
    top = mathMin$a(top, p[1]);
    bottom = mathMax$a(bottom, p[1]);
  }
  min3[0] = left;
  min3[1] = top;
  max3[0] = right;
  max3[1] = bottom;
}
function fromLine(x0, y0, x1, y1, min3, max3) {
  min3[0] = mathMin$a(x0, x1);
  min3[1] = mathMin$a(y0, y1);
  max3[0] = mathMax$a(x0, x1);
  max3[1] = mathMax$a(y0, y1);
}
var xDim = [];
var yDim = [];
function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
  var cubicExtrema$1 = cubicExtrema;
  var cubicAt$1 = cubicAt;
  var n = cubicExtrema$1(x0, x1, x2, x3, xDim);
  min3[0] = Infinity;
  min3[1] = Infinity;
  max3[0] = -Infinity;
  max3[1] = -Infinity;
  for (var i = 0; i < n; i++) {
    var x = cubicAt$1(x0, x1, x2, x3, xDim[i]);
    min3[0] = mathMin$a(x, min3[0]);
    max3[0] = mathMax$a(x, max3[0]);
  }
  n = cubicExtrema$1(y0, y1, y2, y3, yDim);
  for (var i = 0; i < n; i++) {
    var y = cubicAt$1(y0, y1, y2, y3, yDim[i]);
    min3[1] = mathMin$a(y, min3[1]);
    max3[1] = mathMax$a(y, max3[1]);
  }
  min3[0] = mathMin$a(x0, min3[0]);
  max3[0] = mathMax$a(x0, max3[0]);
  min3[0] = mathMin$a(x3, min3[0]);
  max3[0] = mathMax$a(x3, max3[0]);
  min3[1] = mathMin$a(y0, min3[1]);
  max3[1] = mathMax$a(y0, max3[1]);
  min3[1] = mathMin$a(y3, min3[1]);
  max3[1] = mathMax$a(y3, max3[1]);
}
function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
  var quadraticExtremum$1 = quadraticExtremum;
  var quadraticAt2 = quadraticAt$1;
  var tx = mathMax$a(mathMin$a(quadraticExtremum$1(x0, x1, x2), 1), 0);
  var ty = mathMax$a(mathMin$a(quadraticExtremum$1(y0, y1, y2), 1), 0);
  var x = quadraticAt2(x0, x1, x2, tx);
  var y = quadraticAt2(y0, y1, y2, ty);
  min3[0] = mathMin$a(x0, x2, x);
  min3[1] = mathMin$a(y0, y2, y);
  max3[0] = mathMax$a(x0, x2, x);
  max3[1] = mathMax$a(y0, y2, y);
}
function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
  var vec2Min = min$1;
  var vec2Max = max$1;
  var diff = Math.abs(startAngle - endAngle);
  if (diff % PI2$9 < 1e-4 && diff > 1e-4) {
    min3[0] = x - rx;
    min3[1] = y - ry;
    max3[0] = x + rx;
    max3[1] = y + ry;
    return;
  }
  start[0] = mathCos$4(startAngle) * rx + x;
  start[1] = mathSin$4(startAngle) * ry + y;
  end[0] = mathCos$4(endAngle) * rx + x;
  end[1] = mathSin$4(endAngle) * ry + y;
  vec2Min(min3, start, end);
  vec2Max(max3, start, end);
  startAngle = startAngle % PI2$9;
  if (startAngle < 0) {
    startAngle = startAngle + PI2$9;
  }
  endAngle = endAngle % PI2$9;
  if (endAngle < 0) {
    endAngle = endAngle + PI2$9;
  }
  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2$9;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2$9;
  }
  if (anticlockwise) {
    var tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  }
  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos$4(angle) * rx + x;
      extremity[1] = mathSin$4(angle) * ry + y;
      vec2Min(min3, extremity, min3);
      vec2Max(max3, extremity, max3);
    }
  }
}
var CMD$4 = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min = [];
var max = [];
var min2 = [];
var max2 = [];
var mathMin$9 = Math.min;
var mathMax$9 = Math.max;
var mathCos$3 = Math.cos;
var mathSin$3 = Math.sin;
var mathAbs$2 = Math.abs;
var PI$a = Math.PI;
var PI2$8 = PI$a * 2;
var hasTypedArray = typeof Float32Array !== "undefined";
var tmpAngles = [];
function modPI2(radian) {
  var n = Math.round(radian / PI$a * 1e8) / 1e8;
  return n % 2 * PI$a;
}
function normalizeArcAngles(angles, anticlockwise) {
  var newStartAngle = modPI2(angles[0]);
  if (newStartAngle < 0) {
    newStartAngle += PI2$8;
  }
  var delta = newStartAngle - angles[0];
  var newEndAngle = angles[1];
  newEndAngle += delta;
  if (!anticlockwise && newEndAngle - newStartAngle >= PI2$8) {
    newEndAngle = newStartAngle + PI2$8;
  } else if (anticlockwise && newStartAngle - newEndAngle >= PI2$8) {
    newEndAngle = newStartAngle - PI2$8;
  } else if (!anticlockwise && newStartAngle > newEndAngle) {
    newEndAngle = newStartAngle + (PI2$8 - modPI2(newStartAngle - newEndAngle));
  } else if (anticlockwise && newStartAngle < newEndAngle) {
    newEndAngle = newStartAngle - (PI2$8 - modPI2(newEndAngle - newStartAngle));
  }
  angles[0] = newStartAngle;
  angles[1] = newEndAngle;
}
var PathProxy = function() {
  function PathProxy2(notSaveData) {
    this.dpr = 1;
    this._xi = 0;
    this._yi = 0;
    this._x0 = 0;
    this._y0 = 0;
    this._len = 0;
    if (notSaveData) {
      this._saveData = false;
    }
    if (this._saveData) {
      this.data = [];
    }
  }
  PathProxy2.prototype.increaseVersion = function() {
    this._version++;
  };
  PathProxy2.prototype.getVersion = function() {
    return this._version;
  };
  PathProxy2.prototype.setScale = function(sx, sy, segmentIgnoreThreshold) {
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    if (segmentIgnoreThreshold > 0) {
      this._ux = mathAbs$2(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
      this._uy = mathAbs$2(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
    }
  };
  PathProxy2.prototype.setDPR = function(dpr2) {
    this.dpr = dpr2;
  };
  PathProxy2.prototype.setContext = function(ctx) {
    this._ctx = ctx;
  };
  PathProxy2.prototype.getContext = function() {
    return this._ctx;
  };
  PathProxy2.prototype.beginPath = function() {
    this._ctx && this._ctx.beginPath();
    this.reset();
    return this;
  };
  PathProxy2.prototype.reset = function() {
    if (this._saveData) {
      this._len = 0;
    }
    if (this._pathSegLen) {
      this._pathSegLen = null;
      this._pathLen = 0;
    }
    this._version++;
  };
  PathProxy2.prototype.moveTo = function(x, y) {
    this._drawPendingPt();
    this.addData(CMD$4.M, x, y);
    this._ctx && this._ctx.moveTo(x, y);
    this._x0 = x;
    this._y0 = y;
    this._xi = x;
    this._yi = y;
    return this;
  };
  PathProxy2.prototype.lineTo = function(x, y) {
    var dx = mathAbs$2(x - this._xi);
    var dy = mathAbs$2(y - this._yi);
    var exceedUnit = dx > this._ux || dy > this._uy;
    this.addData(CMD$4.L, x, y);
    if (this._ctx && exceedUnit) {
      this._ctx.lineTo(x, y);
    }
    if (exceedUnit) {
      this._xi = x;
      this._yi = y;
      this._pendingPtDist = 0;
    } else {
      var d2 = dx * dx + dy * dy;
      if (d2 > this._pendingPtDist) {
        this._pendingPtX = x;
        this._pendingPtY = y;
        this._pendingPtDist = d2;
      }
    }
    return this;
  };
  PathProxy2.prototype.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {
    this._drawPendingPt();
    this.addData(CMD$4.C, x1, y1, x2, y2, x3, y3);
    if (this._ctx) {
      this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }
    this._xi = x3;
    this._yi = y3;
    return this;
  };
  PathProxy2.prototype.quadraticCurveTo = function(x1, y1, x2, y2) {
    this._drawPendingPt();
    this.addData(CMD$4.Q, x1, y1, x2, y2);
    if (this._ctx) {
      this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }
    this._xi = x2;
    this._yi = y2;
    return this;
  };
  PathProxy2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this._drawPendingPt();
    tmpAngles[0] = startAngle;
    tmpAngles[1] = endAngle;
    normalizeArcAngles(tmpAngles, anticlockwise);
    startAngle = tmpAngles[0];
    endAngle = tmpAngles[1];
    var delta = endAngle - startAngle;
    this.addData(CMD$4.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos$3(endAngle) * r + cx;
    this._yi = mathSin$3(endAngle) * r + cy;
    return this;
  };
  PathProxy2.prototype.arcTo = function(x1, y1, x2, y2, radius) {
    this._drawPendingPt();
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }
    return this;
  };
  PathProxy2.prototype.rect = function(x, y, w, h) {
    this._drawPendingPt();
    this._ctx && this._ctx.rect(x, y, w, h);
    this.addData(CMD$4.R, x, y, w, h);
    return this;
  };
  PathProxy2.prototype.closePath = function() {
    this._drawPendingPt();
    this.addData(CMD$4.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;
    if (ctx) {
      ctx.closePath();
    }
    this._xi = x0;
    this._yi = y0;
    return this;
  };
  PathProxy2.prototype.fill = function(ctx) {
    ctx && ctx.fill();
    this.toStatic();
  };
  PathProxy2.prototype.stroke = function(ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  };
  PathProxy2.prototype.len = function() {
    return this._len;
  };
  PathProxy2.prototype.setData = function(data) {
    var len2 = data.length;
    if (!(this.data && this.data.length === len2) && hasTypedArray) {
      this.data = new Float32Array(len2);
    }
    for (var i = 0; i < len2; i++) {
      this.data[i] = data[i];
    }
    this._len = len2;
  };
  PathProxy2.prototype.appendPath = function(path) {
    if (!(path instanceof Array)) {
      path = [path];
    }
    var len2 = path.length;
    var appendSize = 0;
    var offset = this._len;
    for (var i = 0; i < len2; i++) {
      appendSize += path[i].len();
    }
    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }
    for (var i = 0; i < len2; i++) {
      var appendPathData = path[i].data;
      for (var k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }
    this._len = offset;
  };
  PathProxy2.prototype.addData = function(cmd, a, b, c, d, e2, f, g2, h) {
    if (!this._saveData) {
      return;
    }
    var data = this.data;
    if (this._len + arguments.length > data.length) {
      this._expandData();
      data = this.data;
    }
    for (var i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }
  };
  PathProxy2.prototype._drawPendingPt = function() {
    if (this._pendingPtDist > 0) {
      this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
      this._pendingPtDist = 0;
    }
  };
  PathProxy2.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      var newData = [];
      for (var i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }
  };
  PathProxy2.prototype.toStatic = function() {
    if (!this._saveData) {
      return;
    }
    this._drawPendingPt();
    var data = this.data;
    if (data instanceof Array) {
      data.length = this._len;
      if (hasTypedArray && this._len > 11) {
        this.data = new Float32Array(data);
      }
    }
  };
  PathProxy2.prototype.getBoundingRect = function() {
    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    var i;
    for (i = 0; i < this._len; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD$4.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          min2[0] = x0;
          min2[1] = y0;
          max2[0] = x0;
          max2[1] = y0;
          break;
        case CMD$4.L:
          fromLine(xi, yi, data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$4.C:
          fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$4.Q:
          fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$4.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle;
          i += 1;
          var anticlockwise = !data[i++];
          if (isFirst) {
            x0 = mathCos$3(startAngle) * rx + cx;
            y0 = mathSin$3(startAngle) * ry + cy;
          }
          fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
          xi = mathCos$3(endAngle) * rx + cx;
          yi = mathSin$3(endAngle) * ry + cy;
          break;
        case CMD$4.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
          break;
        case CMD$4.Z:
          xi = x0;
          yi = y0;
          break;
      }
      min$1(min, min, min2);
      max$1(max, max, max2);
    }
    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }
    return new BoundingRect$1(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  };
  PathProxy2.prototype._calculateLength = function() {
    var data = this.data;
    var len2 = this._len;
    var ux = this._ux;
    var uy = this._uy;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    if (!this._pathSegLen) {
      this._pathSegLen = [];
    }
    var pathSegLen = this._pathSegLen;
    var pathTotalLen = 0;
    var segCount = 0;
    for (var i = 0; i < len2; ) {
      var cmd = data[i++];
      var isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      var l = -1;
      switch (cmd) {
        case CMD$4.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          break;
        case CMD$4.L: {
          var x2 = data[i++];
          var y2 = data[i++];
          var dx = x2 - xi;
          var dy = y2 - yi;
          if (mathAbs$2(dx) > ux || mathAbs$2(dy) > uy || i === len2 - 1) {
            l = Math.sqrt(dx * dx + dy * dy);
            xi = x2;
            yi = y2;
          }
          break;
        }
        case CMD$4.C: {
          var x1 = data[i++];
          var y1 = data[i++];
          var x2 = data[i++];
          var y2 = data[i++];
          var x3 = data[i++];
          var y3 = data[i++];
          l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
          xi = x3;
          yi = y3;
          break;
        }
        case CMD$4.Q: {
          var x1 = data[i++];
          var y1 = data[i++];
          var x2 = data[i++];
          var y2 = data[i++];
          l = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
          xi = x2;
          yi = y2;
          break;
        }
        case CMD$4.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var delta = data[i++];
          var endAngle = delta + startAngle;
          i += 1;
          !data[i++];
          if (isFirst) {
            x0 = mathCos$3(startAngle) * rx + cx;
            y0 = mathSin$3(startAngle) * ry + cy;
          }
          l = mathMax$9(rx, ry) * mathMin$9(PI2$8, Math.abs(delta));
          xi = mathCos$3(endAngle) * rx + cx;
          yi = mathSin$3(endAngle) * ry + cy;
          break;
        case CMD$4.R: {
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          l = width * 2 + height * 2;
          break;
        }
        case CMD$4.Z: {
          var dx = x0 - xi;
          var dy = y0 - yi;
          l = Math.sqrt(dx * dx + dy * dy);
          xi = x0;
          yi = y0;
          break;
        }
      }
      if (l >= 0) {
        pathSegLen[segCount++] = l;
        pathTotalLen += l;
      }
    }
    this._pathLen = pathTotalLen;
    return pathTotalLen;
  };
  PathProxy2.prototype.rebuildPath = function(ctx, percent) {
    var d = this.data;
    var ux = this._ux;
    var uy = this._uy;
    var len2 = this._len;
    var x0;
    var y0;
    var xi;
    var yi;
    var x;
    var y;
    var drawPart = percent < 1;
    var pathSegLen;
    var pathTotalLen;
    var accumLength = 0;
    var segCount = 0;
    var displayedLength;
    var pendingPtDist = 0;
    var pendingPtX;
    var pendingPtY;
    if (drawPart) {
      if (!this._pathSegLen) {
        this._calculateLength();
      }
      pathSegLen = this._pathSegLen;
      pathTotalLen = this._pathLen;
      displayedLength = percent * pathTotalLen;
      if (!displayedLength) {
        return;
      }
    }
    lo:
      for (var i = 0; i < len2; ) {
        var cmd = d[i++];
        var isFirst = i === 1;
        if (isFirst) {
          xi = d[i];
          yi = d[i + 1];
          x0 = xi;
          y0 = yi;
        }
        if (cmd !== CMD$4.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD$4.M:
            x0 = xi = d[i++];
            y0 = yi = d[i++];
            ctx.moveTo(xi, yi);
            break;
          case CMD$4.L: {
            x = d[i++];
            y = d[i++];
            var dx = mathAbs$2(x - xi);
            var dy = mathAbs$2(y - yi);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                var l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  var t = (displayedLength - accumLength) / l;
                  ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);
                  break lo;
                }
                accumLength += l;
              }
              ctx.lineTo(x, y);
              xi = x;
              yi = y;
              pendingPtDist = 0;
            } else {
              var d2 = dx * dx + dy * dy;
              if (d2 > pendingPtDist) {
                pendingPtX = x;
                pendingPtY = y;
                pendingPtDist = d2;
              }
            }
            break;
          }
          case CMD$4.C: {
            var x1 = d[i++];
            var y1 = d[i++];
            var x2 = d[i++];
            var y2 = d[i++];
            var x3 = d[i++];
            var y3 = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);
                cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l;
            }
            ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD$4.Q: {
            var x1 = d[i++];
            var y1 = d[i++];
            var x2 = d[i++];
            var y2 = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                quadraticSubdivide(xi, x1, x2, t, tmpOutX);
                quadraticSubdivide(yi, y1, y2, t, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l;
            }
            ctx.quadraticCurveTo(x1, y1, x2, y2);
            xi = x2;
            yi = y2;
            break;
          }
          case CMD$4.A:
            var cx = d[i++];
            var cy = d[i++];
            var rx = d[i++];
            var ry = d[i++];
            var startAngle = d[i++];
            var delta = d[i++];
            var psi = d[i++];
            var anticlockwise = !d[i++];
            var r = rx > ry ? rx : ry;
            var isEllipse = mathAbs$2(rx - ry) > 1e-3;
            var endAngle = startAngle + delta;
            var breakBuild = false;
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l;
                breakBuild = true;
              }
              accumLength += l;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x0 = mathCos$3(startAngle) * rx + cx;
              y0 = mathSin$3(startAngle) * ry + cy;
            }
            xi = mathCos$3(endAngle) * rx + cx;
            yi = mathSin$3(endAngle) * ry + cy;
            break;
          case CMD$4.R:
            x0 = xi = d[i];
            y0 = yi = d[i + 1];
            x = d[i++];
            y = d[i++];
            var width = d[i++];
            var height = d[i++];
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var d_1 = displayedLength - accumLength;
                ctx.moveTo(x, y);
                ctx.lineTo(x + mathMin$9(d_1, width), y);
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x + width, y + mathMin$9(d_1, height));
                }
                d_1 -= height;
                if (d_1 > 0) {
                  ctx.lineTo(x + mathMax$9(width - d_1, 0), y + height);
                }
                d_1 -= width;
                if (d_1 > 0) {
                  ctx.lineTo(x, y + mathMax$9(height - d_1, 0));
                }
                break lo;
              }
              accumLength += l;
            }
            ctx.rect(x, y, width, height);
            break;
          case CMD$4.Z:
            if (drawPart) {
              var l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l;
                ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
                break lo;
              }
              accumLength += l;
            }
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
  };
  PathProxy2.prototype.clone = function() {
    var newProxy = new PathProxy2();
    var data = this.data;
    newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
    newProxy._len = this._len;
    return newProxy;
  };
  PathProxy2.CMD = CMD$4;
  PathProxy2.initDefaultProps = function() {
    var proto = PathProxy2.prototype;
    proto._saveData = true;
    proto._ux = 0;
    proto._uy = 0;
    proto._pendingPtDist = 0;
    proto._version = 0;
  }();
  return PathProxy2;
}();
var PathProxy$1 = PathProxy;
function containStroke$4(x0, y0, x1, y1, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  var _a2 = 0;
  var _b2 = x0;
  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }
  if (x0 !== x1) {
    _a2 = (y0 - y1) / (x0 - x1);
    _b2 = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }
  var tmp = _a2 * x - y + _b2;
  var _s = tmp * tmp / (_a2 * _a2 + 1);
  return _s <= _l / 2 * _l / 2;
}
function containStroke$3(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
    return false;
  }
  var d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
  return d <= _l / 2;
}
function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
    return false;
  }
  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
  return d <= _l / 2;
}
var PI2$7 = Math.PI * 2;
function normalizeRadian(angle) {
  angle %= PI2$7;
  if (angle < 0) {
    angle += PI2$7;
  }
  return angle;
}
var PI2$6 = Math.PI * 2;
function containStroke$1(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  x -= cx;
  y -= cy;
  var d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r) {
    return false;
  }
  if (Math.abs(startAngle - endAngle) % PI2$6 < 1e-4) {
    return true;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2$6;
  }
  var angle = Math.atan2(y, x);
  if (angle < 0) {
    angle += PI2$6;
  }
  return angle >= startAngle && angle <= endAngle || angle + PI2$6 >= startAngle && angle + PI2$6 <= endAngle;
}
function windingLine(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  }
  if (y1 === y0) {
    return 0;
  }
  var t = (y - y0) / (y1 - y0);
  var dir3 = y1 < y0 ? 1 : -1;
  if (t === 1 || t === 0) {
    dir3 = y1 < y0 ? 0.5 : -0.5;
  }
  var x_ = t * (x1 - x0) + x0;
  return x_ === x ? Infinity : x_ > x ? dir3 : 0;
}
var CMD$3 = PathProxy$1.CMD;
var PI2$5 = Math.PI * 2;
var EPSILON$2 = 1e-4;
function isAroundEqual$1(a, b) {
  return Math.abs(a - b) < EPSILON$2;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }
  var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var w = 0;
    var nExtrema = -1;
    var y0_ = void 0;
    var y1_ = void 0;
    for (var i = 0; i < nRoots; i++) {
      var t = roots[i];
      var unit = t === 0 || t === 1 ? 0.5 : 1;
      var x_ = cubicAt(x0, x1, x2, x3, t);
      if (x_ < x) {
        continue;
      }
      if (nExtrema < 0) {
        nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }
        y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
        if (nExtrema > 1) {
          y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }
      if (nExtrema === 2) {
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else if (t < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }
    return w;
  }
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }
  var nRoots = quadraticRootAt(y0, y1, y2, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var t = quadraticExtremum(y0, y1, y2);
    if (t >= 0 && t <= 1) {
      var w = 0;
      var y_ = quadraticAt$1(y0, y1, y2, t);
      for (var i = 0; i < nRoots; i++) {
        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        var x_ = quadraticAt$1(x0, x1, x2, roots[i]);
        if (x_ < x) {
          continue;
        }
        if (roots[i] < t) {
          w += y_ < y0 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }
      return w;
    } else {
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = quadraticAt$1(x0, x1, x2, roots[0]);
      if (x_ < x) {
        return 0;
      }
      return y2 < y0 ? unit : -unit;
    }
  }
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  y -= cy;
  if (y > r || y < -r) {
    return 0;
  }
  var tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  var dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) {
    return 0;
  }
  if (dTheta >= PI2$5 - 1e-4) {
    startAngle = 0;
    endAngle = PI2$5;
    var dir3 = anticlockwise ? 1 : -1;
    if (x >= roots[0] + cx && x <= roots[1] + cx) {
      return dir3;
    } else {
      return 0;
    }
  }
  if (startAngle > endAngle) {
    var tmp_1 = startAngle;
    startAngle = endAngle;
    endAngle = tmp_1;
  }
  if (startAngle < 0) {
    startAngle += PI2$5;
    endAngle += PI2$5;
  }
  var w = 0;
  for (var i = 0; i < 2; i++) {
    var x_ = roots[i];
    if (x_ + cx > x) {
      var angle = Math.atan2(y, x_);
      var dir3 = anticlockwise ? 1 : -1;
      if (angle < 0) {
        angle = PI2$5 + angle;
      }
      if (angle >= startAngle && angle <= endAngle || angle + PI2$5 >= startAngle && angle + PI2$5 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir3 = -dir3;
        }
        w += dir3;
      }
    }
  }
  return w;
}
function containPath(path, lineWidth, isStroke, x, y) {
  var data = path.data;
  var len2 = path.len();
  var w = 0;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;
  var x1;
  var y1;
  for (var i = 0; i < len2; ) {
    var cmd = data[i++];
    var isFirst = i === 1;
    if (cmd === CMD$3.M && i > 1) {
      if (!isStroke) {
        w += windingLine(xi, yi, x0, y0, x, y);
      }
    }
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }
    switch (cmd) {
      case CMD$3.M:
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;
      case CMD$3.L:
        if (isStroke) {
          if (containStroke$4(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$3.C:
        if (isStroke) {
          if (containStroke$3(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$3.Q:
        if (isStroke) {
          if (containStroke$2(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$3.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++];
        i += 1;
        var anticlockwise = !!(1 - data[i++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (!isFirst) {
          w += windingLine(xi, yi, x1, y1, x, y);
        } else {
          x0 = x1;
          y0 = y1;
        }
        var _x = (x - cx) * ry / rx + cx;
        if (isStroke) {
          if (containStroke$1(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD$3.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        x1 = x0 + width;
        y1 = y0 + height;
        if (isStroke) {
          if (containStroke$4(x0, y0, x1, y0, lineWidth, x, y) || containStroke$4(x1, y0, x1, y1, lineWidth, x, y) || containStroke$4(x1, y1, x0, y1, lineWidth, x, y) || containStroke$4(x0, y1, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(x1, y0, x1, y1, x, y);
          w += windingLine(x0, y1, x0, y0, x, y);
        }
        break;
      case CMD$3.Z:
        if (isStroke) {
          if (containStroke$4(xi, yi, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, x0, y0, x, y);
        }
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (!isStroke && !isAroundEqual$1(yi, y0)) {
    w += windingLine(xi, yi, x0, y0, x, y) || 0;
  }
  return w !== 0;
}
function contain$2(pathProxy, x, y) {
  return containPath(pathProxy, 0, false, x, y);
}
function containStroke(pathProxy, lineWidth, x, y) {
  return containPath(pathProxy, lineWidth, true, x, y);
}
var DEFAULT_PATH_STYLE = defaults({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: false,
  strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    strokePercent: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineDashOffset: true,
    lineWidth: true,
    miterLimit: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]);
var Path = function(_super) {
  __extends(Path2, _super);
  function Path2(opts) {
    return _super.call(this, opts) || this;
  }
  Path2.prototype.update = function() {
    var _this = this;
    _super.prototype.update.call(this);
    var style = this.style;
    if (style.decal) {
      var decalEl = this._decalEl = this._decalEl || new Path2();
      if (decalEl.buildPath === Path2.prototype.buildPath) {
        decalEl.buildPath = function(ctx) {
          _this.buildPath(ctx, _this.shape);
        };
      }
      decalEl.silent = true;
      var decalElStyle = decalEl.style;
      for (var key in style) {
        if (decalElStyle[key] !== style[key]) {
          decalElStyle[key] = style[key];
        }
      }
      decalElStyle.fill = style.fill ? style.decal : null;
      decalElStyle.decal = null;
      decalElStyle.shadowColor = null;
      style.strokeFirst && (decalElStyle.stroke = null);
      for (var i = 0; i < pathCopyParams.length; ++i) {
        decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
      }
      decalEl.__dirty |= REDRAW_BIT;
    } else if (this._decalEl) {
      this._decalEl = null;
    }
  };
  Path2.prototype.getDecalElement = function() {
    return this._decalEl;
  };
  Path2.prototype._init = function(props) {
    var keysArr = keys(props);
    this.shape = this.getDefaultShape();
    var defaultStyle = this.getDefaultStyle();
    if (defaultStyle) {
      this.useStyle(defaultStyle);
    }
    for (var i = 0; i < keysArr.length; i++) {
      var key = keysArr[i];
      var value = props[key];
      if (key === "style") {
        if (!this.style) {
          this.useStyle(value);
        } else {
          extend$1(this.style, value);
        }
      } else if (key === "shape") {
        extend$1(this.shape, value);
      } else {
        _super.prototype.attrKV.call(this, key, value);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  };
  Path2.prototype.getDefaultStyle = function() {
    return null;
  };
  Path2.prototype.getDefaultShape = function() {
    return {};
  };
  Path2.prototype.canBeInsideText = function() {
    return this.hasFill();
  };
  Path2.prototype.getInsideTextFill = function() {
    var pathFill = this.style.fill;
    if (pathFill !== "none") {
      if (isString(pathFill)) {
        var fillLum = lum(pathFill, 0);
        if (fillLum > 0.5) {
          return DARK_LABEL_COLOR;
        } else if (fillLum > 0.2) {
          return LIGHTER_LABEL_COLOR;
        }
        return LIGHT_LABEL_COLOR;
      } else if (pathFill) {
        return LIGHT_LABEL_COLOR;
      }
    }
    return DARK_LABEL_COLOR;
  };
  Path2.prototype.getInsideTextStroke = function(textFill) {
    var pathFill = this.style.fill;
    if (isString(pathFill)) {
      var zr = this.__zr;
      var isDarkMode2 = !!(zr && zr.isDarkMode());
      var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
      if (isDarkMode2 === isDarkLabel) {
        return pathFill;
      }
    }
  };
  Path2.prototype.buildPath = function(ctx, shapeCfg, inBatch) {
  };
  Path2.prototype.pathUpdated = function() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  };
  Path2.prototype.getUpdatedPathProxy = function(inBatch) {
    !this.path && this.createPathProxy();
    this.path.beginPath();
    this.buildPath(this.path, this.shape, inBatch);
    return this.path;
  };
  Path2.prototype.createPathProxy = function() {
    this.path = new PathProxy$1(false);
  };
  Path2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  };
  Path2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  Path2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;
    if (needsUpdateRect) {
      var firstInvoke = false;
      if (!this.path) {
        firstInvoke = true;
        this.createPathProxy();
      }
      var path = this.path;
      if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
        this.pathUpdated();
      }
      rect = path.getBoundingRect();
    }
    this._rect = rect;
    if (this.hasStroke() && this.path && this.path.len() > 0) {
      var rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
      if (this.__dirty || needsUpdateRect) {
        rectStroke.copy(rect);
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        var w = style.lineWidth;
        if (!this.hasFill()) {
          var strokeContainThreshold = this.strokeContainThreshold;
          w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
        }
        if (lineScale > 1e-10) {
          rectStroke.width += w / lineScale;
          rectStroke.height += w / lineScale;
          rectStroke.x -= w / lineScale / 2;
          rectStroke.y -= w / lineScale / 2;
        }
      }
      return rectStroke;
    }
    return rect;
  };
  Path2.prototype.contain = function(x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    var style = this.style;
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      var pathProxy = this.path;
      if (this.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (lineScale > 1e-10) {
          if (!this.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }
          if (containStroke(pathProxy, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }
      if (this.hasFill()) {
        return contain$2(pathProxy, x, y);
      }
    }
    return false;
  };
  Path2.prototype.dirtyShape = function() {
    this.__dirty |= SHAPE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
    if (this._decalEl) {
      this._decalEl.dirtyShape();
    }
    this.markRedraw();
  };
  Path2.prototype.dirty = function() {
    this.dirtyStyle();
    this.dirtyShape();
  };
  Path2.prototype.animateShape = function(loop) {
    return this.animate("shape", loop);
  };
  Path2.prototype.updateDuringAnimation = function(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else if (targetKey === "shape") {
      this.dirtyShape();
    } else {
      this.markRedraw();
    }
  };
  Path2.prototype.attrKV = function(key, value) {
    if (key === "shape") {
      this.setShape(value);
    } else {
      _super.prototype.attrKV.call(this, key, value);
    }
  };
  Path2.prototype.setShape = function(keyOrObj, value) {
    var shape = this.shape;
    if (!shape) {
      shape = this.shape = {};
    }
    if (typeof keyOrObj === "string") {
      shape[keyOrObj] = value;
    } else {
      extend$1(shape, keyOrObj);
    }
    this.dirtyShape();
    return this;
  };
  Path2.prototype.shapeChanged = function() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  };
  Path2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_PATH_STYLE, obj);
  };
  Path2.prototype._innerSaveToNormal = function(toState) {
    _super.prototype._innerSaveToNormal.call(this, toState);
    var normalState = this._normalState;
    if (toState.shape && !normalState.shape) {
      normalState.shape = extend$1({}, this.shape);
    }
  };
  Path2.prototype._applyStateObj = function(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    var needsRestoreToNormal = !(state && keepCurrentStates);
    var targetShape;
    if (state && state.shape) {
      if (transition) {
        if (keepCurrentStates) {
          targetShape = state.shape;
        } else {
          targetShape = extend$1({}, normalState.shape);
          extend$1(targetShape, state.shape);
        }
      } else {
        targetShape = extend$1({}, keepCurrentStates ? this.shape : normalState.shape);
        extend$1(targetShape, state.shape);
      }
    } else if (needsRestoreToNormal) {
      targetShape = normalState.shape;
    }
    if (targetShape) {
      if (transition) {
        this.shape = extend$1({}, this.shape);
        var targetShapePrimaryProps = {};
        var shapeKeys = keys(targetShape);
        for (var i = 0; i < shapeKeys.length; i++) {
          var key = shapeKeys[i];
          if (typeof targetShape[key] === "object") {
            this.shape[key] = targetShape[key];
          } else {
            targetShapePrimaryProps[key] = targetShape[key];
          }
        }
        this._transitionState(stateName, {
          shape: targetShapePrimaryProps
        }, animationCfg);
      } else {
        this.shape = targetShape;
        this.dirtyShape();
      }
    }
  };
  Path2.prototype._mergeStates = function(states) {
    var mergedState = _super.prototype._mergeStates.call(this, states);
    var mergedShape;
    for (var i = 0; i < states.length; i++) {
      var state = states[i];
      if (state.shape) {
        mergedShape = mergedShape || {};
        this._mergeStyle(mergedShape, state.shape);
      }
    }
    if (mergedShape) {
      mergedState.shape = mergedShape;
    }
    return mergedState;
  };
  Path2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  };
  Path2.prototype.isZeroArea = function() {
    return false;
  };
  Path2.extend = function(defaultProps) {
    var Sub = function(_super2) {
      __extends(Sub2, _super2);
      function Sub2(opts) {
        var _this = _super2.call(this, opts) || this;
        defaultProps.init && defaultProps.init.call(_this, opts);
        return _this;
      }
      Sub2.prototype.getDefaultStyle = function() {
        return clone$4(defaultProps.style);
      };
      Sub2.prototype.getDefaultShape = function() {
        return clone$4(defaultProps.shape);
      };
      return Sub2;
    }(Path2);
    for (var key in defaultProps) {
      if (typeof defaultProps[key] === "function") {
        Sub.prototype[key] = defaultProps[key];
      }
    }
    return Sub;
  };
  Path2.initDefaultProps = function() {
    var pathProto = Path2.prototype;
    pathProto.type = "path";
    pathProto.strokeContainThreshold = 5;
    pathProto.segmentIgnoreThreshold = 0;
    pathProto.subPixelOptimize = false;
    pathProto.autoBatch = false;
    pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
  }();
  return Path2;
}(Displayable$1);
var Path$1 = Path;
var DEFAULT_TSPAN_STYLE = defaults({
  strokeFirst: true,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan = function(_super) {
  __extends(TSpan2, _super);
  function TSpan2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TSpan2.prototype.hasStroke = function() {
    var style = this.style;
    var stroke = style.stroke;
    return stroke != null && stroke !== "none" && style.lineWidth > 0;
  };
  TSpan2.prototype.hasFill = function() {
    var style = this.style;
    var fill = style.fill;
    return fill != null && fill !== "none";
  };
  TSpan2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_TSPAN_STYLE, obj);
  };
  TSpan2.prototype.setBoundingRect = function(rect) {
    this._rect = rect;
  };
  TSpan2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      var text = style.text;
      text != null ? text += "" : text = "";
      var rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
      rect.x += style.x || 0;
      rect.y += style.y || 0;
      if (this.hasStroke()) {
        var w = style.lineWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }
      this._rect = rect;
    }
    return this._rect;
  };
  TSpan2.initDefaultProps = function() {
    var tspanProto = TSpan2.prototype;
    tspanProto.dirtyRectTolerance = 10;
  }();
  return TSpan2;
}(Displayable$1);
TSpan.prototype.type = "tspan";
var TSpan$1 = TSpan;
var DEFAULT_IMAGE_STYLE = defaults({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults({
    x: true,
    y: true,
    width: true,
    height: true,
    sx: true,
    sy: true,
    sWidth: true,
    sHeight: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike$1(source) {
  return !!(source && typeof source !== "string" && source.width && source.height);
}
var ZRImage = function(_super) {
  __extends(ZRImage2, _super);
  function ZRImage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ZRImage2.prototype.createStyle = function(obj) {
    return createObject(DEFAULT_IMAGE_STYLE, obj);
  };
  ZRImage2.prototype._getSize = function(dim) {
    var style = this.style;
    var size = style[dim];
    if (size != null) {
      return size;
    }
    var imageSource = isImageLike$1(style.image) ? style.image : this.__image;
    if (!imageSource) {
      return 0;
    }
    var otherDim2 = dim === "width" ? "height" : "width";
    var otherDimSize = style[otherDim2];
    if (otherDimSize == null) {
      return imageSource[dim];
    } else {
      return imageSource[dim] / imageSource[otherDim2] * otherDimSize;
    }
  };
  ZRImage2.prototype.getWidth = function() {
    return this._getSize("width");
  };
  ZRImage2.prototype.getHeight = function() {
    return this._getSize("height");
  };
  ZRImage2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  };
  ZRImage2.prototype.getBoundingRect = function() {
    var style = this.style;
    if (!this._rect) {
      this._rect = new BoundingRect$1(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
    }
    return this._rect;
  };
  return ZRImage2;
}(Displayable$1);
ZRImage.prototype.type = "image";
var ZRImage$1 = ZRImage;
function buildPath$2(ctx, shape) {
  var x = shape.x;
  var y = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r = shape.r;
  var r1;
  var r2;
  var r3;
  var r4;
  if (width < 0) {
    x = x + width;
    width = -width;
  }
  if (height < 0) {
    y = y + height;
    height = -height;
  }
  if (typeof r === "number") {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }
  var total;
  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }
  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }
  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }
  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }
  ctx.moveTo(x + r1, y);
  ctx.lineTo(x + width - r2, y);
  r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
  ctx.lineTo(x + width, y + height - r3);
  r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x + r4, y + height);
  r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x, y + r1);
  r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}
var round$2 = Math.round;
function subPixelOptimizeLine$1(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var x1 = inputShape.x1;
  var x2 = inputShape.x2;
  var y1 = inputShape.y1;
  var y2 = inputShape.y2;
  outputShape.x1 = x1;
  outputShape.x2 = x2;
  outputShape.y1 = y1;
  outputShape.y2 = y2;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  if (round$2(x1 * 2) === round$2(x2 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize$1(x1, lineWidth, true);
  }
  if (round$2(y1 * 2) === round$2(y2 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize$1(y1, lineWidth, true);
  }
  return outputShape;
}
function subPixelOptimizeRect$1(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var originX = inputShape.x;
  var originY = inputShape.y;
  var originWidth = inputShape.width;
  var originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  outputShape.x = subPixelOptimize$1(originX, lineWidth, true);
  outputShape.y = subPixelOptimize$1(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize$1(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize$1(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
  return outputShape;
}
function subPixelOptimize$1(position2, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position2;
  }
  var doubledPosition = round$2(position2 * 2);
  return (doubledPosition + round$2(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}
var RectShape = function() {
  function RectShape2() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }
  return RectShape2;
}();
var subPixelOptimizeOutputShape$1 = {};
var Rect$2 = function(_super) {
  __extends(Rect2, _super);
  function Rect2(opts) {
    return _super.call(this, opts) || this;
  }
  Rect2.prototype.getDefaultShape = function() {
    return new RectShape();
  };
  Rect2.prototype.buildPath = function(ctx, shape) {
    var x;
    var y;
    var width;
    var height;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
      x = optimizedShape.x;
      y = optimizedShape.y;
      width = optimizedShape.width;
      height = optimizedShape.height;
      optimizedShape.r = shape.r;
      shape = optimizedShape;
    } else {
      x = shape.x;
      y = shape.y;
      width = shape.width;
      height = shape.height;
    }
    if (!shape.r) {
      ctx.rect(x, y, width, height);
    } else {
      buildPath$2(ctx, shape);
    }
  };
  Rect2.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  };
  return Rect2;
}(Path$1);
Rect$2.prototype.type = "rect";
var Rect$3 = Rect$2;
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
};
var DEFAULT_STROKE_LINE_WIDTH = 2;
var DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineWidth: true,
    fontSize: true,
    lineHeight: true,
    width: true,
    height: true,
    textShadowColor: true,
    textShadowBlur: true,
    textShadowOffsetX: true,
    textShadowOffsetY: true,
    backgroundColor: true,
    padding: true,
    borderColor: true,
    borderWidth: true,
    borderRadius: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var ZRText = function(_super) {
  __extends(ZRText2, _super);
  function ZRText2(opts) {
    var _this = _super.call(this) || this;
    _this.type = "text";
    _this._children = [];
    _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
    _this.attr(opts);
    return _this;
  }
  ZRText2.prototype.childrenRef = function() {
    return this._children;
  };
  ZRText2.prototype.update = function() {
    _super.prototype.update.call(this);
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      child.zlevel = this.zlevel;
      child.z = this.z;
      child.z2 = this.z2;
      child.culling = this.culling;
      child.cursor = this.cursor;
      child.invisible = this.invisible;
    }
  };
  ZRText2.prototype.updateTransform = function() {
    var innerTransformable = this.innerTransformable;
    if (innerTransformable) {
      innerTransformable.updateTransform();
      if (innerTransformable.transform) {
        this.transform = innerTransformable.transform;
      }
    } else {
      _super.prototype.updateTransform.call(this);
    }
  };
  ZRText2.prototype.getLocalTransform = function(m2) {
    var innerTransformable = this.innerTransformable;
    return innerTransformable ? innerTransformable.getLocalTransform(m2) : _super.prototype.getLocalTransform.call(this, m2);
  };
  ZRText2.prototype.getComputedTransform = function() {
    if (this.__hostTarget) {
      this.__hostTarget.getComputedTransform();
      this.__hostTarget.updateInnerText(true);
    }
    return _super.prototype.getComputedTransform.call(this);
  };
  ZRText2.prototype._updateSubTexts = function() {
    this._childCursor = 0;
    normalizeTextStyle(this.style);
    this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
    this._children.length = this._childCursor;
    this.styleUpdated();
  };
  ZRText2.prototype.addSelfToZr = function(zr) {
    _super.prototype.addSelfToZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      this._children[i].__zr = zr;
    }
  };
  ZRText2.prototype.removeSelfFromZr = function(zr) {
    _super.prototype.removeSelfFromZr.call(this, zr);
    for (var i = 0; i < this._children.length; i++) {
      this._children[i].__zr = null;
    }
  };
  ZRText2.prototype.getBoundingRect = function() {
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    if (!this._rect) {
      var tmpRect2 = new BoundingRect$1(0, 0, 0, 0);
      var children = this._children;
      var tmpMat = [];
      var rect = null;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        var childRect = child.getBoundingRect();
        var transform2 = child.getLocalTransform(tmpMat);
        if (transform2) {
          tmpRect2.copy(childRect);
          tmpRect2.applyTransform(transform2);
          rect = rect || tmpRect2.clone();
          rect.union(tmpRect2);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      this._rect = rect || tmpRect2;
    }
    return this._rect;
  };
  ZRText2.prototype.setDefaultTextStyle = function(defaultTextStyle) {
    this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
  };
  ZRText2.prototype.setTextContent = function(textContent) {
  };
  ZRText2.prototype._mergeStyle = function(targetStyle, sourceStyle) {
    if (!sourceStyle) {
      return targetStyle;
    }
    var sourceRich = sourceStyle.rich;
    var targetRich = targetStyle.rich || sourceRich && {};
    extend$1(targetStyle, sourceStyle);
    if (sourceRich && targetRich) {
      this._mergeRich(targetRich, sourceRich);
      targetStyle.rich = targetRich;
    } else if (targetRich) {
      targetStyle.rich = targetRich;
    }
    return targetStyle;
  };
  ZRText2.prototype._mergeRich = function(targetRich, sourceRich) {
    var richNames = keys(sourceRich);
    for (var i = 0; i < richNames.length; i++) {
      var richName = richNames[i];
      targetRich[richName] = targetRich[richName] || {};
      extend$1(targetRich[richName], sourceRich[richName]);
    }
  };
  ZRText2.prototype.getAnimationStyleProps = function() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  };
  ZRText2.prototype._getOrCreateChild = function(Ctor) {
    var child = this._children[this._childCursor];
    if (!child || !(child instanceof Ctor)) {
      child = new Ctor();
    }
    this._children[this._childCursor++] = child;
    child.__zr = this.__zr;
    child.parent = this;
    return child;
  };
  ZRText2.prototype._updatePlainTexts = function() {
    var style = this.style;
    var textFont = style.font || DEFAULT_FONT;
    var textPadding = style.padding;
    var text = getStyleText(style);
    var contentBlock = parsePlainText(text, style);
    var needDrawBg = needDrawBackground(style);
    var bgColorDrawn = !!style.backgroundColor;
    var outerHeight = contentBlock.outerHeight;
    var outerWidth = contentBlock.outerWidth;
    var contentWidth = contentBlock.contentWidth;
    var textLines = contentBlock.lines;
    var lineHeight = contentBlock.lineHeight;
    var defaultStyle = this._defaultStyle;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var textAlign = style.align || defaultStyle.align || "left";
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
    var textX = baseX;
    var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
    if (needDrawBg || textPadding) {
      var boxX = adjustTextX(baseX, outerWidth, textAlign);
      var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
      needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    textY += lineHeight / 2;
    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      if (verticalAlign === "top") {
        textY += textPadding[0];
      } else if (verticalAlign === "bottom") {
        textY -= textPadding[2];
      }
    }
    var defaultLineWidth = 0;
    var useDefaultFill = false;
    var textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow2 = style.textShadowBlur > 0;
    var fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
    var calculatedLineHeight = contentBlock.calculatedLineHeight;
    for (var i = 0; i < textLines.length; i++) {
      var el = this._getOrCreateChild(TSpan$1);
      var subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      subElStyle.text = textLines[i];
      subElStyle.x = textX;
      subElStyle.y = textY;
      if (textAlign) {
        subElStyle.textAlign = textAlign;
      }
      subElStyle.textBaseline = "middle";
      subElStyle.opacity = style.opacity;
      subElStyle.strokeFirst = true;
      if (hasShadow2) {
        subElStyle.shadowBlur = style.textShadowBlur || 0;
        subElStyle.shadowColor = style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
      }
      subElStyle.stroke = textStroke;
      subElStyle.fill = textFill;
      if (textStroke) {
        subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
        subElStyle.lineDash = style.lineDash;
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
      }
      subElStyle.font = textFont;
      setSeparateFont(subElStyle, style);
      textY += lineHeight;
      if (fixedBoundingRect) {
        el.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
      }
    }
  };
  ZRText2.prototype._updateRichTexts = function() {
    var style = this.style;
    var text = getStyleText(style);
    var contentBlock = parseRichText(text, style);
    var contentWidth = contentBlock.width;
    var outerWidth = contentBlock.outerWidth;
    var outerHeight = contentBlock.outerHeight;
    var textPadding = style.padding;
    var baseX = style.x || 0;
    var baseY = style.y || 0;
    var defaultStyle = this._defaultStyle;
    var textAlign = style.align || defaultStyle.align;
    var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
    var boxX = adjustTextX(baseX, outerWidth, textAlign);
    var boxY = adjustTextY(baseY, outerHeight, verticalAlign);
    var xLeft = boxX;
    var lineTop = boxY;
    if (textPadding) {
      xLeft += textPadding[3];
      lineTop += textPadding[0];
    }
    var xRight = xLeft + contentWidth;
    if (needDrawBackground(style)) {
      this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    var bgColorDrawn = !!style.backgroundColor;
    for (var i = 0; i < contentBlock.lines.length; i++) {
      var line = contentBlock.lines[i];
      var tokens = line.tokens;
      var tokenCount = tokens.length;
      var lineHeight = line.lineHeight;
      var remainedWidth = line.width;
      var leftIndex = 0;
      var lineXLeft = xLeft;
      var lineXRight = xRight;
      var rightIndex = tokenCount - 1;
      var token2 = void 0;
      while (leftIndex < tokenCount && (token2 = tokens[leftIndex], !token2.align || token2.align === "left")) {
        this._placeToken(token2, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
        remainedWidth -= token2.width;
        lineXLeft += token2.width;
        leftIndex++;
      }
      while (rightIndex >= 0 && (token2 = tokens[rightIndex], token2.align === "right")) {
        this._placeToken(token2, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
        remainedWidth -= token2.width;
        lineXRight -= token2.width;
        rightIndex--;
      }
      lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
      while (leftIndex <= rightIndex) {
        token2 = tokens[leftIndex];
        this._placeToken(token2, style, lineHeight, lineTop, lineXLeft + token2.width / 2, "center", bgColorDrawn);
        lineXLeft += token2.width;
        leftIndex++;
      }
      lineTop += lineHeight;
    }
  };
  ZRText2.prototype._placeToken = function(token2, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
    var tokenStyle = style.rich[token2.styleName] || {};
    tokenStyle.text = token2.text;
    var verticalAlign = token2.verticalAlign;
    var y = lineTop + lineHeight / 2;
    if (verticalAlign === "top") {
      y = lineTop + token2.height / 2;
    } else if (verticalAlign === "bottom") {
      y = lineTop + lineHeight - token2.height / 2;
    }
    var needDrawBg = !token2.isLineHolder && needDrawBackground(tokenStyle);
    needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x - token2.width : textAlign === "center" ? x - token2.width / 2 : x, y - token2.height / 2, token2.width, token2.height);
    var bgColorDrawn = !!tokenStyle.backgroundColor;
    var textPadding = token2.textPadding;
    if (textPadding) {
      x = getTextXForPadding(x, textAlign, textPadding);
      y -= token2.height / 2 - textPadding[0] - token2.innerHeight / 2;
    }
    var el = this._getOrCreateChild(TSpan$1);
    var subElStyle = el.createStyle();
    el.useStyle(subElStyle);
    var defaultStyle = this._defaultStyle;
    var useDefaultFill = false;
    var defaultLineWidth = 0;
    var textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    var textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    var hasShadow2 = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
    subElStyle.text = token2.text;
    subElStyle.x = x;
    subElStyle.y = y;
    if (hasShadow2) {
      subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
      subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
      subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
      subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
    }
    subElStyle.textAlign = textAlign;
    subElStyle.textBaseline = "middle";
    subElStyle.font = token2.font || DEFAULT_FONT;
    subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
    setSeparateFont(subElStyle, tokenStyle);
    if (textStroke) {
      subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
      subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
      subElStyle.lineDashOffset = style.lineDashOffset || 0;
      subElStyle.stroke = textStroke;
    }
    if (textFill) {
      subElStyle.fill = textFill;
    }
    var textWidth = token2.contentWidth;
    var textHeight = token2.contentHeight;
    el.setBoundingRect(new BoundingRect$1(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
  };
  ZRText2.prototype._renderBackground = function(style, topStyle, x, y, width, height) {
    var textBackgroundColor = style.backgroundColor;
    var textBorderWidth = style.borderWidth;
    var textBorderColor = style.borderColor;
    var isImageBg = textBackgroundColor && textBackgroundColor.image;
    var isPlainOrGradientBg = textBackgroundColor && !isImageBg;
    var textBorderRadius = style.borderRadius;
    var self2 = this;
    var rectEl;
    var imgEl;
    if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
      rectEl = this._getOrCreateChild(Rect$3);
      rectEl.useStyle(rectEl.createStyle());
      rectEl.style.fill = null;
      var rectShape = rectEl.shape;
      rectShape.x = x;
      rectShape.y = y;
      rectShape.width = width;
      rectShape.height = height;
      rectShape.r = textBorderRadius;
      rectEl.dirtyShape();
    }
    if (isPlainOrGradientBg) {
      var rectStyle = rectEl.style;
      rectStyle.fill = textBackgroundColor || null;
      rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
    } else if (isImageBg) {
      imgEl = this._getOrCreateChild(ZRImage$1);
      imgEl.onload = function() {
        self2.dirtyStyle();
      };
      var imgStyle = imgEl.style;
      imgStyle.image = textBackgroundColor.image;
      imgStyle.x = x;
      imgStyle.y = y;
      imgStyle.width = width;
      imgStyle.height = height;
    }
    if (textBorderWidth && textBorderColor) {
      var rectStyle = rectEl.style;
      rectStyle.lineWidth = textBorderWidth;
      rectStyle.stroke = textBorderColor;
      rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
      rectStyle.lineDash = style.borderDash;
      rectStyle.lineDashOffset = style.borderDashOffset || 0;
      rectEl.strokeContainThreshold = 0;
      if (rectEl.hasFill() && rectEl.hasStroke()) {
        rectStyle.strokeFirst = true;
        rectStyle.lineWidth *= 2;
      }
    }
    var commonStyle = (rectEl || imgEl).style;
    commonStyle.shadowBlur = style.shadowBlur || 0;
    commonStyle.shadowColor = style.shadowColor || "transparent";
    commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
    commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
    commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
  };
  ZRText2.makeFont = function(style) {
    var font = "";
    if (hasSeparateFont(style)) {
      font = [
        style.fontStyle,
        style.fontWeight,
        parseFontSize(style.fontSize),
        style.fontFamily || "sans-serif"
      ].join(" ");
    }
    return font && trim$1(font) || style.textFont || style.font;
  };
  return ZRText2;
}(Displayable$1);
var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(fontSize) {
  if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
    return fontSize;
  } else if (!isNaN(+fontSize)) {
    return fontSize + "px";
  } else {
    return DEFAULT_FONT_SIZE + "px";
  }
}
function setSeparateFont(targetStyle, sourceStyle) {
  for (var i = 0; i < FONT_PARTS.length; i++) {
    var fontProp = FONT_PARTS[i];
    var val = sourceStyle[fontProp];
    if (val != null) {
      targetStyle[fontProp] = val;
    }
  }
}
function hasSeparateFont(style) {
  return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
  normalizeStyle(style);
  each$f(style.rich, normalizeStyle);
  return style;
}
function normalizeStyle(style) {
  if (style) {
    style.font = ZRText.makeFont(style);
    var textAlign = style.align;
    textAlign === "middle" && (textAlign = "center");
    style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
    var verticalAlign = style.verticalAlign;
    verticalAlign === "center" && (verticalAlign = "middle");
    style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
    var textPadding = style.padding;
    if (textPadding) {
      style.padding = normalizeCssArray$1(style.padding);
    }
  }
}
function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
  return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
function getStyleText(style) {
  var text = style.text;
  text != null && (text += "");
  return text;
}
function needDrawBackground(style) {
  return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
}
var ZRText$1 = ZRText;
var getECData = makeInner();
var setCommonECData = function(seriesIndex, dataType, dataIdx, el) {
  if (el) {
    var ecData = getECData(el);
    ecData.dataIndex = dataIdx;
    ecData.dataType = dataType;
    ecData.seriesIndex = seriesIndex;
    if (el.type === "group") {
      el.traverse(function(child) {
        var childECData = getECData(child);
        childECData.seriesIndex = seriesIndex;
        childECData.dataIndex = dataIdx;
        childECData.dataType = dataType;
      });
    }
  }
};
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = ["emphasis", "blur", "select"];
var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== "none";
}
var liftedColorCache = new LRUCache$1(100);
function liftColor(color) {
  if (isString(color)) {
    var liftedColor = liftedColorCache.get(color);
    if (!liftedColor) {
      liftedColor = lift(color, -0.1);
      liftedColorCache.put(color, liftedColor);
    }
    return liftedColor;
  } else if (isGradientObject(color)) {
    var ret2 = extend$1({}, color);
    ret2.colorStops = map$1(color.colorStops, function(stop2) {
      return {
        offset: stop2.offset,
        color: lift(stop2.color, -0.1)
      };
    });
    return ret2;
  }
  return color;
}
function doChangeHoverState(el, stateName, hoverStateEnum) {
  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
    el.onHoverStateChange(stateName);
  }
  el.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el) {
  doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el) {
  if (el.hoverState === HOVER_STATE_EMPHASIS) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterBlur(el) {
  doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el) {
  if (el.hoverState === HOVER_STATE_BLUR) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterSelect(el) {
  el.selected = true;
}
function singleLeaveSelect(el) {
  el.selected = false;
}
function updateElementState(el, updater, commonParam) {
  updater(el, commonParam);
}
function traverseUpdateState(el, updater, commonParam) {
  updateElementState(el, updater, commonParam);
  el.isGroup && el.traverse(function(child) {
    updateElementState(child, updater, commonParam);
  });
}
function setStatesFlag(el, stateName) {
  switch (stateName) {
    case "emphasis":
      el.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      el.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      el.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      el.selected = true;
  }
}
function getFromStateStyle(el, props, toStateName, defaultValue) {
  var style = el.style;
  var fromState = {};
  for (var i = 0; i < props.length; i++) {
    var propName = props[i];
    var val = style[propName];
    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
  }
  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];
    if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
      animator.saveTo(fromState, props);
    }
  }
  return fromState;
}
function createEmphasisDefaultState(el, stateName, targetStates, state) {
  var hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
  var cloned = false;
  if (el instanceof Path$1) {
    var store = getSavedStates(el);
    var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
    var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
      state = state || {};
      var emphasisStyle = state.style || {};
      if (emphasisStyle.fill === "inherit") {
        cloned = true;
        state = extend$1({}, state);
        emphasisStyle = extend$1({}, emphasisStyle);
        emphasisStyle.fill = fromFill;
      } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
        cloned = true;
        state = extend$1({}, state);
        emphasisStyle = extend$1({}, emphasisStyle);
        emphasisStyle.fill = liftColor(fromFill);
      } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
        if (!cloned) {
          state = extend$1({}, state);
          emphasisStyle = extend$1({}, emphasisStyle);
        }
        emphasisStyle.stroke = liftColor(fromStroke);
      }
      state.style = emphasisStyle;
    }
  }
  if (state) {
    if (state.z2 == null) {
      if (!cloned) {
        state = extend$1({}, state);
      }
      var z2EmphasisLift = el.z2EmphasisLift;
      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
    }
  }
  return state;
}
function createSelectDefaultState(el, stateName, state) {
  if (state) {
    if (state.z2 == null) {
      state = extend$1({}, state);
      var z2SelectLift = el.z2SelectLift;
      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
    }
  }
  return state;
}
function createBlurDefaultState(el, stateName, state) {
  var hasBlur = indexOf(el.currentStates, stateName) >= 0;
  var currentOpacity = el.style.opacity;
  var fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
    opacity: 1
  }) : null;
  state = state || {};
  var blurStyle = state.style || {};
  if (blurStyle.opacity == null) {
    state = extend$1({}, state);
    blurStyle = extend$1({
      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
    }, blurStyle);
    state.style = blurStyle;
  }
  return state;
}
function elementStateProxy(stateName, targetStates) {
  var state = this.states[stateName];
  if (this.style) {
    if (stateName === "emphasis") {
      return createEmphasisDefaultState(this, stateName, targetStates, state);
    } else if (stateName === "blur") {
      return createBlurDefaultState(this, stateName, state);
    } else if (stateName === "select") {
      return createSelectDefaultState(this, stateName, state);
    }
  }
  return state;
}
function setDefaultStateProxy(el) {
  el.stateProxy = elementStateProxy;
  var textContent = el.getTextContent();
  var textGuide = el.getTextGuideLine();
  if (textContent) {
    textContent.stateProxy = elementStateProxy;
  }
  if (textGuide) {
    textGuide.stateProxy = elementStateProxy;
  }
}
function enterEmphasisWhenMouseOver(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
  el.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
  traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
  traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
  traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
  traverseUpdateState(el, singleLeaveSelect);
}
function shouldSilent(el, e2) {
  return el.__highDownSilentOnTouch && e2.zrByTouch;
}
function allLeaveBlur(api) {
  var model = api.getModel();
  model.eachComponent(function(componentType, componentModel) {
    var componentStates = getComponentStates(componentModel);
    if (componentStates.isBlured) {
      var view = componentType === "series" ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
      view.group.traverse(function(child) {
        singleLeaveBlur(child);
      });
    }
    componentStates.isBlured = false;
  });
}
function blurSeries(targetSeriesIndex, focus, blurScope, api) {
  var ecModel = api.getModel();
  blurScope = blurScope || "coordinateSystem";
  function leaveBlurOfIndices(data, dataIndices) {
    for (var i = 0; i < dataIndices.length; i++) {
      var itemEl = data.getItemGraphicEl(dataIndices[i]);
      itemEl && leaveBlur(itemEl);
    }
  }
  if (targetSeriesIndex == null) {
    return;
  }
  if (!focus || focus === "none") {
    return;
  }
  var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
  var targetCoordSys = targetSeriesModel.coordinateSystem;
  if (targetCoordSys && targetCoordSys.master) {
    targetCoordSys = targetCoordSys.master;
  }
  var blurredSeries = [];
  ecModel.eachSeries(function(seriesModel) {
    var sameSeries = targetSeriesModel === seriesModel;
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.master) {
      coordSys = coordSys.master;
    }
    var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
    if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
      var view = api.getViewOfSeriesModel(seriesModel);
      view.group.traverse(function(child) {
        singleEnterBlur(child);
      });
      if (isArrayLike(focus)) {
        leaveBlurOfIndices(seriesModel.getData(), focus);
      } else if (isObject$3(focus)) {
        var dataTypes = keys(focus);
        for (var d = 0; d < dataTypes.length; d++) {
          leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
        }
      }
      blurredSeries.push(seriesModel);
      getComponentStates(seriesModel).isBlured = true;
    }
  });
  ecModel.eachComponent(function(componentType, componentModel) {
    if (componentType === "series") {
      return;
    }
    var view = api.getViewOfComponentModel(componentModel);
    if (view && view.blurSeries) {
      view.blurSeries(blurredSeries, ecModel);
    }
  });
}
function blurComponent(componentMainType, componentIndex, api) {
  if (componentMainType == null || componentIndex == null) {
    return;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return;
  }
  getComponentStates(componentModel).isBlured = true;
  var view = api.getViewOfComponentModel(componentModel);
  if (!view || !view.focusBlurEnabled) {
    return;
  }
  view.group.traverse(function(child) {
    singleEnterBlur(child);
  });
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api) {
  var seriesIndex = seriesModel.seriesIndex;
  var data = seriesModel.getData(payload.dataType);
  if (!data) {
    return;
  }
  var dataIndex = queryDataIndex(data, payload);
  dataIndex = (isArray$1(dataIndex) ? dataIndex[0] : dataIndex) || 0;
  var el = data.getItemGraphicEl(dataIndex);
  if (!el) {
    var count2 = data.count();
    var current = 0;
    while (!el && current < count2) {
      el = data.getItemGraphicEl(current++);
    }
  }
  if (el) {
    var ecData = getECData(el);
    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api);
  } else {
    var focus_1 = seriesModel.get(["emphasis", "focus"]);
    var blurScope = seriesModel.get(["emphasis", "blurScope"]);
    if (focus_1 != null) {
      blurSeries(seriesIndex, focus_1, blurScope, api);
    }
  }
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api) {
  var ret2 = {
    focusSelf: false,
    dispatchers: null
  };
  if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) {
    return ret2;
  }
  var componentModel = api.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return ret2;
  }
  var view = api.getViewOfComponentModel(componentModel);
  if (!view || !view.findHighDownDispatchers) {
    return ret2;
  }
  var dispatchers = view.findHighDownDispatchers(name);
  var focusSelf;
  for (var i = 0; i < dispatchers.length; i++) {
    if (getECData(dispatchers[i]).focus === "self") {
      focusSelf = true;
      break;
    }
  }
  return {
    focusSelf,
    dispatchers
  };
}
function handleGlobalMouseOverForHighDown(dispatcher, e2, api) {
  var ecData = getECData(dispatcher);
  var _a2 = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api), dispatchers = _a2.dispatchers, focusSelf = _a2.focusSelf;
  if (dispatchers) {
    if (focusSelf) {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    each$f(dispatchers, function(dispatcher2) {
      return enterEmphasisWhenMouseOver(dispatcher2, e2);
    });
  } else {
    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api);
    if (ecData.focus === "self") {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api);
    }
    enterEmphasisWhenMouseOver(dispatcher, e2);
  }
}
function handleGlobalMouseOutForHighDown(dispatcher, e2, api) {
  allLeaveBlur(api);
  var ecData = getECData(dispatcher);
  var dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers;
  if (dispatchers) {
    each$f(dispatchers, function(dispatcher2) {
      return leaveEmphasisWhenMouseOut(dispatcher2, e2);
    });
  } else {
    leaveEmphasisWhenMouseOut(dispatcher, e2);
  }
}
function toggleSelectionFromPayload(seriesModel, payload, api) {
  if (!isSelectChangePayload(payload)) {
    return;
  }
  var dataType = payload.dataType;
  var data = seriesModel.getData(dataType);
  var dataIndex = queryDataIndex(data, payload);
  if (!isArray$1(dataIndex)) {
    dataIndex = [dataIndex];
  }
  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
  var allData = seriesModel.getAllData();
  each$f(allData, function(_a2) {
    var data = _a2.data, type = _a2.type;
    data.eachItemGraphicEl(function(el, idx) {
      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
    });
  });
}
function getAllSelectedIndices(ecModel) {
  var ret2 = [];
  ecModel.eachSeries(function(seriesModel) {
    var allData = seriesModel.getAllData();
    each$f(allData, function(_a2) {
      _a2.data;
      var type = _a2.type;
      var dataIndices = seriesModel.getSelectedDataIndices();
      if (dataIndices.length > 0) {
        var item = {
          dataIndex: dataIndices,
          seriesIndex: seriesModel.seriesIndex
        };
        if (type != null) {
          item.dataType = type;
        }
        ret2.push(item);
      }
    });
  });
  return ret2;
}
function enableHoverEmphasis(el, focus, blurScope) {
  setAsHighDownDispatcher(el, true);
  traverseUpdateState(el, setDefaultStateProxy);
  enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
  setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
  isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
  var ecData = getECData(el);
  if (focus != null) {
    ecData.focus = focus;
    ecData.blurScope = blurScope;
  } else if (ecData.focus) {
    ecData.focus = null;
  }
}
var OTHER_STATES = ["emphasis", "blur", "select"];
var defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(el, itemModel, styleType, getter) {
  styleType = styleType || "itemStyle";
  for (var i = 0; i < OTHER_STATES.length; i++) {
    var stateName = OTHER_STATES[i];
    var model = itemModel.getModel([stateName, styleType]);
    var state = el.ensureState(stateName);
    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
  }
}
function setAsHighDownDispatcher(el, asDispatcher) {
  var disable = asDispatcher === false;
  var extendedEl = el;
  if (el.highDownSilentOnTouch) {
    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
  }
  if (!disable || extendedEl.__highDownDispatcher) {
    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
    extendedEl.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el) {
  return !!(el && el.__highDownDispatcher);
}
function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
  var ecData = getECData(el);
  ecData.componentMainType = componentModel.mainType;
  ecData.componentIndex = componentModel.componentIndex;
  ecData.componentHighDownName = componentHighDownName;
}
function getHighlightDigit(highlightKey) {
  var highlightDigit = _highlightKeyMap[highlightKey];
  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }
  return highlightDigit;
}
function isSelectChangePayload(payload) {
  var payloadType = payload.type;
  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
  var payloadType = payload.type;
  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
  var store = getSavedStates(el);
  store.normalFill = el.style.fill;
  store.normalStroke = el.style.stroke;
  var selectState = el.states.select || {};
  store.selectFill = selectState.style && selectState.style.fill || null;
  store.selectStroke = selectState.style && selectState.style.stroke || null;
}
var CMD$2 = PathProxy$1.CMD;
var points$2 = [[], [], []];
var mathSqrt$2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m2) {
  if (!m2) {
    return;
  }
  var data = path.data;
  var len2 = path.len();
  var cmd;
  var nPoint;
  var i;
  var j;
  var k;
  var p;
  var M = CMD$2.M;
  var C = CMD$2.C;
  var L = CMD$2.L;
  var R = CMD$2.R;
  var A = CMD$2.A;
  var Q = CMD$2.Q;
  for (i = 0, j = 0; i < len2; ) {
    cmd = data[i++];
    j = i;
    nPoint = 0;
    switch (cmd) {
      case M:
        nPoint = 1;
        break;
      case L:
        nPoint = 1;
        break;
      case C:
        nPoint = 3;
        break;
      case Q:
        nPoint = 2;
        break;
      case A:
        var x = m2[4];
        var y = m2[5];
        var sx = mathSqrt$2(m2[0] * m2[0] + m2[1] * m2[1]);
        var sy = mathSqrt$2(m2[2] * m2[2] + m2[3] * m2[3]);
        var angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
        data[i] *= sx;
        data[i++] += x;
        data[i] *= sy;
        data[i++] += y;
        data[i++] *= sx;
        data[i++] *= sy;
        data[i++] += angle;
        data[i++] += angle;
        i += 2;
        j = i;
        break;
      case R:
        p[0] = data[i++];
        p[1] = data[i++];
        applyTransform$1(p, p, m2);
        data[j++] = p[0];
        data[j++] = p[1];
        p[0] += data[i++];
        p[1] += data[i++];
        applyTransform$1(p, p, m2);
        data[j++] = p[0];
        data[j++] = p[1];
    }
    for (k = 0; k < nPoint; k++) {
      var p_1 = points$2[k];
      p_1[0] = data[i++];
      p_1[1] = data[i++];
      applyTransform$1(p_1, p_1, m2);
      data[j++] = p_1[0];
      data[j++] = p_1[1];
    }
  }
  path.increaseVersion();
}
var mathSqrt$1 = Math.sqrt;
var mathSin$2 = Math.sin;
var mathCos$2 = Math.cos;
var PI$9 = Math.PI;
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  var psi = psiDeg * (PI$9 / 180);
  var xp = mathCos$2(psi) * (x1 - x2) / 2 + mathSin$2(psi) * (y1 - y2) / 2;
  var yp = -1 * mathSin$2(psi) * (x1 - x2) / 2 + mathCos$2(psi) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= mathSqrt$1(lambda);
    ry *= mathSqrt$1(lambda);
  }
  var f = (fa === fs ? -1 : 1) * mathSqrt$1((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f * rx * yp / ry;
  var cyp = f * -ry * xp / rx;
  var cx = (x1 + x2) / 2 + mathCos$2(psi) * cxp - mathSin$2(psi) * cyp;
  var cy = (y1 + y2) / 2 + mathSin$2(psi) * cxp + mathCos$2(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = PI$9;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (dTheta < 0) {
    var n = Math.round(dTheta / PI$9 * 1e6) / 1e6;
    dTheta = PI$9 * 2 + n % 2 * PI$9;
  }
  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
  var path = new PathProxy$1();
  if (!data) {
    return path;
  }
  var cpx = 0;
  var cpy = 0;
  var subpathX = cpx;
  var subpathY = cpy;
  var prevCmd;
  var CMD2 = PathProxy$1.CMD;
  var cmdList = data.match(commandReg);
  if (!cmdList) {
    return path;
  }
  for (var l = 0; l < cmdList.length; l++) {
    var cmdText = cmdList[l];
    var cmdStr = cmdText.charAt(0);
    var cmd = void 0;
    var p = cmdText.match(numberReg$1) || [];
    var pLen = p.length;
    for (var i = 0; i < pLen; i++) {
      p[i] = parseFloat(p[i]);
    }
    var off = 0;
    while (off < pLen) {
      var ctlPtx = void 0;
      var ctlPty = void 0;
      var rx = void 0;
      var ry = void 0;
      var psi = void 0;
      var fa = void 0;
      var fs = void 0;
      var x1 = cpx;
      var y1 = cpy;
      var len2 = void 0;
      var pathData = void 0;
      switch (cmdStr) {
        case "l":
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "L":
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "m":
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "l";
          break;
        case "M":
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "L";
          break;
        case "h":
          cpx += p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "H":
          cpx = p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "v":
          cpy += p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "V":
          cpy = p[off++];
          cmd = CMD2.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "C":
          cmd = CMD2.C;
          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
          cpx = p[off - 2];
          cpy = p[off - 1];
          break;
        case "c":
          cmd = CMD2.C;
          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
          cpx += p[off - 2];
          cpy += p[off - 1];
          break;
        case "S":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD2.C;
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "s":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD2.C;
          x1 = cpx + p[off++];
          y1 = cpy + p[off++];
          cpx += p[off++];
          cpy += p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "Q":
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "q":
          x1 = p[off++] + cpx;
          y1 = p[off++] + cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "T":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "t":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "A":
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD2.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
        case "a":
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD2.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }
    if (cmdStr === "z" || cmdStr === "Z") {
      cmd = CMD2.Z;
      path.addData(cmd);
      cpx = subpathX;
      cpy = subpathY;
    }
    prevCmd = cmd;
  }
  path.toStatic();
  return path;
}
var SVGPath = function(_super) {
  __extends(SVGPath2, _super);
  function SVGPath2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SVGPath2.prototype.applyTransform = function(m2) {
  };
  return SVGPath2;
}(Path$1);
function isPathProxy(path) {
  return path.setData != null;
}
function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  var innerOpts = extend$1({}, opts);
  innerOpts.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.setData(pathProxy.data);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    } else {
      var ctx = path;
      pathProxy.rebuildPath(ctx, 1);
    }
  };
  innerOpts.applyTransform = function(m2) {
    transformPath(pathProxy, m2);
    this.dirtyShape();
  };
  return innerOpts;
}
function createFromString(str, opts) {
  return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
  var innerOpts = createPathOptions(str, defaultOpts);
  var Sub = function(_super) {
    __extends(Sub2, _super);
    function Sub2(opts) {
      var _this = _super.call(this, opts) || this;
      _this.applyTransform = innerOpts.applyTransform;
      _this.buildPath = innerOpts.buildPath;
      return _this;
    }
    return Sub2;
  }(SVGPath);
  return Sub;
}
function mergePath$1(pathEls, opts) {
  var pathList = [];
  var len2 = pathEls.length;
  for (var i = 0; i < len2; i++) {
    var pathEl = pathEls[i];
    pathList.push(pathEl.getUpdatedPathProxy(true));
  }
  var pathBundle = new Path$1(opts);
  pathBundle.createPathProxy();
  pathBundle.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.appendPath(pathList);
      var ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    }
  };
  return pathBundle;
}
function clonePath(sourcePath, opts) {
  opts = opts || {};
  var path = new Path$1();
  if (sourcePath.shape) {
    path.setShape(sourcePath.shape);
  }
  path.setStyle(sourcePath.style);
  if (opts.bakeTransform) {
    transformPath(path.path, sourcePath.getComputedTransform());
  } else {
    if (opts.toLocal) {
      path.setLocalTransform(sourcePath.getComputedTransform());
    } else {
      path.copyTransform(sourcePath);
    }
  }
  path.buildPath = sourcePath.buildPath;
  path.applyTransform = path.applyTransform;
  path.z = sourcePath.z;
  path.z2 = sourcePath.z2;
  path.zlevel = sourcePath.zlevel;
  return path;
}
var CircleShape = function() {
  function CircleShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
  }
  return CircleShape2;
}();
var Circle = function(_super) {
  __extends(Circle2, _super);
  function Circle2(opts) {
    return _super.call(this, opts) || this;
  }
  Circle2.prototype.getDefaultShape = function() {
    return new CircleShape();
  };
  Circle2.prototype.buildPath = function(ctx, shape) {
    ctx.moveTo(shape.cx + shape.r, shape.cy);
    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
  };
  return Circle2;
}(Path$1);
Circle.prototype.type = "circle";
var Circle$1 = Circle;
var EllipseShape = function() {
  function EllipseShape2() {
    this.cx = 0;
    this.cy = 0;
    this.rx = 0;
    this.ry = 0;
  }
  return EllipseShape2;
}();
var Ellipse = function(_super) {
  __extends(Ellipse2, _super);
  function Ellipse2(opts) {
    return _super.call(this, opts) || this;
  }
  Ellipse2.prototype.getDefaultShape = function() {
    return new EllipseShape();
  };
  Ellipse2.prototype.buildPath = function(ctx, shape) {
    var k = 0.5522848;
    var x = shape.cx;
    var y = shape.cy;
    var a = shape.rx;
    var b = shape.ry;
    var ox = a * k;
    var oy = b * k;
    ctx.moveTo(x - a, y);
    ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
    ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
    ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
    ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
    ctx.closePath();
  };
  return Ellipse2;
}(Path$1);
Ellipse.prototype.type = "ellipse";
var Ellipse$1 = Ellipse;
var PI$8 = Math.PI;
var PI2$4 = PI$8 * 2;
var mathSin$1 = Math.sin;
var mathCos$1 = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs$1 = Math.abs;
var mathSqrt = Math.sqrt;
var mathMax$8 = Math.max;
var mathMin$8 = Math.min;
var e$1 = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var dx10 = x1 - x0;
  var dy10 = y1 - y0;
  var dx32 = x3 - x2;
  var dy32 = y3 - y2;
  var t = dy32 * dx10 - dx32 * dy10;
  if (t * t < e$1) {
    return;
  }
  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
  return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  var x01 = x0 - x1;
  var y01 = y0 - y1;
  var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
  var ox = lo * y01;
  var oy = -lo * x01;
  var x11 = x0 + ox;
  var y11 = y0 + oy;
  var x10 = x1 + ox;
  var y10 = y1 + oy;
  var x00 = (x11 + x10) / 2;
  var y00 = (y11 + y10) / 2;
  var dx = x10 - x11;
  var dy = y10 - y11;
  var d2 = dx * dx + dy * dy;
  var r = radius - cr;
  var s = x11 * y10 - x10 * y11;
  var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax$8(0, r * r * d2 - s * s));
  var cx0 = (s * dy - dx * d) / d2;
  var cy0 = (-s * dx - dy * d) / d2;
  var cx1 = (s * dy + dx * d) / d2;
  var cy1 = (-s * dx + dy * d) / d2;
  var dx0 = cx0 - x00;
  var dy0 = cy0 - y00;
  var dx1 = cx1 - x00;
  var dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r - 1),
    y1: cy0 * (radius / r - 1)
  };
}
function normalizeCornerRadius(cr) {
  var arr;
  if (isArray$1(cr)) {
    var len2 = cr.length;
    if (!len2) {
      return cr;
    }
    if (len2 === 1) {
      arr = [cr[0], cr[0], 0, 0];
    } else if (len2 === 2) {
      arr = [cr[0], cr[0], cr[1], cr[1]];
    } else if (len2 === 3) {
      arr = cr.concat(cr[2]);
    } else {
      arr = cr;
    }
  } else {
    arr = [cr, cr, cr, cr];
  }
  return arr;
}
function buildPath$1(ctx, shape) {
  var _a2;
  var radius = mathMax$8(shape.r, 0);
  var innerRadius = mathMax$8(shape.r0 || 0, 0);
  var hasRadius = radius > 0;
  var hasInnerRadius = innerRadius > 0;
  if (!hasRadius && !hasInnerRadius) {
    return;
  }
  if (!hasRadius) {
    radius = innerRadius;
    innerRadius = 0;
  }
  if (innerRadius > radius) {
    var tmp = radius;
    radius = innerRadius;
    innerRadius = tmp;
  }
  var startAngle = shape.startAngle, endAngle = shape.endAngle;
  if (isNaN(startAngle) || isNaN(endAngle)) {
    return;
  }
  var cx = shape.cx, cy = shape.cy;
  var clockwise = !!shape.clockwise;
  var arc = mathAbs$1(endAngle - startAngle);
  var mod = arc > PI2$4 && arc % PI2$4;
  mod > e$1 && (arc = mod);
  if (!(radius > e$1)) {
    ctx.moveTo(cx, cy);
  } else if (arc > PI2$4 - e$1) {
    ctx.moveTo(cx + radius * mathCos$1(startAngle), cy + radius * mathSin$1(startAngle));
    ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    if (innerRadius > e$1) {
      ctx.moveTo(cx + innerRadius * mathCos$1(endAngle), cy + innerRadius * mathSin$1(endAngle));
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  } else {
    var icrStart = void 0;
    var icrEnd = void 0;
    var ocrStart = void 0;
    var ocrEnd = void 0;
    var ocrs = void 0;
    var ocre = void 0;
    var icrs = void 0;
    var icre = void 0;
    var ocrMax = void 0;
    var icrMax = void 0;
    var limitedOcrMax = void 0;
    var limitedIcrMax = void 0;
    var xre = void 0;
    var yre = void 0;
    var xirs = void 0;
    var yirs = void 0;
    var xrs = radius * mathCos$1(startAngle);
    var yrs = radius * mathSin$1(startAngle);
    var xire = innerRadius * mathCos$1(endAngle);
    var yire = innerRadius * mathSin$1(endAngle);
    var hasArc = arc > e$1;
    if (hasArc) {
      var cornerRadius = shape.cornerRadius;
      if (cornerRadius) {
        _a2 = normalizeCornerRadius(cornerRadius), icrStart = _a2[0], icrEnd = _a2[1], ocrStart = _a2[2], ocrEnd = _a2[3];
      }
      var halfRd = mathAbs$1(radius - innerRadius) / 2;
      ocrs = mathMin$8(halfRd, ocrStart);
      ocre = mathMin$8(halfRd, ocrEnd);
      icrs = mathMin$8(halfRd, icrStart);
      icre = mathMin$8(halfRd, icrEnd);
      limitedOcrMax = ocrMax = mathMax$8(ocrs, ocre);
      limitedIcrMax = icrMax = mathMax$8(icrs, icre);
      if (ocrMax > e$1 || icrMax > e$1) {
        xre = radius * mathCos$1(endAngle);
        yre = radius * mathSin$1(endAngle);
        xirs = innerRadius * mathCos$1(startAngle);
        yirs = innerRadius * mathSin$1(startAngle);
        if (arc < PI$8) {
          var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it_1) {
            var x0 = xrs - it_1[0];
            var y0 = yrs - it_1[1];
            var x1 = xre - it_1[0];
            var y1 = yre - it_1[1];
            var a = 1 / mathSin$1(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
            var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
            limitedOcrMax = mathMin$8(ocrMax, (radius - b) / (a + 1));
            limitedIcrMax = mathMin$8(icrMax, (innerRadius - b) / (a - 1));
          }
        }
      }
    }
    if (!hasArc) {
      ctx.moveTo(cx + xrs, cy + yrs);
    } else if (limitedOcrMax > e$1) {
      var crStart = mathMin$8(ocrStart, limitedOcrMax);
      var crEnd = mathMin$8(ocrEnd, limitedOcrMax);
      var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
      var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
      ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedOcrMax < ocrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
        crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.moveTo(cx + xrs, cy + yrs);
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    }
    if (!(innerRadius > e$1) || !hasArc) {
      ctx.lineTo(cx + xire, cy + yire);
    } else if (limitedIcrMax > e$1) {
      var crStart = mathMin$8(icrStart, limitedIcrMax);
      var crEnd = mathMin$8(icrEnd, limitedIcrMax);
      var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
      var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
      ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedIcrMax < icrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
        crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.lineTo(cx + xire, cy + yire);
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  }
  ctx.closePath();
}
var SectorShape = function() {
  function SectorShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
    this.cornerRadius = 0;
  }
  return SectorShape2;
}();
var Sector = function(_super) {
  __extends(Sector2, _super);
  function Sector2(opts) {
    return _super.call(this, opts) || this;
  }
  Sector2.prototype.getDefaultShape = function() {
    return new SectorShape();
  };
  Sector2.prototype.buildPath = function(ctx, shape) {
    buildPath$1(ctx, shape);
  };
  Sector2.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  };
  return Sector2;
}(Path$1);
Sector.prototype.type = "sector";
var Sector$1 = Sector;
var RingShape = function() {
  function RingShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.r0 = 0;
  }
  return RingShape2;
}();
var Ring = function(_super) {
  __extends(Ring2, _super);
  function Ring2(opts) {
    return _super.call(this, opts) || this;
  }
  Ring2.prototype.getDefaultShape = function() {
    return new RingShape();
  };
  Ring2.prototype.buildPath = function(ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var PI22 = Math.PI * 2;
    ctx.moveTo(x + shape.r, y);
    ctx.arc(x, y, shape.r, 0, PI22, false);
    ctx.moveTo(x + shape.r0, y);
    ctx.arc(x, y, shape.r0, 0, PI22, true);
  };
  return Ring2;
}(Path$1);
Ring.prototype.type = "ring";
var Ring$1 = Ring;
function smoothBezier(points2, smooth, isLoop, constraint) {
  var cps = [];
  var v = [];
  var v12 = [];
  var v22 = [];
  var prevPoint;
  var nextPoint;
  var min3;
  var max3;
  if (constraint) {
    min3 = [Infinity, Infinity];
    max3 = [-Infinity, -Infinity];
    for (var i = 0, len2 = points2.length; i < len2; i++) {
      min$1(min3, min3, points2[i]);
      max$1(max3, max3, points2[i]);
    }
    min$1(min3, min3, constraint[0]);
    max$1(max3, max3, constraint[1]);
  }
  for (var i = 0, len2 = points2.length; i < len2; i++) {
    var point = points2[i];
    if (isLoop) {
      prevPoint = points2[i ? i - 1 : len2 - 1];
      nextPoint = points2[(i + 1) % len2];
    } else {
      if (i === 0 || i === len2 - 1) {
        cps.push(clone$3(points2[i]));
        continue;
      } else {
        prevPoint = points2[i - 1];
        nextPoint = points2[i + 1];
      }
    }
    sub$1(v, nextPoint, prevPoint);
    scale$2(v, v, smooth);
    var d0 = distance(point, prevPoint);
    var d1 = distance(point, nextPoint);
    var sum2 = d0 + d1;
    if (sum2 !== 0) {
      d0 /= sum2;
      d1 /= sum2;
    }
    scale$2(v12, v, -d0);
    scale$2(v22, v, d1);
    var cp0 = add$1([], point, v12);
    var cp1 = add$1([], point, v22);
    if (constraint) {
      max$1(cp0, cp0, min3);
      min$1(cp0, cp0, max3);
      max$1(cp1, cp1, min3);
      min$1(cp1, cp1, max3);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function buildPath(ctx, shape, closePath) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (points2 && points2.length >= 2) {
    if (smooth) {
      var controlPoints = smoothBezier(points2, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points2[0][0], points2[0][1]);
      var len2 = points2.length;
      for (var i = 0; i < (closePath ? len2 : len2 - 1); i++) {
        var cp1 = controlPoints[i * 2];
        var cp2 = controlPoints[i * 2 + 1];
        var p = points2[(i + 1) % len2];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
      }
    } else {
      ctx.moveTo(points2[0][0], points2[0][1]);
      for (var i = 1, l = points2.length; i < l; i++) {
        ctx.lineTo(points2[i][0], points2[i][1]);
      }
    }
    closePath && ctx.closePath();
  }
}
var PolygonShape = function() {
  function PolygonShape2() {
    this.points = null;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolygonShape2;
}();
var Polygon = function(_super) {
  __extends(Polygon2, _super);
  function Polygon2(opts) {
    return _super.call(this, opts) || this;
  }
  Polygon2.prototype.getDefaultShape = function() {
    return new PolygonShape();
  };
  Polygon2.prototype.buildPath = function(ctx, shape) {
    buildPath(ctx, shape, true);
  };
  return Polygon2;
}(Path$1);
Polygon.prototype.type = "polygon";
var Polygon$1 = Polygon;
var PolylineShape = function() {
  function PolylineShape2() {
    this.points = null;
    this.percent = 1;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
  return PolylineShape2;
}();
var Polyline$2 = function(_super) {
  __extends(Polyline2, _super);
  function Polyline2(opts) {
    return _super.call(this, opts) || this;
  }
  Polyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Polyline2.prototype.getDefaultShape = function() {
    return new PolylineShape();
  };
  Polyline2.prototype.buildPath = function(ctx, shape) {
    buildPath(ctx, shape, false);
  };
  return Polyline2;
}(Path$1);
Polyline$2.prototype.type = "polyline";
var Polyline$3 = Polyline$2;
var subPixelOptimizeOutputShape = {};
var LineShape = function() {
  function LineShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
  return LineShape2;
}();
var Line$2 = function(_super) {
  __extends(Line2, _super);
  function Line2(opts) {
    return _super.call(this, opts) || this;
  }
  Line2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Line2.prototype.getDefaultShape = function() {
    return new LineShape();
  };
  Line2.prototype.buildPath = function(ctx, shape) {
    var x1;
    var y1;
    var x2;
    var y2;
    if (this.subPixelOptimize) {
      var optimizedShape = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
      x1 = optimizedShape.x1;
      y1 = optimizedShape.y1;
      x2 = optimizedShape.x2;
      y2 = optimizedShape.y2;
    } else {
      x1 = shape.x1;
      y1 = shape.y1;
      x2 = shape.x2;
      y2 = shape.y2;
    }
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }
    ctx.lineTo(x2, y2);
  };
  Line2.prototype.pointAt = function(p) {
    var shape = this.shape;
    return [
      shape.x1 * (1 - p) + shape.x2 * p,
      shape.y1 * (1 - p) + shape.y2 * p
    ];
  };
  return Line2;
}(Path$1);
Line$2.prototype.type = "line";
var Line$3 = Line$2;
var out = [];
var BezierCurveShape = function() {
  function BezierCurveShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.percent = 1;
  }
  return BezierCurveShape2;
}();
function someVectorAt(shape, t, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;
  if (cpx2 != null || cpy2 != null) {
    return [
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
    ];
  } else {
    return [
      (isTangent ? quadraticDerivativeAt : quadraticAt$1)(shape.x1, shape.cpx1, shape.x2, t),
      (isTangent ? quadraticDerivativeAt : quadraticAt$1)(shape.y1, shape.cpy1, shape.y2, t)
    ];
  }
}
var BezierCurve = function(_super) {
  __extends(BezierCurve2, _super);
  function BezierCurve2(opts) {
    return _super.call(this, opts) || this;
  }
  BezierCurve2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  BezierCurve2.prototype.getDefaultShape = function() {
    return new BezierCurveShape();
  };
  BezierCurve2.prototype.buildPath = function(ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }
      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  };
  BezierCurve2.prototype.pointAt = function(t) {
    return someVectorAt(this.shape, t, false);
  };
  BezierCurve2.prototype.tangentAt = function(t) {
    var p = someVectorAt(this.shape, t, true);
    return normalize$5(p, p);
  };
  return BezierCurve2;
}(Path$1);
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve$1 = BezierCurve;
var ArcShape = function() {
  function ArcShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return ArcShape2;
}();
var Arc = function(_super) {
  __extends(Arc2, _super);
  function Arc2(opts) {
    return _super.call(this, opts) || this;
  }
  Arc2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  Arc2.prototype.getDefaultShape = function() {
    return new ArcShape();
  };
  Arc2.prototype.buildPath = function(ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
  };
  return Arc2;
}(Path$1);
Arc.prototype.type = "arc";
var Arc$1 = Arc;
var CompoundPath = function(_super) {
  __extends(CompoundPath2, _super);
  function CompoundPath2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "compound";
    return _this;
  }
  CompoundPath2.prototype._updatePathDirty = function() {
    var paths = this.shape.paths;
    var dirtyPath = this.shapeChanged();
    for (var i = 0; i < paths.length; i++) {
      dirtyPath = dirtyPath || paths[i].shapeChanged();
    }
    if (dirtyPath) {
      this.dirtyShape();
    }
  };
  CompoundPath2.prototype.beforeBrush = function() {
    this._updatePathDirty();
    var paths = this.shape.paths || [];
    var scale2 = this.getGlobalScale();
    for (var i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }
      paths[i].path.setScale(scale2[0], scale2[1], paths[i].segmentIgnoreThreshold);
    }
  };
  CompoundPath2.prototype.buildPath = function(ctx, shape) {
    var paths = shape.paths || [];
    for (var i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  };
  CompoundPath2.prototype.afterBrush = function() {
    var paths = this.shape.paths || [];
    for (var i = 0; i < paths.length; i++) {
      paths[i].pathUpdated();
    }
  };
  CompoundPath2.prototype.getBoundingRect = function() {
    this._updatePathDirty.call(this);
    return Path$1.prototype.getBoundingRect.call(this);
  };
  return CompoundPath2;
}(Path$1);
var CompoundPath$1 = CompoundPath;
var Gradient = function() {
  function Gradient2(colorStops) {
    this.colorStops = colorStops || [];
  }
  Gradient2.prototype.addColorStop = function(offset, color) {
    this.colorStops.push({
      offset,
      color
    });
  };
  return Gradient2;
}();
var Gradient$1 = Gradient;
var LinearGradient = function(_super) {
  __extends(LinearGradient2, _super);
  function LinearGradient2(x, y, x2, y2, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x == null ? 0 : x;
    _this.y = y == null ? 0 : y;
    _this.x2 = x2 == null ? 1 : x2;
    _this.y2 = y2 == null ? 0 : y2;
    _this.type = "linear";
    _this.global = globalCoord || false;
    return _this;
  }
  return LinearGradient2;
}(Gradient$1);
var LinearGradient$1 = LinearGradient;
var RadialGradient = function(_super) {
  __extends(RadialGradient2, _super);
  function RadialGradient2(x, y, r, colorStops, globalCoord) {
    var _this = _super.call(this, colorStops) || this;
    _this.x = x == null ? 0.5 : x;
    _this.y = y == null ? 0.5 : y;
    _this.r = r == null ? 0.5 : r;
    _this.type = "radial";
    _this.global = globalCoord || false;
    return _this;
  }
  return RadialGradient2;
}(Gradient$1);
var RadialGradient$1 = RadialGradient;
var extent = [0, 0];
var extent2 = [0, 0];
var minTv = new Point$1();
var maxTv = new Point$1();
var OrientedBoundingRect = function() {
  function OrientedBoundingRect2(rect, transform2) {
    this._corners = [];
    this._axes = [];
    this._origin = [0, 0];
    for (var i = 0; i < 4; i++) {
      this._corners[i] = new Point$1();
    }
    for (var i = 0; i < 2; i++) {
      this._axes[i] = new Point$1();
    }
    if (rect) {
      this.fromBoundingRect(rect, transform2);
    }
  }
  OrientedBoundingRect2.prototype.fromBoundingRect = function(rect, transform2) {
    var corners = this._corners;
    var axes = this._axes;
    var x = rect.x;
    var y = rect.y;
    var x2 = x + rect.width;
    var y2 = y + rect.height;
    corners[0].set(x, y);
    corners[1].set(x2, y);
    corners[2].set(x2, y2);
    corners[3].set(x, y2);
    if (transform2) {
      for (var i = 0; i < 4; i++) {
        corners[i].transform(transform2);
      }
    }
    Point$1.sub(axes[0], corners[1], corners[0]);
    Point$1.sub(axes[1], corners[3], corners[0]);
    axes[0].normalize();
    axes[1].normalize();
    for (var i = 0; i < 2; i++) {
      this._origin[i] = axes[i].dot(corners[0]);
    }
  };
  OrientedBoundingRect2.prototype.intersect = function(other, mtv) {
    var overlapped = true;
    var noMtv = !mtv;
    minTv.set(Infinity, Infinity);
    maxTv.set(0, 0);
    if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!noMtv) {
      Point$1.copy(mtv, overlapped ? minTv : maxTv);
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._intersectCheckOneSide = function(self2, other, minTv2, maxTv2, noMtv, inverse) {
    var overlapped = true;
    for (var i = 0; i < 2; i++) {
      var axis = this._axes[i];
      this._getProjMinMaxOnAxis(i, self2._corners, extent);
      this._getProjMinMaxOnAxis(i, other._corners, extent2);
      if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) > maxTv2.len()) {
          if (dist0 < dist1) {
            Point$1.scale(maxTv2, axis, -dist0 * inverse);
          } else {
            Point$1.scale(maxTv2, axis, dist1 * inverse);
          }
        }
      } else if (minTv2) {
        var dist0 = Math.abs(extent2[0] - extent[1]);
        var dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) < minTv2.len()) {
          if (dist0 < dist1) {
            Point$1.scale(minTv2, axis, dist0 * inverse);
          } else {
            Point$1.scale(minTv2, axis, -dist1 * inverse);
          }
        }
      }
    }
    return overlapped;
  };
  OrientedBoundingRect2.prototype._getProjMinMaxOnAxis = function(dim, corners, out2) {
    var axis = this._axes[dim];
    var origin = this._origin;
    var proj = corners[0].dot(axis) + origin[dim];
    var min3 = proj;
    var max3 = proj;
    for (var i = 1; i < corners.length; i++) {
      var proj_1 = corners[i].dot(axis) + origin[dim];
      min3 = Math.min(proj_1, min3);
      max3 = Math.max(proj_1, max3);
    }
    out2[0] = min3;
    out2[1] = max3;
  };
  return OrientedBoundingRect2;
}();
var OrientedBoundingRect$1 = OrientedBoundingRect;
var m = [];
var IncrementalDisplayable = function(_super) {
  __extends(IncrementalDisplayable2, _super);
  function IncrementalDisplayable2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.notClear = true;
    _this.incremental = true;
    _this._displayables = [];
    _this._temporaryDisplayables = [];
    _this._cursor = 0;
    return _this;
  }
  IncrementalDisplayable2.prototype.traverse = function(cb, context) {
    cb.call(context, this);
  };
  IncrementalDisplayable2.prototype.useStyle = function() {
    this.style = {};
  };
  IncrementalDisplayable2.prototype.getCursor = function() {
    return this._cursor;
  };
  IncrementalDisplayable2.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  };
  IncrementalDisplayable2.prototype.clearDisplaybles = function() {
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.markRedraw();
    this.notClear = false;
  };
  IncrementalDisplayable2.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  };
  IncrementalDisplayable2.prototype.addDisplayable = function(displayable, notPersistent) {
    if (notPersistent) {
      this._temporaryDisplayables.push(displayable);
    } else {
      this._displayables.push(displayable);
    }
    this.markRedraw();
  };
  IncrementalDisplayable2.prototype.addDisplayables = function(displayables, notPersistent) {
    notPersistent = notPersistent || false;
    for (var i = 0; i < displayables.length; i++) {
      this.addDisplayable(displayables[i], notPersistent);
    }
  };
  IncrementalDisplayable2.prototype.getDisplayables = function() {
    return this._displayables;
  };
  IncrementalDisplayable2.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  };
  IncrementalDisplayable2.prototype.eachPendingDisplayable = function(cb) {
    for (var i = this._cursor; i < this._displayables.length; i++) {
      cb && cb(this._displayables[i]);
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      cb && cb(this._temporaryDisplayables[i]);
    }
  };
  IncrementalDisplayable2.prototype.update = function() {
    this.updateTransform();
    for (var i = this._cursor; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var displayable = this._temporaryDisplayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
  };
  IncrementalDisplayable2.prototype.getBoundingRect = function() {
    if (!this._rect) {
      var rect = new BoundingRect$1(Infinity, Infinity, -Infinity, -Infinity);
      for (var i = 0; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        var childRect = displayable.getBoundingRect().clone();
        if (displayable.needLocalTransform()) {
          childRect.applyTransform(displayable.getLocalTransform(m));
        }
        rect.union(childRect);
      }
      this._rect = rect;
    }
    return this._rect;
  };
  IncrementalDisplayable2.prototype.contain = function(x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    if (rect.contain(localPos[0], localPos[1])) {
      for (var i = 0; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        if (displayable.contain(x, y)) {
          return true;
        }
      }
    }
    return false;
  };
  return IncrementalDisplayable2;
}(Displayable$1);
var IncrementalDisplayable$1 = IncrementalDisplayable;
var transitionStore = makeInner();
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
  var animationPayload;
  if (animatableModel && animatableModel.ecModel) {
    var updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }
  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  var isUpdate = animationType === "update";
  if (animationEnabled) {
    var duration = void 0;
    var easing = void 0;
    var delay = void 0;
    if (extraOpts) {
      duration = retrieve2(extraOpts.duration, 200);
      easing = retrieve2(extraOpts.easing, "cubicOut");
      delay = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
      easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
      delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
    }
    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay = animationPayload.delay);
    }
    if (isFunction$1(delay)) {
      delay = delay(dataIndex, extraDelayParams);
    }
    if (isFunction$1(duration)) {
      duration = duration(dataIndex);
    }
    var config = {
      duration: duration || 0,
      delay,
      easing
    };
    return config;
  } else {
    return null;
  }
}
function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
  var isFrom = false;
  var removeOpt;
  if (isFunction$1(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if (isObject$3(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }
  var isRemove = animationType === "leave";
  if (!isRemove) {
    el.stopAnimation("leave");
  }
  var animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
  if (animationConfig && animationConfig.duration > 0) {
    var duration = animationConfig.duration;
    var animationDelay = animationConfig.delay;
    var animationEasing = animationConfig.easing;
    var animateConfig = {
      duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      setToFinal: !isRemove,
      scope: animationType,
      during
    };
    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
  } else {
    el.stopAnimation();
    !isFrom && el.attr(props);
    during && during(1);
    cb && cb();
  }
}
function updateProps$1(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
}
function initProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
}
function isElementRemoved(el) {
  if (!el.__zr) {
    return true;
  }
  for (var i = 0; i < el.animators.length; i++) {
    var animator = el.animators[i];
    if (animator.scope === "leave") {
      return true;
    }
  }
  return false;
}
function removeElement(el, props, animatableModel, dataIndex, cb, during) {
  if (isElementRemoved(el)) {
    return;
  }
  animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
  el.removeTextContent();
  el.removeTextGuideLine();
  removeElement(el, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el, animatableModel, dataIndex) {
  function doRemove() {
    el.parent && el.parent.remove(el);
  }
  if (!el.isGroup) {
    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
  } else {
    el.traverse(function(disp) {
      if (!disp.isGroup) {
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
function saveOldStyle(el) {
  transitionStore(el).oldStyle = el.style;
}
function getOldStyle(el) {
  return transitionStore(el).oldStyle;
}
var mathMax$7 = Math.max;
var mathMin$7 = Math.min;
var _customShapeMap = {};
function extendShape(opts) {
  return Path$1.extend(opts);
}
var extendPathFromString = extendFromString;
function extendPath(pathData, opts) {
  return extendPathFromString(pathData, opts);
}
function registerShape(name, ShapeClass) {
  _customShapeMap[name] = ShapeClass;
}
function getShapeClass(name) {
  if (_customShapeMap.hasOwnProperty(name)) {
    return _customShapeMap[name];
  }
}
function makePath$1(pathData, opts, rect, layout2) {
  var path = createFromString(pathData, opts);
  if (rect) {
    if (layout2 === "center") {
      rect = centerGraphic(rect, path.getBoundingRect());
    }
    resizePath(path, rect);
  }
  return path;
}
function makeImage(imageUrl, rect, layout2) {
  var zrImg = new ZRImage$1({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function(img) {
      if (layout2 === "center") {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        zrImg.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return zrImg;
}
function centerGraphic(rect, boundingRect) {
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;
  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }
  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width,
    height
  };
}
var mergePath = mergePath$1;
function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }
  var pathRect = path.getBoundingRect();
  var m2 = pathRect.calculateTransform(rect);
  path.applyTransform(m2);
}
function subPixelOptimizeLine(param) {
  subPixelOptimizeLine$1(param.shape, param.shape, param.style);
  return param;
}
function subPixelOptimizeRect(param) {
  subPixelOptimizeRect$1(param.shape, param.shape, param.style);
  return param;
}
var subPixelOptimize = subPixelOptimize$1;
function getTransform$1(target, ancestor) {
  var mat = identity([]);
  while (target && target !== ancestor) {
    mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }
  return mat;
}
function applyTransform(target, transform2, invert$1) {
  if (transform2 && !isArrayLike(transform2)) {
    transform2 = Transformable.getLocalTransform(transform2);
  }
  if (invert$1) {
    transform2 = invert([], transform2);
  }
  return applyTransform$1([], target, transform2);
}
function transformDirection(direction, transform2, invert2) {
  var hBase = transform2[4] === 0 || transform2[5] === 0 || transform2[0] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[0]);
  var vBase = transform2[4] === 0 || transform2[5] === 0 || transform2[2] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[2]);
  var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
  vertex = applyTransform(vertex, transform2, invert2);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el) {
  return !el.isGroup;
}
function isPath$1(el) {
  return el.shape != null;
}
function groupTransition(g1, g2, animatableModel) {
  if (!g1 || !g2) {
    return;
  }
  function getElMap(g3) {
    var elMap = {};
    g3.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }
  function getAnimatableProps(el) {
    var obj = {
      x: el.x,
      y: el.y,
      rotation: el.rotation
    };
    if (isPath$1(el)) {
      obj.shape = extend$1({}, el.shape);
    }
    return obj;
  }
  var elMap1 = getElMap(g1);
  g2.traverse(function(el) {
    if (isNotGroup(el) && el.anid) {
      var oldEl = elMap1[el.anid];
      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps$1(el, newProp, animatableModel, getECData(el).dataIndex);
      }
    }
  });
}
function clipPointsByRect(points2, rect) {
  return map$1(points2, function(point) {
    var x = point[0];
    x = mathMax$7(x, rect.x);
    x = mathMin$7(x, rect.x + rect.width);
    var y = point[1];
    y = mathMax$7(y, rect.y);
    y = mathMin$7(y, rect.y + rect.height);
    return [x, y];
  });
}
function clipRectByRect(targetRect, rect) {
  var x = mathMax$7(targetRect.x, rect.x);
  var x2 = mathMin$7(targetRect.x + targetRect.width, rect.x + rect.width);
  var y = mathMax$7(targetRect.y, rect.y);
  var y2 = mathMin$7(targetRect.y + targetRect.height, rect.y + rect.height);
  if (x2 >= x && y2 >= y) {
    return {
      x,
      y,
      width: x2 - x,
      height: y2 - y
    };
  }
}
function createIcon(iconStr, opt, rect) {
  var innerOpts = extend$1({
    rectHover: true
  }, opt);
  var style = innerOpts.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };
  if (iconStr) {
    return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage$1(innerOpts)) : makePath$1(iconStr.replace("path://", ""), innerOpts, rect, "center");
  }
}
function linePolygonIntersect(a1x, a1y, a2x, a2y, points2) {
  for (var i = 0, p22 = points2[points2.length - 1]; i < points2.length; i++) {
    var p = points2[i];
    if (lineLineIntersect$1(a1x, a1y, a2x, a2y, p[0], p[1], p22[0], p22[1])) {
      return true;
    }
    p22 = p;
  }
}
function lineLineIntersect$1(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d$1(nx, ny, mx, my);
  if (nearZero(nmCrossProduct)) {
    return false;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var q = crossProduct2d$1(b1a1x, b1a1y, mx, my) / nmCrossProduct;
  if (q < 0 || q > 1) {
    return false;
  }
  var p = crossProduct2d$1(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p < 0 || p > 1) {
    return false;
  }
  return true;
}
function crossProduct2d$1(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function nearZero(val) {
  return val <= 1e-6 && val >= -1e-6;
}
function setTooltipConfig(opt) {
  var itemTooltipOption = opt.itemTooltipOption;
  var componentModel = opt.componentModel;
  var itemName = opt.itemName;
  var itemTooltipOptionObj = isString(itemTooltipOption) ? {
    formatter: itemTooltipOption
  } : itemTooltipOption;
  var mainType = componentModel.mainType;
  var componentIndex = componentModel.componentIndex;
  var formatterParams = {
    componentType: mainType,
    name: itemName,
    $vars: ["name"]
  };
  formatterParams[mainType + "Index"] = componentIndex;
  var formatterParamsExtra = opt.formatterParamsExtra;
  if (formatterParamsExtra) {
    each$f(keys(formatterParamsExtra), function(key) {
      if (!hasOwn(formatterParams, key)) {
        formatterParams[key] = formatterParamsExtra[key];
        formatterParams.$vars.push(key);
      }
    });
  }
  var ecData = getECData(opt.el);
  ecData.componentMainType = mainType;
  ecData.componentIndex = componentIndex;
  ecData.tooltipConfig = {
    name: itemName,
    option: defaults({
      content: itemName,
      formatterParams
    }, itemTooltipOptionObj)
  };
}
function traverseElement(el, cb) {
  var stopped;
  if (el.isGroup) {
    stopped = cb(el);
  }
  if (!stopped) {
    el.traverse(cb);
  }
}
function traverseElements(els, cb) {
  if (els) {
    if (isArray$1(els)) {
      for (var i = 0; i < els.length; i++) {
        traverseElement(els[i], cb);
      }
    } else {
      traverseElement(els, cb);
    }
  }
}
registerShape("circle", Circle$1);
registerShape("ellipse", Ellipse$1);
registerShape("sector", Sector$1);
registerShape("ring", Ring$1);
registerShape("polygon", Polygon$1);
registerShape("polyline", Polyline$3);
registerShape("rect", Rect$3);
registerShape("line", Line$3);
registerShape("bezierCurve", BezierCurve$1);
registerShape("arc", Arc$1);
var graphic = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  updateProps: updateProps$1,
  initProps,
  removeElement,
  removeElementWithFadeOut,
  isElementRemoved,
  extendShape,
  extendPath,
  registerShape,
  getShapeClass,
  makePath: makePath$1,
  makeImage,
  mergePath,
  resizePath,
  subPixelOptimizeLine,
  subPixelOptimizeRect,
  subPixelOptimize,
  getTransform: getTransform$1,
  applyTransform,
  transformDirection,
  groupTransition,
  clipPointsByRect,
  clipRectByRect,
  createIcon,
  linePolygonIntersect,
  lineLineIntersect: lineLineIntersect$1,
  setTooltipConfig,
  traverseElements,
  Group: Group$4,
  Image: ZRImage$1,
  Text: ZRText$1,
  Circle: Circle$1,
  Ellipse: Ellipse$1,
  Sector: Sector$1,
  Ring: Ring$1,
  Polygon: Polygon$1,
  Polyline: Polyline$3,
  Rect: Rect$3,
  Line: Line$3,
  BezierCurve: BezierCurve$1,
  Arc: Arc$1,
  IncrementalDisplayable: IncrementalDisplayable$1,
  CompoundPath: CompoundPath$1,
  LinearGradient: LinearGradient$1,
  RadialGradient: RadialGradient$1,
  BoundingRect: BoundingRect$1,
  OrientedBoundingRect: OrientedBoundingRect$1,
  Point: Point$1,
  Path: Path$1
});
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    var text = labelTexts[stateName];
    var state = label.ensureState(stateName);
    state.style = state.style || {};
    state.style.text = text;
  }
  var oldStates = label.currentStates.slice();
  label.clearStates(true);
  label.setStyle({
    text: labelTexts.normal
  });
  label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex;
  var normalModel = stateModels.normal;
  var baseText;
  if (labelFetcher) {
    baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
      interpolatedValue
    } : null);
  }
  if (baseText == null) {
    baseText = isFunction$1(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
  }
  var statesText = {
    normal: baseText
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    var stateModel = stateModels[stateName];
    statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
  }
  return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
  opt = opt || EMPTY_OBJ;
  var isSetOnText = targetEl instanceof ZRText$1;
  var needsCreateText = false;
  for (var i = 0; i < DISPLAY_STATES.length; i++) {
    var stateModel = labelStatesModels[DISPLAY_STATES[i]];
    if (stateModel && stateModel.getShallow("show")) {
      needsCreateText = true;
      break;
    }
  }
  var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
  if (needsCreateText) {
    if (!isSetOnText) {
      if (!textContent) {
        textContent = new ZRText$1();
        targetEl.setTextContent(textContent);
      }
      if (targetEl.stateProxy) {
        textContent.stateProxy = targetEl.stateProxy;
      }
    }
    var labelStatesTexts = getLabelText(opt, labelStatesModels);
    var normalModel = labelStatesModels.normal;
    var showNormal = !!normalModel.getShallow("show");
    var normalStyle = createTextStyle$1(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
    normalStyle.text = labelStatesTexts.normal;
    if (!isSetOnText) {
      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
    }
    for (var i = 0; i < SPECIAL_STATES.length; i++) {
      var stateName = SPECIAL_STATES[i];
      var stateModel = labelStatesModels[stateName];
      if (stateModel) {
        var stateObj = textContent.ensureState(stateName);
        var stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
        if (stateShow !== showNormal) {
          stateObj.ignore = !stateShow;
        }
        stateObj.style = createTextStyle$1(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
        stateObj.style.text = labelStatesTexts[stateName];
        if (!isSetOnText) {
          var targetElEmphasisState = targetEl.ensureState(stateName);
          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
        }
      }
    }
    textContent.silent = !!normalModel.getShallow("silent");
    if (textContent.style.x != null) {
      normalStyle.x = textContent.style.x;
    }
    if (textContent.style.y != null) {
      normalStyle.y = textContent.style.y;
    }
    textContent.ignore = !showNormal;
    textContent.useStyle(normalStyle);
    textContent.dirty();
    if (opt.enableTextSetter) {
      labelInner(textContent).setLabelText = function(interpolatedValue) {
        var labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
        setLabelText(textContent, labelStatesTexts2);
      };
    }
  } else if (textContent) {
    textContent.ignore = true;
  }
  targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
  labelName = labelName || "label";
  var statesModels = {
    normal: itemModel.getModel(labelName)
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
  }
  return statesModels;
}
function createTextStyle$1(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
  var textStyle = {};
  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
  specifiedTextStyle && extend$1(textStyle, specifiedTextStyle);
  return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
  opt = opt || {};
  var textConfig = {};
  var labelPosition;
  var labelRotate = textStyleModel.getShallow("rotate");
  var labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
  var labelOffset = textStyleModel.getShallow("offset");
  labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
  labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
  if (labelPosition != null) {
    textConfig.position = labelPosition;
  }
  if (labelOffset != null) {
    textConfig.offset = labelOffset;
  }
  if (labelRotate != null) {
    labelRotate *= Math.PI / 180;
    textConfig.rotation = labelRotate;
  }
  if (labelDistance != null) {
    textConfig.distance = labelDistance;
  }
  textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
  return textConfig;
}
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
  opt = opt || EMPTY_OBJ;
  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle;
  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;
  if (richItemNames) {
    richResult = {};
    for (var name_1 in richItemNames) {
      if (richItemNames.hasOwnProperty(name_1)) {
        var richTextStyle = textStyleModel.getModel(["rich", name_1]);
        setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
      }
    }
  }
  if (richResult) {
    textStyle.rich = richResult;
  }
  var overflow = textStyleModel.get("overflow");
  if (overflow) {
    textStyle.overflow = overflow;
  }
  var margin = textStyleModel.get("minMargin");
  if (margin != null) {
    textStyle.margin = margin;
  }
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
  var richItemNameMap;
  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;
    if (rich) {
      richItemNameMap = richItemNameMap || {};
      var richKeys = keys(rich);
      for (var i = 0; i < richKeys.length; i++) {
        var richKey = richKeys[i];
        richItemNameMap[richKey] = 1;
      }
    }
    textStyleModel = textStyleModel.parentModel;
  }
  return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"];
var TEXT_PROPS_SELF = ["align", "lineHeight", "width", "height", "tag", "verticalAlign"];
var TEXT_PROPS_BOX = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
  var inheritColor = opt && opt.inheritColor;
  var fillColor = textStyleModel.getShallow("color");
  var strokeColor = textStyleModel.getShallow("textBorderColor");
  var opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
  if (fillColor === "inherit" || fillColor === "auto") {
    if (inheritColor) {
      fillColor = inheritColor;
    } else {
      fillColor = null;
    }
  }
  if (strokeColor === "inherit" || strokeColor === "auto") {
    if (inheritColor) {
      strokeColor = inheritColor;
    } else {
      strokeColor = null;
    }
  }
  if (!isAttached) {
    fillColor = fillColor || globalTextStyle.color;
    strokeColor = strokeColor || globalTextStyle.textBorderColor;
  }
  if (fillColor != null) {
    textStyle.fill = fillColor;
  }
  if (strokeColor != null) {
    textStyle.stroke = strokeColor;
  }
  var textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
  if (textBorderWidth != null) {
    textStyle.lineWidth = textBorderWidth;
  }
  var textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
  if (textBorderType != null) {
    textStyle.lineDash = textBorderType;
  }
  var textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
  if (textBorderDashOffset != null) {
    textStyle.lineDashOffset = textBorderDashOffset;
  }
  if (!isNotNormal && opacity == null && !inRich) {
    opacity = opt && opt.defaultOpacity;
  }
  if (opacity != null) {
    textStyle.opacity = opacity;
  }
  if (!isNotNormal && !isAttached) {
    if (textStyle.fill == null && opt.inheritColor) {
      textStyle.fill = opt.inheritColor;
    }
  }
  for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
    var key = TEXT_PROPS_WITH_GLOBAL[i];
    var val = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
    var key = TEXT_PROPS_SELF[i];
    var val = textStyleModel.getShallow(key);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  if (textStyle.verticalAlign == null) {
    var baseline = textStyleModel.getShallow("baseline");
    if (baseline != null) {
      textStyle.verticalAlign = baseline;
    }
  }
  if (!isBlock || !opt.disableBox) {
    for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
      var key = TEXT_PROPS_BOX[i];
      var val = textStyleModel.getShallow(key);
      if (val != null) {
        textStyle[key] = val;
      }
    }
    var borderType = textStyleModel.getShallow("borderType");
    if (borderType != null) {
      textStyle.borderDash = borderType;
    }
    if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
      textStyle.backgroundColor = inheritColor;
    }
    if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
      textStyle.borderColor = inheritColor;
    }
  }
}
function getFont(opt, ecModel) {
  var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
  return trim$1([
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
    opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
    (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
    opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
  if (!label) {
    return;
  }
  var obj = labelInner(label);
  obj.prevValue = obj.value;
  obj.value = value;
  var normalLabelModel = labelStatesModels.normal;
  obj.valueAnimation = normalLabelModel.get("valueAnimation");
  if (obj.valueAnimation) {
    obj.precision = normalLabelModel.get("precision");
    obj.defaultInterpolatedText = getDefaultText;
    obj.statesModels = labelStatesModels;
  }
}
function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
  var labelInnerStore = labelInner(textEl);
  if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
    return;
  }
  var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
  var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
  var targetValue = labelInnerStore.value;
  function during(percent) {
    var interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
    labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
    var labelText = getLabelText({
      labelDataIndex: dataIndex,
      labelFetcher,
      defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
    }, labelInnerStore.statesModels, interpolated);
    setLabelText(textEl, labelText);
  }
  textEl.percent = 0;
  (labelInnerStore.prevValue == null ? initProps : updateProps$1)(textEl, {
    percent: 1
  }, animatableModel, dataIndex, null, during);
}
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"];
var tmpText = new ZRText$1();
var TextStyleMixin = function() {
  function TextStyleMixin2() {
  }
  TextStyleMixin2.prototype.getTextColor = function(isEmphasis) {
    var ecModel = this.ecModel;
    return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  };
  TextStyleMixin2.prototype.getFont = function() {
    return getFont({
      fontStyle: this.getShallow("fontStyle"),
      fontWeight: this.getShallow("fontWeight"),
      fontSize: this.getShallow("fontSize"),
      fontFamily: this.getShallow("fontFamily")
    }, this.ecModel);
  };
  TextStyleMixin2.prototype.getTextRect = function(text) {
    var style = {
      text,
      verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
    };
    for (var i = 0; i < textStyleParams.length; i++) {
      style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
    }
    tmpText.useStyle(style);
    tmpText.update();
    return tmpText.getBoundingRect();
  };
  return TextStyleMixin2;
}();
var TextStyleMixin$1 = TextStyleMixin;
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = function() {
  function LineStyleMixin2() {
  }
  LineStyleMixin2.prototype.getLineStyle = function(excludes) {
    return getLineStyle(this, excludes);
  };
  return LineStyleMixin2;
}();
var ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = function() {
  function ItemStyleMixin2() {
  }
  ItemStyleMixin2.prototype.getItemStyle = function(excludes, includes) {
    return getItemStyle(this, excludes, includes);
  };
  return ItemStyleMixin2;
}();
var Model = function() {
  function Model2(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  Model2.prototype.init = function(option, parentModel, ecModel) {
    var rest = [];
    for (var _i = 3; _i < arguments.length; _i++) {
      rest[_i - 3] = arguments[_i];
    }
  };
  Model2.prototype.mergeOption = function(option, ecModel) {
    merge(this.option, option, true);
  };
  Model2.prototype.get = function(path, ignoreParent) {
    if (path == null) {
      return this.option;
    }
    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
  };
  Model2.prototype.getShallow = function(key, ignoreParent) {
    var option = this.option;
    var val = option == null ? option : option[key];
    if (val == null && !ignoreParent) {
      var parentModel = this.parentModel;
      if (parentModel) {
        val = parentModel.getShallow(key);
      }
    }
    return val;
  };
  Model2.prototype.getModel = function(path, parentModel) {
    var hasPath = path != null;
    var pathFinal = hasPath ? this.parsePath(path) : null;
    var obj = hasPath ? this._doGet(pathFinal) : this.option;
    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
    return new Model2(obj, parentModel, this.ecModel);
  };
  Model2.prototype.isEmpty = function() {
    return this.option == null;
  };
  Model2.prototype.restoreData = function() {
  };
  Model2.prototype.clone = function() {
    var Ctor = this.constructor;
    return new Ctor(clone$4(this.option));
  };
  Model2.prototype.parsePath = function(path) {
    if (typeof path === "string") {
      return path.split(".");
    }
    return path;
  };
  Model2.prototype.resolveParentPath = function(path) {
    return path;
  };
  Model2.prototype.isAnimationEnabled = function() {
    if (!env$1.node && this.option) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  };
  Model2.prototype._doGet = function(pathArr, parentModel) {
    var obj = this.option;
    if (!pathArr) {
      return obj;
    }
    for (var i = 0; i < pathArr.length; i++) {
      if (!pathArr[i]) {
        continue;
      }
      obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
      if (obj == null) {
        break;
      }
    }
    if (obj == null && parentModel) {
      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
    }
    return obj;
  };
  return Model2;
}();
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, TextStyleMixin$1);
var Model$1 = Model;
var base = Math.round(Math.random() * 10);
function getUID(type) {
  return [type || "", base++].join("_");
}
function enableSubTypeDefaulter(target) {
  var subTypeDefaulters = {};
  target.registerSubTypeDefaulter = function(componentType, defaulter) {
    var componentTypeInfo = parseClassType(componentType);
    subTypeDefaulters[componentTypeInfo.main] = defaulter;
  };
  target.determineSubType = function(componentType, option) {
    var type = option.type;
    if (!type) {
      var componentTypeMain = parseClassType(componentType).main;
      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }
    return type;
  };
}
function enableTopologicalTravel(entity, dependencyGetter) {
  entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }
    var result = makeDepndencyGraph(fullNameList);
    var graph = result.graph;
    var noEntryList = result.noEntryList;
    var targetNameSet = {};
    each$f(targetNameList, function(name) {
      targetNameSet[name] = true;
    });
    while (noEntryList.length) {
      var currComponentType = noEntryList.pop();
      var currVertex = graph[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];
      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }
      each$f(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }
    each$f(targetNameSet, function() {
      var errMsg = "";
      throw new Error(errMsg);
    });
    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;
      if (graph[succComponentType].entryCount === 0) {
        noEntryList.push(succComponentType);
      }
    }
    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  function makeDepndencyGraph(fullNameList) {
    var graph = {};
    var noEntryList = [];
    each$f(fullNameList, function(name) {
      var thisItem = createDependencyGraphItem(graph, name);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;
      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }
      each$f(availableDeps, function(dependentName) {
        if (indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }
        var thatItem = createDependencyGraphItem(graph, dependentName);
        if (indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {
      graph,
      noEntryList
    };
  }
  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {
        predecessor: [],
        successor: []
      };
    }
    return graph[name];
  }
  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    each$f(originalDeps, function(dep) {
      indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
function inheritDefaultOption(superOption, subOption) {
  return merge(merge({}, superOption, true), subOption, true);
}
var langEN = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
};
var langZH = {
  time: {
    month: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
    monthAbbr: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"],
    dayOfWeek: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"],
    dayOfWeekAbbr: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"]
  },
  legend: {
    selector: {
      all: "\u5168\u9009",
      inverse: "\u53CD\u9009"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "\u77E9\u5F62\u9009\u62E9",
        polygon: "\u5708\u9009",
        lineX: "\u6A2A\u5411\u9009\u62E9",
        lineY: "\u7EB5\u5411\u9009\u62E9",
        keep: "\u4FDD\u6301\u9009\u62E9",
        clear: "\u6E05\u9664\u9009\u62E9"
      }
    },
    dataView: {
      title: "\u6570\u636E\u89C6\u56FE",
      lang: ["\u6570\u636E\u89C6\u56FE", "\u5173\u95ED", "\u5237\u65B0"]
    },
    dataZoom: {
      title: {
        zoom: "\u533A\u57DF\u7F29\u653E",
        back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
      }
    },
    magicType: {
      title: {
        line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
        bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
        stack: "\u5207\u6362\u4E3A\u5806\u53E0",
        tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
      }
    },
    restore: {
      title: "\u8FD8\u539F"
    },
    saveAsImage: {
      title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
      lang: ["\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"]
    }
  },
  series: {
    typeNames: {
      pie: "\u997C\u56FE",
      bar: "\u67F1\u72B6\u56FE",
      line: "\u6298\u7EBF\u56FE",
      scatter: "\u6563\u70B9\u56FE",
      effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
      radar: "\u96F7\u8FBE\u56FE",
      tree: "\u6811\u56FE",
      treemap: "\u77E9\u5F62\u6811\u56FE",
      boxplot: "\u7BB1\u578B\u56FE",
      candlestick: "K\u7EBF\u56FE",
      k: "K\u7EBF\u56FE",
      heatmap: "\u70ED\u529B\u56FE",
      map: "\u5730\u56FE",
      parallel: "\u5E73\u884C\u5750\u6807\u56FE",
      lines: "\u7EBF\u56FE",
      graph: "\u5173\u7CFB\u56FE",
      sankey: "\u6851\u57FA\u56FE",
      funnel: "\u6F0F\u6597\u56FE",
      gauge: "\u4EEA\u8868\u76D8\u56FE",
      pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
      themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
      sunburst: "\u65ED\u65E5\u56FE"
    }
  },
  aria: {
    general: {
      withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
      withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
    },
    series: {
      single: {
        prefix: "",
        withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
        withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
      },
      multiple: {
        prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
        withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
        withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
        separator: {
          middle: "\uFF1B",
          end: "\u3002"
        }
      }
    },
    data: {
      allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
      partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
      withName: "{name}\u7684\u6570\u636E\u662F{value}",
      withoutName: "{value}",
      separator: {
        middle: "\uFF0C",
        end: ""
      }
    }
  }
};
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env$1.domSupported ? DEFAULT_LOCALE : function() {
  var langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();
  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
  locale = locale.toUpperCase();
  localeModels[locale] = new Model$1(localeObj);
  localeStorage[locale] = localeObj;
}
function createLocaleObject(locale) {
  if (isString(locale)) {
    var localeObj = localeStorage[locale.toUpperCase()] || {};
    if (locale === LOCALE_ZH || locale === LOCALE_EN) {
      return clone$4(localeObj);
    } else {
      return merge(clone$4(localeObj), clone$4(localeStorage[DEFAULT_LOCALE]), false);
    }
  } else {
    return merge(clone$4(locale), clone$4(localeStorage[DEFAULT_LOCALE]), false);
  }
}
function getLocaleModel(lang) {
  return localeModels[lang];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN);
registerLocale(LOCALE_ZH, langZH);
var ONE_SECOND = 1e3;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var defaultLeveledFormatter = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
};
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
  second: fullDayFormatter + " " + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
};
var primaryTimeUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
var timeUnits = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function pad(str, len2) {
  str += "";
  return "0000".substr(0, len2 - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
  switch (timeUnit) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return timeUnit;
  }
}
function isPrimaryTimeUnit(timeUnit) {
  return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
  switch (timeUnit) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format(time, template, isUTC, lang) {
  var date = parseDate(time);
  var y = date[fullYearGetterName(isUTC)]();
  var M = date[monthGetterName(isUTC)]() + 1;
  var q = Math.floor((M - 1) / 4) + 1;
  var d = date[dateGetterName(isUTC)]();
  var e2 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
  var H = date[hoursGetterName(isUTC)]();
  var h = (H - 1) % 12 + 1;
  var m2 = date[minutesGetterName(isUTC)]();
  var s = date[secondsGetterName(isUTC)]();
  var S = date[millisecondsGetterName(isUTC)]();
  var localeModel = lang instanceof Model$1 ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
  var timeModel = localeModel.getModel("time");
  var month = timeModel.get("month");
  var monthAbbr = timeModel.get("monthAbbr");
  var dayOfWeek = timeModel.get("dayOfWeek");
  var dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
  return (template || "").replace(/{yyyy}/g, y + "").replace(/{yy}/g, y % 100 + "").replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + "").replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + "").replace(/{eeee}/g, dayOfWeek[e2]).replace(/{ee}/g, dayOfWeekAbbr[e2]).replace(/{e}/g, e2 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, pad(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + "").replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + "");
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
  var template = null;
  if (isString(formatter)) {
    template = formatter;
  } else if (isFunction$1(formatter)) {
    template = formatter(tick.value, idx, {
      level: tick.level
    });
  } else {
    var defaults$1 = extend$1({}, defaultLeveledFormatter);
    if (tick.level > 0) {
      for (var i = 0; i < primaryTimeUnits.length; ++i) {
        defaults$1[primaryTimeUnits[i]] = "{primary|" + defaults$1[primaryTimeUnits[i]] + "}";
      }
    }
    var mergedFormatter = formatter ? formatter.inherit === false ? formatter : defaults(formatter, defaults$1) : defaults$1;
    var unit = getUnitFromValue(tick.value, isUTC);
    if (mergedFormatter[unit]) {
      template = mergedFormatter[unit];
    } else if (mergedFormatter.inherit) {
      var targetId = timeUnits.indexOf(unit);
      for (var i = targetId - 1; i >= 0; --i) {
        if (mergedFormatter[unit]) {
          template = mergedFormatter[unit];
          break;
        }
      }
      template = template || defaults$1.none;
    }
    if (isArray$1(template)) {
      var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
      levelId = Math.min(levelId, template.length - 1);
      template = template[levelId];
    }
  }
  return format(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
  var date = parseDate(value);
  var M = date[monthGetterName(isUTC)]() + 1;
  var d = date[dateGetterName(isUTC)]();
  var h = date[hoursGetterName(isUTC)]();
  var m2 = date[minutesGetterName(isUTC)]();
  var s = date[secondsGetterName(isUTC)]();
  var S = date[millisecondsGetterName(isUTC)]();
  var isSecond = S === 0;
  var isMinute = isSecond && s === 0;
  var isHour = isMinute && m2 === 0;
  var isDay = isHour && h === 0;
  var isMonth = isDay && d === 1;
  var isYear = isMonth && M === 1;
  if (isYear) {
    return "year";
  } else if (isMonth) {
    return "month";
  } else if (isDay) {
    return "day";
  } else if (isHour) {
    return "hour";
  } else if (isMinute) {
    return "minute";
  } else if (isSecond) {
    return "second";
  } else {
    return "millisecond";
  }
}
function getUnitValue(value, unit, isUTC) {
  var date = isNumber(value) ? parseDate(value) : value;
  unit = unit || getUnitFromValue(value, isUTC);
  switch (unit) {
    case "year":
      return date[fullYearGetterName(isUTC)]();
    case "half-year":
      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
    case "month":
      return date[monthGetterName(isUTC)]();
    case "day":
      return date[dateGetterName(isUTC)]();
    case "half-day":
      return date[hoursGetterName(isUTC)]() / 24;
    case "hour":
      return date[hoursGetterName(isUTC)]();
    case "minute":
      return date[minutesGetterName(isUTC)]();
    case "second":
      return date[secondsGetterName(isUTC)]();
    case "millisecond":
      return date[millisecondsGetterName(isUTC)]();
  }
}
function fullYearGetterName(isUTC) {
  return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
  return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
  return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
  return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
  return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
  return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
  return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
  return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
  return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
  return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
  return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
  return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
  return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
  return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}
function addCommas(x) {
  if (!isNumeric(x)) {
    return isString(x) ? x : "-";
  }
  var parts = (x + "").split(".");
  return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
}
function toCamelCase(str, upperCaseFirst) {
  str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str;
}
var normalizeCssArray = normalizeCssArray$1;
var replaceReg = /([&<>"'])/g;
var replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(source) {
  return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
    return replaceMap[c];
  });
}
function makeValueReadable(value, valueType, useUTC) {
  var USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {hh}:{mm}:{ss}";
  function stringToUserReadable(str) {
    return str && trim$1(str) ? str : "-";
  }
  function isNumberUserReadable(num) {
    return !!(num != null && !isNaN(num) && isFinite(num));
  }
  var isTypeTime = valueType === "time";
  var isValueDate = value instanceof Date;
  if (isTypeTime || isValueDate) {
    var date = isTypeTime ? parseDate(value) : value;
    if (!isNaN(+date)) {
      return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
    } else if (isValueDate) {
      return "-";
    }
  }
  if (valueType === "ordinal") {
    return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
  }
  var numericResult = numericToNumber(value);
  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
var wrapVar = function(varName, seriesIdx) {
  return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
function formatTpl(tpl, paramsList, encode) {
  if (!isArray$1(paramsList)) {
    paramsList = [paramsList];
  }
  var seriesLen = paramsList.length;
  if (!seriesLen) {
    return "";
  }
  var $vars = paramsList[0].$vars || [];
  for (var i = 0; i < $vars.length; i++) {
    var alias = TPL_VAR_ALIAS[i];
    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
  }
  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (var k = 0; k < $vars.length; k++) {
      var val = paramsList[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
    }
  }
  return tpl;
}
function formatTplSimple(tpl, param, encode) {
  each$f(param, function(value, key) {
    tpl = tpl.replace("{" + key + "}", encode ? encodeHTML(value) : value);
  });
  return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
  var opt = isString(inOpt) ? {
    color: inOpt,
    extraCssText
  } : inOpt || {};
  var color = opt.color;
  var type = opt.type;
  extraCssText = opt.extraCssText;
  var renderMode = opt.renderMode || "html";
  if (!color) {
    return "";
  }
  if (renderMode === "html") {
    return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>';
  } else {
    var markerId = opt.markerId || "markerX";
    return {
      renderMode,
      content: "{" + markerId + "|}  ",
      style: type === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: color
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: color
      }
    };
  }
}
function formatTime(tpl, value, isUTC) {
  if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
    tpl = "MM-dd\nyyyy";
  }
  var date = parseDate(value);
  var getUTC = isUTC ? "getUTC" : "get";
  var y = date[getUTC + "FullYear"]();
  var M = date[getUTC + "Month"]() + 1;
  var d = date[getUTC + "Date"]();
  var h = date[getUTC + "Hours"]();
  var m2 = date[getUTC + "Minutes"]();
  var s = date[getUTC + "Seconds"]();
  var S = date[getUTC + "Milliseconds"]();
  tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", y % 100 + "").replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m2, 2)).replace("m", m2).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
  return tpl;
}
function convertToColorString(color, defaultColor) {
  defaultColor = defaultColor || "transparent";
  return isString(color) ? color : isObject$3(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor;
}
function windowOpen(link, target) {
  if (target === "_blank" || target === "blank") {
    var blank = window.open();
    blank.opener = null;
    blank.location.href = link;
  } else {
    window.open(link, target);
  }
}
var each$e = each$f;
var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  var x = 0;
  var y = 0;
  if (maxWidth == null) {
    maxWidth = Infinity;
  }
  if (maxHeight == null) {
    maxHeight = Infinity;
  }
  var currentLineMaxSize = 0;
  group.eachChild(function(child, idx) {
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;
    if (orient === "horizontal") {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x + moveX;
      if (nextX > maxWidth || child.newline) {
        x = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY;
      if (nextY > maxHeight || child.newline) {
        x += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }
    if (child.newline) {
      return;
    }
    child.x = x;
    child.y = y;
    child.markRedraw();
    orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
  });
}
var box = boxLayout;
curry$1(boxLayout, "vertical");
curry$1(boxLayout, "horizontal");
function getAvailableSize(positionInfo, containerRect, margin) {
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var x = parsePercent$1(positionInfo.left, containerWidth);
  var y = parsePercent$1(positionInfo.top, containerHeight);
  var x2 = parsePercent$1(positionInfo.right, containerWidth);
  var y2 = parsePercent$1(positionInfo.bottom, containerHeight);
  (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);
  (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);
  (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);
  (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);
  margin = normalizeCssArray(margin || 0);
  return {
    width: Math.max(x2 - x - margin[1] - margin[3], 0),
    height: Math.max(y2 - y - margin[0] - margin[2], 0)
  };
}
function getLayoutRect(positionInfo, containerRect, margin) {
  margin = normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent$1(positionInfo.left, containerWidth);
  var top = parsePercent$1(positionInfo.top, containerHeight);
  var right = parsePercent$1(positionInfo.right, containerWidth);
  var bottom = parsePercent$1(positionInfo.bottom, containerHeight);
  var width = parsePercent$1(positionInfo.width, containerWidth);
  var height = parsePercent$1(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect;
  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }
  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }
  if (aspect != null) {
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    }
    if (isNaN(width)) {
      width = aspect * height;
    }
    if (isNaN(height)) {
      height = width / aspect;
    }
  }
  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }
  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  }
  switch (positionInfo.left || positionInfo.right) {
    case "center":
      left = containerWidth / 2 - width / 2 - margin[3];
      break;
    case "right":
      left = containerWidth - width - horizontalMargin;
      break;
  }
  switch (positionInfo.top || positionInfo.bottom) {
    case "middle":
    case "center":
      top = containerHeight / 2 - height / 2 - margin[0];
      break;
    case "bottom":
      top = containerHeight - height - verticalMargin;
      break;
  }
  left = left || 0;
  top = top || 0;
  if (isNaN(width)) {
    width = containerWidth - horizontalMargin - left - (right || 0);
  }
  if (isNaN(height)) {
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }
  var rect = new BoundingRect$1(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
function positionElement(el, positionInfo, containerRect, margin, opt, out2) {
  var h = !opt || !opt.hv || opt.hv[0];
  var v = !opt || !opt.hv || opt.hv[1];
  var boundingMode = opt && opt.boundingMode || "all";
  out2 = out2 || el;
  out2.x = el.x;
  out2.y = el.y;
  if (!h && !v) {
    return false;
  }
  var rect;
  if (boundingMode === "raw") {
    rect = el.type === "group" ? new BoundingRect$1(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();
    if (el.needLocalTransform()) {
      var transform2 = el.getLocalTransform();
      rect = rect.clone();
      rect.applyTransform(transform2);
    }
  }
  var layoutRect = getLayoutRect(defaults({
    width: rect.width,
    height: rect.height
  }, positionInfo), containerRect, margin);
  var dx = h ? layoutRect.x - rect.x : 0;
  var dy = v ? layoutRect.y - rect.y : 0;
  if (boundingMode === "raw") {
    out2.x = dx;
    out2.y = dy;
  } else {
    out2.x += dx;
    out2.y += dy;
  }
  if (out2 === el) {
    el.markRedraw();
  }
  return true;
}
function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
function fetchLayoutMode(ins) {
  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
  return isObject$3(layoutMode) ? layoutMode : layoutMode ? {
    type: layoutMode
  } : null;
}
function mergeLayoutParam(targetOption, newOption, opt) {
  var ignoreSize = opt && opt.ignoreSize;
  !isArray$1(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge2(HV_NAMES[0], 0);
  var vResult = merge2(HV_NAMES[1], 1);
  copy2(HV_NAMES[0], targetOption, hResult);
  copy2(HV_NAMES[1], targetOption, vResult);
  function merge2(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each$e(names, function(name) {
      merged[name] = targetOption[name];
    });
    each$e(names, function(name) {
      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });
    if (ignoreSize[hvIdx]) {
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }
      return merged;
    }
    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } else if (newValueCount >= enoughParamNumber) {
      return newParams;
    } else {
      for (var i = 0; i < names.length; i++) {
        var name_1 = names[i];
        if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
          newParams[name_1] = targetOption[name_1];
          break;
        }
      }
      return newParams;
    }
  }
  function hasProp(obj, name) {
    return obj.hasOwnProperty(name);
  }
  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== "auto";
  }
  function copy2(names, target, source) {
    each$e(names, function(name) {
      target[name] = source[name];
    });
  }
}
function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
function copyLayoutParams(target, source) {
  source && target && each$e(LOCATION_PARAMS, function(name) {
    source.hasOwnProperty(name) && (target[name] = source[name]);
  });
  return target;
}
var inner$l = makeInner();
var ComponentModel = function(_super) {
  __extends(ComponentModel2, _super);
  function ComponentModel2(option, parentModel, ecModel) {
    var _this = _super.call(this, option, parentModel, ecModel) || this;
    _this.uid = getUID("ec_cpt_model");
    return _this;
  }
  ComponentModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  ComponentModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    merge(option, themeModel.get(this.mainType));
    merge(option, this.getDefaultOption());
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  ComponentModel2.prototype.mergeOption = function(option, ecModel) {
    merge(this.option, option, true);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, option, layoutMode);
    }
  };
  ComponentModel2.prototype.optionUpdated = function(newCptOption, isInit) {
  };
  ComponentModel2.prototype.getDefaultOption = function() {
    var ctor = this.constructor;
    if (!isExtendedClass(ctor)) {
      return ctor.defaultOption;
    }
    var fields = inner$l(this);
    if (!fields.defaultOption) {
      var optList = [];
      var clz = ctor;
      while (clz) {
        var opt = clz.prototype.defaultOption;
        opt && optList.push(opt);
        clz = clz.superClass;
      }
      var defaultOption2 = {};
      for (var i = optList.length - 1; i >= 0; i--) {
        defaultOption2 = merge(defaultOption2, optList[i], true);
      }
      fields.defaultOption = defaultOption2;
    }
    return fields.defaultOption;
  };
  ComponentModel2.prototype.getReferringComponents = function(mainType, opt) {
    var indexKey = mainType + "Index";
    var idKey = mainType + "Id";
    return queryReferringComponents(this.ecModel, mainType, {
      index: this.get(indexKey, true),
      id: this.get(idKey, true)
    }, opt);
  };
  ComponentModel2.prototype.getBoxLayoutParams = function() {
    var boxLayoutModel = this;
    return {
      left: boxLayoutModel.get("left"),
      top: boxLayoutModel.get("top"),
      right: boxLayoutModel.get("right"),
      bottom: boxLayoutModel.get("bottom"),
      width: boxLayoutModel.get("width"),
      height: boxLayoutModel.get("height")
    };
  };
  ComponentModel2.prototype.getZLevelKey = function() {
    return "";
  };
  ComponentModel2.prototype.setZLevel = function(zlevel) {
    this.option.zlevel = zlevel;
  };
  ComponentModel2.protoInitialize = function() {
    var proto = ComponentModel2.prototype;
    proto.type = "component";
    proto.id = "";
    proto.name = "";
    proto.mainType = "";
    proto.subType = "";
    proto.componentIndex = 0;
  }();
  return ComponentModel2;
}(Model$1);
mountExtend(ComponentModel, Model$1);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
  var deps = [];
  each$f(ComponentModel.getClassesByMainType(componentType), function(clz) {
    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
  });
  deps = map$1(deps, function(type) {
    return parseClassType(type).main;
  });
  if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) {
    deps.unshift("dataset");
  }
  return deps;
}
var ComponentModel$1 = ComponentModel;
var platform = "";
if (typeof navigator !== "undefined") {
  platform = navigator.platform || "";
}
var decalColor = "rgba(0, 0, 0, 0.2)";
var globalDefault = {
  darkMode: "auto",
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  textStyle: {
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  progressiveThreshold: 3e3,
  progressive: 400,
  hoverLayerThreshold: 3e3,
  useUTC: false
};
var VISUAL_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";
var BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
};
var innerGlobalModel = makeInner();
function resetSourceDefaulter(ecModel) {
  innerGlobalModel(ecModel).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
  var encode = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel || !coordDimensions) {
    return encode;
  }
  var encodeItemName = [];
  var encodeSeriesName = [];
  var ecModel = seriesModel.ecModel;
  var datasetMap = innerGlobalModel(ecModel).datasetMap;
  var key = datasetModel.uid + "_" + source.seriesLayoutBy;
  var baseCategoryDimIndex;
  var categoryWayValueDimStart;
  coordDimensions = coordDimensions.slice();
  each$f(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
    var coordDimInfo = isObject$3(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
      name: coordDimInfoLoose
    };
    if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
      baseCategoryDimIndex = coordDimIdx;
      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
    }
    encode[coordDimInfo.name] = [];
  });
  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
    categoryWayDim: categoryWayValueDimStart,
    valueWayDim: 0
  });
  each$f(coordDimensions, function(coordDimInfo, coordDimIdx) {
    var coordDimName = coordDimInfo.name;
    var count2 = getDataDimCountOnCoordDim(coordDimInfo);
    if (baseCategoryDimIndex == null) {
      var start2 = datasetRecord.valueWayDim;
      pushDim(encode[coordDimName], start2, count2);
      pushDim(encodeSeriesName, start2, count2);
      datasetRecord.valueWayDim += count2;
    } else if (baseCategoryDimIndex === coordDimIdx) {
      pushDim(encode[coordDimName], 0, count2);
      pushDim(encodeItemName, 0, count2);
    } else {
      var start2 = datasetRecord.categoryWayDim;
      pushDim(encode[coordDimName], start2, count2);
      pushDim(encodeSeriesName, start2, count2);
      datasetRecord.categoryWayDim += count2;
    }
  });
  function pushDim(dimIdxArr, idxFrom, idxCount) {
    for (var i = 0; i < idxCount; i++) {
      dimIdxArr.push(idxFrom + i);
    }
  }
  function getDataDimCountOnCoordDim(coordDimInfo) {
    var dimsDef = coordDimInfo.dimsDef;
    return dimsDef ? dimsDef.length : 1;
  }
  encodeItemName.length && (encode.itemName = encodeItemName);
  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
  return encode;
}
function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
  var encode = {};
  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel) {
    return encode;
  }
  var sourceFormat = source.sourceFormat;
  var dimensionsDefine = source.dimensionsDefine;
  var potentialNameDimIndex;
  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    each$f(dimensionsDefine, function(dim, idx) {
      if ((isObject$3(dim) ? dim.name : dim) === "name") {
        potentialNameDimIndex = idx;
      }
    });
  }
  var idxResult = function() {
    var idxRes0 = {};
    var idxRes1 = {};
    var guessRecords = [];
    for (var i = 0, len2 = Math.min(5, dimCount); i < len2; i++) {
      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
      guessRecords.push(guessResult);
      var isPureNumber = guessResult === BE_ORDINAL.Not;
      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
        idxRes0.v = i;
      }
      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
        idxRes0.n = i;
      }
      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
        return idxRes0;
      }
      if (!isPureNumber) {
        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
          idxRes1.v = i;
        }
        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
          idxRes1.n = i;
        }
      }
    }
    function fulfilled(idxResult2) {
      return idxResult2.v != null && idxResult2.n != null;
    }
    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
  }();
  if (idxResult) {
    encode.value = [idxResult.v];
    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
    encode.itemName = [nameDimIndex];
    encode.seriesName = [nameDimIndex];
  }
  return encode;
}
function querySeriesUpstreamDatasetModel(seriesModel) {
  var thisData = seriesModel.get("data", true);
  if (!thisData) {
    return queryReferringComponents(seriesModel.ecModel, "dataset", {
      index: seriesModel.get("datasetIndex", true),
      id: seriesModel.get("datasetId", true)
    }, SINGLE_REFERRING).models[0];
  }
}
function queryDatasetUpstreamDatasetModels(datasetModel) {
  if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
    return [];
  }
  return queryReferringComponents(datasetModel.ecModel, "dataset", {
    index: datasetModel.get("fromDatasetIndex", true),
    id: datasetModel.get("fromDatasetId", true)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(source, dimIndex) {
  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
}
function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  var result;
  var maxLoop = 5;
  if (isTypedArray(data)) {
    return BE_ORDINAL.Not;
  }
  var dimName;
  var dimType;
  if (dimensionsDefine) {
    var dimDefItem = dimensionsDefine[dimIndex];
    if (isObject$3(dimDefItem)) {
      dimName = dimDefItem.name;
      dimType = dimDefItem.type;
    } else if (isString(dimDefItem)) {
      dimName = dimDefItem;
    }
  }
  if (dimType != null) {
    return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      var sample = dataArrayRows[dimIndex];
      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
        if ((result = detectValue(sample[startIndex + i])) != null) {
          return result;
        }
      }
    } else {
      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
        var row = dataArrayRows[startIndex + i];
        if (row && (result = detectValue(row[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var dataObjectRows = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
      var item = dataObjectRows[i];
      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    var dataKeyedColumns = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    var sample = dataKeyedColumns[dimName];
    if (!sample || isTypedArray(sample)) {
      return BE_ORDINAL.Not;
    }
    for (var i = 0; i < sample.length && i < maxLoop; i++) {
      if ((result = detectValue(sample[i])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var dataOriginal = data;
    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
      var item = dataOriginal[i];
      var val = getDataItemValue(item);
      if (!isArray$1(val)) {
        return BE_ORDINAL.Not;
      }
      if ((result = detectValue(val[dimIndex])) != null) {
        return result;
      }
    }
  }
  function detectValue(val2) {
    var beStr = isString(val2);
    if (val2 != null && isFinite(val2) && val2 !== "") {
      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    } else if (beStr && val2 !== "-") {
      return BE_ORDINAL.Must;
    }
  }
  return BE_ORDINAL.Not;
}
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(mainType, creator) {
  assert(internalOptionCreatorMap.get(mainType) == null && creator);
  internalOptionCreatorMap.set(mainType, creator);
}
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
  var internalOptionCreator = internalOptionCreatorMap.get(mainType);
  if (!internalOptionCreator) {
    return newCmptOptionList;
  }
  var internalOptions = internalOptionCreator(ecModel);
  if (!internalOptions) {
    return newCmptOptionList;
  }
  return newCmptOptionList.concat(internalOptions);
}
var innerColor = makeInner();
var innerDecal = makeInner();
var PaletteMixin = function() {
  function PaletteMixin2() {
  }
  PaletteMixin2.prototype.getColorFromPalette = function(name, scope, requestNum) {
    var defaultPalette = normalizeToArray(this.get("color", true));
    var layeredPalette = this.get("colorLayer", true);
    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
  };
  PaletteMixin2.prototype.clearColorPalette = function() {
    clearPalette(this, innerColor);
  };
  return PaletteMixin2;
}();
function getDecalFromPalette(ecModel, name, scope, requestNum) {
  var defaultDecals = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum);
}
function getNearestPalette(palettes, requestColorNum) {
  var paletteNum = palettes.length;
  for (var i = 0; i < paletteNum; i++) {
    if (palettes[i].length > requestColorNum) {
      return palettes[i];
    }
  }
  return palettes[paletteNum - 1];
}
function getFromPalette(that, inner2, defaultPalette, layeredPalette, name, scope, requestNum) {
  scope = scope || that;
  var scopeFields = inner2(scope);
  var paletteIdx = scopeFields.paletteIdx || 0;
  var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
  if (paletteNameMap.hasOwnProperty(name)) {
    return paletteNameMap[name];
  }
  var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
  palette = palette || defaultPalette;
  if (!palette || !palette.length) {
    return;
  }
  var pickedPaletteItem = palette[paletteIdx];
  if (name) {
    paletteNameMap[name] = pickedPaletteItem;
  }
  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
  return pickedPaletteItem;
}
function clearPalette(that, inner2) {
  inner2(that).paletteIdx = 0;
  inner2(that).paletteNameMap = {};
}
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\0_ec_inner";
var OPTION_INNER_VALUE = 1;
var GlobalModel = function(_super) {
  __extends(GlobalModel2, _super);
  function GlobalModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GlobalModel2.prototype.init = function(option, parentModel, ecModel, theme2, locale, optionManager) {
    theme2 = theme2 || {};
    this.option = null;
    this._theme = new Model$1(theme2);
    this._locale = new Model$1(locale);
    this._optionManager = optionManager;
  };
  GlobalModel2.prototype.setOption = function(option, opts, optionPreprocessorFuncs2) {
    var innerOpt = normalizeSetOptionInput(opts);
    this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
    this._resetOption(null, innerOpt);
  };
  GlobalModel2.prototype.resetOption = function(type, opt) {
    return this._resetOption(type, normalizeSetOptionInput(opt));
  };
  GlobalModel2.prototype._resetOption = function(type, opt) {
    var optionChanged = false;
    var optionManager = this._optionManager;
    if (!type || type === "recreate") {
      var baseOption = optionManager.mountOption(type === "recreate");
      if (!this.option || type === "recreate") {
        initBase(this, baseOption);
      } else {
        this.restoreData();
        this._mergeOption(baseOption, opt);
      }
      optionChanged = true;
    }
    if (type === "timeline" || type === "media") {
      this.restoreData();
    }
    if (!type || type === "recreate" || type === "timeline") {
      var timelineOption = optionManager.getTimelineOption(this);
      if (timelineOption) {
        optionChanged = true;
        this._mergeOption(timelineOption, opt);
      }
    }
    if (!type || type === "recreate" || type === "media") {
      var mediaOptions = optionManager.getMediaOption(this);
      if (mediaOptions.length) {
        each$f(mediaOptions, function(mediaOption) {
          optionChanged = true;
          this._mergeOption(mediaOption, opt);
        }, this);
      }
    }
    return optionChanged;
  };
  GlobalModel2.prototype.mergeOption = function(option) {
    this._mergeOption(option, null);
  };
  GlobalModel2.prototype._mergeOption = function(newOption, opt) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var componentsCount = this._componentsCount;
    var newCmptTypes = [];
    var newCmptTypeMap = createHashMap();
    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
    resetSourceDefaulter(this);
    each$f(newOption, function(componentOption, mainType) {
      if (componentOption == null) {
        return;
      }
      if (!ComponentModel$1.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? clone$4(componentOption) : merge(option[mainType], componentOption, true);
      } else if (mainType) {
        newCmptTypes.push(mainType);
        newCmptTypeMap.set(mainType, true);
      }
    });
    if (replaceMergeMainTypeMap) {
      replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
        if (ComponentModel$1.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
          newCmptTypes.push(mainTypeInReplaceMerge);
          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
        }
      });
    }
    ComponentModel$1.topologicalTravel(newCmptTypes, ComponentModel$1.getAllClassMainTypes(), visitComponent, this);
    function visitComponent(mainType) {
      var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
      var oldCmptList = componentsMap.get(mainType);
      var mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
      var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
      setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel$1);
      option[mainType] = null;
      componentsMap.set(mainType, null);
      componentsCount.set(mainType, 0);
      var optionsByMainType = [];
      var cmptsByMainType = [];
      var cmptsCountByMainType = 0;
      var tooltipExists;
      each$f(mappingResult, function(resultItem, index) {
        var componentModel = resultItem.existing;
        var newCmptOption = resultItem.newOption;
        if (!newCmptOption) {
          if (componentModel) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          }
        } else {
          var isSeriesType = mainType === "series";
          var ComponentModelClass = ComponentModel$1.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType);
          if (!ComponentModelClass) {
            return;
          }
          if (mainType === "tooltip") {
            if (tooltipExists) {
              return;
            }
            tooltipExists = true;
          }
          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCmptOption, this);
            componentModel.optionUpdated(newCmptOption, false);
          } else {
            var extraOpt = extend$1({
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
            extend$1(componentModel, extraOpt);
            if (resultItem.brandNew) {
              componentModel.__requireNewView = true;
            }
            componentModel.init(newCmptOption, this, this);
            componentModel.optionUpdated(null, true);
          }
        }
        if (componentModel) {
          optionsByMainType.push(componentModel.option);
          cmptsByMainType.push(componentModel);
          cmptsCountByMainType++;
        } else {
          optionsByMainType.push(void 0);
          cmptsByMainType.push(void 0);
        }
      }, this);
      option[mainType] = optionsByMainType;
      componentsMap.set(mainType, cmptsByMainType);
      componentsCount.set(mainType, cmptsCountByMainType);
      if (mainType === "series") {
        reCreateSeriesIndices(this);
      }
    }
    if (!this._seriesIndices) {
      reCreateSeriesIndices(this);
    }
  };
  GlobalModel2.prototype.getOption = function() {
    var option = clone$4(this.option);
    each$f(option, function(optInMainType, mainType) {
      if (ComponentModel$1.hasClass(mainType)) {
        var opts = normalizeToArray(optInMainType);
        var realLen = opts.length;
        var metNonInner = false;
        for (var i = realLen - 1; i >= 0; i--) {
          if (opts[i] && !isComponentIdInternal(opts[i])) {
            metNonInner = true;
          } else {
            opts[i] = null;
            !metNonInner && realLen--;
          }
        }
        opts.length = realLen;
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  };
  GlobalModel2.prototype.getTheme = function() {
    return this._theme;
  };
  GlobalModel2.prototype.getLocaleModel = function() {
    return this._locale;
  };
  GlobalModel2.prototype.setUpdatePayload = function(payload) {
    this._payload = payload;
  };
  GlobalModel2.prototype.getUpdatePayload = function() {
    return this._payload;
  };
  GlobalModel2.prototype.getComponent = function(mainType, idx) {
    var list = this._componentsMap.get(mainType);
    if (list) {
      var cmpt = list[idx || 0];
      if (cmpt) {
        return cmpt;
      } else if (idx == null) {
        for (var i = 0; i < list.length; i++) {
          if (list[i]) {
            return list[i];
          }
        }
      }
    }
  };
  GlobalModel2.prototype.queryComponents = function(condition) {
    var mainType = condition.mainType;
    if (!mainType) {
      return [];
    }
    var index = condition.index;
    var id = condition.id;
    var name = condition.name;
    var cmpts = this._componentsMap.get(mainType);
    if (!cmpts || !cmpts.length) {
      return [];
    }
    var result;
    if (index != null) {
      result = [];
      each$f(normalizeToArray(index), function(idx) {
        cmpts[idx] && result.push(cmpts[idx]);
      });
    } else if (id != null) {
      result = queryByIdOrName("id", id, cmpts);
    } else if (name != null) {
      result = queryByIdOrName("name", name, cmpts);
    } else {
      result = filter(cmpts, function(cmpt) {
        return !!cmpt;
      });
    }
    return filterBySubType(result, condition);
  };
  GlobalModel2.prototype.findComponents = function(condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), function(cmpt) {
      return !!cmpt;
    });
    return doFilter(filterBySubType(result, condition));
    function getQueryCond(q) {
      var indexAttr = mainType + "Index";
      var idAttr = mainType + "Id";
      var nameAttr = mainType + "Name";
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType,
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }
    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  };
  GlobalModel2.prototype.eachComponent = function(mainType, cb, context) {
    var componentsMap = this._componentsMap;
    if (isFunction$1(mainType)) {
      var ctxForAll_1 = cb;
      var cbForAll_1 = mainType;
      componentsMap.each(function(cmpts2, componentType) {
        for (var i2 = 0; cmpts2 && i2 < cmpts2.length; i2++) {
          var cmpt2 = cmpts2[i2];
          cmpt2 && cbForAll_1.call(ctxForAll_1, componentType, cmpt2, cmpt2.componentIndex);
        }
      });
    } else {
      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject$3(mainType) ? this.findComponents(mainType) : null;
      for (var i = 0; cmpts && i < cmpts.length; i++) {
        var cmpt = cmpts[i];
        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
      }
    }
  };
  GlobalModel2.prototype.getSeriesByName = function(name) {
    var nameStr = convertOptionIdName(name, null);
    return filter(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
    });
  };
  GlobalModel2.prototype.getSeriesByIndex = function(seriesIndex) {
    return this._componentsMap.get("series")[seriesIndex];
  };
  GlobalModel2.prototype.getSeriesByType = function(subType) {
    return filter(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries && oneSeries.subType === subType;
    });
  };
  GlobalModel2.prototype.getSeries = function() {
    return filter(this._componentsMap.get("series"), function(oneSeries) {
      return !!oneSeries;
    });
  };
  GlobalModel2.prototype.getSeriesCount = function() {
    return this._componentsCount.get("series");
  };
  GlobalModel2.prototype.eachSeries = function(cb, context) {
    assertSeriesInitialized(this);
    each$f(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      cb.call(context, series, rawSeriesIndex);
    }, this);
  };
  GlobalModel2.prototype.eachRawSeries = function(cb, context) {
    each$f(this._componentsMap.get("series"), function(series) {
      series && cb.call(context, series, series.componentIndex);
    });
  };
  GlobalModel2.prototype.eachSeriesByType = function(subType, cb, context) {
    assertSeriesInitialized(this);
    each$f(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  };
  GlobalModel2.prototype.eachRawSeriesByType = function(subType, cb, context) {
    return each$f(this.getSeriesByType(subType), cb, context);
  };
  GlobalModel2.prototype.isSeriesFiltered = function(seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  };
  GlobalModel2.prototype.getCurrentSeriesIndices = function() {
    return (this._seriesIndices || []).slice();
  };
  GlobalModel2.prototype.filterSeries = function(cb, context) {
    assertSeriesInitialized(this);
    var newSeriesIndices = [];
    each$f(this._seriesIndices, function(seriesRawIdx) {
      var series = this._componentsMap.get("series")[seriesRawIdx];
      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
    }, this);
    this._seriesIndices = newSeriesIndices;
    this._seriesIndicesMap = createHashMap(newSeriesIndices);
  };
  GlobalModel2.prototype.restoreData = function(payload) {
    reCreateSeriesIndices(this);
    var componentsMap = this._componentsMap;
    var componentTypes = [];
    componentsMap.each(function(components, componentType) {
      if (ComponentModel$1.hasClass(componentType)) {
        componentTypes.push(componentType);
      }
    });
    ComponentModel$1.topologicalTravel(componentTypes, ComponentModel$1.getAllClassMainTypes(), function(componentType) {
      each$f(componentsMap.get(componentType), function(component) {
        if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
          component.restoreData();
        }
      });
    });
  };
  GlobalModel2.internalField = function() {
    reCreateSeriesIndices = function(ecModel) {
      var seriesIndices = ecModel._seriesIndices = [];
      each$f(ecModel._componentsMap.get("series"), function(series) {
        series && seriesIndices.push(series.componentIndex);
      });
      ecModel._seriesIndicesMap = createHashMap(seriesIndices);
    };
    assertSeriesInitialized = function(ecModel) {
    };
    initBase = function(ecModel, baseOption) {
      ecModel.option = {};
      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
      ecModel._componentsMap = createHashMap({
        series: []
      });
      ecModel._componentsCount = createHashMap();
      var airaOption = baseOption.aria;
      if (isObject$3(airaOption) && airaOption.enabled == null) {
        airaOption.enabled = true;
      }
      mergeTheme(baseOption, ecModel._theme.option);
      merge(baseOption, globalDefault, false);
      ecModel._mergeOption(baseOption, null);
    };
  }();
  return GlobalModel2;
}(Model$1);
function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    var index = payload.seriesIndex;
    var id = payload.seriesId;
    var name_1 = payload.seriesName;
    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
  }
}
function mergeTheme(option, theme2) {
  var notMergeColorLayer = option.color && !option.colorLayer;
  each$f(theme2, function(themeItem, name) {
    if (name === "colorLayer" && notMergeColorLayer) {
      return;
    }
    if (!ComponentModel$1.hasClass(name)) {
      if (typeof themeItem === "object") {
        option[name] = !option[name] ? clone$4(themeItem) : merge(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}
function queryByIdOrName(attr, idOrName, cmpts) {
  if (isArray$1(idOrName)) {
    var keyMap_1 = createHashMap();
    each$f(idOrName, function(idOrNameItem) {
      if (idOrNameItem != null) {
        var idName = convertOptionIdName(idOrNameItem, null);
        idName != null && keyMap_1.set(idOrNameItem, true);
      }
    });
    return filter(cmpts, function(cmpt) {
      return cmpt && keyMap_1.get(cmpt[attr]);
    });
  } else {
    var idName_1 = convertOptionIdName(idOrName, null);
    return filter(cmpts, function(cmpt) {
      return cmpt && idName_1 != null && cmpt[attr] === idName_1;
    });
  }
}
function filterBySubType(components, condition) {
  return condition.hasOwnProperty("subType") ? filter(components, function(cmpt) {
    return cmpt && cmpt.subType === condition.subType;
  }) : components;
}
function normalizeSetOptionInput(opts) {
  var replaceMergeMainTypeMap = createHashMap();
  opts && each$f(normalizeToArray(opts.replaceMerge), function(mainType) {
    replaceMergeMainTypeMap.set(mainType, true);
  });
  return {
    replaceMergeMainTypeMap
  };
}
mixin(GlobalModel, PaletteMixin);
var GlobalModel$1 = GlobalModel;
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  "getOption",
  "getId",
  "updateLabelLayout"
];
var ExtensionAPI = function() {
  function ExtensionAPI2(ecInstance) {
    each$f(availableMethods, function(methodName) {
      this[methodName] = bind$1(ecInstance[methodName], ecInstance);
    }, this);
  }
  return ExtensionAPI2;
}();
var ExtensionAPI$1 = ExtensionAPI;
var coordinateSystemCreators = {};
var CoordinateSystemManager = function() {
  function CoordinateSystemManager2() {
    this._coordinateSystems = [];
  }
  CoordinateSystemManager2.prototype.create = function(ecModel, api) {
    var coordinateSystems = [];
    each$f(coordinateSystemCreators, function(creater, type) {
      var list = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  };
  CoordinateSystemManager2.prototype.update = function(ecModel, api) {
    each$f(this._coordinateSystems, function(coordSys) {
      coordSys.update && coordSys.update(ecModel, api);
    });
  };
  CoordinateSystemManager2.prototype.getCoordinateSystems = function() {
    return this._coordinateSystems.slice();
  };
  CoordinateSystemManager2.register = function(type, creator) {
    coordinateSystemCreators[type] = creator;
  };
  CoordinateSystemManager2.get = function(type) {
    return coordinateSystemCreators[type];
  };
  return CoordinateSystemManager2;
}();
var CoordinateSystem = CoordinateSystemManager;
var QUERY_REG = /^(min|max)?(.+)$/;
var OptionManager = function() {
  function OptionManager2(api) {
    this._timelineOptions = [];
    this._mediaList = [];
    this._currentMediaIndices = [];
    this._api = api;
  }
  OptionManager2.prototype.setOption = function(rawOption, optionPreprocessorFuncs2, opt) {
    if (rawOption) {
      each$f(normalizeToArray(rawOption.series), function(series) {
        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
      });
      each$f(normalizeToArray(rawOption.dataset), function(dataset) {
        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
      });
    }
    rawOption = clone$4(rawOption);
    var optionBackup = this._optionBackup;
    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
    this._newBaseOption = newParsedOption.baseOption;
    if (optionBackup) {
      if (newParsedOption.timelineOptions.length) {
        optionBackup.timelineOptions = newParsedOption.timelineOptions;
      }
      if (newParsedOption.mediaList.length) {
        optionBackup.mediaList = newParsedOption.mediaList;
      }
      if (newParsedOption.mediaDefault) {
        optionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  };
  OptionManager2.prototype.mountOption = function(isRecreate) {
    var optionBackup = this._optionBackup;
    this._timelineOptions = optionBackup.timelineOptions;
    this._mediaList = optionBackup.mediaList;
    this._mediaDefault = optionBackup.mediaDefault;
    this._currentMediaIndices = [];
    return clone$4(isRecreate ? optionBackup.baseOption : this._newBaseOption);
  };
  OptionManager2.prototype.getTimelineOption = function(ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;
    if (timelineOptions.length) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel) {
        option = clone$4(timelineOptions[timelineModel.getCurrentIndex()]);
      }
    }
    return option;
  };
  OptionManager2.prototype.getMediaOption = function(ecModel) {
    var ecWidth = this._api.getWidth();
    var ecHeight = this._api.getHeight();
    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = [];
    if (!mediaList.length && !mediaDefault) {
      return result;
    }
    for (var i = 0, len2 = mediaList.length; i < len2; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    }
    if (!indices.length && mediaDefault) {
      indices = [-1];
    }
    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map$1(indices, function(index) {
        return clone$4(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    }
    this._currentMediaIndices = indices;
    return result;
  };
  return OptionManager2;
}();
function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
  var mediaList = [];
  var mediaDefault;
  var baseOption;
  var declaredBaseOption = rawOption.baseOption;
  var timelineOnRoot = rawOption.timeline;
  var timelineOptionsOnRoot = rawOption.options;
  var mediaOnRoot = rawOption.media;
  var hasMedia = !!rawOption.media;
  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
  if (declaredBaseOption) {
    baseOption = declaredBaseOption;
    if (!baseOption.timeline) {
      baseOption.timeline = timelineOnRoot;
    }
  } else {
    if (hasTimeline || hasMedia) {
      rawOption.options = rawOption.media = null;
    }
    baseOption = rawOption;
  }
  if (hasMedia) {
    if (isArray$1(mediaOnRoot)) {
      each$f(mediaOnRoot, function(singleMedia) {
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            mediaDefault = singleMedia;
          }
        }
      });
    }
  }
  doPreprocess(baseOption);
  each$f(timelineOptionsOnRoot, function(option) {
    return doPreprocess(option);
  });
  each$f(mediaList, function(media) {
    return doPreprocess(media.option);
  });
  function doPreprocess(option) {
    each$f(optionPreprocessorFuncs2, function(preProcess) {
      preProcess(option, isNew);
    });
  }
  return {
    baseOption,
    timelineOptions: timelineOptionsOnRoot || [],
    mediaDefault,
    mediaList
  };
}
function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight
  };
  var applicatable = true;
  each$f(query, function(value, attr) {
    var matched = attr.match(QUERY_REG);
    if (!matched || !matched[1] || !matched[2]) {
      return;
    }
    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();
    if (!compare(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}
function compare(real, expect, operator) {
  if (operator === "min") {
    return real >= expect;
  } else if (operator === "max") {
    return real <= expect;
  } else {
    return real === expect;
  }
}
function indicesEquals(indices1, indices2) {
  return indices1.join(",") === indices2.join(",");
}
var OptionManager$1 = OptionManager;
var each$d = each$f;
var isObject$2 = isObject$3;
var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function compatEC2ItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;
  if (!itemStyleOpt) {
    return;
  }
  for (var i = 0, len2 = POSSIBLE_STYLES.length; i < len2; i++) {
    var styleName = POSSIBLE_STYLES[i];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;
    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }
      normalItemStyleOpt[styleName] = null;
    }
    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }
      emphasisItemStyleOpt[styleName] = null;
    }
  }
}
function convertNormalEmphasis$1(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    var normalOpt = opt[optType].normal;
    var emphasisOpt = opt[optType].emphasis;
    if (normalOpt) {
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }
    if (emphasisOpt) {
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
      if (emphasisOpt.focus) {
        opt.emphasis.focus = emphasisOpt.focus;
      }
      if (emphasisOpt.blurScope) {
        opt.emphasis.blurScope = emphasisOpt.blurScope;
      }
    }
  }
}
function removeEC3NormalStatus(opt) {
  convertNormalEmphasis$1(opt, "itemStyle");
  convertNormalEmphasis$1(opt, "lineStyle");
  convertNormalEmphasis$1(opt, "areaStyle");
  convertNormalEmphasis$1(opt, "label");
  convertNormalEmphasis$1(opt, "labelLine");
  convertNormalEmphasis$1(opt, "upperLabel");
  convertNormalEmphasis$1(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
  var labelOptSingle = isObject$2(opt) && opt[propName];
  var textStyle = isObject$2(labelOptSingle) && labelOptSingle.textStyle;
  if (textStyle) {
    for (var i = 0, len2 = TEXT_STYLE_OPTIONS.length; i < len2; i++) {
      var textPropName = TEXT_STYLE_OPTIONS[i];
      if (textStyle.hasOwnProperty(textPropName)) {
        labelOptSingle[textPropName] = textStyle[textPropName];
      }
    }
  }
}
function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, "label");
    opt.emphasis && compatTextStyle(opt.emphasis, "label");
  }
}
function processSeries(seriesOpt) {
  if (!isObject$2(seriesOpt)) {
    return;
  }
  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, "label");
  compatTextStyle(seriesOpt, "upperLabel");
  compatTextStyle(seriesOpt, "edgeLabel");
  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, "label");
    compatTextStyle(seriesOpt.emphasis, "upperLabel");
    compatTextStyle(seriesOpt.emphasis, "edgeLabel");
  }
  var markPoint = seriesOpt.markPoint;
  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }
  var markLine = seriesOpt.markLine;
  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }
  var markArea = seriesOpt.markArea;
  if (markArea) {
    compatEC3CommonStyles(markArea);
  }
  var data = seriesOpt.data;
  if (seriesOpt.type === "graph") {
    data = data || seriesOpt.nodes;
    var edgeData = seriesOpt.links || seriesOpt.edges;
    if (edgeData && !isTypedArray(edgeData)) {
      for (var i = 0; i < edgeData.length; i++) {
        compatEC3CommonStyles(edgeData[i]);
      }
    }
    each$f(seriesOpt.categories, function(opt) {
      removeEC3NormalStatus(opt);
    });
  }
  if (data && !isTypedArray(data)) {
    for (var i = 0; i < data.length; i++) {
      compatEC3CommonStyles(data[i]);
    }
  }
  markPoint = seriesOpt.markPoint;
  if (markPoint && markPoint.data) {
    var mpData = markPoint.data;
    for (var i = 0; i < mpData.length; i++) {
      compatEC3CommonStyles(mpData[i]);
    }
  }
  markLine = seriesOpt.markLine;
  if (markLine && markLine.data) {
    var mlData = markLine.data;
    for (var i = 0; i < mlData.length; i++) {
      if (isArray$1(mlData[i])) {
        compatEC3CommonStyles(mlData[i][0]);
        compatEC3CommonStyles(mlData[i][1]);
      } else {
        compatEC3CommonStyles(mlData[i]);
      }
    }
  }
  if (seriesOpt.type === "gauge") {
    compatTextStyle(seriesOpt, "axisLabel");
    compatTextStyle(seriesOpt, "title");
    compatTextStyle(seriesOpt, "detail");
  } else if (seriesOpt.type === "treemap") {
    convertNormalEmphasis$1(seriesOpt.breadcrumb, "itemStyle");
    each$f(seriesOpt.levels, function(opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === "tree") {
    removeEC3NormalStatus(seriesOpt.leaves);
  }
}
function toArr(o) {
  return isArray$1(o) ? o : o ? [o] : [];
}
function toObj(o) {
  return (isArray$1(o) ? o[0] : o) || {};
}
function globalCompatStyle(option, isTheme) {
  each$d(toArr(option.series), function(seriesOpt) {
    isObject$2(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
  each$d(axes, function(axisName) {
    each$d(toArr(option[axisName]), function(axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, "axisLabel");
        compatTextStyle(axisOpt.axisPointer, "label");
      }
    });
  });
  each$d(toArr(option.parallel), function(parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, "axisLabel");
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
  });
  each$d(toArr(option.calendar), function(calendarOpt) {
    convertNormalEmphasis$1(calendarOpt, "itemStyle");
    compatTextStyle(calendarOpt, "dayLabel");
    compatTextStyle(calendarOpt, "monthLabel");
    compatTextStyle(calendarOpt, "yearLabel");
  });
  each$d(toArr(option.radar), function(radarOpt) {
    compatTextStyle(radarOpt, "name");
    if (radarOpt.name && radarOpt.axisName == null) {
      radarOpt.axisName = radarOpt.name;
      delete radarOpt.name;
    }
    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
      radarOpt.axisNameGap = radarOpt.nameGap;
      delete radarOpt.nameGap;
    }
  });
  each$d(toArr(option.geo), function(geoOpt) {
    if (isObject$2(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each$d(toArr(geoOpt.regions), function(regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each$d(toArr(option.timeline), function(timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis$1(timelineOpt, "label");
    convertNormalEmphasis$1(timelineOpt, "itemStyle");
    convertNormalEmphasis$1(timelineOpt, "controlStyle", true);
    var data = timelineOpt.data;
    isArray$1(data) && each$f(data, function(item) {
      if (isObject$3(item)) {
        convertNormalEmphasis$1(item, "label");
        convertNormalEmphasis$1(item, "itemStyle");
      }
    });
  });
  each$d(toArr(option.toolbox), function(toolboxOpt) {
    convertNormalEmphasis$1(toolboxOpt, "iconStyle");
    each$d(toolboxOpt.feature, function(featureOpt) {
      convertNormalEmphasis$1(featureOpt, "iconStyle");
    });
  });
  compatTextStyle(toObj(option.axisPointer), "label");
  compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}
function get$1(opt, path) {
  var pathArr = path.split(",");
  var obj = opt;
  for (var i = 0; i < pathArr.length; i++) {
    obj = obj && obj[pathArr[i]];
    if (obj == null) {
      break;
    }
  }
  return obj;
}
function set(opt, path, val, overwrite) {
  var pathArr = path.split(",");
  var obj = opt;
  var key;
  var i = 0;
  for (; i < pathArr.length - 1; i++) {
    key = pathArr[i];
    if (obj[key] == null) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  if (overwrite || obj[pathArr[i]] == null) {
    obj[pathArr[i]] = val;
  }
}
function compatLayoutProperties(option) {
  option && each$f(LAYOUT_PROPERTIES, function(prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}
var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
var BAR_ITEM_STYLE_MAP = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function compatBarItemStyle(option) {
  var itemStyle = option && option.itemStyle;
  if (itemStyle) {
    for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
      var oldName = BAR_ITEM_STYLE_MAP[i][1];
      var newName = BAR_ITEM_STYLE_MAP[i][0];
      if (itemStyle[oldName] != null) {
        itemStyle[newName] = itemStyle[oldName];
      }
    }
  }
}
function compatPieLabel(option) {
  if (!option) {
    return;
  }
  if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
    option.edgeDistance = option.margin;
  }
}
function compatSunburstState(option) {
  if (!option) {
    return;
  }
  if (option.downplay && !option.blur) {
    option.blur = option.downplay;
  }
}
function compatGraphFocus(option) {
  if (!option) {
    return;
  }
  if (option.focusNodeAdjacency != null) {
    option.emphasis = option.emphasis || {};
    if (option.emphasis.focus == null) {
      option.emphasis.focus = "adjacency";
    }
  }
}
function traverseTree(data, cb) {
  if (data) {
    for (var i = 0; i < data.length; i++) {
      cb(data[i]);
      data[i] && traverseTree(data[i].children, cb);
    }
  }
}
function globalBackwardCompat(option, isTheme) {
  globalCompatStyle(option, isTheme);
  option.series = normalizeToArray(option.series);
  each$f(option.series, function(seriesOpt) {
    if (!isObject$3(seriesOpt)) {
      return;
    }
    var seriesType2 = seriesOpt.type;
    if (seriesType2 === "line") {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;
      }
    } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
      }
      compatPieLabel(seriesOpt.label);
      var data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          compatPieLabel(data[i]);
        }
      }
      if (seriesOpt.hoverOffset != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis.scaleSize = null) {
          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
        }
      }
    } else if (seriesType2 === "gauge") {
      var pointerColor = get$1(seriesOpt, "pointer.color");
      pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
    } else if (seriesType2 === "bar") {
      compatBarItemStyle(seriesOpt);
      compatBarItemStyle(seriesOpt.backgroundStyle);
      compatBarItemStyle(seriesOpt.emphasis);
      var data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          if (typeof data[i] === "object") {
            compatBarItemStyle(data[i]);
            compatBarItemStyle(data[i] && data[i].emphasis);
          }
        }
      }
    } else if (seriesType2 === "sunburst") {
      var highlightPolicy = seriesOpt.highlightPolicy;
      if (highlightPolicy) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (!seriesOpt.emphasis.focus) {
          seriesOpt.emphasis.focus = highlightPolicy;
        }
      }
      compatSunburstState(seriesOpt);
      traverseTree(seriesOpt.data, compatSunburstState);
    } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
      compatGraphFocus(seriesOpt);
    } else if (seriesType2 === "map") {
      if (seriesOpt.mapType && !seriesOpt.map) {
        seriesOpt.map = seriesOpt.mapType;
      }
      if (seriesOpt.mapLocation) {
        defaults(seriesOpt, seriesOpt.mapLocation);
      }
    }
    if (seriesOpt.hoverAnimation != null) {
      seriesOpt.emphasis = seriesOpt.emphasis || {};
      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
      }
    }
    compatLayoutProperties(seriesOpt);
  });
  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }
  each$f(COMPATITABLE_COMPONENTS, function(componentName) {
    var options = option[componentName];
    if (options) {
      if (!isArray$1(options)) {
        options = [options];
      }
      each$f(options, function(option2) {
        compatLayoutProperties(option2);
      });
    }
  });
}
function dataStack$1(ecModel) {
  var stackInfoMap = createHashMap();
  ecModel.eachSeries(function(seriesModel) {
    var stack = seriesModel.get("stack");
    if (stack) {
      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      var data = seriesModel.getData();
      var stackInfo = {
        stackResultDimension: data.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
        stackedDimension: data.getCalculationInfo("stackedDimension"),
        stackedByDimension: data.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
        data,
        seriesModel
      };
      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }
      stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}
function calculateStack(stackInfoList) {
  each$f(stackInfoList, function(targetStackInfo, idxInStack) {
    var resultVal = [];
    var resultNaN = [NaN, NaN];
    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    var targetData = targetStackInfo.data;
    var isStackedByIndex = targetStackInfo.isStackedByIndex;
    targetData.modify(dims, function(v0, v12, dataIndex) {
      var sum2 = targetData.get(targetStackInfo.stackedDimension, dataIndex);
      if (isNaN(sum2)) {
        return resultNaN;
      }
      var byValue;
      var stackedDataRawIndex;
      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      }
      var stackedOver = NaN;
      for (var j = idxInStack - 1; j >= 0; j--) {
        var stackInfo = stackInfoList[j];
        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }
        if (stackedDataRawIndex >= 0) {
          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
          if (sum2 >= 0 && val > 0 || sum2 <= 0 && val < 0) {
            sum2 = addSafe(sum2, val);
            stackedOver = val;
            break;
          }
        }
      }
      resultVal[0] = sum2;
      resultVal[1] = stackedOver;
      return resultVal;
    });
  });
}
var SourceImpl = function() {
  function SourceImpl2(fields) {
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
    this.metaRawOption = fields.metaRawOption;
    var dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
    if (dimensionsDefine) {
      for (var i = 0; i < dimensionsDefine.length; i++) {
        var dim = dimensionsDefine[i];
        if (dim.type == null) {
          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
            dim.type = "ordinal";
          }
        }
      }
    }
  }
  return SourceImpl2;
}();
function isSourceInstance(val) {
  return val instanceof SourceImpl;
}
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
  var source = new SourceImpl({
    data: sourceData,
    sourceFormat,
    seriesLayoutBy,
    dimensionsDefine: determined.dimensionsDefine,
    startIndex: determined.startIndex,
    dimensionsDetectedCount: determined.dimensionsDetectedCount,
    metaRawOption: clone$4(thisMetaRawOption)
  });
  return source;
}
function createSourceFromSeriesDataOption(data) {
  return new SourceImpl({
    data,
    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(source) {
  return new SourceImpl({
    data: source.data,
    sourceFormat: source.sourceFormat,
    seriesLayoutBy: source.seriesLayoutBy,
    dimensionsDefine: clone$4(source.dimensionsDefine),
    startIndex: source.startIndex,
    dimensionsDetectedCount: source.dimensionsDetectedCount
  });
}
function detectSourceFormat(data) {
  var sourceFormat = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray(data)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray$1(data)) {
    if (data.length === 0) {
      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
    }
    for (var i = 0, len2 = data.length; i < len2; i++) {
      var item = data[i];
      if (item == null) {
        continue;
      } else if (isArray$1(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject$3(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject$3(data)) {
    for (var key in data) {
      if (hasOwn(data, key) && isArrayLike(data[key])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  }
  return sourceFormat;
}
function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
  var dimensionsDetectedCount;
  var startIndex;
  if (!data) {
    return {
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      startIndex,
      dimensionsDetectedCount
    };
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var dataArrayRows = data;
    if (sourceHeader === "auto" || sourceHeader == null) {
      arrayRowsTravelFirst(function(val) {
        if (val != null && val !== "-") {
          if (isString(val)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        }
      }, seriesLayoutBy, dataArrayRows, 10);
    } else {
      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
    }
    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function(val, index) {
        dimensionsDefine[index] = val != null ? val + "" : "";
      }, seriesLayoutBy, dataArrayRows, Infinity);
    }
    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data);
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      each$f(data, function(colArr, key) {
        dimensionsDefine.push(key);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var value0 = getDataItemValue(data[0]);
    dimensionsDetectedCount = isArray$1(value0) && value0.length || 1;
  } else
    ;
  return {
    startIndex,
    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
    dimensionsDetectedCount
  };
}
function objectRowsCollectDimensions(data) {
  var firstIndex = 0;
  var obj;
  while (firstIndex < data.length && !(obj = data[firstIndex++])) {
  }
  if (obj) {
    var dimensions_1 = [];
    each$f(obj, function(value, key) {
      dimensions_1.push(key);
    });
    return dimensions_1;
  }
}
function normalizeDimensionsOption(dimensionsDefine) {
  if (!dimensionsDefine) {
    return;
  }
  var nameMap = createHashMap();
  return map$1(dimensionsDefine, function(rawItem, index) {
    rawItem = isObject$3(rawItem) ? rawItem : {
      name: rawItem
    };
    var item = {
      name: rawItem.name,
      displayName: rawItem.displayName,
      type: rawItem.type
    };
    if (item.name == null) {
      return item;
    }
    item.name += "";
    if (item.displayName == null) {
      item.displayName = item.name;
    }
    var exist = nameMap.get(item.name);
    if (!exist) {
      nameMap.set(item.name, {
        count: 1
      });
    } else {
      item.name += "-" + exist.count++;
    }
    return item;
  });
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (var i = 0; i < data.length && i < maxLoop; i++) {
      cb(data[i] ? data[i][0] : null, i);
    }
  } else {
    var value0 = data[0] || [];
    for (var i = 0; i < value0.length && i < maxLoop; i++) {
      cb(value0[i], i);
    }
  }
}
function shouldRetrieveDataByName(source) {
  var sourceFormat = source.sourceFormat;
  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}
var _a, _b, _c;
var providerMethods;
var mountMethods;
var DefaultDataProvider = function() {
  function DefaultDataProvider2(sourceParam, dimSize) {
    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
    this._source = source;
    var data = this._data = source.data;
    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data;
    }
    mountMethods(this, data, source);
  }
  DefaultDataProvider2.prototype.getSource = function() {
    return this._source;
  };
  DefaultDataProvider2.prototype.count = function() {
    return 0;
  };
  DefaultDataProvider2.prototype.getItem = function(idx, out2) {
    return;
  };
  DefaultDataProvider2.prototype.appendData = function(newData) {
  };
  DefaultDataProvider2.prototype.clean = function() {
  };
  DefaultDataProvider2.protoInitialize = function() {
    var proto = DefaultDataProvider2.prototype;
    proto.pure = false;
    proto.persistent = true;
  }();
  DefaultDataProvider2.internalField = function() {
    var _a2;
    mountMethods = function(provider, data, source) {
      var sourceFormat = source.sourceFormat;
      var seriesLayoutBy = source.seriesLayoutBy;
      var startIndex = source.startIndex;
      var dimsDef = source.dimensionsDefine;
      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
      extend$1(provider, methods);
      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        provider.getItem = getItemForTypedArray;
        provider.count = countForTypedArray;
        provider.fillStorage = fillStorageForTypedArray;
      } else {
        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
        provider.getItem = bind$1(rawItemGetter, null, data, startIndex, dimsDef);
        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
        provider.count = bind$1(rawCounter, null, data, startIndex, dimsDef);
      }
    };
    var getItemForTypedArray = function(idx, out2) {
      idx = idx - this._offset;
      out2 = out2 || [];
      var data = this._data;
      var dimSize = this._dimSize;
      var offset = dimSize * idx;
      for (var i = 0; i < dimSize; i++) {
        out2[i] = data[offset + i];
      }
      return out2;
    };
    var fillStorageForTypedArray = function(start2, end2, storage2, extent3) {
      var data = this._data;
      var dimSize = this._dimSize;
      for (var dim = 0; dim < dimSize; dim++) {
        var dimExtent = extent3[dim];
        var min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
        var max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
        var count2 = end2 - start2;
        var arr = storage2[dim];
        for (var i = 0; i < count2; i++) {
          var val = data[i * dimSize + dim];
          arr[start2 + i] = val;
          val < min3 && (min3 = val);
          val > max3 && (max3 = val);
        }
        dimExtent[0] = min3;
        dimExtent[1] = max3;
      }
    };
    var countForTypedArray = function() {
      return this._data ? this._data.length / this._dimSize : 0;
    };
    providerMethods = (_a2 = {}, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = {
      pure: true,
      appendData: function() {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    }, _a2[SOURCE_FORMAT_OBJECT_ROWS] = {
      pure: true,
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_KEYED_COLUMNS] = {
      pure: true,
      appendData: function(newData) {
        var data = this._data;
        each$f(newData, function(newCol, key) {
          var oldCol = data[key] || (data[key] = []);
          for (var i = 0; i < (newCol || []).length; i++) {
            oldCol.push(newCol[i]);
          }
        });
      }
    }, _a2[SOURCE_FORMAT_ORIGINAL] = {
      appendData: appendDataSimply
    }, _a2[SOURCE_FORMAT_TYPED_ARRAY] = {
      persistent: false,
      pure: true,
      appendData: function(newData) {
        this._data = newData;
      },
      clean: function() {
        this._offset += this.count();
        this._data = null;
      }
    }, _a2);
    function appendDataSimply(newData) {
      for (var i = 0; i < newData.length; i++) {
        this._data.push(newData[i]);
      }
    }
  }();
  return DefaultDataProvider2;
}();
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx];
};
var rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx + startIndex];
}, _a[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef, idx, out2) {
  idx += startIndex;
  var item = out2 || [];
  var data = rawData;
  for (var i = 0; i < data.length; i++) {
    var row = data[i];
    item[i] = row ? row[idx] : null;
  }
  return item;
}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef, idx, out2) {
  var item = out2 || [];
  for (var i = 0; i < dimsDef.length; i++) {
    var dimName = dimsDef[i].name;
    var col = rawData[dimName];
    item[i] = col ? col[idx] : null;
  }
  return item;
}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
  return rawData.length;
};
var rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN] = function(rawData, startIndex, dimsDef) {
  return Math.max(0, rawData.length - startIndex);
}, _b[SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW] = function(rawData, startIndex, dimsDef) {
  var row = rawData[0];
  return row ? Math.max(0, row.length - startIndex) : 0;
}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function(rawData, startIndex, dimsDef) {
  var dimName = dimsDef[0].name;
  var col = rawData[dimName];
  return col ? col.length : 0;
}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property) {
  return dataItem[dimIndex];
};
var rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function(dataItem, dimIndex, property) {
  return dataItem[property];
}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function(dataItem, dimIndex, property) {
  var value = getDataItemValue(dataItem);
  return !(value instanceof Array) ? value : value[dimIndex];
}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
function getRawSourceValueGetter(sourceFormat) {
  var method = rawSourceValueGetterMap[sourceFormat];
  return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data, dataIndex, dim) {
  if (!data) {
    return;
  }
  var dataItem = data.getRawDataItem(dataIndex);
  if (dataItem == null) {
    return;
  }
  var store = data.getStore();
  var sourceFormat = store.getSource().sourceFormat;
  if (dim != null) {
    var dimIndex = data.getDimensionIndex(dim);
    var property = store.getDimensionProperty(dimIndex);
    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
  } else {
    var result = dataItem;
    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      result = getDataItemValue(dataItem);
    }
    return result;
  }
}
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = function() {
  function DataFormatMixin2() {
  }
  DataFormatMixin2.prototype.getDataParams = function(dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name = data.getName(dataIndex);
    var itemOpt = data.getRawDataItem(dataIndex);
    var style = data.getItemVisual(dataIndex, "style");
    var color = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
    var borderColor = style && style.stroke;
    var mainType = this.mainType;
    var isSeries2 = mainType === "series";
    var userOutput = data.userOutput && data.userOutput.get();
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries2 ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries2 ? this.id : null,
      seriesName: isSeries2 ? this.name : null,
      name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType,
      value: rawValue,
      color,
      borderColor,
      dimensionNames: userOutput ? userOutput.fullDimensions : null,
      encode: userOutput ? userOutput.encode : null,
      $vars: ["seriesName", "name", "value"]
    };
  };
  DataFormatMixin2.prototype.getFormattedLabel = function(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
    status = status || "normal";
    var data = this.getData(dataType);
    var params = this.getDataParams(dataIndex, dataType);
    if (extendParams) {
      params.value = extendParams.interpolatedValue;
    }
    if (labelDimIndex != null && isArray$1(params.value)) {
      params.value = params.value[labelDimIndex];
    }
    if (!formatter) {
      var itemModel = data.getItemModel(dataIndex);
      formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
    }
    if (isFunction$1(formatter)) {
      params.status = status;
      params.dimensionIndex = labelDimIndex;
      return formatter(params);
    } else if (isString(formatter)) {
      var str = formatTpl(formatter, params);
      return str.replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
        var len2 = dimStr.length;
        var dimLoose = dimStr;
        if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
          dimLoose = +dimLoose.slice(1, len2 - 1);
        }
        var val = retrieveRawValue(data, dataIndex, dimLoose);
        if (extendParams && isArray$1(extendParams.interpolatedValue)) {
          var dimIndex = data.getDimensionIndex(dimLoose);
          if (dimIndex >= 0) {
            val = extendParams.interpolatedValue[dimIndex];
          }
        }
        return val != null ? val + "" : "";
      });
    }
  };
  DataFormatMixin2.prototype.getRawValue = function(idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  };
  DataFormatMixin2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return;
  };
  return DataFormatMixin2;
}();
function normalizeTooltipFormatResult(result) {
  var markupText;
  var markupFragment;
  if (isObject$3(result)) {
    if (result.type) {
      markupFragment = result;
    }
  } else {
    markupText = result;
  }
  return {
    text: markupText,
    frag: markupFragment
  };
}
function createTask(define) {
  return new Task(define);
}
var Task = function() {
  function Task2(define) {
    define = define || {};
    this._reset = define.reset;
    this._plan = define.plan;
    this._count = define.count;
    this._onDirty = define.onDirty;
    this._dirty = true;
  }
  Task2.prototype.perform = function(performArgs) {
    var upTask = this._upstream;
    var skip = performArgs && performArgs.skip;
    if (this._dirty && upTask) {
      var context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }
    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }
    var planResult;
    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    }
    var lastModBy = normalizeModBy(this._modBy);
    var lastModDataCount = this._modDataCount || 0;
    var modBy = normalizeModBy(performArgs && performArgs.modBy);
    var modDataCount = performArgs && performArgs.modDataCount || 0;
    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = "reset";
    }
    function normalizeModBy(val) {
      !(val >= 1) && (val = 1);
      return val;
    }
    var forceFirstProgress;
    if (this._dirty || planResult === "reset") {
      this._dirty = false;
      forceFirstProgress = this._doReset(skip);
    }
    this._modBy = modBy;
    this._modDataCount = modDataCount;
    var step = performArgs && performArgs.step;
    if (upTask) {
      this._dueEnd = upTask._outputDueEnd;
    } else {
      this._dueEnd = this._count ? this._count(this.context) : Infinity;
    }
    if (this._progress) {
      var start2 = this._dueIndex;
      var end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
      if (!skip && (forceFirstProgress || start2 < end2)) {
        var progress = this._progress;
        if (isArray$1(progress)) {
          for (var i = 0; i < progress.length; i++) {
            this._doProgress(progress[i], start2, end2, modBy, modDataCount);
          }
        } else {
          this._doProgress(progress, start2, end2, modBy, modDataCount);
        }
      }
      this._dueIndex = end2;
      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
      this._outputDueEnd = outputDueEnd;
    } else {
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }
    return this.unfinished();
  };
  Task2.prototype.dirty = function() {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  };
  Task2.prototype._doProgress = function(progress, start2, end2, modBy, modDataCount) {
    iterator.reset(start2, end2, modBy, modDataCount);
    this._callingProgress = progress;
    this._callingProgress({
      start: start2,
      end: end2,
      count: end2 - start2,
      next: iterator.next
    }, this.context);
  };
  Task2.prototype._doReset = function(skip) {
    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
    this._settedOutputEnd = null;
    var progress;
    var forceFirstProgress;
    if (!skip && this._reset) {
      progress = this._reset(this.context);
      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      }
      if (isArray$1(progress) && !progress.length) {
        progress = null;
      }
    }
    this._progress = progress;
    this._modBy = this._modDataCount = null;
    var downstream = this._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  };
  Task2.prototype.unfinished = function() {
    return this._progress && this._dueIndex < this._dueEnd;
  };
  Task2.prototype.pipe = function(downTask) {
    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  };
  Task2.prototype.dispose = function() {
    if (this._disposed) {
      return;
    }
    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  };
  Task2.prototype.getUpstream = function() {
    return this._upstream;
  };
  Task2.prototype.getDownstream = function() {
    return this._downstream;
  };
  Task2.prototype.setOutputEnd = function(end2) {
    this._outputDueEnd = this._settedOutputEnd = end2;
  };
  return Task2;
}();
var iterator = function() {
  var end2;
  var current;
  var modBy;
  var modDataCount;
  var winCount;
  var it = {
    reset: function(s, e2, sStep, sCount) {
      current = s;
      end2 = e2;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;
  function sequentialNext() {
    return current < end2 ? current++ : null;
  }
  function modNext() {
    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    var result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
    current++;
    return result;
  }
}();
function parseDataValue(value, opt) {
  var dimType = opt && opt.type;
  if (dimType === "ordinal") {
    return value;
  }
  if (dimType === "time" && !isNumber(value) && value != null && value !== "-") {
    value = +parseDate(value);
  }
  return value == null || value === "" ? NaN : +value;
}
var valueParserMap = createHashMap({
  "number": function(val) {
    return parseFloat(val);
  },
  "time": function(val) {
    return +parseDate(val);
  },
  "trim": function(val) {
    return isString(val) ? trim$1(val) : val;
  }
});
function getRawValueParser(type) {
  return valueParserMap.get(type);
}
var ORDER_COMPARISON_OP_MAP = {
  lt: function(lval, rval) {
    return lval < rval;
  },
  lte: function(lval, rval) {
    return lval <= rval;
  },
  gt: function(lval, rval) {
    return lval > rval;
  },
  gte: function(lval, rval) {
    return lval >= rval;
  }
};
var FilterOrderComparator = function() {
  function FilterOrderComparator2(op, rval) {
    if (!isNumber(rval)) {
      var errMsg = "";
      throwError(errMsg);
    }
    this._opFn = ORDER_COMPARISON_OP_MAP[op];
    this._rvalFloat = numericToNumber(rval);
  }
  FilterOrderComparator2.prototype.evaluate = function(lval) {
    return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
  };
  return FilterOrderComparator2;
}();
var SortOrderComparator = function() {
  function SortOrderComparator2(order, incomparable) {
    var isDesc = order === "desc";
    this._resultLT = isDesc ? 1 : -1;
    if (incomparable == null) {
      incomparable = isDesc ? "min" : "max";
    }
    this._incomparable = incomparable === "min" ? -Infinity : Infinity;
  }
  SortOrderComparator2.prototype.evaluate = function(lval, rval) {
    var lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
    var rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
    var lvalNotNumeric = isNaN(lvalFloat);
    var rvalNotNumeric = isNaN(rvalFloat);
    if (lvalNotNumeric) {
      lvalFloat = this._incomparable;
    }
    if (rvalNotNumeric) {
      rvalFloat = this._incomparable;
    }
    if (lvalNotNumeric && rvalNotNumeric) {
      var lvalIsStr = isString(lval);
      var rvalIsStr = isString(rval);
      if (lvalIsStr) {
        lvalFloat = rvalIsStr ? lval : 0;
      }
      if (rvalIsStr) {
        rvalFloat = lvalIsStr ? rval : 0;
      }
    }
    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
  };
  return SortOrderComparator2;
}();
var FilterEqualityComparator = function() {
  function FilterEqualityComparator2(isEq, rval) {
    this._rval = rval;
    this._isEQ = isEq;
    this._rvalTypeof = typeof rval;
    this._rvalFloat = numericToNumber(rval);
  }
  FilterEqualityComparator2.prototype.evaluate = function(lval) {
    var eqResult = lval === this._rval;
    if (!eqResult) {
      var lvalTypeof = typeof lval;
      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) {
        eqResult = numericToNumber(lval) === this._rvalFloat;
      }
    }
    return this._isEQ ? eqResult : !eqResult;
  };
  return FilterEqualityComparator2;
}();
function createFilterComparator(op, rval) {
  return op === "eq" || op === "ne" ? new FilterEqualityComparator(op === "eq", rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
}
var ExternalSource = function() {
  function ExternalSource2() {
  }
  ExternalSource2.prototype.getRawData = function() {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.getRawDataItem = function(dataIndex) {
    throw new Error("not supported");
  };
  ExternalSource2.prototype.cloneRawData = function() {
    return;
  };
  ExternalSource2.prototype.getDimensionInfo = function(dim) {
    return;
  };
  ExternalSource2.prototype.cloneAllDimensionInfo = function() {
    return;
  };
  ExternalSource2.prototype.count = function() {
    return;
  };
  ExternalSource2.prototype.retrieveValue = function(dataIndex, dimIndex) {
    return;
  };
  ExternalSource2.prototype.retrieveValueFromItem = function(dataItem, dimIndex) {
    return;
  };
  ExternalSource2.prototype.convertValue = function(rawVal, dimInfo) {
    return parseDataValue(rawVal, dimInfo);
  };
  return ExternalSource2;
}();
function createExternalSource(internalSource, externalTransform) {
  var extSource = new ExternalSource();
  var data = internalSource.data;
  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
  var sourceHeaderCount = internalSource.startIndex;
  var errMsg = "";
  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
    throwError(errMsg);
  }
  var dimensions = [];
  var dimsByName = {};
  var dimsDef = internalSource.dimensionsDefine;
  if (dimsDef) {
    each$f(dimsDef, function(dimDef, idx) {
      var name = dimDef.name;
      var dimDefExt = {
        index: idx,
        name,
        displayName: dimDef.displayName
      };
      dimensions.push(dimDefExt);
      if (name != null) {
        var errMsg_1 = "";
        if (hasOwn(dimsByName, name)) {
          throwError(errMsg_1);
        }
        dimsByName[name] = dimDefExt;
      }
    });
  } else {
    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
      dimensions.push({
        index: i
      });
    }
  }
  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  if (externalTransform.__isBuiltIn) {
    extSource.getRawDataItem = function(dataIndex) {
      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    };
    extSource.getRawData = bind$1(getRawData, null, internalSource);
  }
  extSource.cloneRawData = bind$1(cloneRawData, null, internalSource);
  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  extSource.count = bind$1(rawCounter, null, data, sourceHeaderCount, dimensions);
  var rawValueGetter = getRawSourceValueGetter(sourceFormat);
  extSource.retrieveValue = function(dataIndex, dimIndex) {
    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    return retrieveValueFromItem(rawItem, dimIndex);
  };
  var retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
    if (dataItem == null) {
      return;
    }
    var dimDef = dimensions[dimIndex];
    if (dimDef) {
      return rawValueGetter(dataItem, dimIndex, dimDef.name);
    }
  };
  extSource.getDimensionInfo = bind$1(getDimensionInfo, null, dimensions, dimsByName);
  extSource.cloneAllDimensionInfo = bind$1(cloneAllDimensionInfo, null, dimensions);
  return extSource;
}
function getRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    throwError(errMsg);
  }
  return upstream.data;
}
function cloneRawData(upstream) {
  var sourceFormat = upstream.sourceFormat;
  var data = upstream.data;
  if (!isSupportedSourceFormat(sourceFormat)) {
    var errMsg = "";
    throwError(errMsg);
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    var result = [];
    for (var i = 0, len2 = data.length; i < len2; i++) {
      result.push(data[i].slice());
    }
    return result;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    var result = [];
    for (var i = 0, len2 = data.length; i < len2; i++) {
      result.push(extend$1({}, data[i]));
    }
    return result;
  }
}
function getDimensionInfo(dimensions, dimsByName, dim) {
  if (dim == null) {
    return;
  }
  if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
    return dimensions[dim];
  } else if (hasOwn(dimsByName, dim)) {
    return dimsByName[dim];
  }
}
function cloneAllDimensionInfo(dimensions) {
  return clone$4(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
  externalTransform = clone$4(externalTransform);
  var type = externalTransform.type;
  var errMsg = "";
  if (!type) {
    throwError(errMsg);
  }
  var typeParsed = type.split(":");
  if (typeParsed.length !== 2) {
    throwError(errMsg);
  }
  var isBuiltIn = false;
  if (typeParsed[0] === "echarts") {
    type = typeParsed[1];
    isBuiltIn = true;
  }
  externalTransform.__isBuiltIn = isBuiltIn;
  externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
  var pipedTransOption = normalizeToArray(rawTransOption);
  var pipeLen = pipedTransOption.length;
  var errMsg = "";
  if (!pipeLen) {
    throwError(errMsg);
  }
  for (var i = 0, len2 = pipeLen; i < len2; i++) {
    var transOption = pipedTransOption[i];
    sourceList = applySingleDataTransform(transOption, sourceList);
    if (i !== len2 - 1) {
      sourceList.length = Math.max(sourceList.length, 1);
    }
  }
  return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
  var errMsg = "";
  if (!upSourceList.length) {
    throwError(errMsg);
  }
  if (!isObject$3(transOption)) {
    throwError(errMsg);
  }
  var transType = transOption.type;
  var externalTransform = externalTransformMap.get(transType);
  if (!externalTransform) {
    throwError(errMsg);
  }
  var extUpSourceList = map$1(upSourceList, function(upSource) {
    return createExternalSource(upSource, externalTransform);
  });
  var resultList = normalizeToArray(externalTransform.transform({
    upstream: extUpSourceList[0],
    upstreamList: extUpSourceList,
    config: clone$4(transOption.config)
  }));
  return map$1(resultList, function(result, resultIndex) {
    var errMsg2 = "";
    if (!isObject$3(result)) {
      throwError(errMsg2);
    }
    if (!result.data) {
      throwError(errMsg2);
    }
    var sourceFormat = detectSourceFormat(result.data);
    if (!isSupportedSourceFormat(sourceFormat)) {
      throwError(errMsg2);
    }
    var resultMetaRawOption;
    var firstUpSource = upSourceList[0];
    if (firstUpSource && resultIndex === 0 && !result.dimensions) {
      var startIndex = firstUpSource.startIndex;
      if (startIndex) {
        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
      }
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: startIndex,
        dimensions: firstUpSource.metaRawOption.dimensions
      };
    } else {
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: result.dimensions
      };
    }
    return createSource(result.data, resultMetaRawOption, null);
  });
}
function isSupportedSourceFormat(sourceFormat) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array$1 = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
var dataCtors = {
  "float": CtorFloat64Array,
  "int": CtorInt32Array$1,
  "ordinal": Array,
  "number": Array,
  "time": CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
  var Ctor = originalChunk.constructor;
  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end2, append) {
  var DataCtor = dataCtors[dimType || "float"];
  if (append) {
    var oldStore = store[dimIdx];
    var oldLen = oldStore && oldStore.length;
    if (!(oldLen === end2)) {
      var newStore = new DataCtor(end2);
      for (var j = 0; j < oldLen; j++) {
        newStore[j] = oldStore[j];
      }
      store[dimIdx] = newStore;
    }
  } else {
    store[dimIdx] = new DataCtor(end2);
  }
}
var DataStore = function() {
  function DataStore2() {
    this._chunks = [];
    this._rawExtent = [];
    this._extent = [];
    this._count = 0;
    this._rawCount = 0;
    this._calcDimNameToIdx = createHashMap();
  }
  DataStore2.prototype.initData = function(provider, inputDimensions, dimValueGetter) {
    this._provider = provider;
    this._chunks = [];
    this._indices = null;
    this.getRawIndex = this._getRawIdxIdentity;
    var source = provider.getSource();
    var defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
    this._dimValueGetter = dimValueGetter || defaultGetter;
    this._rawExtent = [];
    shouldRetrieveDataByName(source);
    this._dimensions = map$1(inputDimensions, function(dim) {
      return {
        type: dim.type,
        property: dim.property
      };
    });
    this._initDataFromProvider(0, provider.count());
  };
  DataStore2.prototype.getProvider = function() {
    return this._provider;
  };
  DataStore2.prototype.getSource = function() {
    return this._provider.getSource();
  };
  DataStore2.prototype.ensureCalculationDimension = function(dimName, type) {
    var calcDimNameToIdx = this._calcDimNameToIdx;
    var dimensions = this._dimensions;
    var calcDimIdx = calcDimNameToIdx.get(dimName);
    if (calcDimIdx != null) {
      if (dimensions[calcDimIdx].type === type) {
        return calcDimIdx;
      }
    } else {
      calcDimIdx = dimensions.length;
    }
    dimensions[calcDimIdx] = {
      type
    };
    calcDimNameToIdx.set(dimName, calcDimIdx);
    this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
    this._rawExtent[calcDimIdx] = getInitialExtent();
    return calcDimIdx;
  };
  DataStore2.prototype.collectOrdinalMeta = function(dimIdx, ordinalMeta) {
    var chunk = this._chunks[dimIdx];
    var dim = this._dimensions[dimIdx];
    var rawExtents = this._rawExtent;
    var offset = dim.ordinalOffset || 0;
    var len2 = chunk.length;
    if (offset === 0) {
      rawExtents[dimIdx] = getInitialExtent();
    }
    var dimRawExtent = rawExtents[dimIdx];
    for (var i = offset; i < len2; i++) {
      var val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);
      dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
      dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
    }
    dim.ordinalMeta = ordinalMeta;
    dim.ordinalOffset = len2;
    dim.type = "ordinal";
  };
  DataStore2.prototype.getOrdinalMeta = function(dimIdx) {
    var dimInfo = this._dimensions[dimIdx];
    var ordinalMeta = dimInfo.ordinalMeta;
    return ordinalMeta;
  };
  DataStore2.prototype.getDimensionProperty = function(dimIndex) {
    var item = this._dimensions[dimIndex];
    return item && item.property;
  };
  DataStore2.prototype.appendData = function(data) {
    var provider = this._provider;
    var start2 = this.count();
    provider.appendData(data);
    var end2 = provider.count();
    if (!provider.persistent) {
      end2 += start2;
    }
    if (start2 < end2) {
      this._initDataFromProvider(start2, end2, true);
    }
    return [start2, end2];
  };
  DataStore2.prototype.appendValues = function(values, minFillLen) {
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var start2 = this.count();
    var end2 = start2 + Math.max(values.length, minFillLen || 0);
    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      prepareStore(chunks, i, dim.type, end2, true);
    }
    var emptyDataItem = [];
    for (var idx = start2; idx < end2; idx++) {
      var sourceIdx = idx - start2;
      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
        var dim = dimensions[dimIdx];
        var val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
        chunks[dimIdx][idx] = val;
        var dimRawExtent = rawExtent[dimIdx];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
    }
    this._rawCount = this._count = end2;
    return {
      start: start2,
      end: end2
    };
  };
  DataStore2.prototype._initDataFromProvider = function(start2, end2, append) {
    var provider = this._provider;
    var chunks = this._chunks;
    var dimensions = this._dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var dimNames = map$1(dimensions, function(dim2) {
      return dim2.property;
    });
    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      if (!rawExtent[i]) {
        rawExtent[i] = getInitialExtent();
      }
      prepareStore(chunks, i, dim.type, end2, append);
    }
    if (provider.fillStorage) {
      provider.fillStorage(start2, end2, chunks, rawExtent);
    } else {
      var dataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        dataItem = provider.getItem(idx, dataItem);
        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
          var dimStorage = chunks[dimIdx];
          var val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
          dimStorage[idx] = val;
          var dimRawExtent = rawExtent[dimIdx];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
      }
    }
    if (!provider.persistent && provider.clean) {
      provider.clean();
    }
    this._rawCount = this._count = end2;
    this._extent = [];
  };
  DataStore2.prototype.count = function() {
    return this._count;
  };
  DataStore2.prototype.get = function(dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
  };
  DataStore2.prototype.getValues = function(dimensions, idx) {
    var values = [];
    var dimArr = [];
    if (idx == null) {
      idx = dimensions;
      dimensions = [];
      for (var i = 0; i < this._dimensions.length; i++) {
        dimArr.push(i);
      }
    } else {
      dimArr = dimensions;
    }
    for (var i = 0, len2 = dimArr.length; i < len2; i++) {
      values.push(this.get(dimArr[i], idx));
    }
    return values;
  };
  DataStore2.prototype.getByRawIndex = function(dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }
    var dimStore = this._chunks[dim];
    return dimStore ? dimStore[rawIdx] : NaN;
  };
  DataStore2.prototype.getSum = function(dim) {
    var dimData = this._chunks[dim];
    var sum2 = 0;
    if (dimData) {
      for (var i = 0, len2 = this.count(); i < len2; i++) {
        var value = this.get(dim, i);
        if (!isNaN(value)) {
          sum2 += value;
        }
      }
    }
    return sum2;
  };
  DataStore2.prototype.getMedian = function(dim) {
    var dimDataArray = [];
    this.each([dim], function(val) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    });
    var sortedDimDataArray = dimDataArray.sort(function(a, b) {
      return a - b;
    });
    var len2 = this.count();
    return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
  };
  DataStore2.prototype.indexOfRawIndex = function(rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }
    if (!this._indices) {
      return rawIndex;
    }
    var indices = this._indices;
    var rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }
    var left = 0;
    var right = this._count - 1;
    while (left <= right) {
      var mid = (left + right) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  };
  DataStore2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
    var chunks = this._chunks;
    var dimData = chunks[dim];
    var nearestIndices = [];
    if (!dimData) {
      return nearestIndices;
    }
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    var minDist = Infinity;
    var minDiff = -1;
    var nearestIndicesLen = 0;
    for (var i = 0, len2 = this.count(); i < len2; i++) {
      var dataIndex = this.getRawIndex(i);
      var diff = value - dimData[dataIndex];
      var dist2 = Math.abs(diff);
      if (dist2 <= maxDistance) {
        if (dist2 < minDist || dist2 === minDist && diff >= 0 && minDiff < 0) {
          minDist = dist2;
          minDiff = diff;
          nearestIndicesLen = 0;
        }
        if (diff === minDiff) {
          nearestIndices[nearestIndicesLen++] = i;
        }
      }
    }
    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  };
  DataStore2.prototype.getIndices = function() {
    var newIndices;
    var indices = this._indices;
    if (indices) {
      var Ctor = indices.constructor;
      var thisCount = this._count;
      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);
        for (var i = 0; i < thisCount; i++) {
          newIndices[i] = indices[i];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      var Ctor = getIndicesCtor(this._rawCount);
      newIndices = new Ctor(this.count());
      for (var i = 0; i < newIndices.length; i++) {
        newIndices[i] = i;
      }
    }
    return newIndices;
  };
  DataStore2.prototype.filter = function(dims, cb) {
    if (!this._count) {
      return this;
    }
    var newStore = this.clone();
    var count2 = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(count2);
    var value = [];
    var dimSize = dims.length;
    var offset = 0;
    var dim0 = dims[0];
    var chunks = newStore._chunks;
    for (var i = 0; i < count2; i++) {
      var keep = void 0;
      var rawIdx = newStore.getRawIndex(i);
      if (dimSize === 0) {
        keep = cb(i);
      } else if (dimSize === 1) {
        var val = chunks[dim0][rawIdx];
        keep = cb(val, i);
      } else {
        var k = 0;
        for (; k < dimSize; k++) {
          value[k] = chunks[dims[k]][rawIdx];
        }
        value[k] = i;
        keep = cb.apply(null, value);
      }
      if (keep) {
        newIndices[offset++] = rawIdx;
      }
    }
    if (offset < count2) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.selectRange = function(range) {
    var newStore = this.clone();
    var len2 = newStore._count;
    if (!len2) {
      return this;
    }
    var dims = keys(range);
    var dimSize = dims.length;
    if (!dimSize) {
      return this;
    }
    var originalCount = newStore.count();
    var Ctor = getIndicesCtor(newStore._rawCount);
    var newIndices = new Ctor(originalCount);
    var offset = 0;
    var dim0 = dims[0];
    var min3 = range[dim0][0];
    var max3 = range[dim0][1];
    var storeArr = newStore._chunks;
    var quickFinished = false;
    if (!newStore._indices) {
      var idx = 0;
      if (dimSize === 1) {
        var dimStorage = storeArr[dims[0]];
        for (var i = 0; i < len2; i++) {
          var val = dimStorage[i];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      } else if (dimSize === 2) {
        var dimStorage = storeArr[dims[0]];
        var dimStorage2 = storeArr[dims[1]];
        var min22 = range[dims[1]][0];
        var max22 = range[dims[1]][1];
        for (var i = 0; i < len2; i++) {
          var val = dimStorage[i];
          var val2 = dimStorage2[i];
          if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min22 && val2 <= max22 || isNaN(val2))) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      }
    }
    if (!quickFinished) {
      if (dimSize === 1) {
        for (var i = 0; i < originalCount; i++) {
          var rawIndex = newStore.getRawIndex(i);
          var val = storeArr[dims[0]][rawIndex];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = rawIndex;
          }
        }
      } else {
        for (var i = 0; i < originalCount; i++) {
          var keep = true;
          var rawIndex = newStore.getRawIndex(i);
          for (var k = 0; k < dimSize; k++) {
            var dimk = dims[k];
            var val = storeArr[dimk][rawIndex];
            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }
          if (keep) {
            newIndices[offset++] = newStore.getRawIndex(i);
          }
        }
      }
    }
    if (offset < originalCount) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  };
  DataStore2.prototype.map = function(dims, cb) {
    var target = this.clone(dims);
    this._updateDims(target, dims, cb);
    return target;
  };
  DataStore2.prototype.modify = function(dims, cb) {
    this._updateDims(this, dims, cb);
  };
  DataStore2.prototype._updateDims = function(target, dims, cb) {
    var targetChunks = target._chunks;
    var tmpRetValue = [];
    var dimSize = dims.length;
    var dataCount = target.count();
    var values = [];
    var rawExtent = target._rawExtent;
    for (var i = 0; i < dims.length; i++) {
      rawExtent[dims[i]] = getInitialExtent();
    }
    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      var rawIndex = target.getRawIndex(dataIndex);
      for (var k = 0; k < dimSize; k++) {
        values[k] = targetChunks[dims[k]][rawIndex];
      }
      values[dimSize] = dataIndex;
      var retValue = cb && cb.apply(null, values);
      if (retValue != null) {
        if (typeof retValue !== "object") {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        for (var i = 0; i < retValue.length; i++) {
          var dim = dims[i];
          var val = retValue[i];
          var rawExtentOnDim = rawExtent[dim];
          var dimStore = targetChunks[dim];
          if (dimStore) {
            dimStore[rawIndex] = val;
          }
          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }
          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }
  };
  DataStore2.prototype.lttbDownSample = function(valueDimension, rate) {
    var target = this.clone([valueDimension], true);
    var targetStorage = target._chunks;
    var dimStore = targetStorage[valueDimension];
    var len2 = this.count();
    var sampledIndex = 0;
    var frameSize = Math.floor(1 / rate);
    var currentRawIndex = this.getRawIndex(0);
    var maxArea;
    var area2;
    var nextRawIndex;
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize) + 2);
    newIndices[sampledIndex++] = currentRawIndex;
    for (var i = 1; i < len2 - 1; i += frameSize) {
      var nextFrameStart = Math.min(i + frameSize, len2 - 1);
      var nextFrameEnd = Math.min(i + frameSize * 2, len2);
      var avgX = (nextFrameEnd + nextFrameStart) / 2;
      var avgY = 0;
      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y = dimStore[rawIndex];
        if (isNaN(y)) {
          continue;
        }
        avgY += y;
      }
      avgY /= nextFrameEnd - nextFrameStart;
      var frameStart = i;
      var frameEnd = Math.min(i + frameSize, len2);
      var pointAX = i - 1;
      var pointAY = dimStore[currentRawIndex];
      maxArea = -1;
      nextRawIndex = frameStart;
      for (var idx = frameStart; idx < frameEnd; idx++) {
        var rawIndex = this.getRawIndex(idx);
        var y = dimStore[rawIndex];
        if (isNaN(y)) {
          continue;
        }
        area2 = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
        if (area2 > maxArea) {
          maxArea = area2;
          nextRawIndex = rawIndex;
        }
      }
      newIndices[sampledIndex++] = nextRawIndex;
      currentRawIndex = nextRawIndex;
    }
    newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
    target._count = sampledIndex;
    target._indices = newIndices;
    target.getRawIndex = this._getRawIdx;
    return target;
  };
  DataStore2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var target = this.clone([dimension], true);
    var targetStorage = target._chunks;
    var frameValues = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len2 = this.count();
    var rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
    var newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
    var offset = 0;
    for (var i = 0; i < len2; i += frameSize) {
      if (frameSize > len2 - i) {
        frameSize = len2 - i;
        frameValues.length = frameSize;
      }
      for (var k = 0; k < frameSize; k++) {
        var dataIdx = this.getRawIndex(i + k);
        frameValues[k] = dimStore[dataIdx];
      }
      var value = sampleValue(frameValues);
      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len2 - 1));
      dimStore[sampleFrameIdx] = value;
      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }
      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }
      newIndices[offset++] = sampleFrameIdx;
    }
    target._count = offset;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype.each = function(dims, cb) {
    if (!this._count) {
      return;
    }
    var dimSize = dims.length;
    var chunks = this._chunks;
    for (var i = 0, len2 = this.count(); i < len2; i++) {
      var rawIdx = this.getRawIndex(i);
      switch (dimSize) {
        case 0:
          cb(i);
          break;
        case 1:
          cb(chunks[dims[0]][rawIdx], i);
          break;
        case 2:
          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
          break;
        default:
          var k = 0;
          var value = [];
          for (; k < dimSize; k++) {
            value[k] = chunks[dims[k]][rawIdx];
          }
          value[k] = i;
          cb.apply(null, value);
      }
    }
  };
  DataStore2.prototype.getDataExtent = function(dim) {
    var dimData = this._chunks[dim];
    var initialExtent = getInitialExtent();
    if (!dimData) {
      return initialExtent;
    }
    var currEnd = this.count();
    var useRaw = !this._indices;
    var dimExtent;
    if (useRaw) {
      return this._rawExtent[dim].slice();
    }
    dimExtent = this._extent[dim];
    if (dimExtent) {
      return dimExtent.slice();
    }
    dimExtent = initialExtent;
    var min3 = dimExtent[0];
    var max3 = dimExtent[1];
    for (var i = 0; i < currEnd; i++) {
      var rawIdx = this.getRawIndex(i);
      var value = dimData[rawIdx];
      value < min3 && (min3 = value);
      value > max3 && (max3 = value);
    }
    dimExtent = [min3, max3];
    this._extent[dim] = dimExtent;
    return dimExtent;
  };
  DataStore2.prototype.getRawDataItem = function(idx) {
    var rawIdx = this.getRawIndex(idx);
    if (!this._provider.persistent) {
      var val = [];
      var chunks = this._chunks;
      for (var i = 0; i < chunks.length; i++) {
        val.push(chunks[i][rawIdx]);
      }
      return val;
    } else {
      return this._provider.getItem(rawIdx);
    }
  };
  DataStore2.prototype.clone = function(clonedDims, ignoreIndices) {
    var target = new DataStore2();
    var chunks = this._chunks;
    var clonedDimsMap = clonedDims && reduce(clonedDims, function(obj, dimIdx) {
      obj[dimIdx] = true;
      return obj;
    }, {});
    if (clonedDimsMap) {
      for (var i = 0; i < chunks.length; i++) {
        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
      }
    } else {
      target._chunks = chunks;
    }
    this._copyCommonProps(target);
    if (!ignoreIndices) {
      target._indices = this._cloneIndices();
    }
    target._updateGetRawIdx();
    return target;
  };
  DataStore2.prototype._copyCommonProps = function(target) {
    target._count = this._count;
    target._rawCount = this._rawCount;
    target._provider = this._provider;
    target._dimensions = this._dimensions;
    target._extent = clone$4(this._extent);
    target._rawExtent = clone$4(this._rawExtent);
  };
  DataStore2.prototype._cloneIndices = function() {
    if (this._indices) {
      var Ctor = this._indices.constructor;
      var indices = void 0;
      if (Ctor === Array) {
        var thisCount = this._indices.length;
        indices = new Ctor(thisCount);
        for (var i = 0; i < thisCount; i++) {
          indices[i] = this._indices[i];
        }
      } else {
        indices = new Ctor(this._indices);
      }
      return indices;
    }
    return null;
  };
  DataStore2.prototype._getRawIdxIdentity = function(idx) {
    return idx;
  };
  DataStore2.prototype._getRawIdx = function(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }
    return -1;
  };
  DataStore2.prototype._updateGetRawIdx = function() {
    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
  };
  DataStore2.internalField = function() {
    function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
      return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
    }
    defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function(dataItem, property, dataIndex, dimIndex) {
        return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
      },
      keyedColumns: getDimValueSimply,
      original: function(dataItem, property, dataIndex, dimIndex) {
        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
        return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
      },
      typedArray: function(dataItem, property, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };
  }();
  return DataStore2;
}();
var SourceManager = function() {
  function SourceManager2(sourceHost) {
    this._sourceList = [];
    this._storeList = [];
    this._upstreamSignList = [];
    this._versionSignBase = 0;
    this._dirty = true;
    this._sourceHost = sourceHost;
  }
  SourceManager2.prototype.dirty = function() {
    this._setLocalSource([], []);
    this._storeList = [];
    this._dirty = true;
  };
  SourceManager2.prototype._setLocalSource = function(sourceList, upstreamSignList) {
    this._sourceList = sourceList;
    this._upstreamSignList = upstreamSignList;
    this._versionSignBase++;
    if (this._versionSignBase > 9e10) {
      this._versionSignBase = 0;
    }
  };
  SourceManager2.prototype._getVersionSign = function() {
    return this._sourceHost.uid + "_" + this._versionSignBase;
  };
  SourceManager2.prototype.prepareSource = function() {
    if (this._isDirty()) {
      this._createSource();
      this._dirty = false;
    }
  };
  SourceManager2.prototype._createSource = function() {
    this._setLocalSource([], []);
    var sourceHost = this._sourceHost;
    var upSourceMgrList = this._getUpstreamSourceManagers();
    var hasUpstream = !!upSourceMgrList.length;
    var resultSourceList;
    var upstreamSignList;
    if (isSeries(sourceHost)) {
      var seriesModel = sourceHost;
      var data = void 0;
      var sourceFormat = void 0;
      var upSource = void 0;
      if (hasUpstream) {
        var upSourceMgr = upSourceMgrList[0];
        upSourceMgr.prepareSource();
        upSource = upSourceMgr.getSource();
        data = upSource.data;
        sourceFormat = upSource.sourceFormat;
        upstreamSignList = [upSourceMgr._getVersionSign()];
      } else {
        data = seriesModel.get("data", true);
        sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
        upstreamSignList = [];
      }
      var newMetaRawOption = this._getSourceMetaRawOption() || {};
      var upMetaRawOption = upSource && upSource.metaRawOption || {};
      var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
      var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
      var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
      var needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
      resultSourceList = needsCreateSource ? [createSource(data, {
        seriesLayoutBy,
        sourceHeader,
        dimensions
      }, sourceFormat)] : [];
    } else {
      var datasetModel = sourceHost;
      if (hasUpstream) {
        var result = this._applyTransform(upSourceMgrList);
        resultSourceList = result.sourceList;
        upstreamSignList = result.upstreamSignList;
      } else {
        var sourceData = datasetModel.get("source", true);
        resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
        upstreamSignList = [];
      }
    }
    this._setLocalSource(resultSourceList, upstreamSignList);
  };
  SourceManager2.prototype._applyTransform = function(upMgrList) {
    var datasetModel = this._sourceHost;
    var transformOption = datasetModel.get("transform", true);
    var fromTransformResult = datasetModel.get("fromTransformResult", true);
    if (fromTransformResult != null) {
      var errMsg = "";
      if (upMgrList.length !== 1) {
        doThrow(errMsg);
      }
    }
    var sourceList;
    var upSourceList = [];
    var upstreamSignList = [];
    each$f(upMgrList, function(upMgr) {
      upMgr.prepareSource();
      var upSource = upMgr.getSource(fromTransformResult || 0);
      var errMsg2 = "";
      if (fromTransformResult != null && !upSource) {
        doThrow(errMsg2);
      }
      upSourceList.push(upSource);
      upstreamSignList.push(upMgr._getVersionSign());
    });
    if (transformOption) {
      sourceList = applyDataTransform(transformOption, upSourceList, {
        datasetIndex: datasetModel.componentIndex
      });
    } else if (fromTransformResult != null) {
      sourceList = [cloneSourceShallow(upSourceList[0])];
    }
    return {
      sourceList,
      upstreamSignList
    };
  };
  SourceManager2.prototype._isDirty = function() {
    if (this._dirty) {
      return true;
    }
    var upSourceMgrList = this._getUpstreamSourceManagers();
    for (var i = 0; i < upSourceMgrList.length; i++) {
      var upSrcMgr = upSourceMgrList[i];
      if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
        return true;
      }
    }
  };
  SourceManager2.prototype.getSource = function(sourceIndex) {
    sourceIndex = sourceIndex || 0;
    var source = this._sourceList[sourceIndex];
    if (!source) {
      var upSourceMgrList = this._getUpstreamSourceManagers();
      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
    }
    return source;
  };
  SourceManager2.prototype.getSharedDataStore = function(seriesDimRequest) {
    var schema = seriesDimRequest.makeStoreSchema();
    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
  };
  SourceManager2.prototype._innerGetDataStore = function(storeDims, seriesSource, sourceReadKey) {
    var sourceIndex = 0;
    var storeList = this._storeList;
    var cachedStoreMap = storeList[sourceIndex];
    if (!cachedStoreMap) {
      cachedStoreMap = storeList[sourceIndex] = {};
    }
    var cachedStore = cachedStoreMap[sourceReadKey];
    if (!cachedStore) {
      var upSourceMgr = this._getUpstreamSourceManagers()[0];
      if (isSeries(this._sourceHost) && upSourceMgr) {
        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
      } else {
        cachedStore = new DataStore();
        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
      }
      cachedStoreMap[sourceReadKey] = cachedStore;
    }
    return cachedStore;
  };
  SourceManager2.prototype._getUpstreamSourceManagers = function() {
    var sourceHost = this._sourceHost;
    if (isSeries(sourceHost)) {
      var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
      return !datasetModel ? [] : [datasetModel.getSourceManager()];
    } else {
      return map$1(queryDatasetUpstreamDatasetModels(sourceHost), function(datasetModel2) {
        return datasetModel2.getSourceManager();
      });
    }
  };
  SourceManager2.prototype._getSourceMetaRawOption = function() {
    var sourceHost = this._sourceHost;
    var seriesLayoutBy;
    var sourceHeader;
    var dimensions;
    if (isSeries(sourceHost)) {
      seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
      sourceHeader = sourceHost.get("sourceHeader", true);
      dimensions = sourceHost.get("dimensions", true);
    } else if (!this._getUpstreamSourceManagers().length) {
      var model = sourceHost;
      seriesLayoutBy = model.get("seriesLayoutBy", true);
      sourceHeader = model.get("sourceHeader", true);
      dimensions = model.get("dimensions", true);
    }
    return {
      seriesLayoutBy,
      sourceHeader,
      dimensions
    };
  };
  return SourceManager2;
}();
function disableTransformOptionMerge(datasetModel) {
  var transformOption = datasetModel.option.transform;
  transformOption && setAsPrimitive(datasetModel.option.transform);
}
function isSeries(sourceHost) {
  return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
  throw new Error(errMsg);
}
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipTextStyle(textStyle, renderMode) {
  var nameFontColor = textStyle.color || "#6e7079";
  var nameFontSize = textStyle.fontSize || 12;
  var nameFontWeight = textStyle.fontWeight || "400";
  var valueFontColor = textStyle.color || "#464646";
  var valueFontSize = textStyle.fontSize || 14;
  var valueFontWeight = textStyle.fontWeight || "900";
  if (renderMode === "html") {
    return {
      nameStyle: "font-size:" + encodeHTML(nameFontSize + "") + "px;color:" + encodeHTML(nameFontColor) + ";font-weight:" + encodeHTML(nameFontWeight + ""),
      valueStyle: "font-size:" + encodeHTML(valueFontSize + "") + "px;color:" + encodeHTML(valueFontColor) + ";font-weight:" + encodeHTML(valueFontWeight + "")
    };
  } else {
    return {
      nameStyle: {
        fontSize: nameFontSize,
        fill: nameFontColor,
        fontWeight: nameFontWeight
      },
      valueStyle: {
        fontSize: valueFontSize,
        fill: valueFontColor,
        fontWeight: valueFontWeight
      }
    };
  }
}
var HTML_GAPS = [0, 10, 20, 30];
var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
function createTooltipMarkup(type, option) {
  option.type = type;
  return option;
}
function isSectionFragment(frag) {
  return frag.type === "section";
}
function getBuilder(frag) {
  return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
  if (isSectionFragment(frag)) {
    var gapLevel_1 = 0;
    var subBlockLen = frag.blocks.length;
    var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
    each$f(frag.blocks, function(subBlock) {
      var subGapLevel = getBlockGapLevel(subBlock);
      if (subGapLevel >= gapLevel_1) {
        gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
      }
    });
    return gapLevel_1;
  }
  return 0;
}
function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var noHeader = fragment.noHeader;
  var gaps = getGap(getBlockGapLevel(fragment));
  var subMarkupTextList = [];
  var subBlocks = fragment.blocks || [];
  assert(!subBlocks || isArray$1(subBlocks));
  subBlocks = subBlocks || [];
  var orderMode = ctx.orderMode;
  if (fragment.sortBlocks && orderMode) {
    subBlocks = subBlocks.slice();
    var orderMap = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (hasOwn(orderMap, orderMode)) {
      var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);
      subBlocks.sort(function(a, b) {
        return comparator_1.evaluate(a.sortParam, b.sortParam);
      });
    } else if (orderMode === "seriesDesc") {
      subBlocks.reverse();
    }
  }
  each$f(subBlocks, function(subBlock, idx) {
    var valueFormatter = fragment.valueFormatter;
    var subMarkupText2 = getBuilder(subBlock)(valueFormatter ? extend$1(extend$1({}, ctx), {
      valueFormatter
    }) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
    subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
  });
  var subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
  if (noHeader) {
    return subMarkupText;
  }
  var displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
  var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;
  if (ctx.renderMode === "richText") {
    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
  } else {
    return wrapBlockHTML('<div style="' + nameStyle + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
  }
}
function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  var renderMode = ctx.renderMode;
  var noName = fragment.noName;
  var noValue = fragment.noValue;
  var noMarker = !fragment.markerType;
  var name = fragment.name;
  var useUTC = ctx.useUTC;
  var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function(value) {
    value = isArray$1(value) ? value : [value];
    return map$1(value, function(val, idx) {
      return makeValueReadable(val, isArray$1(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
    });
  };
  if (noName && noValue) {
    return;
  }
  var markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || "#333", renderMode);
  var readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
  var valueTypeOption = fragment.valueType;
  var readableValueList = noValue ? [] : valueFormatter(fragment.value);
  var valueAlignRight = !noMarker || !noName;
  var valueCloseToMarker = !noMarker && noName;
  var _a2 = getTooltipTextStyle(toolTipTextStyle, renderMode), nameStyle = _a2.nameStyle, valueStyle = _a2.valueStyle;
  return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
  if (!fragment) {
    return;
  }
  var builder = getBuilder(fragment);
  var ctx = {
    useUTC,
    renderMode,
    orderMode,
    markupStyleCreator,
    valueFormatter: fragment.valueFormatter
  };
  return builder(ctx, fragment, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
  return {
    html: HTML_GAPS[gapLevel],
    richText: RICH_TEXT_GAPS[gapLevel]
  };
}
function wrapBlockHTML(encodedContent, topGap) {
  var clearfix = '<div style="clear:both"></div>';
  var marginCSS = "margin: " + topGap + "px 0 0";
  return '<div style="' + marginCSS + ";" + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name, leftHasMarker, style) {
  var marginCss = leftHasMarker ? "margin-left:2px" : "";
  return '<span style="' + style + ";" + marginCss + '">' + encodeHTML(name) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
  var paddingStr = valueCloseToMarker ? "10px" : "20px";
  var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : "";
  valueList = isArray$1(valueList) ? valueList : [valueList];
  return '<span style="' + alignCSS + ";" + style + '">' + map$1(valueList, function(value) {
    return encodeHTML(value);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name, style) {
  return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
}
function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
  var styles = [style];
  var paddingLeft = valueCloseToMarker ? 10 : 20;
  alignRight && styles.push({
    padding: [0, 0, 0, paddingLeft],
    align: "right"
  });
  return ctx.markupStyleCreator.wrapRichTextStyle(isArray$1(values) ? values.join("  ") : values, styles);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
  var style = series.getData().getItemVisual(dataIndex, "style");
  var color = style[series.visualDrawType];
  return convertToColorString(color);
}
function getPaddingFromTooltipModel(model, renderMode) {
  var padding = model.get("padding");
  return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
var TooltipMarkupStyleCreator = function() {
  function TooltipMarkupStyleCreator2() {
    this.richTextStyles = {};
    this._nextStyleNameId = getRandomIdBase();
  }
  TooltipMarkupStyleCreator2.prototype._generateStyleName = function() {
    return "__EC_aUTo_" + this._nextStyleNameId++;
  };
  TooltipMarkupStyleCreator2.prototype.makeTooltipMarker = function(markerType, colorStr, renderMode) {
    var markerId = renderMode === "richText" ? this._generateStyleName() : null;
    var marker = getTooltipMarker({
      color: colorStr,
      type: markerType,
      renderMode,
      markerId
    });
    if (isString(marker)) {
      return marker;
    } else {
      this.richTextStyles[markerId] = marker.style;
      return marker.content;
    }
  };
  TooltipMarkupStyleCreator2.prototype.wrapRichTextStyle = function(text, styles) {
    var finalStl = {};
    if (isArray$1(styles)) {
      each$f(styles, function(stl) {
        return extend$1(finalStl, stl);
      });
    } else {
      extend$1(finalStl, styles);
    }
    var styleName = this._generateStyleName();
    this.richTextStyles[styleName] = finalStl;
    return "{" + styleName + "|" + text + "}";
  };
  return TooltipMarkupStyleCreator2;
}();
function defaultSeriesFormatTooltip(opt) {
  var series = opt.series;
  var dataIndex = opt.dataIndex;
  var multipleSeries = opt.multipleSeries;
  var data = series.getData();
  var tooltipDims = data.mapDimensionsAll("defaultedTooltip");
  var tooltipDimLen = tooltipDims.length;
  var value = series.getRawValue(dataIndex);
  var isValueArr = isArray$1(value);
  var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
  var inlineValue;
  var inlineValueType;
  var subBlocks;
  var sortParam;
  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
    var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
    inlineValue = formatArrResult.inlineValues;
    inlineValueType = formatArrResult.inlineValueTypes;
    subBlocks = formatArrResult.blocks;
    sortParam = formatArrResult.inlineValues[0];
  } else if (tooltipDimLen) {
    var dimInfo = data.getDimensionInfo(tooltipDims[0]);
    sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
    inlineValueType = dimInfo.type;
  } else {
    sortParam = inlineValue = isValueArr ? value[0] : value;
  }
  var seriesNameSpecified = isNameSpecified(series);
  var seriesName = seriesNameSpecified && series.name || "";
  var itemName = data.getName(dataIndex);
  var inlineName = multipleSeries ? seriesName : itemName;
  return createTooltipMarkup("section", {
    header: seriesName,
    noHeader: multipleSeries || !seriesNameSpecified,
    sortParam,
    blocks: [createTooltipMarkup("nameValue", {
      markerType: "item",
      markerColor,
      name: inlineName,
      noName: !trim$1(inlineName),
      value: inlineValue,
      valueType: inlineValueType
    })].concat(subBlocks || [])
  });
}
function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
  var data = series.getData();
  var isValueMultipleLine = reduce(value, function(isValueMultipleLine2, val, idx) {
    var dimItem = data.getDimensionInfo(idx);
    return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
  }, false);
  var inlineValues = [];
  var inlineValueTypes = [];
  var blocks = [];
  tooltipDims.length ? each$f(tooltipDims, function(dim) {
    setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
  }) : each$f(value, setEachItem);
  function setEachItem(val, dim) {
    var dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
      return;
    }
    if (isValueMultipleLine) {
      blocks.push(createTooltipMarkup("nameValue", {
        markerType: "subItem",
        markerColor: colorStr,
        name: dimInfo.displayName,
        value: val,
        valueType: dimInfo.type
      }));
    } else {
      inlineValues.push(val);
      inlineValueTypes.push(dimInfo.type);
    }
  }
  return {
    inlineValues,
    inlineValueTypes,
    blocks
  };
}
var inner$k = makeInner();
function getSelectionKey(data, dataIndex) {
  return data.getName(dataIndex) || data.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel = function(_super) {
  __extends(SeriesModel2, _super);
  function SeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._selectedDataIndicesMap = {};
    return _this;
  }
  SeriesModel2.prototype.init = function(option, parentModel, ecModel) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {
      model: this
    };
    this.mergeDefaultAndTheme(option, ecModel);
    var sourceManager = inner$k(this).sourceManager = new SourceManager(this);
    sourceManager.prepareSource();
    var data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;
    inner$k(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  };
  SeriesModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
    var layoutMode = fetchLayoutMode(this);
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeSubType = this.subType;
    if (ComponentModel$1.hasClass(themeSubType)) {
      themeSubType += "Series";
    }
    merge(option, ecModel.getTheme().get(this.subType));
    merge(option, this.getDefaultOption());
    defaultEmphasis(option, "label", ["show"]);
    this.fillDataTextStyle(option.data);
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  };
  SeriesModel2.prototype.mergeOption = function(newSeriesOption, ecModel) {
    newSeriesOption = merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }
    var sourceManager = inner$k(this).sourceManager;
    sourceManager.dirty();
    sourceManager.prepareSource();
    var data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner$k(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  };
  SeriesModel2.prototype.fillDataTextStyle = function(data) {
    if (data && !isTypedArray(data)) {
      var props = ["show"];
      for (var i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          defaultEmphasis(data[i], "label", props);
        }
      }
    }
  };
  SeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return;
  };
  SeriesModel2.prototype.appendData = function(params) {
    var data = this.getRawData();
    data.appendData(params.data);
  };
  SeriesModel2.prototype.getData = function(dataType) {
    var task = getCurrentTask(this);
    if (task) {
      var data = task.context.data;
      return dataType == null ? data : data.getLinkedData(dataType);
    } else {
      return inner$k(this).data;
    }
  };
  SeriesModel2.prototype.getAllData = function() {
    var mainData = this.getData();
    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
      data: mainData
    }];
  };
  SeriesModel2.prototype.setData = function(data) {
    var task = getCurrentTask(this);
    if (task) {
      var context = task.context;
      context.outputData = data;
      if (task !== this.dataTask) {
        context.data = data;
      }
    }
    inner$k(this).data = data;
  };
  SeriesModel2.prototype.getEncode = function() {
    var encode = this.get("encode", true);
    if (encode) {
      return createHashMap(encode);
    }
  };
  SeriesModel2.prototype.getSourceManager = function() {
    return inner$k(this).sourceManager;
  };
  SeriesModel2.prototype.getSource = function() {
    return this.getSourceManager().getSource();
  };
  SeriesModel2.prototype.getRawData = function() {
    return inner$k(this).dataBeforeProcessed;
  };
  SeriesModel2.prototype.getColorBy = function() {
    var colorBy = this.get("colorBy");
    return colorBy || "series";
  };
  SeriesModel2.prototype.isColorBySeries = function() {
    return this.getColorBy() === "series";
  };
  SeriesModel2.prototype.getBaseAxis = function() {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  };
  SeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    return defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
  };
  SeriesModel2.prototype.isAnimationEnabled = function() {
    var ecModel = this.ecModel;
    if (env$1.node && !(ecModel && ecModel.ssr)) {
      return false;
    }
    var animationEnabled = this.getShallow("animation");
    if (animationEnabled) {
      if (this.getData().count() > this.getShallow("animationThreshold")) {
        animationEnabled = false;
      }
    }
    return !!animationEnabled;
  };
  SeriesModel2.prototype.restoreData = function() {
    this.dataTask.dirty();
  };
  SeriesModel2.prototype.getColorFromPalette = function(name, scope, requestColorNum) {
    var ecModel = this.ecModel;
    var color = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
    if (!color) {
      color = ecModel.getColorFromPalette(name, scope, requestColorNum);
    }
    return color;
  };
  SeriesModel2.prototype.coordDimToDataDim = function(coordDim) {
    return this.getRawData().mapDimensionsAll(coordDim);
  };
  SeriesModel2.prototype.getProgressive = function() {
    return this.get("progressive");
  };
  SeriesModel2.prototype.getProgressiveThreshold = function() {
    return this.get("progressiveThreshold");
  };
  SeriesModel2.prototype.select = function(innerDataIndices, dataType) {
    this._innerSelect(this.getData(dataType), innerDataIndices);
  };
  SeriesModel2.prototype.unselect = function(innerDataIndices, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return;
    }
    var selectedMode = this.option.selectedMode;
    var data = this.getData(dataType);
    if (selectedMode === "series" || selectedMap === "all") {
      this.option.selectedMap = {};
      this._selectedDataIndicesMap = {};
      return;
    }
    for (var i = 0; i < innerDataIndices.length; i++) {
      var dataIndex = innerDataIndices[i];
      var nameOrId = getSelectionKey(data, dataIndex);
      selectedMap[nameOrId] = false;
      this._selectedDataIndicesMap[nameOrId] = -1;
    }
  };
  SeriesModel2.prototype.toggleSelect = function(innerDataIndices, dataType) {
    var tmpArr2 = [];
    for (var i = 0; i < innerDataIndices.length; i++) {
      tmpArr2[0] = innerDataIndices[i];
      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr2, dataType) : this.select(tmpArr2, dataType);
    }
  };
  SeriesModel2.prototype.getSelectedDataIndices = function() {
    if (this.option.selectedMap === "all") {
      return [].slice.call(this.getData().getIndices());
    }
    var selectedDataIndicesMap = this._selectedDataIndicesMap;
    var nameOrIds = keys(selectedDataIndicesMap);
    var dataIndices = [];
    for (var i = 0; i < nameOrIds.length; i++) {
      var dataIndex = selectedDataIndicesMap[nameOrIds[i]];
      if (dataIndex >= 0) {
        dataIndices.push(dataIndex);
      }
    }
    return dataIndices;
  };
  SeriesModel2.prototype.isSelected = function(dataIndex, dataType) {
    var selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return false;
    }
    var data = this.getData(dataType);
    return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
  };
  SeriesModel2.prototype.isUniversalTransitionEnabled = function() {
    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
      return true;
    }
    var universalTransitionOpt = this.option.universalTransition;
    if (!universalTransitionOpt) {
      return false;
    }
    if (universalTransitionOpt === true) {
      return true;
    }
    return universalTransitionOpt && universalTransitionOpt.enabled;
  };
  SeriesModel2.prototype._innerSelect = function(data, innerDataIndices) {
    var _a2, _b2;
    var option = this.option;
    var selectedMode = option.selectedMode;
    var len2 = innerDataIndices.length;
    if (!selectedMode || !len2) {
      return;
    }
    if (selectedMode === "series") {
      option.selectedMap = "all";
    } else if (selectedMode === "multiple") {
      if (!isObject$3(option.selectedMap)) {
        option.selectedMap = {};
      }
      var selectedMap = option.selectedMap;
      for (var i = 0; i < len2; i++) {
        var dataIndex = innerDataIndices[i];
        var nameOrId = getSelectionKey(data, dataIndex);
        selectedMap[nameOrId] = true;
        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
      }
    } else if (selectedMode === "single" || selectedMode === true) {
      var lastDataIndex = innerDataIndices[len2 - 1];
      var nameOrId = getSelectionKey(data, lastDataIndex);
      option.selectedMap = (_a2 = {}, _a2[nameOrId] = true, _a2);
      this._selectedDataIndicesMap = (_b2 = {}, _b2[nameOrId] = data.getRawIndex(lastDataIndex), _b2);
    }
  };
  SeriesModel2.prototype._initSelectedMapFromData = function(data) {
    if (this.option.selectedMap) {
      return;
    }
    var dataIndices = [];
    if (data.hasItemOption) {
      data.each(function(idx) {
        var rawItem = data.getRawDataItem(idx);
        if (rawItem && rawItem.selected) {
          dataIndices.push(idx);
        }
      });
    }
    if (dataIndices.length > 0) {
      this._innerSelect(data, dataIndices);
    }
  };
  SeriesModel2.registerClass = function(clz) {
    return ComponentModel$1.registerClass(clz);
  };
  SeriesModel2.protoInitialize = function() {
    var proto = SeriesModel2.prototype;
    proto.type = "series.__base__";
    proto.seriesIndex = 0;
    proto.ignoreStyleOnData = false;
    proto.hasSymbolVisual = false;
    proto.defaultSymbol = "circle";
    proto.visualStyleAccessPath = "itemStyle";
    proto.visualDrawType = "fill";
  }();
  return SeriesModel2;
}(ComponentModel$1);
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, ComponentModel$1);
function autoSeriesName(seriesModel) {
  var name = seriesModel.name;
  if (!isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name;
  }
}
function getSeriesAutoName(seriesModel) {
  var data = seriesModel.getRawData();
  var dataDims = data.mapDimensionsAll("seriesName");
  var nameArr = [];
  each$f(dataDims, function(dataDim) {
    var dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(" ");
}
function dataTaskCount(context) {
  return context.model.getRawData().count();
}
function dataTaskReset(context) {
  var seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}
function dataTaskProgress(param, context) {
  if (context.outputData && param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
}
function wrapData(data, seriesModel) {
  each$f(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
    data.wrapMethod(methodName, curry$1(onDataChange, seriesModel));
  });
}
function onDataChange(seriesModel, newList) {
  var task = getCurrentTask(seriesModel);
  if (task) {
    task.setOutputEnd((newList || this).count());
  }
  return newList;
}
function getCurrentTask(seriesModel) {
  var scheduler = (seriesModel.ecModel || {}).scheduler;
  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
  if (pipeline) {
    var task = pipeline.currentTask;
    if (task) {
      var agentStubMap = task.agentStubMap;
      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }
    return task;
  }
}
var SeriesModel$1 = SeriesModel;
var ComponentView = function() {
  function ComponentView2() {
    this.group = new Group$4();
    this.uid = getUID("viewComponent");
  }
  ComponentView2.prototype.init = function(ecModel, api) {
  };
  ComponentView2.prototype.render = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.dispose = function(ecModel, api) {
  };
  ComponentView2.prototype.updateView = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.updateLayout = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.updateVisual = function(model, ecModel, api, payload) {
  };
  ComponentView2.prototype.blurSeries = function(seriesModels, ecModel) {
  };
  ComponentView2.prototype.eachRendered = function(cb) {
    var group = this.group;
    if (group) {
      group.traverse(cb);
    }
  };
  return ComponentView2;
}();
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var ComponentView$1 = ComponentView;
function createRenderPlanner() {
  var inner2 = makeInner();
  return function(seriesModel) {
    var fields = inner2(seriesModel);
    var pipelineContext = seriesModel.pipelineContext;
    var originalLarge = !!fields.large;
    var originalProgressive = !!fields.progressiveRender;
    var large = fields.large = !!(pipelineContext && pipelineContext.large);
    var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
    return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
  };
}
var inner$j = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView = function() {
  function ChartView2() {
    this.group = new Group$4();
    this.uid = getUID("viewChart");
    this.renderTask = createTask({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {
      view: this
    };
  }
  ChartView2.prototype.init = function(ecModel, api) {
  };
  ChartView2.prototype.render = function(seriesModel, ecModel, api, payload) {
  };
  ChartView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      return;
    }
    toggleHighlight(data, payload, "emphasis");
  };
  ChartView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      return;
    }
    toggleHighlight(data, payload, "normal");
  };
  ChartView2.prototype.remove = function(ecModel, api) {
    this.group.removeAll();
  };
  ChartView2.prototype.dispose = function(ecModel, api) {
  };
  ChartView2.prototype.updateView = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateLayout = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.updateVisual = function(seriesModel, ecModel, api, payload) {
    this.render(seriesModel, ecModel, api, payload);
  };
  ChartView2.prototype.eachRendered = function(cb) {
    traverseElements(this.group, cb);
  };
  ChartView2.markUpdateMethod = function(payload, methodName) {
    inner$j(payload).updateMethod = methodName;
  };
  ChartView2.protoInitialize = function() {
    var proto = ChartView2.prototype;
    proto.type = "chart";
  }();
  return ChartView2;
}();
function elSetState(el, state, highlightDigit) {
  if (el && isHighDownDispatcher(el)) {
    (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
  }
}
function toggleHighlight(data, payload, state) {
  var dataIndex = queryDataIndex(data, payload);
  var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
  if (dataIndex != null) {
    each$f(normalizeToArray(dataIndex), function(dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data.eachItemGraphicEl(function(el) {
      elSetState(el, state, highlightDigit);
    });
  }
}
enableClassExtend(ChartView);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
  return renderPlanner(context.model);
}
function renderTaskReset(context) {
  var seriesModel = context.model;
  var ecModel = context.ecModel;
  var api = context.api;
  var payload = context.payload;
  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
  var view = context.view;
  var updateMethod = payload && inner$j(payload).updateMethod;
  var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
  if (methodName !== "render") {
    view[methodName](seriesModel, ecModel, api, payload);
  }
  return progressMethodMap[methodName];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    forceFirstProgress: true,
    progress: function(params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var ChartView$1 = ChartView;
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
function throttle(fn, delay, debounce2) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;
  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }
  var cb = function() {
    var cbArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      cbArgs[_i] = arguments[_i];
    }
    currCall = new Date().getTime();
    scope = this;
    args = cbArgs;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce2;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);
    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }
    lastCall = currCall;
  };
  cb.clear = function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  cb.debounceNextCall = function(debounceDelay) {
    debounceNextCall = debounceDelay;
  };
  return cb;
}
function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn = obj[fnAttr];
  if (!fn) {
    return;
  }
  var originFn = fn[ORIGIN_METHOD] || fn;
  var lastThrottleType = fn[THROTTLE_TYPE];
  var lastRate = fn[RATE];
  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }
    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }
  return fn;
}
function clear$1(obj, fnAttr) {
  var fn = obj[fnAttr];
  if (fn && fn[ORIGIN_METHOD]) {
    fn.clear && fn.clear();
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}
var inner$i = makeInner();
var defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
  var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
  if (!styleMapper) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return defaultStyleMappers.itemStyle;
  }
  return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
  var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
  if (!colorKey) {
    console.warn("Unkown style type '" + stylePath + "'.");
    return "fill";
  }
  return colorKey;
}
var seriesStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var styleModel = seriesModel.getModel(stylePath);
    var getStyle2 = getStyleMapper(seriesModel, stylePath);
    var globalStyle = getStyle2(styleModel);
    var decalOption = styleModel.getShallow("decal");
    if (decalOption) {
      data.setVisual("decal", decalOption);
      decalOption.dirty = true;
    }
    var colorKey = getDefaultColorKey(seriesModel, stylePath);
    var color = globalStyle[colorKey];
    var colorCallback = isFunction$1(color) ? color : null;
    var hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
    if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
      var colorPalette2 = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
      if (!globalStyle[colorKey]) {
        globalStyle[colorKey] = colorPalette2;
        data.setVisual("colorFromPalette", true);
      }
      globalStyle.fill = globalStyle.fill === "auto" || isFunction$1(globalStyle.fill) ? colorPalette2 : globalStyle.fill;
      globalStyle.stroke = globalStyle.stroke === "auto" || isFunction$1(globalStyle.stroke) ? colorPalette2 : globalStyle.stroke;
    }
    data.setVisual("style", globalStyle);
    data.setVisual("drawType", colorKey);
    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
      data.setVisual("colorFromPalette", false);
      return {
        dataEach: function(data2, idx) {
          var dataParams = seriesModel.getDataParams(idx);
          var itemStyle = extend$1({}, globalStyle);
          itemStyle[colorKey] = colorCallback(dataParams);
          data2.setItemVisual(idx, "style", itemStyle);
        }
      };
    }
  }
};
var sharedModel = new Model$1();
var dataStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    var getStyle2 = getStyleMapper(seriesModel, stylePath);
    var colorKey = data.getVisual("drawType");
    return {
      dataEach: data.hasItemOption ? function(data2, idx) {
        var rawItem = data2.getRawDataItem(idx);
        if (rawItem && rawItem[stylePath]) {
          sharedModel.option = rawItem[stylePath];
          var style = getStyle2(sharedModel);
          var existsStyle = data2.ensureUniqueItemVisual(idx, "style");
          extend$1(existsStyle, style);
          if (sharedModel.option.decal) {
            data2.setItemVisual(idx, "decal", sharedModel.option.decal);
            sharedModel.option.decal.dirty = true;
          }
          if (colorKey in style) {
            data2.setItemVisual(idx, "colorFromPalette", false);
          }
        }
      } : null
    };
  }
};
var dataColorPaletteTask = {
  performRawSeries: true,
  overallReset: function(ecModel) {
    var paletteScopeGroupByType = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var colorBy = seriesModel.getColorBy();
      if (seriesModel.isColorBySeries()) {
        return;
      }
      var key = seriesModel.type + "-" + colorBy;
      var colorScope = paletteScopeGroupByType.get(key);
      if (!colorScope) {
        colorScope = {};
        paletteScopeGroupByType.set(key, colorScope);
      }
      inner$i(seriesModel).scope = colorScope;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var dataAll = seriesModel.getRawData();
      var idxMap = {};
      var data = seriesModel.getData();
      var colorScope = inner$i(seriesModel).scope;
      var stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      var colorKey = getDefaultColorKey(seriesModel, stylePath);
      data.each(function(idx) {
        var rawIdx = data.getRawIndex(idx);
        idxMap[rawIdx] = idx;
      });
      dataAll.each(function(rawIdx) {
        var idx = idxMap[rawIdx];
        var fromPalette = data.getItemVisual(idx, "colorFromPalette");
        if (fromPalette) {
          var itemStyle = data.ensureUniqueItemVisual(idx, "style");
          var name_1 = dataAll.getName(rawIdx) || rawIdx + "";
          var dataCount = dataAll.count();
          itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
        }
      });
    });
  }
};
var PI$7 = Math.PI;
function defaultLoading(api, opts) {
  opts = opts || {};
  defaults(opts, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: true,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var group = new Group$4();
  var mask = new Rect$3({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 1e4
  });
  group.add(mask);
  var textContent = new ZRText$1({
    style: {
      text: opts.text,
      fill: opts.textColor,
      fontSize: opts.fontSize,
      fontWeight: opts.fontWeight,
      fontStyle: opts.fontStyle,
      fontFamily: opts.fontFamily
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  var labelRect = new Rect$3({
    style: {
      fill: "none"
    },
    textContent,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  var arc;
  if (opts.showSpinner) {
    arc = new Arc$1({
      shape: {
        startAngle: -PI$7 / 2,
        endAngle: -PI$7 / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: "round",
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc.animateShape(true).when(1e3, {
      endAngle: PI$7 * 3 / 2
    }).start("circularInOut");
    arc.animateShape(true).when(1e3, {
      startAngle: PI$7 * 3 / 2
    }).delay(300).start("circularInOut");
    group.add(arc);
  }
  group.resize = function() {
    var textWidth = textContent.getBoundingRect().width;
    var r = opts.showSpinner ? opts.spinnerRadius : 0;
    var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
    var cy = api.getHeight() / 2;
    opts.showSpinner && arc.setShape({
      cx,
      cy
    });
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  group.resize();
  return group;
}
var Scheduler = function() {
  function Scheduler2(ecInstance, api, dataProcessorHandlers, visualHandlers) {
    this._stageTaskMap = createHashMap();
    this.ecInstance = ecInstance;
    this.api = api;
    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  }
  Scheduler2.prototype.restoreData = function(ecModel, payload) {
    ecModel.restoreData(payload);
    this._stageTaskMap.each(function(taskRecord) {
      var overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  };
  Scheduler2.prototype.getPerformArgs = function(task, isBlock) {
    if (!task.__pipeline) {
      return;
    }
    var pipeline = this._pipelineMap.get(task.__pipeline.id);
    var pCtx = pipeline.context;
    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    var step = incremental ? pipeline.step : null;
    var modDataCount = pCtx && pCtx.modDataCount;
    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {
      step,
      modBy,
      modDataCount
    };
  };
  Scheduler2.prototype.getPipeline = function(pipelineId) {
    return this._pipelineMap.get(pipelineId);
  };
  Scheduler2.prototype.updateStreamModes = function(seriesModel, view) {
    var pipeline = this._pipelineMap.get(seriesModel.uid);
    var data = seriesModel.getData();
    var dataLen = data.count();
    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
    var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
    var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender,
      modDataCount,
      large
    };
  };
  Scheduler2.prototype.restorePipelines = function(ecModel) {
    var scheduler = this;
    var pipelineMap = scheduler._pipelineMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      var progressive = seriesModel.getProgressive();
      var pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });
      scheduler._pipe(seriesModel, seriesModel.dataTask);
    });
  };
  Scheduler2.prototype.prepareStageTasks = function() {
    var stageTaskMap = this._stageTaskMap;
    var ecModel = this.api.getModel();
    var api = this.api;
    each$f(this._allHandlers, function(handler) {
      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
      var errMsg = "";
      assert(!(handler.reset && handler.overallReset), errMsg);
      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
    }, this);
  };
  Scheduler2.prototype.prepareView = function(view, model, ecModel, api) {
    var renderTask = view.renderTask;
    var context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api;
    renderTask.__block = !view.incrementalPrepareRender;
    this._pipe(model, renderTask);
  };
  Scheduler2.prototype.performDataProcessorTasks = function(ecModel, payload) {
    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
      block: true
    });
  };
  Scheduler2.prototype.performVisualTasks = function(ecModel, payload, opt) {
    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
  };
  Scheduler2.prototype._performStageTasks = function(stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    var unfinished = false;
    var scheduler = this;
    each$f(stageHandlers, function(stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }
      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      var overallTask = stageHandlerRecord.overallTask;
      if (overallTask) {
        var overallNeedDirty_1;
        var agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function(stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty_1 = true;
          }
        });
        overallNeedDirty_1 && overallTask.dirty();
        scheduler.updatePayload(overallTask, payload);
        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
        agentStubMap.each(function(stub) {
          stub.perform(performArgs_1);
        });
        if (overallTask.perform(performArgs_1)) {
          unfinished = true;
        }
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function(task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }
          var performArgs = scheduler.getPerformArgs(task, opt.block);
          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          scheduler.updatePayload(task, payload);
          if (task.perform(performArgs)) {
            unfinished = true;
          }
        });
      }
    });
    function needSetDirty(opt2, task) {
      return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
    }
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.performSeriesTasks = function(ecModel) {
    var unfinished;
    ecModel.eachSeries(function(seriesModel) {
      unfinished = seriesModel.dataTask.perform() || unfinished;
    });
    this.unfinished = unfinished || this.unfinished;
  };
  Scheduler2.prototype.plan = function() {
    this._pipelineMap.each(function(pipeline) {
      var task = pipeline.tail;
      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }
        task = task.getUpstream();
      } while (task);
    });
  };
  Scheduler2.prototype.updatePayload = function(task, payload) {
    payload !== "remain" && (task.context.payload = payload);
  };
  Scheduler2.prototype._createSeriesStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
    var seriesType2 = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create2);
    } else if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, create2);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(create2);
    }
    function create2(seriesModel) {
      var pipelineId = seriesModel.uid;
      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel,
        api,
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler
      };
      scheduler._pipe(seriesModel, task);
    }
  };
  Scheduler2.prototype._createOverallStageTask = function(stageHandler, stageHandlerRecord, ecModel, api) {
    var scheduler = this;
    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
      reset: overallTaskReset
    });
    overallTask.context = {
      ecModel,
      api,
      overallReset: stageHandler.overallReset,
      scheduler
    };
    var oldAgentStubMap = overallTask.agentStubMap;
    var newAgentStubMap = overallTask.agentStubMap = createHashMap();
    var seriesType2 = stageHandler.seriesType;
    var getTargetSeries = stageHandler.getTargetSeries;
    var overallProgress = true;
    var shouldOverallTaskDirty = false;
    var errMsg = "";
    assert(!stageHandler.createOnAllSeries, errMsg);
    if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api).each(createStub);
    } else {
      overallProgress = false;
      each$f(ecModel.getSeries(), createStub);
    }
    function createStub(seriesModel) {
      var pipelineId = seriesModel.uid;
      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({
        reset: stubReset,
        onDirty: stubOnDirty
      })));
      stub.context = {
        model: seriesModel,
        overallProgress
      };
      stub.agent = overallTask;
      stub.__block = overallProgress;
      scheduler._pipe(seriesModel, stub);
    }
    if (shouldOverallTaskDirty) {
      overallTask.dirty();
    }
  };
  Scheduler2.prototype._pipe = function(seriesModel, task) {
    var pipelineId = seriesModel.uid;
    var pipeline = this._pipelineMap.get(pipelineId);
    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  };
  Scheduler2.wrapStageHandler = function(stageHandler, visualType) {
    if (isFunction$1(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }
    stageHandler.uid = getUID("stageHandler");
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  };
  return Scheduler2;
}();
function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
  return context.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }
  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map$1(resetDefines, function(v, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
  return function(params, context) {
    var data = context.data;
    var resetDefine = context.resetDefines[resetDefineIdx];
    if (resetDefine && resetDefine.dataEach) {
      for (var i = params.start; i < params.end; i++) {
        resetDefine.dataEach(data, i);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}
function seriesTaskCount(context) {
  return context.data.count();
}
function detectSeriseType(legacyFunc) {
  seriesType = null;
  try {
    legacyFunc(ecModelMock, apiMock);
  } catch (e2) {
  }
  return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, GlobalModel$1);
mockMethods(apiMock, ExtensionAPI$1);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
  seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
  if (cond.mainType === "series" && cond.subType) {
    seriesType = cond.subType;
  }
};
function mockMethods(target, Clz) {
  for (var name_1 in Clz.prototype) {
    target[name_1] = noop$1;
  }
}
var Scheduler$1 = Scheduler;
var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
var lightTheme = {
  color: colorAll,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
};
var contrastColor = "#B9B8CE";
var backgroundColor = "#100C2A";
var axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
};
var colorPalette = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"];
var theme = {
  darkMode: true,
  color: colorPalette,
  backgroundColor,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var darkTheme = theme;
var ECEventProcessor = function() {
  function ECEventProcessor2() {
  }
  ECEventProcessor2.prototype.normalizeQuery = function(query) {
    var cptQuery = {};
    var dataQuery = {};
    var otherQuery = {};
    if (isString(query)) {
      var condCptType = parseClassType(query);
      cptQuery.mainType = condCptType.main || null;
      cptQuery.subType = condCptType.sub || null;
    } else {
      var suffixes_1 = ["Index", "Name", "Id"];
      var dataKeys_1 = {
        name: 1,
        dataIndex: 1,
        dataType: 1
      };
      each$f(query, function(val, key) {
        var reserved = false;
        for (var i = 0; i < suffixes_1.length; i++) {
          var propSuffix = suffixes_1[i];
          var suffixPos = key.lastIndexOf(propSuffix);
          if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
            var mainType = key.slice(0, suffixPos);
            if (mainType !== "data") {
              cptQuery.mainType = mainType;
              cptQuery[propSuffix.toLowerCase()] = val;
              reserved = true;
            }
          }
        }
        if (dataKeys_1.hasOwnProperty(key)) {
          dataQuery[key] = val;
          reserved = true;
        }
        if (!reserved) {
          otherQuery[key] = val;
        }
      });
    }
    return {
      cptQuery,
      dataQuery,
      otherQuery
    };
  };
  ECEventProcessor2.prototype.filter = function(eventType, query) {
    var eventInfo = this.eventInfo;
    if (!eventInfo) {
      return true;
    }
    var targetEl = eventInfo.targetEl;
    var packedEvent = eventInfo.packedEvent;
    var model = eventInfo.model;
    var view = eventInfo.view;
    if (!model || !view) {
      return true;
    }
    var cptQuery = query.cptQuery;
    var dataQuery = query.dataQuery;
    return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
    function check(query2, host, prop, propOnHost) {
      return query2[prop] == null || host[propOnHost || prop] === query2[prop];
    }
  };
  ECEventProcessor2.prototype.afterTrigger = function() {
    this.eventInfo = null;
  };
  return ECEventProcessor2;
}();
var SYMBOL_PROPS_WITH_CB = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(["symbolKeepAspect"]);
var seriesSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    if (seriesModel.legendIcon) {
      data.setVisual("legendIcon", seriesModel.legendIcon);
    }
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    var symbolOptions = {};
    var symbolOptionsCb = {};
    var hasCallback = false;
    for (var i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
      var symbolPropName = SYMBOL_PROPS_WITH_CB[i];
      var val = seriesModel.get(symbolPropName);
      if (isFunction$1(val)) {
        hasCallback = true;
        symbolOptionsCb[symbolPropName] = val;
      } else {
        symbolOptions[symbolPropName] = val;
      }
    }
    symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
    data.setVisual(extend$1({
      legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
      symbolKeepAspect: seriesModel.get("symbolKeepAspect")
    }, symbolOptions));
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var symbolPropsCb = keys(symbolOptionsCb);
    function dataEach(data2, idx) {
      var rawValue = seriesModel.getRawValue(idx);
      var params = seriesModel.getDataParams(idx);
      for (var i2 = 0; i2 < symbolPropsCb.length; i2++) {
        var symbolPropName2 = symbolPropsCb[i2];
        data2.setItemVisual(idx, symbolPropName2, symbolOptionsCb[symbolPropName2](rawValue, params));
      }
    }
    return {
      dataEach: hasCallback ? dataEach : null
    };
  }
};
var dataSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    function dataEach(data2, idx) {
      var itemModel = data2.getItemModel(idx);
      for (var i = 0; i < SYMBOL_PROPS.length; i++) {
        var symbolPropName = SYMBOL_PROPS[i];
        var val = itemModel.getShallow(symbolPropName, true);
        if (val != null) {
          data2.setItemVisual(idx, symbolPropName, val);
        }
      }
    }
    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};
function getItemVisualFromData(data, dataIndex, key) {
  switch (key) {
    case "color":
      var style = data.getItemVisual(dataIndex, "style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getItemVisual(dataIndex, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getItemVisual(dataIndex, key);
  }
}
function getVisualFromData(data, key) {
  switch (key) {
    case "color":
      var style = data.getVisual("style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getVisual(key);
  }
}
function setItemVisualFromData(data, dataIndex, key, value) {
  switch (key) {
    case "color":
      var style = data.ensureUniqueItemVisual(dataIndex, "style");
      style[data.getVisual("drawType")] = value;
      data.setItemVisual(dataIndex, "colorFromPalette", false);
      break;
    case "opacity":
      data.ensureUniqueItemVisual(dataIndex, "style").opacity = value;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      data.setItemVisual(dataIndex, key, value);
      break;
  }
}
function createLegacyDataSelectAction(seriesType2, ecRegisterAction) {
  function getSeriesIndices(ecModel, payload) {
    var seriesIndices = [];
    ecModel.eachComponent({
      mainType: "series",
      subType: seriesType2,
      query: payload
    }, function(seriesModel) {
      seriesIndices.push(seriesModel.seriesIndex);
    });
    return seriesIndices;
  }
  each$f([[seriesType2 + "ToggleSelect", "toggleSelect"], [seriesType2 + "Select", "select"], [seriesType2 + "UnSelect", "unselect"]], function(eventsMap) {
    ecRegisterAction(eventsMap[0], function(payload, ecModel, api) {
      payload = extend$1({}, payload);
      api.dispatchAction(extend$1(payload, {
        type: eventsMap[1],
        seriesIndex: getSeriesIndices(ecModel, payload)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
  var legacyEventName = type + eventPostfix;
  if (!ecIns.isSilent(legacyEventName)) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(seriesModel) {
      var seriesIndex = seriesModel.seriesIndex;
      var selectedMap = seriesModel.option.selectedMap;
      var selected = payload.selected;
      for (var i = 0; i < selected.length; i++) {
        if (selected[i].seriesIndex === seriesIndex) {
          var data = seriesModel.getData();
          var dataIndex = queryDataIndex(data, payload.fromActionPayload);
          ecIns.trigger(legacyEventName, {
            type: legacyEventName,
            seriesId: seriesModel.id,
            name: isArray$1(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
            selected: isString(selectedMap) ? selectedMap : extend$1({}, selectedMap)
          });
        }
      }
    });
  }
}
function handleLegacySelectEvents(messageCenter, ecIns, api) {
  messageCenter.on("selectchanged", function(params) {
    var ecModel = api.getModel();
    if (params.isFromClick) {
      handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
    } else if (params.fromAction === "select") {
      handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
    } else if (params.fromAction === "unselect") {
      handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
    }
  });
}
function findEventDispatcher(target, det, returnFirstMatch) {
  var found;
  while (target) {
    if (det(target)) {
      found = target;
      if (returnFirstMatch) {
        break;
      }
    }
    target = target.__hostTarget || target.parent;
  }
  return found;
}
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap = function() {
  function WeakMap2() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  WeakMap2.prototype.get = function(key) {
    return this._guard(key)[this._id];
  };
  WeakMap2.prototype.set = function(key, value) {
    var target = this._guard(key);
    if (supportDefineProperty) {
      Object.defineProperty(target, this._id, {
        value,
        enumerable: false,
        configurable: true
      });
    } else {
      target[this._id] = value;
    }
    return this;
  };
  WeakMap2.prototype["delete"] = function(key) {
    if (this.has(key)) {
      delete this._guard(key)[this._id];
      return true;
    }
    return false;
  };
  WeakMap2.prototype.has = function(key) {
    return !!this._guard(key)[this._id];
  };
  WeakMap2.prototype._guard = function(key) {
    if (key !== Object(key)) {
      throw TypeError("Value of WeakMap is not a non-null object.");
    }
    return key;
  };
  return WeakMap2;
}();
var WeakMap$1 = WeakMap;
var Triangle = Path$1.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
var Diamond = Path$1.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var width = shape.width / 2;
    var height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
var Pin = Path$1.extend({
  type: "pin",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    var x = shape.x;
    var y = shape.y;
    var w = shape.width / 5 * 3;
    var h = Math.max(w, shape.height);
    var r = w / 2;
    var dy = r * r / (h - r);
    var cy = y - h + r + dy;
    var angle = Math.asin(dy / r);
    var dx = Math.cos(angle) * r;
    var tanX = Math.sin(angle);
    var tanY = Math.cos(angle);
    var cpLen = r * 0.6;
    var cpLen2 = r * 0.7;
    path.moveTo(x - dx, cy + dy);
    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
    path.closePath();
  }
});
var Arrow = Path$1.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(ctx, shape) {
    var height = shape.height;
    var width = shape.width;
    var x = shape.x;
    var y = shape.y;
    var dx = width / 3 * 2;
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + height);
    ctx.lineTo(x, y + height / 4 * 3);
    ctx.lineTo(x - dx, y + height);
    ctx.lineTo(x, y);
    ctx.closePath();
  }
});
var symbolCtors = {
  line: Line$3,
  rect: Rect$3,
  roundRect: Rect$3,
  square: Rect$3,
  circle: Circle$1,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function(x, y, w, h, shape) {
    shape.x1 = x;
    shape.y1 = y + h / 2;
    shape.x2 = x + w;
    shape.y2 = y + h / 2;
  },
  rect: function(x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
  },
  roundRect: function(x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
    shape.r = Math.min(w, h) / 4;
  },
  square: function(x, y, w, h, shape) {
    var size = Math.min(w, h);
    shape.x = x;
    shape.y = y;
    shape.width = size;
    shape.height = size;
  },
  circle: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.r = Math.min(w, h) / 2;
  },
  diamond: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  pin: function(x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  arrow: function(x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  triangle: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  }
};
var symbolBuildProxies = {};
each$f(symbolCtors, function(Ctor, name) {
  symbolBuildProxies[name] = new Ctor();
});
var SymbolClz$1 = Path$1.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(out2, config, rect) {
    var res = calculateTextPosition(out2, config, rect);
    var shape = this.shape;
    if (shape && shape.symbolType === "pin" && config.position === "inside") {
      res.y = rect.y + rect.height * 0.4;
    }
    return res;
  },
  buildPath: function(ctx, shape, inBundle) {
    var symbolType = shape.symbolType;
    if (symbolType !== "none") {
      var proxySymbol = symbolBuildProxies[symbolType];
      if (!proxySymbol) {
        symbolType = "rect";
        proxySymbol = symbolBuildProxies[symbolType];
      }
      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
});
function symbolPathSetColor(color, innerColor2) {
  if (this.type !== "image") {
    var symbolStyle = this.style;
    if (this.__isEmptyBrush) {
      symbolStyle.stroke = color;
      symbolStyle.fill = innerColor2 || "#fff";
      symbolStyle.lineWidth = 2;
    } else if (this.shape.symbolType === "line") {
      symbolStyle.stroke = color;
    } else {
      symbolStyle.fill = color;
    }
    this.markRedraw();
  }
}
function createSymbol$1(symbolType, x, y, w, h, color, keepAspect) {
  var isEmpty = symbolType.indexOf("empty") === 0;
  if (isEmpty) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }
  var symbolPath;
  if (symbolType.indexOf("image://") === 0) {
    symbolPath = makeImage(symbolType.slice(8), new BoundingRect$1(x, y, w, h), keepAspect ? "center" : "cover");
  } else if (symbolType.indexOf("path://") === 0) {
    symbolPath = makePath$1(symbolType.slice(7), {}, new BoundingRect$1(x, y, w, h), keepAspect ? "center" : "cover");
  } else {
    symbolPath = new SymbolClz$1({
      shape: {
        symbolType,
        x,
        y,
        width: w,
        height: h
      }
    });
  }
  symbolPath.__isEmptyBrush = isEmpty;
  symbolPath.setColor = symbolPathSetColor;
  if (color) {
    symbolPath.setColor(color);
  }
  return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
  if (!isArray$1(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }
  return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
  if (symbolOffset == null) {
    return;
  }
  if (!isArray$1(symbolOffset)) {
    symbolOffset = [symbolOffset, symbolOffset];
  }
  return [parsePercent$1(symbolOffset[0], symbolSize[0]) || 0, parsePercent$1(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0];
}
function createLinearGradient(ctx, obj, rect) {
  var x = obj.x == null ? 0 : obj.x;
  var x2 = obj.x2 == null ? 1 : obj.x2;
  var y = obj.y == null ? 0 : obj.y;
  var y2 = obj.y2 == null ? 0 : obj.y2;
  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  }
  x = isNaN(x) ? 0 : x;
  x2 = isNaN(x2) ? 1 : x2;
  y = isNaN(y) ? 0 : y;
  y2 = isNaN(y2) ? 0 : y2;
  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
  return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min3 = Math.min(width, height);
  var x = obj.x == null ? 0.5 : obj.x;
  var y = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min3;
  }
  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
  return canvasGradient;
}
function getCanvasGradient(ctx, obj, rect) {
  var canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
  var colorStops = obj.colorStops;
  for (var i = 0; i < colorStops.length; i++) {
    canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
  }
  return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
    return false;
  }
  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }
  for (var i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
  return false;
}
function parseInt10(val) {
  return parseInt(val, 10);
}
function getSize$1(root2, whIdx, opts) {
  var wh = ["width", "height"][whIdx];
  var cwh = ["clientWidth", "clientHeight"][whIdx];
  var plt = ["paddingLeft", "paddingTop"][whIdx];
  var prb = ["paddingRight", "paddingBottom"][whIdx];
  if (opts[wh] != null && opts[wh] !== "auto") {
    return parseFloat(opts[wh]);
  }
  var stl = document.defaultView.getComputedStyle(root2);
  return (root2[cwh] || parseInt10(stl[wh]) || parseInt10(root2.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
}
function normalizeLineDash(lineType, lineWidth) {
  if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
    return null;
  }
  return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber(lineType) ? [lineType] : isArray$1(lineType) ? lineType : null;
}
function getLineDash(el) {
  var style = el.style;
  var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
  var lineDashOffset = style.lineDashOffset;
  if (lineDash) {
    var lineScale_1 = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
    if (lineScale_1 && lineScale_1 !== 1) {
      lineDash = map$1(lineDash, function(rawVal) {
        return rawVal / lineScale_1;
      });
      lineDashOffset /= lineScale_1;
    }
  }
  return [lineDash, lineDashOffset];
}
var pathProxyForDraw = new PathProxy$1(true);
function styleHasStroke(style) {
  var stroke = style.stroke;
  return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
  return typeof strokeOrFill === "string" && strokeOrFill !== "none";
}
function styleHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== "none";
}
function doFillPath(ctx, style) {
  if (style.fillOpacity != null && style.fillOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.fillOpacity * style.opacity;
    ctx.fill();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.fill();
  }
}
function doStrokePath(ctx, style) {
  if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
    var originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.strokeOpacity * style.opacity;
    ctx.stroke();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.stroke();
  }
}
function createCanvasPattern(ctx, pattern, el) {
  var image = createOrUpdateImage(pattern.image, pattern.__image, el);
  if (isImageReady(image)) {
    var canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
    if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
      var matrix = new DOMMatrix();
      matrix.translateSelf(pattern.x || 0, pattern.y || 0);
      matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
      matrix.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
      canvasPattern.setTransform(matrix);
    }
    return canvasPattern;
  }
}
function brushPath(ctx, el, style, inBatch) {
  var _a2;
  var hasStroke = styleHasStroke(style);
  var hasFill = styleHasFill(style);
  var strokePercent = style.strokePercent;
  var strokePart = strokePercent < 1;
  var firstDraw = !el.path;
  if ((!el.silent || strokePart) && firstDraw) {
    el.createPathProxy();
  }
  var path = el.path || pathProxyForDraw;
  var dirtyFlag = el.__dirty;
  if (!inBatch) {
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    var fillGradient = void 0;
    var strokeGradient = void 0;
    var fillPattern = void 0;
    var strokePattern = void 0;
    var rect = void 0;
    if (hasFillGradient || hasStrokeGradient) {
      rect = el.getBoundingRect();
    }
    if (hasFillGradient) {
      fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
      el.__canvasFillGradient = fillGradient;
    }
    if (hasStrokeGradient) {
      strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
      el.__canvasStrokeGradient = strokeGradient;
    }
    if (hasFillPattern) {
      fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
      el.__canvasFillPattern = fillPattern;
    }
    if (hasStrokePattern) {
      strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
      el.__canvasStrokePattern = fillPattern;
    }
    if (hasFillGradient) {
      ctx.fillStyle = fillGradient;
    } else if (hasFillPattern) {
      if (fillPattern) {
        ctx.fillStyle = fillPattern;
      } else {
        hasFill = false;
      }
    }
    if (hasStrokeGradient) {
      ctx.strokeStyle = strokeGradient;
    } else if (hasStrokePattern) {
      if (strokePattern) {
        ctx.strokeStyle = strokePattern;
      } else {
        hasStroke = false;
      }
    }
  }
  var scale2 = el.getGlobalScale();
  path.setScale(scale2[0], scale2[1], el.segmentIgnoreThreshold);
  var lineDash;
  var lineDashOffset;
  if (ctx.setLineDash && style.lineDash) {
    _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
  }
  var needsRebuild = true;
  if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
    path.setDPR(ctx.dpr);
    if (strokePart) {
      path.setContext(null);
    } else {
      path.setContext(ctx);
      needsRebuild = false;
    }
    path.reset();
    el.buildPath(path, el.shape, inBatch);
    path.toStatic();
    el.pathUpdated();
  }
  if (needsRebuild) {
    path.rebuildPath(ctx, strokePart ? strokePercent : 1);
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
    ctx.lineDashOffset = lineDashOffset;
  }
  if (!inBatch) {
    if (style.strokeFirst) {
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
      if (hasFill) {
        doFillPath(ctx, style);
      }
    } else {
      if (hasFill) {
        doFillPath(ctx, style);
      }
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
    }
  }
  if (lineDash) {
    ctx.setLineDash([]);
  }
}
function brushImage(ctx, el, style) {
  var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
  if (!image || !isImageReady(image)) {
    return;
  }
  var x = style.x || 0;
  var y = style.y || 0;
  var width = el.getWidth();
  var height = el.getHeight();
  var aspect = image.width / image.height;
  if (width == null && height != null) {
    width = height * aspect;
  } else if (height == null && width != null) {
    height = width / aspect;
  } else if (width == null && height == null) {
    width = image.width;
    height = image.height;
  }
  if (style.sWidth && style.sHeight) {
    var sx = style.sx || 0;
    var sy = style.sy || 0;
    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
  } else if (style.sx && style.sy) {
    var sx = style.sx;
    var sy = style.sy;
    var sWidth = width - sx;
    var sHeight = height - sy;
    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
  } else {
    ctx.drawImage(image, x, y, width, height);
  }
}
function brushText(ctx, el, style) {
  var _a2;
  var text = style.text;
  text != null && (text += "");
  if (text) {
    ctx.font = style.font || DEFAULT_FONT;
    ctx.textAlign = style.textAlign;
    ctx.textBaseline = style.textBaseline;
    var lineDash = void 0;
    var lineDashOffset = void 0;
    if (ctx.setLineDash && style.lineDash) {
      _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (style.strokeFirst) {
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
    } else {
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
  var styleChanged = false;
  if (!forceSetAll) {
    prevStyle = prevStyle || {};
    if (style === prevStyle) {
      return false;
    }
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    flushPathDrawn(ctx, scope);
    styleChanged = true;
    var opacity = Math.max(Math.min(style.opacity, 1), 0);
    ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
  }
  if (forceSetAll || style.blend !== prevStyle.blend) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
  }
  for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
    var propName = SHADOW_NUMBER_PROPS[i];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = ctx.dpr * (style[propName] || 0);
    }
  }
  if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
  }
  return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
  var style = getStyle(el, scope.inHover);
  var prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
  if (style === prevStyle) {
    return false;
  }
  var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
  if (forceSetAll || style.fill !== prevStyle.fill) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
  }
  if (forceSetAll || style.stroke !== prevStyle.stroke) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
  }
  if (el.hasStroke()) {
    var lineWidth = style.lineWidth;
    var newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
    if (ctx.lineWidth !== newLineWidth) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.lineWidth = newLineWidth;
    }
  }
  for (var i = 0; i < STROKE_PROPS.length; i++) {
    var prop = STROKE_PROPS[i];
    var propName = prop[0];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = style[propName] || prop[1];
    }
  }
  return styleChanged;
}
function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
  return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el) {
  var m2 = el.transform;
  var dpr2 = ctx.dpr || 1;
  if (m2) {
    ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
  } else {
    ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
  }
}
function updateClipStatus(clipPaths, ctx, scope) {
  var allClipped = false;
  for (var i = 0; i < clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    allClipped = allClipped || clipPath.isZeroArea();
    setContextTransform(ctx, clipPath);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip();
  }
  scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
  if (m0 && m1) {
    return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
  } else if (!m0 && !m1) {
    return false;
  }
  return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
  var hasFill = styleHasFill(style);
  var hasStroke = styleHasStroke(style);
  return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
  scope.batchFill && ctx.fill();
  scope.batchStroke && ctx.stroke();
  scope.batchFill = "";
  scope.batchStroke = "";
}
function getStyle(el, inHover) {
  return inHover ? el.__hoverStyle || el.style : el.style;
}
function brushSingle(ctx, el) {
  brush$1(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
}
function brush$1(ctx, el, scope, isLast) {
  var m2 = el.transform;
  if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
    el.__dirty &= ~REDRAW_BIT;
    el.__isRendered = false;
    return;
  }
  var clipPaths = el.__clipPaths;
  var prevElClipPaths = scope.prevElClipPaths;
  var forceSetTransform = false;
  var forceSetStyle = false;
  if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
    if (prevElClipPaths && prevElClipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.restore();
      forceSetStyle = forceSetTransform = true;
      scope.prevElClipPaths = null;
      scope.allClipped = false;
      scope.prevEl = null;
    }
    if (clipPaths && clipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.save();
      updateClipStatus(clipPaths, ctx, scope);
      forceSetTransform = true;
    }
    scope.prevElClipPaths = clipPaths;
  }
  if (scope.allClipped) {
    el.__isRendered = false;
    return;
  }
  el.beforeBrush && el.beforeBrush();
  el.innerBeforeBrush();
  var prevEl = scope.prevEl;
  if (!prevEl) {
    forceSetStyle = forceSetTransform = true;
  }
  var canBatchPath = el instanceof Path$1 && el.autoBatch && canPathBatch(el.style);
  if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
    flushPathDrawn(ctx, scope);
    setContextTransform(ctx, el);
  } else if (!canBatchPath) {
    flushPathDrawn(ctx, scope);
  }
  var style = getStyle(el, scope.inHover);
  if (el instanceof Path$1) {
    if (scope.lastDrawType !== DRAW_TYPE_PATH) {
      forceSetStyle = true;
      scope.lastDrawType = DRAW_TYPE_PATH;
    }
    bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
    if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
      ctx.beginPath();
    }
    brushPath(ctx, el, style, canBatchPath);
    if (canBatchPath) {
      scope.batchFill = style.fill || "";
      scope.batchStroke = style.stroke || "";
    }
  } else {
    if (el instanceof TSpan$1) {
      if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_TEXT;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushText(ctx, el, style);
    } else if (el instanceof ZRImage$1) {
      if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_IMAGE;
      }
      bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushImage(ctx, el, style);
    } else if (el.getTemporalDisplayables) {
      if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
      }
      brushIncremental(ctx, el, scope);
    }
  }
  if (canBatchPath && isLast) {
    flushPathDrawn(ctx, scope);
  }
  el.innerAfterBrush();
  el.afterBrush && el.afterBrush();
  scope.prevEl = el;
  el.__dirty = 0;
  el.__isRendered = true;
}
function brushIncremental(ctx, el, scope) {
  var displayables = el.getDisplayables();
  var temporalDisplayables = el.getTemporalDisplayables();
  ctx.save();
  var innerScope = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: false,
    viewWidth: scope.viewWidth,
    viewHeight: scope.viewHeight,
    inHover: scope.inHover
  };
  var i;
  var len2;
  for (i = el.getCursor(), len2 = displayables.length; i < len2; i++) {
    var displayable = displayables[i];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush$1(ctx, displayable, innerScope, i === len2 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
    var displayable = temporalDisplayables[i_1];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush$1(ctx, displayable, innerScope, i_1 === len_1 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  el.clearTemporalDisplayables();
  el.notClear = true;
  ctx.restore();
}
var decalMap = new WeakMap$1();
var decalCache = new LRUCache$1(100);
var decalKeys = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function createOrUpdatePatternFromDecal(decalObject, api) {
  if (decalObject === "none") {
    return null;
  }
  var dpr2 = api.getDevicePixelRatio();
  var zr = api.getZr();
  var isSVG = zr.painter.type === "svg";
  if (decalObject.dirty) {
    decalMap["delete"](decalObject);
  }
  var oldPattern = decalMap.get(decalObject);
  if (oldPattern) {
    return oldPattern;
  }
  var decalOpt = defaults(decalObject, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: true,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  if (decalOpt.backgroundColor === "none") {
    decalOpt.backgroundColor = null;
  }
  var pattern = {
    repeat: "repeat"
  };
  setPatternnSource(pattern);
  pattern.rotation = decalOpt.rotation;
  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
  decalMap.set(decalObject, pattern);
  decalObject.dirty = false;
  return pattern;
  function setPatternnSource(pattern2) {
    var keys2 = [dpr2];
    var isValidKey = true;
    for (var i = 0; i < decalKeys.length; ++i) {
      var value = decalOpt[decalKeys[i]];
      if (value != null && !isArray$1(value) && !isString(value) && !isNumber(value) && typeof value !== "boolean") {
        isValidKey = false;
        break;
      }
      keys2.push(value);
    }
    var cacheKey;
    if (isValidKey) {
      cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
      var cache2 = decalCache.get(cacheKey);
      if (cache2) {
        isSVG ? pattern2.svgElement = cache2 : pattern2.image = cache2;
      }
    }
    var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
    var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
    var symbolArray = normalizeSymbolArray(decalOpt.symbol);
    var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
    var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
    var canvas = !isSVG && platformApi.createCanvas();
    var svgRoot = isSVG && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    };
    var pSize = getPatternSize();
    var ctx;
    if (canvas) {
      canvas.width = pSize.width * dpr2;
      canvas.height = pSize.height * dpr2;
      ctx = canvas.getContext("2d");
    }
    brushDecal();
    if (isValidKey) {
      decalCache.put(cacheKey, canvas || svgRoot);
    }
    pattern2.image = canvas;
    pattern2.svgElement = svgRoot;
    pattern2.svgWidth = pSize.width;
    pattern2.svgHeight = pSize.height;
    function getPatternSize() {
      var width = 1;
      for (var i2 = 0, xlen = lineBlockLengthsX.length; i2 < xlen; ++i2) {
        width = getLeastCommonMultiple(width, lineBlockLengthsX[i2]);
      }
      var symbolRepeats = 1;
      for (var i2 = 0, xlen = symbolArray.length; i2 < xlen; ++i2) {
        symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i2].length);
      }
      width *= symbolRepeats;
      var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
      return {
        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
      };
    }
    function brushDecal() {
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (decalOpt.backgroundColor) {
          ctx.fillStyle = decalOpt.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
      var ySum = 0;
      for (var i2 = 0; i2 < dashArrayY.length; ++i2) {
        ySum += dashArrayY[i2];
      }
      if (ySum <= 0) {
        return;
      }
      var y = -lineBlockLengthY;
      var yId = 0;
      var yIdTotal = 0;
      var xId0 = 0;
      while (y < pSize.height) {
        if (yId % 2 === 0) {
          var symbolYId = yIdTotal / 2 % symbolArray.length;
          var x = 0;
          var xId1 = 0;
          var xId1Total = 0;
          while (x < pSize.width * 2) {
            var xSum = 0;
            for (var i2 = 0; i2 < dashArrayX[xId0].length; ++i2) {
              xSum += dashArrayX[xId0][i2];
            }
            if (xSum <= 0) {
              break;
            }
            if (xId1 % 2 === 0) {
              var size = (1 - decalOpt.symbolSize) * 0.5;
              var left = x + dashArrayX[xId0][xId1] * size;
              var top_1 = y + dashArrayY[yId] * size;
              var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
              var height = dashArrayY[yId] * decalOpt.symbolSize;
              var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
              brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
            }
            x += dashArrayX[xId0][xId1];
            ++xId1Total;
            ++xId1;
            if (xId1 === dashArrayX[xId0].length) {
              xId1 = 0;
            }
          }
          ++xId0;
          if (xId0 === dashArrayX.length) {
            xId0 = 0;
          }
        }
        y += dashArrayY[yId];
        ++yIdTotal;
        ++yId;
        if (yId === dashArrayY.length) {
          yId = 0;
        }
      }
      function brushSymbol(x2, y2, width2, height2, symbolType) {
        var scale2 = isSVG ? 1 : dpr2;
        var symbol = createSymbol$1(symbolType, x2 * scale2, y2 * scale2, width2 * scale2, height2 * scale2, decalOpt.color, decalOpt.symbolKeepAspect);
        if (isSVG) {
          var symbolVNode = zr.painter.renderOneToVNode(symbol);
          if (symbolVNode) {
            svgRoot.children.push(symbolVNode);
          }
        } else {
          brushSingle(ctx, symbol);
        }
      }
    }
  }
}
function normalizeSymbolArray(symbol) {
  if (!symbol || symbol.length === 0) {
    return [["rect"]];
  }
  if (isString(symbol)) {
    return [[symbol]];
  }
  var isAllString = true;
  for (var i = 0; i < symbol.length; ++i) {
    if (!isString(symbol[i])) {
      isAllString = false;
      break;
    }
  }
  if (isAllString) {
    return normalizeSymbolArray([symbol]);
  }
  var result = [];
  for (var i = 0; i < symbol.length; ++i) {
    if (isString(symbol[i])) {
      result.push([symbol[i]]);
    } else {
      result.push(symbol[i]);
    }
  }
  return result;
}
function normalizeDashArrayX(dash) {
  if (!dash || dash.length === 0) {
    return [[0, 0]];
  }
  if (isNumber(dash)) {
    var dashValue = Math.ceil(dash);
    return [[dashValue, dashValue]];
  }
  var isAllNumber = true;
  for (var i = 0; i < dash.length; ++i) {
    if (!isNumber(dash[i])) {
      isAllNumber = false;
      break;
    }
  }
  if (isAllNumber) {
    return normalizeDashArrayX([dash]);
  }
  var result = [];
  for (var i = 0; i < dash.length; ++i) {
    if (isNumber(dash[i])) {
      var dashValue = Math.ceil(dash[i]);
      result.push([dashValue, dashValue]);
    } else {
      var dashValue = map$1(dash[i], function(n) {
        return Math.ceil(n);
      });
      if (dashValue.length % 2 === 1) {
        result.push(dashValue.concat(dashValue));
      } else {
        result.push(dashValue);
      }
    }
  }
  return result;
}
function normalizeDashArrayY(dash) {
  if (!dash || typeof dash === "object" && dash.length === 0) {
    return [0, 0];
  }
  if (isNumber(dash)) {
    var dashValue_1 = Math.ceil(dash);
    return [dashValue_1, dashValue_1];
  }
  var dashValue = map$1(dash, function(n) {
    return Math.ceil(n);
  });
  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
function getLineBlockLengthX(dash) {
  return map$1(dash, function(line) {
    return getLineBlockLengthY(line);
  });
}
function getLineBlockLengthY(dash) {
  var blockLength = 0;
  for (var i = 0; i < dash.length; ++i) {
    blockLength += dash[i];
  }
  if (dash.length % 2 === 1) {
    return blockLength * 2;
  }
  return blockLength;
}
function decalVisual(ecModel, api) {
  ecModel.eachRawSeries(function(seriesModel) {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var data = seriesModel.getData();
    if (data.hasItemVisual()) {
      data.each(function(idx) {
        var decal2 = data.getItemVisual(idx, "decal");
        if (decal2) {
          var itemStyle = data.ensureUniqueItemVisual(idx, "style");
          itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api);
        }
      });
    }
    var decal = data.getVisual("decal");
    if (decal) {
      var style = data.getVisual("style");
      style.decal = createOrUpdatePatternFromDecal(decal, api);
    }
  });
}
var lifecycle = new Eventful$1();
var lifecycle$1 = lifecycle;
var implsStore = {};
function registerImpl(name, impl) {
  implsStore[name] = impl;
}
function getImpl(name) {
  return implsStore[name];
}
var hasWindow = typeof window !== "undefined";
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1e3;
var PRIORITY_PROCESSOR_DEFAULT = 2e3;
var PRIORITY_PROCESSOR_STATISTIC = 5e3;
var PRIORITY_VISUAL_LAYOUT = 1e3;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2e3;
var PRIORITY_VISUAL_CHART = 3e3;
var PRIORITY_VISUAL_COMPONENT = 4e3;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5e3;
var PRIORITY_VISUAL_ARIA = 6e3;
var PRIORITY_VISUAL_DECAL = 7e3;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = "__connectUpdateStatus";
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(method) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function createRegisterEventWithLowercaseMessageCenter(method) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function toLowercaseNameAndCallEventful(host, method, args) {
  args[0] = args[0] && args[0].toLowerCase();
  return Eventful$1.prototype[method].apply(host, args);
}
var MessageCenter = function(_super) {
  __extends(MessageCenter2, _super);
  function MessageCenter2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return MessageCenter2;
}(Eventful$1);
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;
var ECharts = function(_super) {
  __extends(ECharts2, _super);
  function ECharts2(dom, theme2, opts) {
    var _this = _super.call(this, new ECEventProcessor()) || this;
    _this._chartsViews = [];
    _this._chartsMap = {};
    _this._componentsViews = [];
    _this._componentsMap = {};
    _this._pendingActions = [];
    opts = opts || {};
    if (isString(theme2)) {
      theme2 = themeStorage[theme2];
    }
    _this._dom = dom;
    var defaultRenderer = "canvas";
    var defaultUseDirtyRect = false;
    var zr = _this._zr = init$2(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height,
      ssr: opts.ssr,
      useDirtyRect: opts.useDirtyRect == null ? defaultUseDirtyRect : opts.useDirtyRect
    });
    _this._ssr = opts.ssr;
    _this._throttledZrFlush = throttle(bind$1(zr.flush, zr), 17);
    theme2 = clone$4(theme2);
    theme2 && globalBackwardCompat(theme2, true);
    _this._theme = theme2;
    _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
    _this._coordSysMgr = new CoordinateSystem();
    var api = _this._api = createExtensionAPI(_this);
    function prioritySortFunc(a, b) {
      return a.__prio - b.__prio;
    }
    sort$2(visualFuncs, prioritySortFunc);
    sort$2(dataProcessorFuncs, prioritySortFunc);
    _this._scheduler = new Scheduler$1(_this, api, dataProcessorFuncs, visualFuncs);
    _this._messageCenter = new MessageCenter();
    _this._initEvents();
    _this.resize = bind$1(_this.resize, _this);
    zr.animation.on("frame", _this._onframe, _this);
    bindRenderedEvent(zr, _this);
    bindMouseEvent(zr, _this);
    setAsPrimitive(_this);
    return _this;
  }
  ECharts2.prototype._onframe = function() {
    if (this._disposed) {
      return;
    }
    applyChangedStates(this);
    var scheduler = this._scheduler;
    if (this[PENDING_UPDATE]) {
      var silent = this[PENDING_UPDATE].silent;
      this[IN_MAIN_PROCESS_KEY] = true;
      try {
        prepare(this);
        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
      } catch (e2) {
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        throw e2;
      }
      this._zr.flush();
      this[IN_MAIN_PROCESS_KEY] = false;
      this[PENDING_UPDATE] = null;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } else if (scheduler.unfinished) {
      var remainTime = TEST_FRAME_REMAIN_TIME;
      var ecModel = this._model;
      var api = this._api;
      scheduler.unfinished = false;
      do {
        var startTime = +new Date();
        scheduler.performSeriesTasks(ecModel);
        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel);
        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api, "remain", {});
        remainTime -= +new Date() - startTime;
      } while (remainTime > 0 && scheduler.unfinished);
      if (!scheduler.unfinished) {
        this._zr.flush();
      }
    }
  };
  ECharts2.prototype.getDom = function() {
    return this._dom;
  };
  ECharts2.prototype.getId = function() {
    return this.id;
  };
  ECharts2.prototype.getZr = function() {
    return this._zr;
  };
  ECharts2.prototype.isSSR = function() {
    return this._ssr;
  };
  ECharts2.prototype.setOption = function(option, notMerge, lazyUpdate) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var silent;
    var replaceMerge;
    var transitionOpt;
    if (isObject$3(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      replaceMerge = notMerge.replaceMerge;
      transitionOpt = notMerge.transition;
      notMerge = notMerge.notMerge;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    if (!this._model || notMerge) {
      var optionManager = new OptionManager$1(this._api);
      var theme2 = this._theme;
      var ecModel = this._model = new GlobalModel$1();
      ecModel.scheduler = this._scheduler;
      ecModel.ssr = this._ssr;
      ecModel.init(null, null, null, theme2, this._locale, optionManager);
    }
    this._model.setOption(option, {
      replaceMerge
    }, optionPreprocessorFuncs);
    var updateParams = {
      seriesTransition: transitionOpt,
      optionChanged: true
    };
    if (lazyUpdate) {
      this[PENDING_UPDATE] = {
        silent,
        updateParams
      };
      this[IN_MAIN_PROCESS_KEY] = false;
      this.getZr().wakeUp();
    } else {
      try {
        prepare(this);
        updateMethods.update.call(this, null, updateParams);
      } catch (e2) {
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e2;
      }
      if (!this._ssr) {
        this._zr.flush();
      }
      this[PENDING_UPDATE] = null;
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  };
  ECharts2.prototype.setTheme = function() {
  };
  ECharts2.prototype.getModel = function() {
    return this._model;
  };
  ECharts2.prototype.getOption = function() {
    return this._model && this._model.getOption();
  };
  ECharts2.prototype.getWidth = function() {
    return this._zr.getWidth();
  };
  ECharts2.prototype.getHeight = function() {
    return this._zr.getHeight();
  };
  ECharts2.prototype.getDevicePixelRatio = function() {
    return this._zr.painter.dpr || hasWindow && window.devicePixelRatio || 1;
  };
  ECharts2.prototype.getRenderedCanvas = function(opts) {
    return this.renderToCanvas(opts);
  };
  ECharts2.prototype.renderToCanvas = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    return painter.getRenderedCanvas({
      backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
    });
  };
  ECharts2.prototype.renderToSVGString = function(opts) {
    opts = opts || {};
    var painter = this._zr.painter;
    return painter.renderToString({
      useViewBox: opts.useViewBox
    });
  };
  ECharts2.prototype.getSvgDataURL = function() {
    if (!env$1.svgSupported) {
      return;
    }
    var zr = this._zr;
    var list = zr.storage.getDisplayList();
    each$f(list, function(el) {
      el.stopAnimation(null, true);
    });
    return zr.painter.toDataURL();
  };
  ECharts2.prototype.getDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self2 = this;
    each$f(excludeComponents, function(componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function(component) {
        var view = self2._componentsMap[component.__viewId];
        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
    each$f(excludesComponentViews, function(view) {
      view.group.ignore = false;
    });
    return url;
  };
  ECharts2.prototype.getConnectedDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var isSvg = opts.type === "svg";
    var groupId = this.group;
    var mathMin2 = Math.min;
    var mathMax2 = Math.max;
    var MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      var left_1 = MAX_NUMBER;
      var top_1 = MAX_NUMBER;
      var right_1 = -MAX_NUMBER;
      var bottom_1 = -MAX_NUMBER;
      var canvasList_1 = [];
      var dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio();
      each$f(instances, function(chart, id) {
        if (chart.group === groupId) {
          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone$4(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left_1 = mathMin2(boundingRect.left, left_1);
          top_1 = mathMin2(boundingRect.top, top_1);
          right_1 = mathMax2(boundingRect.right, right_1);
          bottom_1 = mathMax2(boundingRect.bottom, bottom_1);
          canvasList_1.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left_1 *= dpr_1;
      top_1 *= dpr_1;
      right_1 *= dpr_1;
      bottom_1 *= dpr_1;
      var width = right_1 - left_1;
      var height = bottom_1 - top_1;
      var targetCanvas = platformApi.createCanvas();
      var zr_1 = init$2(targetCanvas, {
        renderer: isSvg ? "svg" : "canvas"
      });
      zr_1.resize({
        width,
        height
      });
      if (isSvg) {
        var content_1 = "";
        each$f(canvasList_1, function(item) {
          var x = item.left - left_1;
          var y = item.top - top_1;
          content_1 += '<g transform="translate(' + x + "," + y + ')">' + item.dom + "</g>";
        });
        zr_1.painter.getSvgRoot().innerHTML = content_1;
        if (opts.connectedBackgroundColor) {
          zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }
        zr_1.refreshImmediately();
        return zr_1.painter.toDataURL();
      } else {
        if (opts.connectedBackgroundColor) {
          zr_1.add(new Rect$3({
            shape: {
              x: 0,
              y: 0,
              width,
              height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }
        each$f(canvasList_1, function(item) {
          var img = new ZRImage$1({
            style: {
              x: item.left * dpr_1 - left_1,
              y: item.top * dpr_1 - top_1,
              image: item.dom
            }
          });
          zr_1.add(img);
        });
        zr_1.refreshImmediately();
        return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
      }
    } else {
      return this.getDataURL(opts);
    }
  };
  ECharts2.prototype.convertToPixel = function(finder, value) {
    return doConvertPixel(this, "convertToPixel", finder, value);
  };
  ECharts2.prototype.convertFromPixel = function(finder, value) {
    return doConvertPixel(this, "convertFromPixel", finder, value);
  };
  ECharts2.prototype.containPixel = function(finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var ecModel = this._model;
    var result;
    var findResult = parseFinder$1(ecModel, finder);
    each$f(findResult, function(models, key) {
      key.indexOf("Models") >= 0 && each$f(models, function(model) {
        var coordSys = model.coordinateSystem;
        if (coordSys && coordSys.containPoint) {
          result = result || !!coordSys.containPoint(value);
        } else if (key === "seriesModels") {
          var view = this._chartsMap[model.__viewId];
          if (view && view.containPoint) {
            result = result || view.containPoint(value, model);
          }
        } else
          ;
      }, this);
    }, this);
    return !!result;
  };
  ECharts2.prototype.getVisual = function(finder, visualType) {
    var ecModel = this._model;
    var parsedFinder = parseFinder$1(ecModel, finder, {
      defaultMainType: "series"
    });
    var seriesModel = parsedFinder.seriesModel;
    var data = seriesModel.getData();
    var dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
    return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
  };
  ECharts2.prototype.getViewOfComponentModel = function(componentModel) {
    return this._componentsMap[componentModel.__viewId];
  };
  ECharts2.prototype.getViewOfSeriesModel = function(seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  };
  ECharts2.prototype._initEvents = function() {
    var _this = this;
    each$f(MOUSE_EVENT_NAMES, function(eveName) {
      var handler = function(e2) {
        var ecModel = _this.getModel();
        var el = e2.target;
        var params;
        var isGlobalOut = eveName === "globalout";
        if (isGlobalOut) {
          params = {};
        } else {
          el && findEventDispatcher(el, function(parent) {
            var ecData = getECData(parent);
            if (ecData && ecData.dataIndex != null) {
              var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {};
              return true;
            } else if (ecData.eventData) {
              params = extend$1({}, ecData.eventData);
              return true;
            }
          }, true);
        }
        if (params) {
          var componentType = params.componentType;
          var componentIndex = params.componentIndex;
          if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
            componentType = "series";
            componentIndex = params.seriesIndex;
          }
          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          var view = model && _this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
          params.event = e2;
          params.type = eveName;
          _this._$eventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model,
            view
          };
          _this.trigger(eveName, params);
        }
      };
      handler.zrEventfulCallAtLast = true;
      _this._zr.on(eveName, handler, _this);
    });
    each$f(eventActionMap, function(actionType, eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    each$f(["selectchanged"], function(eventType) {
      _this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, _this);
    });
    handleLegacySelectEvents(this._messageCenter, this, this._api);
  };
  ECharts2.prototype.isDisposed = function() {
    return this._disposed;
  };
  ECharts2.prototype.clear = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this.setOption({
      series: []
    }, true);
  };
  ECharts2.prototype.dispose = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._disposed = true;
    var dom = this.getDom();
    if (dom) {
      setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
    }
    var chart = this;
    var api = chart._api;
    var ecModel = chart._model;
    each$f(chart._componentsViews, function(component) {
      component.dispose(ecModel, api);
    });
    each$f(chart._chartsViews, function(chart2) {
      chart2.dispose(ecModel, api);
    });
    chart._zr.dispose();
    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
    delete instances[chart.id];
  };
  ECharts2.prototype.resize = function(opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._zr.resize(opts);
    var ecModel = this._model;
    this._loadingFX && this._loadingFX.resize();
    if (!ecModel) {
      return;
    }
    var needPrepare = ecModel.resetOption("media");
    var silent = opts && opts.silent;
    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }
      needPrepare = true;
      this[PENDING_UPDATE] = null;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    try {
      needPrepare && prepare(this);
      updateMethods.update.call(this, {
        type: "resize",
        animation: extend$1({
          duration: 0
        }, opts && opts.animation)
      });
    } catch (e2) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e2;
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.showLoading = function(name, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (isObject$3(name)) {
      cfg = name;
      name = "";
    }
    name = name || "default";
    this.hideLoading();
    if (!loadingEffects[name]) {
      return;
    }
    var el = loadingEffects[name](this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  };
  ECharts2.prototype.hideLoading = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };
  ECharts2.prototype.makeActionFromEvent = function(eventObj) {
    var payload = extend$1({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  ECharts2.prototype.dispatchAction = function(payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!isObject$3(opt)) {
      opt = {
        silent: !!opt
      };
    }
    if (!actions[payload.type]) {
      return;
    }
    if (!this._model) {
      return;
    }
    if (this[IN_MAIN_PROCESS_KEY]) {
      this._pendingActions.push(payload);
      return;
    }
    var silent = opt.silent;
    doDispatchAction.call(this, payload, silent);
    var flush = opt.flush;
    if (flush) {
      this._zr.flush();
    } else if (flush !== false && env$1.browser.weChat) {
      this._throttledZrFlush();
    }
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  ECharts2.prototype.updateLabelLayout = function() {
    lifecycle$1.trigger("series:layoutlabels", this._model, this._api, {
      updatedSeries: []
    });
  };
  ECharts2.prototype.appendData = function(params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var seriesIndex = params.seriesIndex;
    var ecModel = this.getModel();
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    seriesModel.appendData(params);
    this._scheduler.unfinished = true;
    this.getZr().wakeUp();
  };
  ECharts2.internalField = function() {
    prepare = function(ecIns) {
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecIns._model);
      scheduler.prepareStageTasks();
      prepareView(ecIns, true);
      prepareView(ecIns, false);
      scheduler.plan();
    };
    prepareView = function(ecIns, isComponent) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr = ecIns._zr;
      var api = ecIns._api;
      for (var i = 0; i < viewList.length; i++) {
        viewList[i].__alive = false;
      }
      isComponent ? ecModel.eachComponent(function(componentType, model) {
        componentType !== "series" && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);
      function doPrepare(model) {
        var requireNewView = model.__requireNewView;
        model.__requireNewView = false;
        var viewId = "_ec_" + model.id + "_" + model.type;
        var view2 = !requireNewView && viewMap[viewId];
        if (!view2) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? ComponentView$1.getClass(classType.main, classType.sub) : ChartView$1.getClass(classType.sub);
          view2 = new Clazz();
          view2.init(ecModel, api);
          viewMap[viewId] = view2;
          viewList.push(view2);
          zr.add(view2.group);
        }
        model.__viewId = view2.__id = viewId;
        view2.__alive = true;
        view2.__model = model;
        view2.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view2, model, ecModel, api);
      }
      for (var i = 0; i < viewList.length; ) {
        var view = viewList[i];
        if (!view.__alive) {
          !isComponent && view.renderTask.dispose();
          zr.remove(view.group);
          view.dispose(ecModel, api);
          viewList.splice(i, 1);
          if (viewMap[view.__id] === view) {
            delete viewMap[view.__id];
          }
          view.__id = view.group.__ecComponentInfo = null;
        } else {
          i++;
        }
      }
    };
    updateDirectly = function(ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model;
      ecModel.setUpdatePayload(payload);
      if (!mainType) {
        each$f([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
        return;
      }
      var query = {};
      query[mainType + "Id"] = payload[mainType + "Id"];
      query[mainType + "Index"] = payload[mainType + "Index"];
      query[mainType + "Name"] = payload[mainType + "Name"];
      var condition = {
        mainType,
        query
      };
      subType && (condition.subType = subType);
      var excludeSeriesId = payload.excludeSeriesId;
      var excludeSeriesIdMap;
      if (excludeSeriesId != null) {
        excludeSeriesIdMap = createHashMap();
        each$f(normalizeToArray(excludeSeriesId), function(id) {
          var modelId = convertOptionIdName(id, null);
          if (modelId != null) {
            excludeSeriesIdMap.set(modelId, true);
          }
        });
      }
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
        if (isExcluded) {
          return;
        }
        if (isHighDownPayload(payload)) {
          if (model instanceof SeriesModel$1) {
            if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
              blurSeriesFromHighlightPayload(model, payload, ecIns._api);
            }
          } else {
            var _a2 = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api), focusSelf = _a2.focusSelf, dispatchers = _a2.dispatchers;
            if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
              blurComponent(model.mainType, model.componentIndex, ecIns._api);
            }
            if (dispatchers) {
              each$f(dispatchers, function(dispatcher) {
                payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
              });
            }
          }
        } else if (isSelectChangePayload(payload)) {
          if (model instanceof SeriesModel$1) {
            toggleSelectionFromPayload(model, payload, ecIns._api);
            updateSeriesElementSelection(model);
            markStatusToUpdate(ecIns);
          }
        }
      }, ecIns);
      ecModel && ecModel.eachComponent(condition, function(model) {
        var isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null;
        if (isExcluded) {
          return;
        }
        callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
      }, ecIns);
      function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
      }
    };
    updateMethods = {
      prepareAndUpdate: function(payload) {
        prepare(this);
        updateMethods.update.call(this, payload, {
          optionChanged: payload.newOption != null
        });
      },
      update: function(payload, updateParams) {
        var ecModel = this._model;
        var api = this._api;
        var zr = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel);
        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload);
        updateStreamModes(this, ecModel);
        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render(this, ecModel, api, payload, updateParams);
        var backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
        var darkMode = ecModel.get("darkMode");
        zr.setBackgroundColor(backgroundColor2);
        if (darkMode != null && darkMode !== "auto") {
          zr.setDarkMode(darkMode);
        }
        lifecycle$1.trigger("afterupdate", ecModel, api);
      },
      updateTransform: function(payload) {
        var _this = this;
        var ecModel = this._model;
        var api = this._api;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        var componentDirtyList = [];
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType === "series") {
            return;
          }
          var componentView = _this.getViewOfComponentModel(componentModel);
          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        });
        renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap);
        lifecycle$1.trigger("afterupdate", ecModel, api);
      },
      updateView: function(payload) {
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ChartView$1.markUpdateMethod(payload, "updateView");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });
        render(this, ecModel, this._api, payload, {});
        lifecycle$1.trigger("afterupdate", ecModel, this._api);
      },
      updateVisual: function(payload) {
        var _this = this;
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ecModel.setUpdatePayload(payload);
        ecModel.eachSeries(function(seriesModel) {
          seriesModel.getData().clearAllVisual();
        });
        ChartView$1.markUpdateMethod(payload, "updateVisual");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          visualType: "visual",
          setDirty: true
        });
        ecModel.eachComponent(function(componentType, componentModel) {
          if (componentType !== "series") {
            var componentView = _this.getViewOfComponentModel(componentModel);
            componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
          }
        });
        ecModel.eachSeries(function(seriesModel) {
          var chartView = _this._chartsMap[seriesModel.__viewId];
          chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
        });
        lifecycle$1.trigger("afterupdate", ecModel, this._api);
      },
      updateLayout: function(payload) {
        updateMethods.update.call(this, payload);
      }
    };
    doConvertPixel = function(ecIns, methodName, finder, value) {
      if (ecIns._disposed) {
        disposedWarning(ecIns.id);
        return;
      }
      var ecModel = ecIns._model;
      var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
      var result;
      var parsedFinder = parseFinder$1(ecModel, finder);
      for (var i = 0; i < coordSysList.length; i++) {
        var coordSys = coordSysList[i];
        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
          return result;
        }
      }
    };
    updateStreamModes = function(ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function(seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    };
    doDispatchAction = function(payload, silent) {
      var _this = this;
      var ecModel = this.getModel();
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo2 = actionWrap.actionInfo;
      var cptTypeTmp = (actionInfo2.update || "update").split(":");
      var updateMethod = cptTypeTmp.pop();
      var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
      this[IN_MAIN_PROCESS_KEY] = true;
      var payloads = [payload];
      var batched = false;
      if (payload.batch) {
        batched = true;
        payloads = map$1(payload.batch, function(item) {
          item = defaults(extend$1({}, item), payload);
          item.batch = null;
          return item;
        });
      }
      var eventObjBatch = [];
      var eventObj;
      var isSelectChange = isSelectChangePayload(payload);
      var isHighDown = isHighDownPayload(payload);
      if (isHighDown) {
        allLeaveBlur(this._api);
      }
      each$f(payloads, function(batchItem) {
        eventObj = actionWrap.action(batchItem, _this._model, _this._api);
        eventObj = eventObj || extend$1({}, batchItem);
        eventObj.type = actionInfo2.event || eventObj.type;
        eventObjBatch.push(eventObj);
        if (isHighDown) {
          var _a2 = preParseFinder(payload), queryOptionMap = _a2.queryOptionMap, mainTypeSpecified = _a2.mainTypeSpecified;
          var componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
          updateDirectly(_this, updateMethod, batchItem, componentMainType);
          markStatusToUpdate(_this);
        } else if (isSelectChange) {
          updateDirectly(_this, updateMethod, batchItem, "series");
          markStatusToUpdate(_this);
        } else if (cptType) {
          updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      });
      if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
        try {
          if (this[PENDING_UPDATE]) {
            prepare(this);
            updateMethods.update.call(this, payload);
            this[PENDING_UPDATE] = null;
          } else {
            updateMethods[updateMethod].call(this, payload);
          }
        } catch (e2) {
          this[IN_MAIN_PROCESS_KEY] = false;
          throw e2;
        }
      }
      if (batched) {
        eventObj = {
          type: actionInfo2.event || payloadType,
          escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }
      this[IN_MAIN_PROCESS_KEY] = false;
      if (!silent) {
        var messageCenter = this._messageCenter;
        messageCenter.trigger(eventObj.type, eventObj);
        if (isSelectChange) {
          var newObj = {
            type: "selectchanged",
            escapeConnect,
            selected: getAllSelectedIndices(ecModel),
            isFromClick: payload.isFromClick || false,
            fromAction: payload.type,
            fromActionPayload: payload
          };
          messageCenter.trigger(newObj.type, newObj);
        }
      }
    };
    flushPendingActions = function(silent) {
      var pendingActions = this._pendingActions;
      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    };
    triggerUpdatedEvent = function(silent) {
      !silent && this.trigger("updated");
    };
    bindRenderedEvent = function(zr, ecIns) {
      zr.on("rendered", function(params) {
        ecIns.trigger("rendered", params);
        if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
          ecIns.trigger("finished");
        }
      });
    };
    bindMouseEvent = function(zr, ecIns) {
      zr.on("mouseover", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOverForHighDown(dispatcher, e2, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("mouseout", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, isHighDownDispatcher);
        if (dispatcher) {
          handleGlobalMouseOutForHighDown(dispatcher, e2, ecIns._api);
          markStatusToUpdate(ecIns);
        }
      }).on("click", function(e2) {
        var el = e2.target;
        var dispatcher = findEventDispatcher(el, function(target) {
          return getECData(target).dataIndex != null;
        }, true);
        if (dispatcher) {
          var actionType = dispatcher.selected ? "unselect" : "select";
          var ecData = getECData(dispatcher);
          ecIns._api.dispatchAction({
            type: actionType,
            dataType: ecData.dataType,
            dataIndexInside: ecData.dataIndex,
            seriesIndex: ecData.seriesIndex,
            isFromClick: true
          });
        }
      });
    };
    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.clearColorPalette();
      });
    }
    function allocateZlevels(ecModel) {
      var componentZLevels = [];
      var seriesZLevels = [];
      var hasSeperateZLevel = false;
      ecModel.eachComponent(function(componentType, componentModel) {
        var zlevel = componentModel.get("zlevel") || 0;
        var z = componentModel.get("z") || 0;
        var zlevelKey = componentModel.getZLevelKey();
        hasSeperateZLevel = hasSeperateZLevel || !!zlevelKey;
        (componentType === "series" ? seriesZLevels : componentZLevels).push({
          zlevel,
          z,
          idx: componentModel.componentIndex,
          type: componentType,
          key: zlevelKey
        });
      });
      if (hasSeperateZLevel) {
        var zLevels = componentZLevels.concat(seriesZLevels);
        var lastSeriesZLevel_1;
        var lastSeriesKey_1;
        sort$2(zLevels, function(a, b) {
          if (a.zlevel === b.zlevel) {
            return a.z - b.z;
          }
          return a.zlevel - b.zlevel;
        });
        each$f(zLevels, function(item) {
          var componentModel = ecModel.getComponent(item.type, item.idx);
          var zlevel = item.zlevel;
          var key = item.key;
          if (lastSeriesZLevel_1 != null) {
            zlevel = Math.max(lastSeriesZLevel_1, zlevel);
          }
          if (key) {
            if (zlevel === lastSeriesZLevel_1 && key !== lastSeriesKey_1) {
              zlevel++;
            }
            lastSeriesKey_1 = key;
          } else if (lastSeriesKey_1) {
            if (zlevel === lastSeriesZLevel_1) {
              zlevel++;
            }
            lastSeriesKey_1 = "";
          }
          lastSeriesZLevel_1 = zlevel;
          componentModel.setZLevel(zlevel);
        });
      }
    }
    render = function(ecIns, ecModel, api, payload, updateParams) {
      allocateZlevels(ecModel);
      renderComponents(ecIns, ecModel, api, payload, updateParams);
      each$f(ecIns._chartsViews, function(chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload, updateParams);
      each$f(ecIns._chartsViews, function(chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    };
    renderComponents = function(ecIns, ecModel, api, payload, updateParams, dirtyList) {
      each$f(dirtyList || ecIns._componentsViews, function(componentView) {
        var componentModel = componentView.__model;
        clearStates(componentModel, componentView);
        componentView.render(componentModel, ecModel, api, payload);
        updateZ2(componentModel, componentView);
        updateStates(componentModel, componentView);
      });
    };
    renderSeries = function(ecIns, ecModel, api, payload, updateParams, dirtyMap) {
      var scheduler = ecIns._scheduler;
      updateParams = extend$1(updateParams || {}, {
        updatedSeries: ecModel.getSeries()
      });
      lifecycle$1.trigger("series:beforeupdate", ecModel, api, updateParams);
      var unfinished = false;
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload);
        clearStates(seriesModel, chartView);
        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }
        if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
          unfinished = true;
        }
        chartView.group.silent = !!seriesModel.get("silent");
        updateBlend(seriesModel, chartView);
        updateSeriesElementSelection(seriesModel);
      });
      scheduler.unfinished = unfinished || scheduler.unfinished;
      lifecycle$1.trigger("series:layoutlabels", ecModel, api, updateParams);
      lifecycle$1.trigger("series:transition", ecModel, api, updateParams);
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        updateZ2(seriesModel, chartView);
        updateStates(seriesModel, chartView);
      });
      updateHoverLayerStatus(ecIns, ecModel);
      lifecycle$1.trigger("series:afterupdate", ecModel, api, updateParams);
    };
    markStatusToUpdate = function(ecIns) {
      ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
      ecIns.getZr().wakeUp();
    };
    applyChangedStates = function(ecIns) {
      if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
        return;
      }
      ecIns.getZr().storage.traverse(function(el) {
        if (isElementRemoved(el)) {
          return;
        }
        applyElementStates(el);
      });
      ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
    };
    function applyElementStates(el) {
      var newStates = [];
      var oldStates = el.currentStates;
      for (var i = 0; i < oldStates.length; i++) {
        var stateName = oldStates[i];
        if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
          newStates.push(stateName);
        }
      }
      if (el.selected && el.states.select) {
        newStates.push("select");
      }
      if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
        newStates.push("emphasis");
      } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
        newStates.push("blur");
      }
      el.useStates(newStates);
    }
    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr = ecIns._zr;
      var storage2 = zr.storage;
      var elCount = 0;
      storage2.traverse(function(el) {
        if (!el.isGroup) {
          elCount++;
        }
      });
      if (elCount > ecModel.get("hoverLayerThreshold") && !env$1.node && !env$1.worker) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.__alive) {
            chartView.eachRendered(function(el) {
              if (el.states.emphasis) {
                el.states.emphasis.hoverLayer = true;
              }
            });
          }
        });
      }
    }
    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get("blendMode") || null;
      chartView.eachRendered(function(el) {
        if (!el.isGroup) {
          el.style.blend = blendMode;
        }
      });
    }
    function updateZ2(model, view) {
      if (model.preventAutoZ) {
        return;
      }
      var z = model.get("z") || 0;
      var zlevel = model.get("zlevel") || 0;
      view.eachRendered(function(el) {
        doUpdateZ(el, z, zlevel, -Infinity);
        return true;
      });
    }
    function doUpdateZ(el, z, zlevel, maxZ2) {
      var label = el.getTextContent();
      var labelLine = el.getTextGuideLine();
      var isGroup = el.isGroup;
      if (isGroup) {
        var children = el.childrenRef();
        for (var i = 0; i < children.length; i++) {
          maxZ2 = Math.max(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);
        }
      } else {
        el.z = z;
        el.zlevel = zlevel;
        maxZ2 = Math.max(el.z2, maxZ2);
      }
      if (label) {
        label.z = z;
        label.zlevel = zlevel;
        isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
      }
      if (labelLine) {
        var textGuideLineConfig = el.textGuideLineConfig;
        labelLine.z = z;
        labelLine.zlevel = zlevel;
        isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
      }
      return maxZ2;
    }
    function clearStates(model, view) {
      view.eachRendered(function(el) {
        if (isElementRemoved(el)) {
          return;
        }
        var textContent = el.getTextContent();
        var textGuide = el.getTextGuideLine();
        if (el.stateTransition) {
          el.stateTransition = null;
        }
        if (textContent && textContent.stateTransition) {
          textContent.stateTransition = null;
        }
        if (textGuide && textGuide.stateTransition) {
          textGuide.stateTransition = null;
        }
        if (el.hasState()) {
          el.prevStates = el.currentStates;
          el.clearStates();
        } else if (el.prevStates) {
          el.prevStates = null;
        }
      });
    }
    function updateStates(model, view) {
      var stateAnimationModel = model.getModel("stateAnimation");
      var enableAnimation = model.isAnimationEnabled();
      var duration = stateAnimationModel.get("duration");
      var stateTransition = duration > 0 ? {
        duration,
        delay: stateAnimationModel.get("delay"),
        easing: stateAnimationModel.get("easing")
      } : null;
      view.eachRendered(function(el) {
        if (el.states && el.states.emphasis) {
          if (isElementRemoved(el)) {
            return;
          }
          if (el instanceof Path$1) {
            savePathStates(el);
          }
          if (el.__dirty) {
            var prevStates = el.prevStates;
            if (prevStates) {
              el.useStates(prevStates);
            }
          }
          if (enableAnimation) {
            el.stateTransition = stateTransition;
            var textContent = el.getTextContent();
            var textGuide = el.getTextGuideLine();
            if (textContent) {
              textContent.stateTransition = stateTransition;
            }
            if (textGuide) {
              textGuide.stateTransition = stateTransition;
            }
          }
          if (el.__dirty) {
            applyElementStates(el);
          }
        }
      });
    }
    createExtensionAPI = function(ecIns) {
      return new (function(_super2) {
        __extends(class_1, _super2);
        function class_1() {
          return _super2 !== null && _super2.apply(this, arguments) || this;
        }
        class_1.prototype.getCoordinateSystems = function() {
          return ecIns._coordSysMgr.getCoordinateSystems();
        };
        class_1.prototype.getComponentByElement = function(el) {
          while (el) {
            var modelInfo = el.__ecComponentInfo;
            if (modelInfo != null) {
              return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
            }
            el = el.parent;
          }
        };
        class_1.prototype.enterEmphasis = function(el, highlightDigit) {
          enterEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveEmphasis = function(el, highlightDigit) {
          leaveEmphasis(el, highlightDigit);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterBlur = function(el) {
          enterBlur(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveBlur = function(el) {
          leaveBlur(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.enterSelect = function(el) {
          enterSelect(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.leaveSelect = function(el) {
          leaveSelect(el);
          markStatusToUpdate(ecIns);
        };
        class_1.prototype.getModel = function() {
          return ecIns.getModel();
        };
        class_1.prototype.getViewOfComponentModel = function(componentModel) {
          return ecIns.getViewOfComponentModel(componentModel);
        };
        class_1.prototype.getViewOfSeriesModel = function(seriesModel) {
          return ecIns.getViewOfSeriesModel(seriesModel);
        };
        return class_1;
      }(ExtensionAPI$1))(ecIns);
    };
    enableConnect = function(chart) {
      function updateConnectedChartsStatus(charts, status) {
        for (var i = 0; i < charts.length; i++) {
          var otherChart = charts[i];
          otherChart[CONNECT_STATUS_KEY] = status;
        }
      }
      each$f(eventActionMap, function(actionType, eventType) {
        chart._messageCenter.on(eventType, function(event) {
          if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
            if (event && event.escapeConnect) {
              return;
            }
            var action_1 = chart.makeActionFromEvent(event);
            var otherCharts_1 = [];
            each$f(instances, function(otherChart) {
              if (otherChart !== chart && otherChart.group === chart.group) {
                otherCharts_1.push(otherChart);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
            each$f(otherCharts_1, function(otherChart) {
              if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                otherChart.dispatchAction(action_1);
              }
            });
            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
          }
        });
      });
    };
  }();
  return ECharts2;
}(Eventful$1);
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(eventName, cb, ctx) {
  var self2 = this;
  function wrapped() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    cb && cb.apply && cb.apply(this, args2);
    self2.off(eventName, wrapped);
  }
  this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function disposedWarning(id) {
}
var actions = {};
var eventActionMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances = {};
var connectedGroups = {};
var idBase = +new Date() - 0;
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init$1(dom, theme2, opts) {
  var isClient = !(opts && opts.ssr);
  if (isClient) {
    var existInstance = getInstanceByDom(dom);
    if (existInstance) {
      return existInstance;
    }
  }
  var chart = new ECharts(dom, theme2, opts);
  chart.id = "ec_" + idBase++;
  instances[chart.id] = chart;
  isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
  enableConnect(chart);
  lifecycle$1.trigger("afterinit", chart);
  return chart;
}
function getInstanceByDom(dom) {
  return instances[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function registerTheme(name, theme2) {
  themeStorage[name] = theme2;
}
function registerPreprocessor(preprocessorFunc) {
  if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
}
function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(postInitFunc) {
  registerUpdateLifecycle("afterinit", postInitFunc);
}
function registerPostUpdate(postUpdateFunc) {
  registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name, cb) {
  lifecycle$1.on(name, cb);
}
function registerAction(actionInfo2, eventName, action) {
  if (isFunction$1(eventName)) {
    action = eventName;
    eventName = "";
  }
  var actionType = isObject$3(actionInfo2) ? actionInfo2.type : [actionInfo2, actionInfo2 = {
    event: eventName
  }][0];
  actionInfo2.event = (actionInfo2.event || actionType).toLowerCase();
  eventName = actionInfo2.event;
  if (eventActionMap[eventName]) {
    return;
  }
  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
  if (!actions[actionType]) {
    actions[actionType] = {
      action,
      actionInfo: actionInfo2
    };
  }
  eventActionMap[eventName] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
  CoordinateSystem.register(type, coordSysCreator);
}
function getCoordinateSystemDimensions(type) {
  var coordSysCreator = CoordinateSystem.get(type);
  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}
function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList2, priority, fn, defaultPriority, visualType) {
  if (isFunction$1(priority) || isObject$3(priority)) {
    fn = priority;
    priority = defaultPriority;
  }
  if (indexOf(registeredTasks, fn) >= 0) {
    return;
  }
  registeredTasks.push(fn);
  var stageHandler = Scheduler$1.wrapStageHandler(fn, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn;
  targetList2.push(stageHandler);
}
function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
function registerMap$1(mapName, geoJson, specialAreas) {
  var registerMap2 = getImpl("registerMap");
  registerMap2 && registerMap2(mapName, geoJson, specialAreas);
}
function getMap(mapName) {
  var getMap2 = getImpl("getMap");
  return getMap2 && getMap2(mapName);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop$1);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop$1);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop$1);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop$1);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop$1);
registerTheme("light", lightTheme);
registerTheme("dark", darkTheme);
var extensions = [];
var extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap: registerMap$1,
  registerImpl,
  PRIORITY,
  ComponentModel: ComponentModel$1,
  ComponentView: ComponentView$1,
  SeriesModel: SeriesModel$1,
  ChartView: ChartView$1,
  registerComponentModel: function(ComponentModelClass) {
    ComponentModel$1.registerClass(ComponentModelClass);
  },
  registerComponentView: function(ComponentViewClass) {
    ComponentView$1.registerClass(ComponentViewClass);
  },
  registerSeriesModel: function(SeriesModelClass) {
    SeriesModel$1.registerClass(SeriesModelClass);
  },
  registerChartView: function(ChartViewClass) {
    ChartView$1.registerClass(ChartViewClass);
  },
  registerSubTypeDefaulter: function(componentType, defaulter) {
    ComponentModel$1.registerSubTypeDefaulter(componentType, defaulter);
  },
  registerPainter: function(painterType, PainterCtor) {
    registerPainter(painterType, PainterCtor);
  }
};
function use(ext) {
  if (isArray$1(ext)) {
    each$f(ext, function(singleExt) {
      use(singleExt);
    });
    return;
  }
  if (indexOf(extensions, ext) >= 0) {
    return;
  }
  extensions.push(ext);
  if (isFunction$1(ext)) {
    ext = {
      install: ext
    };
  }
  ext.install(extensionRegisters);
}
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
  return item;
}
var DataDiffer = function() {
  function DataDiffer2(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
    this._diffModeMultiple = diffMode === "multiple";
  }
  DataDiffer2.prototype.add = function(func) {
    this._add = func;
    return this;
  };
  DataDiffer2.prototype.update = function(func) {
    this._update = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToOne = function(func) {
    this._updateManyToOne = func;
    return this;
  };
  DataDiffer2.prototype.updateOneToMany = function(func) {
    this._updateOneToMany = func;
    return this;
  };
  DataDiffer2.prototype.updateManyToMany = function(func) {
    this._updateManyToMany = func;
    return this;
  };
  DataDiffer2.prototype.remove = function(func) {
    this._remove = func;
    return this;
  };
  DataDiffer2.prototype.execute = function() {
    this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
  };
  DataDiffer2.prototype._executeOneToOne = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var newDataIndexMap = {};
    var oldDataKeyArr = new Array(oldArr.length);
    var newDataKeyArr = new Array(newArr.length);
    this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i = 0; i < oldArr.length; i++) {
      var oldKey = oldDataKeyArr[i];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (newIdxMapValLen > 1) {
        var newIdx = newIdxMapVal.shift();
        if (newIdxMapVal.length === 1) {
          newDataIndexMap[oldKey] = newIdxMapVal[0];
        }
        this._update && this._update(newIdx, i);
      } else if (newIdxMapValLen === 1) {
        newDataIndexMap[oldKey] = null;
        this._update && this._update(newIdxMapVal, i);
      } else {
        this._remove && this._remove(i);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._executeMultiple = function() {
    var oldArr = this._old;
    var newArr = this._new;
    var oldDataIndexMap = {};
    var newDataIndexMap = {};
    var oldDataKeyArr = [];
    var newDataKeyArr = [];
    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (var i = 0; i < oldDataKeyArr.length; i++) {
      var oldKey = oldDataKeyArr[i];
      var oldIdxMapVal = oldDataIndexMap[oldKey];
      var newIdxMapVal = newDataIndexMap[oldKey];
      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
        this._update && this._update(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1) {
        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
          this._remove && this._remove(oldIdxMapVal[i_1]);
        }
      } else {
        this._remove && this._remove(oldIdxMapVal);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  };
  DataDiffer2.prototype._performRestAdd = function(newDataKeyArr, newDataIndexMap) {
    for (var i = 0; i < newDataKeyArr.length; i++) {
      var newKey = newDataKeyArr[i];
      var newIdxMapVal = newDataIndexMap[newKey];
      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (idxMapValLen > 1) {
        for (var j = 0; j < idxMapValLen; j++) {
          this._add && this._add(newIdxMapVal[j]);
        }
      } else if (idxMapValLen === 1) {
        this._add && this._add(newIdxMapVal);
      }
      newDataIndexMap[newKey] = null;
    }
  };
  DataDiffer2.prototype._initIndexMap = function(arr, map2, keyArr, keyGetterName) {
    var cbModeMultiple = this._diffModeMultiple;
    for (var i = 0; i < arr.length; i++) {
      var key = "_ec_" + this[keyGetterName](arr[i], i);
      if (!cbModeMultiple) {
        keyArr[i] = key;
      }
      if (!map2) {
        continue;
      }
      var idxMapVal = map2[key];
      var idxMapValLen = dataIndexMapValueLength(idxMapVal);
      if (idxMapValLen === 0) {
        map2[key] = i;
        if (cbModeMultiple) {
          keyArr.push(key);
        }
      } else if (idxMapValLen === 1) {
        map2[key] = [idxMapVal, i];
      } else {
        idxMapVal.push(i);
      }
    }
  };
  return DataDiffer2;
}();
var DataDiffer$1 = DataDiffer;
var DimensionUserOuput = function() {
  function DimensionUserOuput2(encode, dimRequest) {
    this._encode = encode;
    this._schema = dimRequest;
  }
  DimensionUserOuput2.prototype.get = function() {
    return {
      fullDimensions: this._getFullDimensionNames(),
      encode: this._encode
    };
  };
  DimensionUserOuput2.prototype._getFullDimensionNames = function() {
    if (!this._cachedDimNames) {
      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
    }
    return this._cachedDimNames;
  };
  return DimensionUserOuput2;
}();
function summarizeDimensions(data, schema) {
  var summary = {};
  var encode = summary.encode = {};
  var notExtraCoordDimMap = createHashMap();
  var defaultedLabel = [];
  var defaultedTooltip = [];
  var userOutputEncode = {};
  each$f(data.dimensions, function(dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var coordDim = dimItem.coordDim;
    if (coordDim) {
      var coordDimIndex = dimItem.coordDimIndex;
      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1);
        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        }
        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
      }
      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }
    VISUAL_DIMENSIONS.each(function(v, otherDim2) {
      var encodeArr = getOrCreateEncodeArr(encode, otherDim2);
      var dimIndex = dimItem.otherDims[otherDim2];
      if (dimIndex != null && dimIndex !== false) {
        encodeArr[dimIndex] = dimItem.name;
      }
    });
  });
  var dataDimsOnCoord = [];
  var encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function(v, coordDim) {
    var dimArr = encode[coordDim];
    encodeFirstDimNotExtra[coordDim] = dimArr[0];
    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.dataDimIndicesOnCoord = map$1(dataDimsOnCoord, function(dimName) {
    return data.getDimensionInfo(dimName).storeDimIndex;
  });
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  var encodeLabel = encode.label;
  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }
  var encodeTooltip = encode.tooltip;
  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }
  encode.defaultedLabel = defaultedLabel;
  encode.defaultedTooltip = defaultedTooltip;
  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
  return summary;
}
function getOrCreateEncodeArr(encode, dim) {
  if (!encode.hasOwnProperty(dim)) {
    encode[dim] = [];
  }
  return encode[dim];
}
function getDimensionTypeByAxis(axisType) {
  return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
  return !(dimType === "ordinal" || dimType === "time");
}
var SeriesDimensionDefine = function() {
  function SeriesDimensionDefine2(opt) {
    this.otherDims = {};
    if (opt != null) {
      extend$1(this, opt);
    }
  }
  return SeriesDimensionDefine2;
}();
var SeriesDimensionDefine$1 = SeriesDimensionDefine;
var inner$h = makeInner();
var dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
};
var SeriesDataSchema = function() {
  function SeriesDataSchema2(opt) {
    this.dimensions = opt.dimensions;
    this._dimOmitted = opt.dimensionOmitted;
    this.source = opt.source;
    this._fullDimCount = opt.fullDimensionCount;
    this._updateDimOmitted(opt.dimensionOmitted);
  }
  SeriesDataSchema2.prototype.isDimensionOmitted = function() {
    return this._dimOmitted;
  };
  SeriesDataSchema2.prototype._updateDimOmitted = function(dimensionOmitted) {
    this._dimOmitted = dimensionOmitted;
    if (!dimensionOmitted) {
      return;
    }
    if (!this._dimNameMap) {
      this._dimNameMap = ensureSourceDimNameMap(this.source);
    }
  };
  SeriesDataSchema2.prototype.getSourceDimensionIndex = function(dimName) {
    return retrieve2(this._dimNameMap.get(dimName), -1);
  };
  SeriesDataSchema2.prototype.getSourceDimension = function(dimIndex) {
    var dimensionsDefine = this.source.dimensionsDefine;
    if (dimensionsDefine) {
      return dimensionsDefine[dimIndex];
    }
  };
  SeriesDataSchema2.prototype.makeStoreSchema = function() {
    var dimCount = this._fullDimCount;
    var willRetrieveDataByName = shouldRetrieveDataByName(this.source);
    var makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
    var dimHash = "";
    var dims = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
      var property = void 0;
      var type = void 0;
      var ordinalMeta = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        property = willRetrieveDataByName ? seriesDimDef.name : null;
        type = seriesDimDef.type;
        ordinalMeta = seriesDimDef.ordinalMeta;
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          property = willRetrieveDataByName ? sourceDimDef.name : null;
          type = sourceDimDef.type;
        }
      }
      dims.push({
        property,
        type,
        ordinalMeta
      });
      if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
        dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
      }
      dimHash += "$";
      dimHash += dimTypeShort[type] || "f";
      if (ordinalMeta) {
        dimHash += ordinalMeta.uid;
      }
      dimHash += "$";
    }
    var source = this.source;
    var hash = [source.seriesLayoutBy, source.startIndex, dimHash].join("$$");
    return {
      dimensions: dims,
      hash
    };
  };
  SeriesDataSchema2.prototype.makeOutputDimensionNames = function() {
    var result = [];
    for (var fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
      var name_1 = void 0;
      var seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        if (!seriesDimDef.isCalculationCoord) {
          name_1 = seriesDimDef.name;
        }
        seriesDimIdx++;
      } else {
        var sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          name_1 = sourceDimDef.name;
        }
      }
      result.push(name_1);
    }
    return result;
  };
  SeriesDataSchema2.prototype.appendCalculationDimension = function(dimDef) {
    this.dimensions.push(dimDef);
    dimDef.isCalculationCoord = true;
    this._fullDimCount++;
    this._updateDimOmitted(true);
  };
  return SeriesDataSchema2;
}();
function isSeriesDataSchema(schema) {
  return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
  var dataDimNameMap = createHashMap();
  for (var i = 0; i < (dimsDef || []).length; i++) {
    var dimDefItemRaw = dimsDef[i];
    var userDimName = isObject$3(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      dataDimNameMap.set(userDimName, i);
    }
  }
  return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
  var innerSource = inner$h(source);
  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
  return dimCount > 30;
}
var isObject$1 = isObject$3;
var map = map$1;
var CtorInt32Array = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\0\0";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"];
var CLONE_PROPERTIES = ["_approximateExtent"];
var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData = function() {
  function SeriesData2(dimensionsInput, hostModel) {
    this.type = "list";
    this._dimOmitted = false;
    this._nameList = [];
    this._idList = [];
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this._itemLayouts = [];
    this._graphicEls = [];
    this._approximateExtent = {};
    this._calculationInfo = {};
    this.hasItemOption = false;
    this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"];
    this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
    var dimensions;
    var assignStoreDimIdx = false;
    if (isSeriesDataSchema(dimensionsInput)) {
      dimensions = dimensionsInput.dimensions;
      this._dimOmitted = dimensionsInput.isDimensionOmitted();
      this._schema = dimensionsInput;
    } else {
      assignStoreDimIdx = true;
      dimensions = dimensionsInput;
    }
    dimensions = dimensions || ["x", "y"];
    var dimensionInfos = {};
    var dimensionNames = [];
    var invertedIndicesMap = {};
    var needsHasOwn = false;
    var emptyObj = {};
    for (var i = 0; i < dimensions.length; i++) {
      var dimInfoInput = dimensions[i];
      var dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine$1({
        name: dimInfoInput
      }) : !(dimInfoInput instanceof SeriesDimensionDefine$1) ? new SeriesDimensionDefine$1(dimInfoInput) : dimInfoInput;
      var dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || "float";
      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      if (emptyObj[dimensionName] != null) {
        needsHasOwn = true;
      }
      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
      if (otherDims.itemName === 0) {
        this._nameDimIdx = i;
      }
      if (otherDims.itemId === 0) {
        this._idDimIdx = i;
      }
      if (assignStoreDimIdx) {
        dimensionInfo.storeDimIndex = i;
      }
    }
    this.dimensions = dimensionNames;
    this._dimInfos = dimensionInfos;
    this._initGetDimensionInfo(needsHasOwn);
    this.hostModel = hostModel;
    this._invertedIndicesMap = invertedIndicesMap;
    if (this._dimOmitted) {
      var dimIdxToName_1 = this._dimIdxToName = createHashMap();
      each$f(dimensionNames, function(dimName) {
        dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName);
      });
    }
  }
  SeriesData2.prototype.getDimension = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx == null) {
      return dim;
    }
    dimIdx = dim;
    if (!this._dimOmitted) {
      return this.dimensions[dimIdx];
    }
    var dimName = this._dimIdxToName.get(dimIdx);
    if (dimName != null) {
      return dimName;
    }
    var sourceDimDef = this._schema.getSourceDimension(dimIdx);
    if (sourceDimDef) {
      return sourceDimDef.name;
    }
  };
  SeriesData2.prototype.getDimensionIndex = function(dim) {
    var dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx != null) {
      return dimIdx;
    }
    if (dim == null) {
      return -1;
    }
    var dimInfo = this._getDimInfo(dim);
    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
  };
  SeriesData2.prototype._recognizeDimIndex = function(dim) {
    if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
      return +dim;
    }
  };
  SeriesData2.prototype._getStoreDimIndex = function(dim) {
    var dimIdx = this.getDimensionIndex(dim);
    return dimIdx;
  };
  SeriesData2.prototype.getDimensionInfo = function(dim) {
    return this._getDimInfo(this.getDimension(dim));
  };
  SeriesData2.prototype._initGetDimensionInfo = function(needsHasOwn) {
    var dimensionInfos = this._dimInfos;
    this._getDimInfo = needsHasOwn ? function(dimName) {
      return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0;
    } : function(dimName) {
      return dimensionInfos[dimName];
    };
  };
  SeriesData2.prototype.getDimensionsOnCoord = function() {
    return this._dimSummary.dataDimsOnCoord.slice();
  };
  SeriesData2.prototype.mapDimension = function(coordDim, idx) {
    var dimensionsSummary = this._dimSummary;
    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }
    var dims = dimensionsSummary.encode[coordDim];
    return dims ? dims[idx] : null;
  };
  SeriesData2.prototype.mapDimensionsAll = function(coordDim) {
    var dimensionsSummary = this._dimSummary;
    var dims = dimensionsSummary.encode[coordDim];
    return (dims || []).slice();
  };
  SeriesData2.prototype.getStore = function() {
    return this._store;
  };
  SeriesData2.prototype.initData = function(data, nameList, dimValueGetter) {
    var _this = this;
    var store;
    if (data instanceof DataStore) {
      store = data;
    }
    if (!store) {
      var dimensions = this.dimensions;
      var provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
      store = new DataStore();
      var dimensionInfos = map(dimensions, function(dimName) {
        return {
          type: _this._dimInfos[dimName].type,
          property: dimName
        };
      });
      store.initData(provider, dimensionInfos, dimValueGetter);
    }
    this._store = store;
    this._nameList = (nameList || []).slice();
    this._idList = [];
    this._nameRepeatCount = {};
    this._doInit(0, store.count());
    this._dimSummary = summarizeDimensions(this, this._schema);
    this.userOutput = this._dimSummary.userOutput;
  };
  SeriesData2.prototype.appendData = function(data) {
    var range = this._store.appendData(data);
    this._doInit(range[0], range[1]);
  };
  SeriesData2.prototype.appendValues = function(values, names) {
    var _a2 = this._store.appendValues(values, names.length), start2 = _a2.start, end2 = _a2.end;
    var shouldMakeIdFromName = this._shouldMakeIdFromName();
    this._updateOrdinalMeta();
    if (names) {
      for (var idx = start2; idx < end2; idx++) {
        var sourceIdx = idx - start2;
        this._nameList[idx] = names[sourceIdx];
        if (shouldMakeIdFromName) {
          makeIdFromName(this, idx);
        }
      }
    }
  };
  SeriesData2.prototype._updateOrdinalMeta = function() {
    var store = this._store;
    var dimensions = this.dimensions;
    for (var i = 0; i < dimensions.length; i++) {
      var dimInfo = this._dimInfos[dimensions[i]];
      if (dimInfo.ordinalMeta) {
        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
      }
    }
  };
  SeriesData2.prototype._shouldMakeIdFromName = function() {
    var provider = this._store.getProvider();
    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
  };
  SeriesData2.prototype._doInit = function(start2, end2) {
    if (start2 >= end2) {
      return;
    }
    var store = this._store;
    var provider = store.getProvider();
    this._updateOrdinalMeta();
    var nameList = this._nameList;
    var idList = this._idList;
    var sourceFormat = provider.getSource().sourceFormat;
    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
    if (isFormatOriginal && !provider.pure) {
      var sharedDataItem = [];
      for (var idx = start2; idx < end2; idx++) {
        var dataItem = provider.getItem(idx, sharedDataItem);
        if (!this.hasItemOption && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        if (dataItem) {
          var itemName = dataItem.name;
          if (nameList[idx] == null && itemName != null) {
            nameList[idx] = convertOptionIdName(itemName, null);
          }
          var itemId = dataItem.id;
          if (idList[idx] == null && itemId != null) {
            idList[idx] = convertOptionIdName(itemId, null);
          }
        }
      }
    }
    if (this._shouldMakeIdFromName()) {
      for (var idx = start2; idx < end2; idx++) {
        makeIdFromName(this, idx);
      }
    }
    prepareInvertedIndex(this);
  };
  SeriesData2.prototype.getApproximateExtent = function(dim) {
    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.setApproximateExtent = function(extent3, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent3.slice();
  };
  SeriesData2.prototype.getCalculationInfo = function(key) {
    return this._calculationInfo[key];
  };
  SeriesData2.prototype.setCalculationInfo = function(key, value) {
    isObject$1(key) ? extend$1(this._calculationInfo, key) : this._calculationInfo[key] = value;
  };
  SeriesData2.prototype.getName = function(idx) {
    var rawIndex = this.getRawIndex(idx);
    var name = this._nameList[rawIndex];
    if (name == null && this._nameDimIdx != null) {
      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
    }
    if (name == null) {
      name = "";
    }
    return name;
  };
  SeriesData2.prototype._getCategory = function(dimIdx, idx) {
    var ordinal = this._store.get(dimIdx, idx);
    var ordinalMeta = this._store.getOrdinalMeta(dimIdx);
    if (ordinalMeta) {
      return ordinalMeta.categories[ordinal];
    }
    return ordinal;
  };
  SeriesData2.prototype.getId = function(idx) {
    return getId(this, this.getRawIndex(idx));
  };
  SeriesData2.prototype.count = function() {
    return this._store.count();
  };
  SeriesData2.prototype.get = function(dim, idx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.get(dimInfo.storeDimIndex, idx);
    }
  };
  SeriesData2.prototype.getByRawIndex = function(dim, rawIdx) {
    var store = this._store;
    var dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
    }
  };
  SeriesData2.prototype.getIndices = function() {
    return this._store.getIndices();
  };
  SeriesData2.prototype.getDataExtent = function(dim) {
    return this._store.getDataExtent(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getSum = function(dim) {
    return this._store.getSum(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getMedian = function(dim) {
    return this._store.getMedian(this._getStoreDimIndex(dim));
  };
  SeriesData2.prototype.getValues = function(dimensions, idx) {
    var _this = this;
    var store = this._store;
    return isArray$1(dimensions) ? store.getValues(map(dimensions, function(dim) {
      return _this._getStoreDimIndex(dim);
    }), idx) : store.getValues(dimensions);
  };
  SeriesData2.prototype.hasValue = function(idx) {
    var dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
    for (var i = 0, len2 = dataDimIndicesOnCoord.length; i < len2; i++) {
      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
        return false;
      }
    }
    return true;
  };
  SeriesData2.prototype.indexOfName = function(name) {
    for (var i = 0, len2 = this._store.count(); i < len2; i++) {
      if (this.getName(i) === name) {
        return i;
      }
    }
    return -1;
  };
  SeriesData2.prototype.getRawIndex = function(idx) {
    return this._store.getRawIndex(idx);
  };
  SeriesData2.prototype.indexOfRawIndex = function(rawIndex) {
    return this._store.indexOfRawIndex(rawIndex);
  };
  SeriesData2.prototype.rawIndexOf = function(dim, value) {
    var invertedIndices = dim && this._invertedIndicesMap[dim];
    var rawIndex = invertedIndices[value];
    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }
    return rawIndex;
  };
  SeriesData2.prototype.indicesOfNearest = function(dim, value, maxDistance) {
    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);
  };
  SeriesData2.prototype.each = function(dims, cb, ctx) {
    if (isFunction$1(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.each(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
  };
  SeriesData2.prototype.filterSelf = function(dims, cb, ctx) {
    if (isFunction$1(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    var fCtx = ctx || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store = this._store.filter(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
    return this;
  };
  SeriesData2.prototype.selectRange = function(range) {
    var _this = this;
    var innerRange = {};
    var dims = keys(range);
    each$f(dims, function(dim) {
      var dimIdx = _this._getStoreDimIndex(dim);
      innerRange[dimIdx] = range[dim];
    });
    this._store = this._store.selectRange(innerRange);
    return this;
  };
  SeriesData2.prototype.mapArray = function(dims, cb, ctx) {
    if (isFunction$1(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    ctx = ctx || this;
    var result = [];
    this.each(dims, function() {
      result.push(cb && cb.apply(this, arguments));
    }, ctx);
    return result;
  };
  SeriesData2.prototype.map = function(dims, cb, ctx, ctxCompat) {
    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    var list = cloneListForMapAndSample(this);
    list._store = this._store.map(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
    return list;
  };
  SeriesData2.prototype.modify = function(dims, cb, ctx, ctxCompat) {
    var fCtx = ctx || ctxCompat || this;
    var dimIndices = map(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.modify(dimIndices, fCtx ? bind$1(cb, fCtx) : cb);
  };
  SeriesData2.prototype.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
    return list;
  };
  SeriesData2.prototype.lttbDownSample = function(valueDimension, rate) {
    var list = cloneListForMapAndSample(this);
    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  };
  SeriesData2.prototype.getRawDataItem = function(idx) {
    return this._store.getRawDataItem(idx);
  };
  SeriesData2.prototype.getItemModel = function(idx) {
    var hostModel = this.hostModel;
    var dataItem = this.getRawDataItem(idx);
    return new Model$1(dataItem, hostModel, hostModel && hostModel.ecModel);
  };
  SeriesData2.prototype.diff = function(otherList) {
    var thisList = this;
    return new DataDiffer$1(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
      return getId(otherList, idx);
    }, function(idx) {
      return getId(thisList, idx);
    });
  };
  SeriesData2.prototype.getVisual = function(key) {
    var visual = this._visual;
    return visual && visual[key];
  };
  SeriesData2.prototype.setVisual = function(kvObj, val) {
    this._visual = this._visual || {};
    if (isObject$1(kvObj)) {
      extend$1(this._visual, kvObj);
    } else {
      this._visual[kvObj] = val;
    }
  };
  SeriesData2.prototype.getItemVisual = function(idx, key) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key];
    if (val == null) {
      return this.getVisual(key);
    }
    return val;
  };
  SeriesData2.prototype.hasItemVisual = function() {
    return this._itemVisuals.length > 0;
  };
  SeriesData2.prototype.ensureUniqueItemVisual = function(idx, key) {
    var itemVisuals = this._itemVisuals;
    var itemVisual = itemVisuals[idx];
    if (!itemVisual) {
      itemVisual = itemVisuals[idx] = {};
    }
    var val = itemVisual[key];
    if (val == null) {
      val = this.getVisual(key);
      if (isArray$1(val)) {
        val = val.slice();
      } else if (isObject$1(val)) {
        val = extend$1({}, val);
      }
      itemVisual[key] = val;
    }
    return val;
  };
  SeriesData2.prototype.setItemVisual = function(idx, key, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;
    if (isObject$1(key)) {
      extend$1(itemVisual, key);
    } else {
      itemVisual[key] = value;
    }
  };
  SeriesData2.prototype.clearAllVisual = function() {
    this._visual = {};
    this._itemVisuals = [];
  };
  SeriesData2.prototype.setLayout = function(key, val) {
    isObject$1(key) ? extend$1(this._layout, key) : this._layout[key] = val;
  };
  SeriesData2.prototype.getLayout = function(key) {
    return this._layout[key];
  };
  SeriesData2.prototype.getItemLayout = function(idx) {
    return this._itemLayouts[idx];
  };
  SeriesData2.prototype.setItemLayout = function(idx, layout2, merge2) {
    this._itemLayouts[idx] = merge2 ? extend$1(this._itemLayouts[idx] || {}, layout2) : layout2;
  };
  SeriesData2.prototype.clearItemLayouts = function() {
    this._itemLayouts.length = 0;
  };
  SeriesData2.prototype.setItemGraphicEl = function(idx, el) {
    var seriesIndex = this.hostModel && this.hostModel.seriesIndex;
    setCommonECData(seriesIndex, this.dataType, idx, el);
    this._graphicEls[idx] = el;
  };
  SeriesData2.prototype.getItemGraphicEl = function(idx) {
    return this._graphicEls[idx];
  };
  SeriesData2.prototype.eachItemGraphicEl = function(cb, context) {
    each$f(this._graphicEls, function(el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  };
  SeriesData2.prototype.cloneShallow = function(list) {
    if (!list) {
      list = new SeriesData2(this._schema ? this._schema : map(this.dimensions, this._getDimInfo, this), this.hostModel);
    }
    transferProperties(list, this);
    list._store = this._store;
    return list;
  };
  SeriesData2.prototype.wrapMethod = function(methodName, injectFunction) {
    var originalMethod = this[methodName];
    if (!isFunction$1(originalMethod)) {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(slice(arguments)));
    };
  };
  SeriesData2.internalField = function() {
    prepareInvertedIndex = function(data) {
      var invertedIndicesMap = data._invertedIndicesMap;
      each$f(invertedIndicesMap, function(invertedIndices, dim) {
        var dimInfo = data._dimInfos[dim];
        var ordinalMeta = dimInfo.ordinalMeta;
        var store = data._store;
        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
          for (var i = 0; i < invertedIndices.length; i++) {
            invertedIndices[i] = INDEX_NOT_FOUND;
          }
          for (var i = 0; i < store.count(); i++) {
            invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
          }
        }
      });
    };
    getIdNameFromStore = function(data, dimIdx, idx) {
      return convertOptionIdName(data._getCategory(dimIdx, idx), null);
    };
    getId = function(data, rawIndex) {
      var id = data._idList[rawIndex];
      if (id == null && data._idDimIdx != null) {
        id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
      }
      if (id == null) {
        id = ID_PREFIX + rawIndex;
      }
      return id;
    };
    normalizeDimensions = function(dimensions) {
      if (!isArray$1(dimensions)) {
        dimensions = dimensions != null ? [dimensions] : [];
      }
      return dimensions;
    };
    cloneListForMapAndSample = function(original) {
      var list = new SeriesData2(original._schema ? original._schema : map(original.dimensions, original._getDimInfo, original), original.hostModel);
      transferProperties(list, original);
      return list;
    };
    transferProperties = function(target, source) {
      each$f(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
        if (source.hasOwnProperty(propName)) {
          target[propName] = source[propName];
        }
      });
      target.__wrappedMethods = source.__wrappedMethods;
      each$f(CLONE_PROPERTIES, function(propName) {
        target[propName] = clone$4(source[propName]);
      });
      target._calculationInfo = extend$1({}, source._calculationInfo);
    };
    makeIdFromName = function(data, idx) {
      var nameList = data._nameList;
      var idList = data._idList;
      var nameDimIdx = data._nameDimIdx;
      var idDimIdx = data._idDimIdx;
      var name = nameList[idx];
      var id = idList[idx];
      if (name == null && nameDimIdx != null) {
        nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
      }
      if (id == null && idDimIdx != null) {
        idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
      }
      if (id == null && name != null) {
        var nameRepeatCount = data._nameRepeatCount;
        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
        id = name;
        if (nmCnt > 1) {
          id += "__ec__" + nmCnt;
        }
        idList[idx] = id;
      }
    };
  }();
  return SeriesData2;
}();
var SeriesData$1 = SeriesData;
function createDimensions(source, opt) {
  return prepareSeriesDataSchema(source, opt).dimensions;
}
function prepareSeriesDataSchema(source, opt) {
  if (!isSourceInstance(source)) {
    source = createSourceFromSeriesDataOption(source);
  }
  opt = opt || {};
  var sysDims = opt.coordDimensions || [];
  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
  var coordDimNameMap = createHashMap();
  var resultList = [];
  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
  var encodeDef = opt.encodeDefine;
  if (!encodeDef && opt.encodeDefaulter) {
    encodeDef = opt.encodeDefaulter(source, dimCount);
  }
  var encodeDefMap = createHashMap(encodeDef);
  var indicesMap = new CtorInt32Array$1(dimCount);
  for (var i = 0; i < indicesMap.length; i++) {
    indicesMap[i] = -1;
  }
  function getResultItem(dimIdx) {
    var idx = indicesMap[dimIdx];
    if (idx < 0) {
      var dimDefItemRaw = dimsDef[dimIdx];
      var dimDefItem = isObject$3(dimDefItemRaw) ? dimDefItemRaw : {
        name: dimDefItemRaw
      };
      var resultItem2 = new SeriesDimensionDefine$1();
      var userDimName = dimDefItem.name;
      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
        resultItem2.name = resultItem2.displayName = userDimName;
      }
      dimDefItem.type != null && (resultItem2.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem2.displayName = dimDefItem.displayName);
      var newIdx = resultList.length;
      indicesMap[dimIdx] = newIdx;
      resultItem2.storeDimIndex = dimIdx;
      resultList.push(resultItem2);
      return resultItem2;
    }
    return resultList[idx];
  }
  if (!omitUnusedDimensions) {
    for (var i = 0; i < dimCount; i++) {
      getResultItem(i);
    }
  }
  encodeDefMap.each(function(dataDimsRaw, coordDim2) {
    var dataDims = normalizeToArray(dataDimsRaw).slice();
    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
      encodeDefMap.set(coordDim2, false);
      return;
    }
    var validDataDims = encodeDefMap.set(coordDim2, []);
    each$f(dataDims, function(resultDimIdxOrName, idx) {
      var resultDimIdx2 = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
      if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
        validDataDims[idx] = resultDimIdx2;
        applyDim(getResultItem(resultDimIdx2), coordDim2, idx);
      }
    });
  });
  var availDimIdx = 0;
  each$f(sysDims, function(sysDimItemRaw) {
    var coordDim2;
    var sysDimItemDimsDef;
    var sysDimItemOtherDims;
    var sysDimItem;
    if (isString(sysDimItemRaw)) {
      coordDim2 = sysDimItemRaw;
      sysDimItem = {};
    } else {
      sysDimItem = sysDimItemRaw;
      coordDim2 = sysDimItem.name;
      var ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = extend$1({}, sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta;
      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }
    var dataDims = encodeDefMap.get(coordDim2);
    if (dataDims === false) {
      return;
    }
    dataDims = normalizeToArray(dataDims);
    if (!dataDims.length) {
      for (var i2 = 0; i2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i2++) {
        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
          availDimIdx++;
        }
        availDimIdx < dimCount && dataDims.push(availDimIdx++);
      }
    }
    each$f(dataDims, function(resultDimIdx2, coordDimIndex) {
      var resultItem2 = getResultItem(resultDimIdx2);
      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
        resultItem2.type = sysDimItem.type;
      }
      applyDim(defaults(resultItem2, sysDimItem), coordDim2, coordDimIndex);
      if (resultItem2.name == null && sysDimItemDimsDef) {
        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject$3(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
        resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      }
      sysDimItemOtherDims && defaults(resultItem2.otherDims, sysDimItemOtherDims);
    });
  });
  function applyDim(resultItem2, coordDim2, coordDimIndex) {
    if (VISUAL_DIMENSIONS.get(coordDim2) != null) {
      resultItem2.otherDims[coordDim2] = coordDimIndex;
    } else {
      resultItem2.coordDim = coordDim2;
      resultItem2.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim2, true);
    }
  }
  var generateCoord = opt.generateCoord;
  var generateCoordCount = opt.generateCoordCount;
  var fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  var extra = generateCoord || "value";
  function ifNoNameFillWithCoordName(resultItem2) {
    if (resultItem2.name == null) {
      resultItem2.name = resultItem2.coordDim;
    }
  }
  if (!omitUnusedDimensions) {
    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      var resultItem = getResultItem(resultDimIdx);
      var coordDim = resultItem.coordDim;
      if (coordDim == null) {
        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;
        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }
        generateCoordCount--;
      }
      ifNoNameFillWithCoordName(resultItem);
      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = "ordinal";
      }
    }
  } else {
    each$f(resultList, function(resultItem2) {
      ifNoNameFillWithCoordName(resultItem2);
    });
    resultList.sort(function(item0, item1) {
      return item0.storeDimIndex - item1.storeDimIndex;
    });
  }
  removeDuplication(resultList);
  return new SeriesDataSchema({
    source,
    dimensions: resultList,
    fullDimensionCount: dimCount,
    dimensionOmitted: omitUnusedDimensions
  });
}
function removeDuplication(result) {
  var duplicationMap = createHashMap();
  for (var i = 0; i < result.length; i++) {
    var dim = result[i];
    var dimOriginalName = dim.name;
    var count2 = duplicationMap.get(dimOriginalName) || 0;
    if (count2 > 0) {
      dim.name = dimOriginalName + (count2 - 1);
    }
    count2++;
    duplicationMap.set(dimOriginalName, count2);
  }
}
function getDimCount(source, sysDims, dimsDef, optDimCount) {
  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each$f(sysDims, function(sysDimItem) {
    var sysDimItemDimsDef;
    if (isObject$3(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
    }
  });
  return dimCount;
}
function genCoordDimName(name, map2, fromZero) {
  var mapData = map2.data;
  if (fromZero || mapData.hasOwnProperty(name)) {
    var i = 0;
    while (mapData.hasOwnProperty(name + i)) {
      i++;
    }
    name += i;
  }
  map2.set(name, true);
  return name;
}
var CoordSysInfo = function() {
  function CoordSysInfo2(coordSysName) {
    this.coordSysDims = [];
    this.axisMap = createHashMap();
    this.categoryAxisMap = createHashMap();
    this.coordSysName = coordSysName;
  }
  return CoordSysInfo2;
}();
function getCoordSysInfoBySeries(seriesModel) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var result = new CoordSysInfo(coordSysName);
  var fetch = fetchers[coordSysName];
  if (fetch) {
    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}
var fetchers = {
  cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
    var xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    result.coordSysDims = ["x", "y"];
    axisMap.set("x", xAxisModel);
    axisMap.set("y", yAxisModel);
    if (isCategory(xAxisModel)) {
      categoryAxisMap.set("x", xAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(yAxisModel)) {
      categoryAxisMap.set("y", yAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
    var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    result.coordSysDims = ["single"];
    axisMap.set("single", singleAxisModel);
    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set("single", singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function(seriesModel, result, axisMap, categoryAxisMap) {
    var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
    var angleAxisModel = polarModel.findAxisModel("angleAxis");
    result.coordSysDims = ["radius", "angle"];
    axisMap.set("radius", radiusAxisModel);
    axisMap.set("angle", angleAxisModel);
    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set("radius", radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set("angle", angleAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  geo: function(seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ["lng", "lat"];
  },
  parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
    var ecModel = seriesModel.ecModel;
    var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each$f(parallelModel.parallelAxisIndex, function(axisIndex, index) {
      var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      var axisDim = coordSysDims[index];
      axisMap.set(axisDim, axisModel);
      if (isCategory(axisModel)) {
        categoryAxisMap.set(axisDim, axisModel);
        if (result.firstCategoryDimIndex == null) {
          result.firstCategoryDimIndex = index;
        }
      }
    });
  }
};
function isCategory(axisModel) {
  return axisModel.get("type") === "category";
}
function enableDataStack(seriesModel, dimensionsInput, opt) {
  opt = opt || {};
  var byIndex = opt.byIndex;
  var stackedCoordDimension = opt.stackedCoordDimension;
  var dimensionDefineList;
  var schema;
  var store;
  if (isLegacyDimensionsInput(dimensionsInput)) {
    dimensionDefineList = dimensionsInput;
  } else {
    schema = dimensionsInput.schema;
    dimensionDefineList = schema.dimensions;
    store = dimensionsInput.store;
  }
  var mayStack = !!(seriesModel && seriesModel.get("stack"));
  var stackedByDimInfo;
  var stackedDimInfo;
  var stackResultDimension;
  var stackedOverDimension;
  each$f(dimensionDefineList, function(dimensionInfo, index) {
    if (isString(dimensionInfo)) {
      dimensionDefineList[index] = dimensionInfo = {
        name: dimensionInfo
      };
    }
    if (mayStack && !dimensionInfo.isExtraCoord) {
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      }
      if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });
  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    byIndex = true;
  }
  if (stackedDimInfo) {
    stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
    stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }
    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
    var stackedDimType = stackedDimInfo.type;
    var stackedDimCoordIndex_1 = 0;
    each$f(dimensionDefineList, function(dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
        stackedDimCoordIndex_1++;
      }
    });
    var stackedOverDimensionDefine = {
      name: stackResultDimension,
      coordDim: stackedDimCoordDim_1,
      coordDimIndex: stackedDimCoordIndex_1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length
    };
    var stackResultDimensionDefine = {
      name: stackedOverDimension,
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex_1 + 1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length + 1
    };
    if (schema) {
      if (store) {
        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
      }
      schema.appendCalculationDimension(stackedOverDimensionDefine);
      schema.appendCalculationDimension(stackResultDimensionDefine);
    } else {
      dimensionDefineList.push(stackedOverDimensionDefine);
      dimensionDefineList.push(stackResultDimensionDefine);
    }
  }
  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension,
    stackResultDimension
  };
}
function isLegacyDimensionsInput(dimensionsInput) {
  return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked$2(data, stackedDim) {
  return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data, targetDim) {
  return isDimensionStacked$2(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
}
function getCoordSysDimDefs(seriesModel, coordSysInfo) {
  var coordSysName = seriesModel.get("coordinateSystem");
  var registeredCoordSys = CoordinateSystem.get(coordSysName);
  var coordSysDimDefs;
  if (coordSysInfo && coordSysInfo.coordSysDims) {
    coordSysDimDefs = map$1(coordSysInfo.coordSysDims, function(dim) {
      var dimInfo = {
        name: dim
      };
      var axisModel = coordSysInfo.axisMap.get(dim);
      if (axisModel) {
        var axisType = axisModel.get("type");
        dimInfo.type = getDimensionTypeByAxis(axisType);
      }
      return dimInfo;
    });
  }
  if (!coordSysDimDefs) {
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
  }
  return coordSysDimDefs;
}
function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
  var firstCategoryDimIndex;
  var hasNameEncode;
  coordSysInfo && each$f(dimInfoList, function(dimInfo, dimIndex) {
    var coordDim = dimInfo.coordDim;
    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }
      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      if (createInvertedIndices) {
        dimInfo.createInvertedIndices = true;
      }
    }
    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });
  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }
  return firstCategoryDimIndex;
}
function createSeriesData(sourceRaw, seriesModel, opt) {
  opt = opt || {};
  var sourceManager = seriesModel.getSourceManager();
  var source;
  var isOriginalSource = false;
  if (sourceRaw) {
    isOriginalSource = true;
    source = createSourceFromSeriesDataOption(sourceRaw);
  } else {
    source = sourceManager.getSource();
    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
  }
  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
  var useEncodeDefaulter = opt.useEncodeDefaulter;
  var encodeDefaulter = isFunction$1(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry$1(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
  var createDimensionOptions = {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord,
    encodeDefine: seriesModel.getEncode(),
    encodeDefaulter,
    canOmitUnusedDimensions: !isOriginalSource
  };
  var schema = prepareSeriesDataSchema(source, createDimensionOptions);
  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
  var stackCalculationInfo = enableDataStack(seriesModel, {
    schema,
    store
  });
  var data = new SeriesData$1(schema, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  data.hasItemOption = false;
  data.initData(isOriginalSource ? source : store, null, dimValueGetter);
  return data;
}
function isNeedCompleteOrdinalData(source) {
  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var sampleItem = firstDataNotNull(source.data || []);
    return !isArray$1(getDataItemValue(sampleItem));
  }
}
function firstDataNotNull(arr) {
  var i = 0;
  while (i < arr.length && arr[i] == null) {
    i++;
  }
  return arr[i];
}
var Scale = function() {
  function Scale2(setting) {
    this._setting = setting || {};
    this._extent = [Infinity, -Infinity];
  }
  Scale2.prototype.getSetting = function(name) {
    return this._setting[name];
  };
  Scale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
  };
  Scale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  Scale2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Scale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = start2;
    }
    if (!isNaN(end2)) {
      thisExtent[1] = end2;
    }
  };
  Scale2.prototype.isInExtentRange = function(value) {
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  Scale2.prototype.isBlank = function() {
    return this._isBlank;
  };
  Scale2.prototype.setBlank = function(isBlank) {
    this._isBlank = isBlank;
  };
  return Scale2;
}();
enableClassManagement(Scale);
var Scale$1 = Scale;
var uidBase = 0;
var OrdinalMeta = function() {
  function OrdinalMeta2(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this.uid = ++uidBase;
  }
  OrdinalMeta2.createByAxisModel = function(axisModel) {
    var option = axisModel.option;
    var data = option.data;
    var categories = data && map$1(data, getName);
    return new OrdinalMeta2({
      categories,
      needCollect: !categories,
      deduplication: option.dedplication !== false
    });
  };
  OrdinalMeta2.prototype.getOrdinal = function(category) {
    return this._getOrCreateMap().get(category);
  };
  OrdinalMeta2.prototype.parseAndCollect = function(category) {
    var index;
    var needCollect = this._needCollect;
    if (!isString(category) && !needCollect) {
      return category;
    }
    if (needCollect && !this._deduplication) {
      index = this.categories.length;
      this.categories[index] = category;
      return index;
    }
    var map2 = this._getOrCreateMap();
    index = map2.get(category);
    if (index == null) {
      if (needCollect) {
        index = this.categories.length;
        this.categories[index] = category;
        map2.set(category, index);
      } else {
        index = NaN;
      }
    }
    return index;
  };
  OrdinalMeta2.prototype._getOrCreateMap = function() {
    return this._map || (this._map = createHashMap(this.categories));
  };
  return OrdinalMeta2;
}();
function getName(obj) {
  if (isObject$3(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + "";
  }
}
var OrdinalMeta$1 = OrdinalMeta;
function isIntervalOrLogScale(scale2) {
  return scale2.type === "interval" || scale2.type === "log";
}
function intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval) {
  var result = {};
  var span = extent3[1] - extent3[0];
  var interval = result.interval = nice(span / splitNumber, true);
  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }
  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  }
  var precision = result.intervalPrecision = getIntervalPrecision(interval);
  var niceTickExtent = result.niceTickExtent = [round$3(Math.ceil(extent3[0] / interval) * interval, precision), round$3(Math.floor(extent3[1] / interval) * interval, precision)];
  fixExtent(niceTickExtent, extent3);
  return result;
}
function increaseInterval(interval) {
  var exp10 = Math.pow(10, quantityExponent(interval));
  var f = interval / exp10;
  if (!f) {
    f = 1;
  } else if (f === 2) {
    f = 3;
  } else if (f === 3) {
    f = 5;
  } else {
    f *= 2;
  }
  return round$3(f * exp10);
}
function getIntervalPrecision(interval) {
  return getPrecision(interval) + 2;
}
function clamp$1(niceTickExtent, idx, extent3) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent3[1]), extent3[0]);
}
function fixExtent(niceTickExtent, extent3) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent3[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent3[1]);
  clamp$1(niceTickExtent, 0, extent3);
  clamp$1(niceTickExtent, 1, extent3);
  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}
function contain$1(val, extent3) {
  return val >= extent3[0] && val <= extent3[1];
}
function normalize$4(val, extent3) {
  if (extent3[1] === extent3[0]) {
    return 0.5;
  }
  return (val - extent3[0]) / (extent3[1] - extent3[0]);
}
function scale(val, extent3) {
  return val * (extent3[1] - extent3[0]) + extent3[0];
}
var OrdinalScale = function(_super) {
  __extends(OrdinalScale2, _super);
  function OrdinalScale2(setting) {
    var _this = _super.call(this, setting) || this;
    _this.type = "ordinal";
    var ordinalMeta = _this.getSetting("ordinalMeta");
    if (!ordinalMeta) {
      ordinalMeta = new OrdinalMeta$1({});
    }
    if (isArray$1(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta$1({
        categories: map$1(ordinalMeta, function(item) {
          return isObject$3(item) ? item.value : item;
        })
      });
    }
    _this._ordinalMeta = ordinalMeta;
    _this._extent = _this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
    return _this;
  }
  OrdinalScale2.prototype.parse = function(val) {
    return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
  };
  OrdinalScale2.prototype.contain = function(rank) {
    rank = this.parse(rank);
    return contain$1(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
  };
  OrdinalScale2.prototype.normalize = function(val) {
    val = this._getTickNumber(this.parse(val));
    return normalize$4(val, this._extent);
  };
  OrdinalScale2.prototype.scale = function(val) {
    val = Math.round(scale(val, this._extent));
    return this.getRawOrdinalNumber(val);
  };
  OrdinalScale2.prototype.getTicks = function() {
    var ticks = [];
    var extent3 = this._extent;
    var rank = extent3[0];
    while (rank <= extent3[1]) {
      ticks.push({
        value: rank
      });
      rank++;
    }
    return ticks;
  };
  OrdinalScale2.prototype.getMinorTicks = function(splitNumber) {
    return;
  };
  OrdinalScale2.prototype.setSortInfo = function(info) {
    if (info == null) {
      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
      return;
    }
    var infoOrdinalNumbers = info.ordinalNumbers;
    var ordinalsByTick = this._ordinalNumbersByTick = [];
    var ticksByOrdinal = this._ticksByOrdinalNumber = [];
    var tickNum = 0;
    var allCategoryLen = this._ordinalMeta.categories.length;
    for (var len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
      var ordinalNumber = infoOrdinalNumbers[tickNum];
      ordinalsByTick[tickNum] = ordinalNumber;
      ticksByOrdinal[ordinalNumber] = tickNum;
    }
    var unusedOrdinal = 0;
    for (; tickNum < allCategoryLen; ++tickNum) {
      while (ticksByOrdinal[unusedOrdinal] != null) {
        unusedOrdinal++;
      }
      ordinalsByTick.push(unusedOrdinal);
      ticksByOrdinal[unusedOrdinal] = tickNum;
    }
  };
  OrdinalScale2.prototype._getTickNumber = function(ordinal) {
    var ticksByOrdinalNumber = this._ticksByOrdinalNumber;
    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
  };
  OrdinalScale2.prototype.getRawOrdinalNumber = function(tickNumber) {
    var ordinalNumbersByTick = this._ordinalNumbersByTick;
    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
  };
  OrdinalScale2.prototype.getLabel = function(tick) {
    if (!this.isBlank()) {
      var ordinalNumber = this.getRawOrdinalNumber(tick.value);
      var cateogry = this._ordinalMeta.categories[ordinalNumber];
      return cateogry == null ? "" : cateogry + "";
    }
  };
  OrdinalScale2.prototype.count = function() {
    return this._extent[1] - this._extent[0] + 1;
  };
  OrdinalScale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  OrdinalScale2.prototype.isInExtentRange = function(value) {
    value = this._getTickNumber(value);
    return this._extent[0] <= value && this._extent[1] >= value;
  };
  OrdinalScale2.prototype.getOrdinalMeta = function() {
    return this._ordinalMeta;
  };
  OrdinalScale2.prototype.calcNiceTicks = function() {
  };
  OrdinalScale2.prototype.calcNiceExtent = function() {
  };
  OrdinalScale2.type = "ordinal";
  return OrdinalScale2;
}(Scale$1);
Scale$1.registerClass(OrdinalScale);
var OrdinalScale$1 = OrdinalScale;
var roundNumber = round$3;
var IntervalScale = function(_super) {
  __extends(IntervalScale2, _super);
  function IntervalScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "interval";
    _this._interval = 0;
    _this._intervalPrecision = 2;
    return _this;
  }
  IntervalScale2.prototype.parse = function(val) {
    return val;
  };
  IntervalScale2.prototype.contain = function(val) {
    return contain$1(val, this._extent);
  };
  IntervalScale2.prototype.normalize = function(val) {
    return normalize$4(val, this._extent);
  };
  IntervalScale2.prototype.scale = function(val) {
    return scale(val, this._extent);
  };
  IntervalScale2.prototype.setExtent = function(start2, end2) {
    var thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = parseFloat(start2);
    }
    if (!isNaN(end2)) {
      thisExtent[1] = parseFloat(end2);
    }
  };
  IntervalScale2.prototype.unionExtent = function(other) {
    var extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
    this.setExtent(extent3[0], extent3[1]);
  };
  IntervalScale2.prototype.getInterval = function() {
    return this._interval;
  };
  IntervalScale2.prototype.setInterval = function(interval) {
    this._interval = interval;
    this._niceExtent = this._extent.slice();
    this._intervalPrecision = getIntervalPrecision(interval);
  };
  IntervalScale2.prototype.getTicks = function(expandToNicedExtent) {
    var interval = this._interval;
    var extent3 = this._extent;
    var niceTickExtent = this._niceExtent;
    var intervalPrecision = this._intervalPrecision;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    var safeLimit = 1e4;
    if (extent3[0] < niceTickExtent[0]) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[0]
        });
      }
    }
    var tick = niceTickExtent[0];
    while (tick <= niceTickExtent[1]) {
      ticks.push({
        value: tick
      });
      tick = roundNumber(tick + interval, intervalPrecision);
      if (tick === ticks[ticks.length - 1].value) {
        break;
      }
      if (ticks.length > safeLimit) {
        return [];
      }
    }
    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
    if (extent3[1] > lastNiceTick) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(lastNiceTick + interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[1]
        });
      }
    }
    return ticks;
  };
  IntervalScale2.prototype.getMinorTicks = function(splitNumber) {
    var ticks = this.getTicks(true);
    var minorTicks = [];
    var extent3 = this.getExtent();
    for (var i = 1; i < ticks.length; i++) {
      var nextTick2 = ticks[i];
      var prevTick = ticks[i - 1];
      var count2 = 0;
      var minorTicksGroup = [];
      var interval = nextTick2.value - prevTick.value;
      var minorInterval = interval / splitNumber;
      while (count2 < splitNumber - 1) {
        var minorTick = roundNumber(prevTick.value + (count2 + 1) * minorInterval);
        if (minorTick > extent3[0] && minorTick < extent3[1]) {
          minorTicksGroup.push(minorTick);
        }
        count2++;
      }
      minorTicks.push(minorTicksGroup);
    }
    return minorTicks;
  };
  IntervalScale2.prototype.getLabel = function(data, opt) {
    if (data == null) {
      return "";
    }
    var precision = opt && opt.precision;
    if (precision == null) {
      precision = getPrecision(data.value) || 0;
    } else if (precision === "auto") {
      precision = this._intervalPrecision;
    }
    var dataNum = roundNumber(data.value, precision, true);
    return addCommas(dataNum);
  };
  IntervalScale2.prototype.calcNiceTicks = function(splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      return;
    }
    if (span < 0) {
      span = -span;
      extent3.reverse();
    }
    var result = intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  };
  IntervalScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      if (extent3[0] !== 0) {
        var expandSize = extent3[0];
        if (!opt.fixMax) {
          extent3[1] += expandSize / 2;
          extent3[0] -= expandSize / 2;
        } else {
          extent3[0] -= expandSize / 2;
        }
      } else {
        extent3[1] = 1;
      }
    }
    var span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      extent3[0] = 0;
      extent3[1] = 1;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
    var interval = this._interval;
    if (!opt.fixMin) {
      extent3[0] = roundNumber(Math.floor(extent3[0] / interval) * interval);
    }
    if (!opt.fixMax) {
      extent3[1] = roundNumber(Math.ceil(extent3[1] / interval) * interval);
    }
  };
  IntervalScale2.prototype.setNiceExtent = function(min3, max3) {
    this._niceExtent = [min3, max3];
  };
  IntervalScale2.type = "interval";
  return IntervalScale2;
}(Scale$1);
Scale$1.registerClass(IntervalScale);
var IntervalScale$1 = IntervalScale;
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if (isArray$1(arg)) {
    return supportFloat32Array ? new Float32Array(arg) : arg;
  }
  return new Float32ArrayCtor(arg);
}
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId$1(seriesModel) {
  return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey$1(axis) {
  return axis.dim + axis.index;
}
function getLayoutOnAxis(opt) {
  var params = [];
  var baseAxis = opt.axis;
  var axisKey = "axis0";
  if (baseAxis.type !== "category") {
    return;
  }
  var bandWidth = baseAxis.getBandWidth();
  for (var i = 0; i < opt.count || 0; i++) {
    params.push(defaults({
      bandWidth,
      axisKey,
      stackId: STACK_PREFIX + i
    }, opt));
  }
  var widthAndOffsets = doCalBarWidthAndOffset(params);
  var result = [];
  for (var i = 0; i < opt.count; i++) {
    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
    item.offsetCenter = item.offset + item.width / 2;
    result.push(item);
  }
  return result;
}
function prepareLayoutBarSeries(seriesType2, ecModel) {
  var seriesModels = [];
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (isOnCartesian(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}
function getValueAxesMinGaps(barSeries) {
  var axisValues = {};
  each$f(barSeries, function(seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    if (baseAxis.type !== "time" && baseAxis.type !== "value") {
      return;
    }
    var data = seriesModel.getData();
    var key2 = baseAxis.dim + "_" + baseAxis.index;
    var dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
    var store = data.getStore();
    for (var i = 0, cnt = store.count(); i < cnt; ++i) {
      var value = store.get(dimIdx, i);
      if (!axisValues[key2]) {
        axisValues[key2] = [value];
      } else {
        axisValues[key2].push(value);
      }
    }
  });
  var axisMinGaps = {};
  for (var key in axisValues) {
    if (axisValues.hasOwnProperty(key)) {
      var valuesInAxis = axisValues[key];
      if (valuesInAxis) {
        valuesInAxis.sort(function(a, b) {
          return a - b;
        });
        var min3 = null;
        for (var j = 1; j < valuesInAxis.length; ++j) {
          var delta = valuesInAxis[j] - valuesInAxis[j - 1];
          if (delta > 0) {
            min3 = min3 === null ? delta : Math.min(min3, delta);
          }
        }
        axisMinGaps[key] = min3;
      }
    }
  }
  return axisMinGaps;
}
function makeColumnLayout(barSeries) {
  var axisMinGaps = getValueAxesMinGaps(barSeries);
  var seriesInfoList = [];
  each$f(barSeries, function(seriesModel) {
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var axisExtent = baseAxis.getExtent();
    var bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else if (baseAxis.type === "value" || baseAxis.type === "time") {
      var key = baseAxis.dim + "_" + baseAxis.index;
      var minGap = axisMinGaps[key];
      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
      var scale2 = baseAxis.scale.getExtent();
      var scaleSpan = Math.abs(scale2[1] - scale2[0]);
      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
    } else {
      var data = seriesModel.getData();
      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    }
    var barWidth = parsePercent$1(seriesModel.get("barWidth"), bandWidth);
    var barMaxWidth = parsePercent$1(seriesModel.get("barMaxWidth"), bandWidth);
    var barMinWidth = parsePercent$1(seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);
    var barGap = seriesModel.get("barGap");
    var barCategoryGap = seriesModel.get("barCategoryGap");
    seriesInfoList.push({
      bandWidth,
      barWidth,
      barMaxWidth,
      barMinWidth,
      barGap,
      barCategoryGap,
      axisKey: getAxisKey$1(baseAxis),
      stackId: getSeriesStackId$1(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
  var columnsMap = {};
  each$f(seriesInfoList, function(seriesInfo, idx) {
    var axisKey = seriesInfo.axisKey;
    var bandWidth = seriesInfo.bandWidth;
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = seriesInfo.stackId;
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = seriesInfo.barWidth;
    if (barWidth && !stacks[stackId].width) {
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }
    var barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    var barMinWidth = seriesInfo.barMinWidth;
    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
    var barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    var barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each$f(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGapPercent = columnsOnAxis.categoryGap;
    if (categoryGapPercent == null) {
      var columnCount = keys(stacks).length;
      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
    }
    var categoryGap = parsePercent$1(categoryGapPercent, bandWidth);
    var barGapPercent = parsePercent$1(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each$f(stacks, function(column) {
      var maxWidth = column.maxWidth;
      var minWidth = column.minWidth;
      if (!column.width) {
        var finalWidth = autoWidth;
        if (maxWidth && maxWidth < finalWidth) {
          finalWidth = Math.min(maxWidth, remainedWidth);
        }
        if (minWidth && minWidth > finalWidth) {
          finalWidth = minWidth;
        }
        if (finalWidth !== autoWidth) {
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      } else {
        var finalWidth = column.width;
        if (maxWidth) {
          finalWidth = Math.min(finalWidth, maxWidth);
        }
        if (minWidth) {
          finalWidth = Math.max(finalWidth, minWidth);
        }
        column.width = finalWidth;
        remainedWidth -= finalWidth + barGapPercent * finalWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each$f(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    var offset = -widthSum / 2;
    each$f(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        bandWidth,
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    var result = barWidthAndOffset[getAxisKey$1(axis)];
    if (result != null && seriesModel != null) {
      return result[getSeriesStackId$1(seriesModel)];
    }
    return result;
  }
}
function layout$3(seriesType2, ecModel) {
  var seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
  var barWidthAndOffset = makeColumnLayout(seriesModels);
  each$f(seriesModels, function(seriesModel) {
    var data = seriesModel.getData();
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var stackId = getSeriesStackId$1(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[getAxisKey$1(baseAxis)][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    data.setLayout({
      bandWidth: columnLayoutInfo.bandWidth,
      offset: columnOffset,
      size: columnWidth
    });
  });
}
function createProgressiveLayout(seriesType2) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      if (!isOnCartesian(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var valueAxis2 = cartesian.getOtherAxis(baseAxis);
      var valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis2.dim));
      var baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      var drawBackground = seriesModel.get("showBackground", true);
      var valueDim = data.mapDimension(valueAxis2.dim);
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      var stacked = isDimensionStacked$2(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
      var isValueAxisH = valueAxis2.isHorizontal();
      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis2);
      var isLarge = isInLargeMode(seriesModel);
      var barMinHeight = seriesModel.get("barMinHeight") || 0;
      var stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
      var columnWidth = data.getLayout("size");
      var columnOffset = data.getLayout("offset");
      return {
        progress: function(params, data2) {
          var count2 = params.count;
          var largePoints = isLarge && createFloat32Array(count2 * 3);
          var largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count2 * 3);
          var largeDataIndices = isLarge && createFloat32Array(count2);
          var coordLayout = cartesian.master.getRect();
          var bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
          var dataIndex;
          var store = data2.getStore();
          var idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            var value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
            var baseValue = store.get(baseDimIdx, dataIndex);
            var baseCoord = valueAxisStart;
            var startValue = void 0;
            if (stacked) {
              startValue = +value - store.get(valueDimIdx, dataIndex);
            }
            var x = void 0;
            var y = void 0;
            var width = void 0;
            var height = void 0;
            if (isValueAxisH) {
              var coord = cartesian.dataToPoint([value, baseValue]);
              if (stacked) {
                var startCoord = cartesian.dataToPoint([startValue, baseValue]);
                baseCoord = startCoord[0];
              }
              x = baseCoord;
              y = coord[1] + columnOffset;
              width = coord[0] - baseCoord;
              height = columnWidth;
              if (Math.abs(width) < barMinHeight) {
                width = (width < 0 ? -1 : 1) * barMinHeight;
              }
            } else {
              var coord = cartesian.dataToPoint([baseValue, value]);
              if (stacked) {
                var startCoord = cartesian.dataToPoint([baseValue, startValue]);
                baseCoord = startCoord[1];
              }
              x = coord[0] + columnOffset;
              y = baseCoord;
              width = columnWidth;
              height = coord[1] - baseCoord;
              if (Math.abs(height) < barMinHeight) {
                height = (height <= 0 ? -1 : 1) * barMinHeight;
              }
            }
            if (!isLarge) {
              data2.setItemLayout(dataIndex, {
                x,
                y,
                width,
                height
              });
            } else {
              largePoints[idxOffset] = x;
              largePoints[idxOffset + 1] = y;
              largePoints[idxOffset + 2] = isValueAxisH ? width : height;
              if (largeBackgroundPoints) {
                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;
                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;
                largeBackgroundPoints[idxOffset + 2] = bgSize;
              }
              largeDataIndices[dataIndex] = dataIndex;
            }
            idxOffset += 3;
          }
          if (isLarge) {
            data2.setLayout({
              largePoints,
              largeDataIndices,
              largeBackgroundPoints,
              valueAxisHorizontal: isValueAxisH
            });
          }
        }
      };
    }
  };
}
function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis2) {
  return valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(valueAxis2.type === "log" ? 1 : 0));
}
var bisect = function(a, x, lo, hi) {
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid][1] < x) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
};
var TimeScale = function(_super) {
  __extends(TimeScale2, _super);
  function TimeScale2(settings) {
    var _this = _super.call(this, settings) || this;
    _this.type = "time";
    return _this;
  }
  TimeScale2.prototype.getLabel = function(tick) {
    var useUTC = this.getSetting("useUTC");
    return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
  };
  TimeScale2.prototype.getFormattedLabel = function(tick, idx, labelFormatter) {
    var isUTC = this.getSetting("useUTC");
    var lang = this.getSetting("locale");
    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
  };
  TimeScale2.prototype.getTicks = function() {
    var interval = this._interval;
    var extent3 = this._extent;
    var ticks = [];
    if (!interval) {
      return ticks;
    }
    ticks.push({
      value: extent3[0],
      level: 0
    });
    var useUTC = this.getSetting("useUTC");
    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent3);
    ticks = ticks.concat(innerTicks);
    ticks.push({
      value: extent3[1],
      level: 0
    });
    return ticks;
  };
  TimeScale2.prototype.calcNiceExtent = function(opt) {
    var extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      extent3[0] -= ONE_DAY;
      extent3[1] += ONE_DAY;
    }
    if (extent3[1] === -Infinity && extent3[0] === Infinity) {
      var d = new Date();
      extent3[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
      extent3[0] = extent3[1] - ONE_DAY;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
  };
  TimeScale2.prototype.calcNiceTicks = function(approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    this._approxInterval = span / approxTickNum;
    if (minInterval != null && this._approxInterval < minInterval) {
      this._approxInterval = minInterval;
    }
    if (maxInterval != null && this._approxInterval > maxInterval) {
      this._approxInterval = maxInterval;
    }
    var scaleIntervalsLen = scaleIntervals.length;
    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
    this._interval = scaleIntervals[idx][1];
    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
  };
  TimeScale2.prototype.parse = function(val) {
    return isNumber(val) ? val : +parseDate(val);
  };
  TimeScale2.prototype.contain = function(val) {
    return contain$1(this.parse(val), this._extent);
  };
  TimeScale2.prototype.normalize = function(val) {
    return normalize$4(this.parse(val), this._extent);
  };
  TimeScale2.prototype.scale = function(val) {
    return scale(val, this._extent);
  };
  TimeScale2.type = "time";
  return TimeScale2;
}(IntervalScale$1);
var scaleIntervals = [
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
];
function isUnitValueSame(unit, valueA, valueB, isUTC) {
  var dateA = parseDate(valueA);
  var dateB = parseDate(valueB);
  var isSame = function(unit2) {
    return getUnitValue(dateA, unit2, isUTC) === getUnitValue(dateB, unit2, isUTC);
  };
  var isSameYear = function() {
    return isSame("year");
  };
  var isSameMonth = function() {
    return isSameYear() && isSame("month");
  };
  var isSameDay = function() {
    return isSameMonth() && isSame("day");
  };
  var isSameHour = function() {
    return isSameDay() && isSame("hour");
  };
  var isSameMinute = function() {
    return isSameHour() && isSame("minute");
  };
  var isSameSecond = function() {
    return isSameMinute() && isSame("second");
  };
  var isSameMilliSecond = function() {
    return isSameSecond() && isSame("millisecond");
  };
  switch (unit) {
    case "year":
      return isSameYear();
    case "month":
      return isSameMonth();
    case "day":
      return isSameDay();
    case "hour":
      return isSameHour();
    case "minute":
      return isSameMinute();
    case "second":
      return isSameSecond();
    case "millisecond":
      return isSameMilliSecond();
  }
}
function getDateInterval(approxInterval, daysInMonth) {
  approxInterval /= ONE_DAY;
  return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
  var APPROX_ONE_MONTH = 30 * ONE_DAY;
  approxInterval /= APPROX_ONE_MONTH;
  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
  approxInterval /= ONE_HOUR;
  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
  return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(date, unitName, isUTC) {
  var outDate = new Date(date);
  switch (getPrimaryTimeUnit(unitName)) {
    case "year":
    case "month":
      outDate[monthSetterName(isUTC)](0);
    case "day":
      outDate[dateSetterName(isUTC)](1);
    case "hour":
      outDate[hoursSetterName(isUTC)](0);
    case "minute":
      outDate[minutesSetterName(isUTC)](0);
    case "second":
      outDate[secondsSetterName(isUTC)](0);
      outDate[millisecondsSetterName(isUTC)](0);
  }
  return outDate.getTime();
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent3) {
  var safeLimit = 1e4;
  var unitNames = timeUnits;
  var iter = 0;
  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out2) {
    var date = new Date(minTimestamp);
    var dateTime = minTimestamp;
    var d = date[getMethodName]();
    while (dateTime < maxTimestamp && dateTime <= extent3[1]) {
      out2.push({
        value: dateTime
      });
      d += interval;
      date[setMethodName](d);
      dateTime = date.getTime();
    }
    out2.push({
      value: dateTime,
      notAdd: true
    });
  }
  function addLevelTicks(unitName, lastLevelTicks, levelTicks2) {
    var newAddedTicks = [];
    var isFirstLevel = !lastLevelTicks.length;
    if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent3[0], extent3[1], isUTC)) {
      return;
    }
    if (isFirstLevel) {
      lastLevelTicks = [{
        value: getFirstTimestampOfUnit(new Date(extent3[0]), unitName, isUTC)
      }, {
        value: extent3[1]
      }];
    }
    for (var i2 = 0; i2 < lastLevelTicks.length - 1; i2++) {
      var startTick = lastLevelTicks[i2].value;
      var endTick = lastLevelTicks[i2 + 1].value;
      if (startTick === endTick) {
        continue;
      }
      var interval = void 0;
      var getterName = void 0;
      var setterName = void 0;
      var isDate = false;
      switch (unitName) {
        case "year":
          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
          getterName = fullYearGetterName(isUTC);
          setterName = fullYearSetterName(isUTC);
          break;
        case "half-year":
        case "quarter":
        case "month":
          interval = getMonthInterval(approxInterval);
          getterName = monthGetterName(isUTC);
          setterName = monthSetterName(isUTC);
          break;
        case "week":
        case "half-week":
        case "day":
          interval = getDateInterval(approxInterval);
          getterName = dateGetterName(isUTC);
          setterName = dateSetterName(isUTC);
          isDate = true;
          break;
        case "half-day":
        case "quarter-day":
        case "hour":
          interval = getHourInterval(approxInterval);
          getterName = hoursGetterName(isUTC);
          setterName = hoursSetterName(isUTC);
          break;
        case "minute":
          interval = getMinutesAndSecondsInterval(approxInterval, true);
          getterName = minutesGetterName(isUTC);
          setterName = minutesSetterName(isUTC);
          break;
        case "second":
          interval = getMinutesAndSecondsInterval(approxInterval, false);
          getterName = secondsGetterName(isUTC);
          setterName = secondsSetterName(isUTC);
          break;
        case "millisecond":
          interval = getMillisecondsInterval(approxInterval);
          getterName = millisecondsGetterName(isUTC);
          setterName = millisecondsSetterName(isUTC);
          break;
      }
      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
      if (unitName === "year" && levelTicks2.length > 1 && i2 === 0) {
        levelTicks2.unshift({
          value: levelTicks2[0].value - interval
        });
      }
    }
    for (var i2 = 0; i2 < newAddedTicks.length; i2++) {
      levelTicks2.push(newAddedTicks[i2]);
    }
    return newAddedTicks;
  }
  var levelsTicks = [];
  var currentLevelTicks = [];
  var tickCount = 0;
  var lastLevelTickCount = 0;
  for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {
    var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);
    if (!isPrimaryTimeUnit(unitNames[i])) {
      continue;
    }
    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
    var nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;
    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
      if (currentLevelTicks.length) {
        lastLevelTickCount = tickCount;
        currentLevelTicks.sort(function(a, b) {
          return a.value - b.value;
        });
        var levelTicksRemoveDuplicated = [];
        for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
          var tickValue = currentLevelTicks[i_1].value;
          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
            if (tickValue >= extent3[0] && tickValue <= extent3[1]) {
              tickCount++;
            }
          }
        }
        var targetTickNum = (extent3[1] - extent3[0]) / approxInterval;
        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
          break;
        }
        levelsTicks.push(levelTicksRemoveDuplicated);
        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
          break;
        }
      }
      currentLevelTicks = [];
    }
  }
  var levelsTicksInExtent = filter(map$1(levelsTicks, function(levelTicks2) {
    return filter(levelTicks2, function(tick) {
      return tick.value >= extent3[0] && tick.value <= extent3[1] && !tick.notAdd;
    });
  }), function(levelTicks2) {
    return levelTicks2.length > 0;
  });
  var ticks = [];
  var maxLevel = levelsTicksInExtent.length - 1;
  for (var i = 0; i < levelsTicksInExtent.length; ++i) {
    var levelTicks = levelsTicksInExtent[i];
    for (var k = 0; k < levelTicks.length; ++k) {
      ticks.push({
        value: levelTicks[k].value,
        level: maxLevel - i
      });
    }
  }
  ticks.sort(function(a, b) {
    return a.value - b.value;
  });
  var result = [];
  for (var i = 0; i < ticks.length; ++i) {
    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
      result.push(ticks[i]);
    }
  }
  return result;
}
Scale$1.registerClass(TimeScale);
var TimeScale$1 = TimeScale;
var scaleProto = Scale$1.prototype;
var intervalScaleProto = IntervalScale$1.prototype;
var roundingErrorFix = round$3;
var mathFloor$1 = Math.floor;
var mathCeil$1 = Math.ceil;
var mathPow$1 = Math.pow;
var mathLog$1 = Math.log;
var LogScale = function(_super) {
  __extends(LogScale2, _super);
  function LogScale2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    _this.base = 10;
    _this._originalScale = new IntervalScale$1();
    _this._interval = 0;
    return _this;
  }
  LogScale2.prototype.getTicks = function(expandToNicedExtent) {
    var originalScale = this._originalScale;
    var extent3 = this._extent;
    var originalExtent = originalScale.getExtent();
    var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
    return map$1(ticks, function(tick) {
      var val = tick.value;
      var powVal = round$3(mathPow$1(this.base, val));
      powVal = val === extent3[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent3[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return {
        value: powVal
      };
    }, this);
  };
  LogScale2.prototype.setExtent = function(start2, end2) {
    var base2 = this.base;
    start2 = mathLog$1(start2) / mathLog$1(base2);
    end2 = mathLog$1(end2) / mathLog$1(base2);
    intervalScaleProto.setExtent.call(this, start2, end2);
  };
  LogScale2.prototype.getExtent = function() {
    var base2 = this.base;
    var extent3 = scaleProto.getExtent.call(this);
    extent3[0] = mathPow$1(base2, extent3[0]);
    extent3[1] = mathPow$1(base2, extent3[1]);
    var originalScale = this._originalScale;
    var originalExtent = originalScale.getExtent();
    this._fixMin && (extent3[0] = fixRoundingError(extent3[0], originalExtent[0]));
    this._fixMax && (extent3[1] = fixRoundingError(extent3[1], originalExtent[1]));
    return extent3;
  };
  LogScale2.prototype.unionExtent = function(extent3) {
    this._originalScale.unionExtent(extent3);
    var base2 = this.base;
    extent3[0] = mathLog$1(extent3[0]) / mathLog$1(base2);
    extent3[1] = mathLog$1(extent3[1]) / mathLog$1(base2);
    scaleProto.unionExtent.call(this, extent3);
  };
  LogScale2.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  LogScale2.prototype.calcNiceTicks = function(approxTickNum) {
    approxTickNum = approxTickNum || 10;
    var extent3 = this._extent;
    var span = extent3[1] - extent3[0];
    if (span === Infinity || span <= 0) {
      return;
    }
    var interval = quantity(span);
    var err = approxTickNum / span * interval;
    if (err <= 0.5) {
      interval *= 10;
    }
    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }
    var niceExtent = [round$3(mathCeil$1(extent3[0] / interval) * interval), round$3(mathFloor$1(extent3[1] / interval) * interval)];
    this._interval = interval;
    this._niceExtent = niceExtent;
  };
  LogScale2.prototype.calcNiceExtent = function(opt) {
    intervalScaleProto.calcNiceExtent.call(this, opt);
    this._fixMin = opt.fixMin;
    this._fixMax = opt.fixMax;
  };
  LogScale2.prototype.parse = function(val) {
    return val;
  };
  LogScale2.prototype.contain = function(val) {
    val = mathLog$1(val) / mathLog$1(this.base);
    return contain$1(val, this._extent);
  };
  LogScale2.prototype.normalize = function(val) {
    val = mathLog$1(val) / mathLog$1(this.base);
    return normalize$4(val, this._extent);
  };
  LogScale2.prototype.scale = function(val) {
    val = scale(val, this._extent);
    return mathPow$1(this.base, val);
  };
  LogScale2.type = "log";
  return LogScale2;
}(Scale$1);
var proto$5 = LogScale.prototype;
proto$5.getMinorTicks = intervalScaleProto.getMinorTicks;
proto$5.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecision(originalVal));
}
Scale$1.registerClass(LogScale);
var LogScale$1 = LogScale;
var ScaleRawExtentInfo = function() {
  function ScaleRawExtentInfo2(scale2, model, originalExtent) {
    this._prepareParams(scale2, model, originalExtent);
  }
  ScaleRawExtentInfo2.prototype._prepareParams = function(scale2, model, dataExtent) {
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }
    this._dataMin = dataExtent[0];
    this._dataMax = dataExtent[1];
    var isOrdinal = this._isOrdinal = scale2.type === "ordinal";
    this._needCrossZero = scale2.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
    var modelMinRaw = this._modelMinRaw = model.get("min", true);
    if (isFunction$1(modelMinRaw)) {
      this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMinRaw !== "dataMin") {
      this._modelMinNum = parseAxisModelMinMax(scale2, modelMinRaw);
    }
    var modelMaxRaw = this._modelMaxRaw = model.get("max", true);
    if (isFunction$1(modelMaxRaw)) {
      this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMaxRaw !== "dataMax") {
      this._modelMaxNum = parseAxisModelMinMax(scale2, modelMaxRaw);
    }
    if (isOrdinal) {
      this._axisDataLen = model.getCategories().length;
    } else {
      var boundaryGap = model.get("boundaryGap");
      var boundaryGapArr = isArray$1(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
      if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
        this._boundaryGapInner = [0, 0];
      } else {
        this._boundaryGapInner = [parsePercent$2(boundaryGapArr[0], 1), parsePercent$2(boundaryGapArr[1], 1)];
      }
    }
  };
  ScaleRawExtentInfo2.prototype.calculate = function() {
    var isOrdinal = this._isOrdinal;
    var dataMin = this._dataMin;
    var dataMax = this._dataMax;
    var axisDataLen = this._axisDataLen;
    var boundaryGapInner = this._boundaryGapInner;
    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
    var min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
    var max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
    var minFixed = min3 != null;
    var maxFixed = max3 != null;
    if (min3 == null) {
      min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
    }
    if (max3 == null) {
      max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
    }
    (min3 == null || !isFinite(min3)) && (min3 = NaN);
    (max3 == null || !isFinite(max3)) && (max3 = NaN);
    var isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
    if (this._needCrossZero) {
      if (min3 > 0 && max3 > 0 && !minFixed) {
        min3 = 0;
      }
      if (min3 < 0 && max3 < 0 && !maxFixed) {
        max3 = 0;
      }
    }
    var determinedMin = this._determinedMin;
    var determinedMax = this._determinedMax;
    if (determinedMin != null) {
      min3 = determinedMin;
      minFixed = true;
    }
    if (determinedMax != null) {
      max3 = determinedMax;
      maxFixed = true;
    }
    return {
      min: min3,
      max: max3,
      minFixed,
      maxFixed,
      isBlank
    };
  };
  ScaleRawExtentInfo2.prototype.modifyDataMinMax = function(minMaxName, val) {
    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
  };
  ScaleRawExtentInfo2.prototype.setDeterminedMinMax = function(minMaxName, val) {
    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
    this[attr] = val;
  };
  ScaleRawExtentInfo2.prototype.freeze = function() {
    this.frozen = true;
  };
  return ScaleRawExtentInfo2;
}();
var DETERMINED_MIN_MAX_ATTR = {
  min: "_determinedMin",
  max: "_determinedMax"
};
var DATA_MIN_MAX_ATTR = {
  min: "_dataMin",
  max: "_dataMax"
};
function ensureScaleRawExtentInfo(scale2, model, originalExtent) {
  var rawExtentInfo = scale2.rawExtentInfo;
  if (rawExtentInfo) {
    return rawExtentInfo;
  }
  rawExtentInfo = new ScaleRawExtentInfo(scale2, model, originalExtent);
  scale2.rawExtentInfo = rawExtentInfo;
  return rawExtentInfo;
}
function parseAxisModelMinMax(scale2, minMax) {
  return minMax == null ? null : eqNaN(minMax) ? NaN : scale2.parse(minMax);
}
function getScaleExtent(scale2, model) {
  var scaleType = scale2.type;
  var rawExtentResult = ensureScaleRawExtentInfo(scale2, model, scale2.getExtent()).calculate();
  scale2.setBlank(rawExtentResult.isBlank);
  var min3 = rawExtentResult.min;
  var max3 = rawExtentResult.max;
  var ecModel = model.ecModel;
  if (ecModel && scaleType === "time") {
    var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
    var isBaseAxisAndHasBarSeries_1 = false;
    each$f(barSeriesModels, function(seriesModel) {
      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
    });
    if (isBaseAxisAndHasBarSeries_1) {
      var barWidthAndOffset = makeColumnLayout(barSeriesModels);
      var adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
      min3 = adjustedScale.min;
      max3 = adjustedScale.max;
    }
  }
  return {
    extent: [min3, max3],
    fixMin: rawExtentResult.minFixed,
    fixMax: rawExtentResult.maxFixed
  };
}
function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
  var axisExtent = model.axis.getExtent();
  var axisLength = axisExtent[1] - axisExtent[0];
  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
  if (barsOnCurrentAxis === void 0) {
    return {
      min: min3,
      max: max3
    };
  }
  var minOverflow = Infinity;
  each$f(barsOnCurrentAxis, function(item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  var maxOverflow = -Infinity;
  each$f(barsOnCurrentAxis, function(item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  var totalOverFlow = minOverflow + maxOverflow;
  var oldRange = max3 - min3;
  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max3 += overflowBuffer * (maxOverflow / totalOverFlow);
  min3 -= overflowBuffer * (minOverflow / totalOverFlow);
  return {
    min: min3,
    max: max3
  };
}
function niceScaleExtent(scale2, inModel) {
  var model = inModel;
  var extentInfo = getScaleExtent(scale2, model);
  var extent3 = extentInfo.extent;
  var splitNumber = model.get("splitNumber");
  if (scale2 instanceof LogScale$1) {
    scale2.base = model.get("logBase");
  }
  var scaleType = scale2.type;
  var interval = model.get("interval");
  var isIntervalOrTime = scaleType === "interval" || scaleType === "time";
  scale2.setExtent(extent3[0], extent3[1]);
  scale2.calcNiceExtent({
    splitNumber,
    fixMin: extentInfo.fixMin,
    fixMax: extentInfo.fixMax,
    minInterval: isIntervalOrTime ? model.get("minInterval") : null,
    maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
  });
  if (interval != null) {
    scale2.setInterval && scale2.setInterval(interval);
  }
}
function createScaleByModel$1(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new TimeScale$1({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new (Scale$1.getClass(axisType) || IntervalScale$1)();
    }
  }
}
function ifAxisCrossZero(axis) {
  var dataExtent = axis.scale.getExtent();
  var min3 = dataExtent[0];
  var max3 = dataExtent[1];
  return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
}
function makeLabelFormatter(axis) {
  var labelFormatter = axis.getLabelModel().get("formatter");
  var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
  if (axis.scale.type === "time") {
    return function(tpl) {
      return function(tick, idx) {
        return axis.scale.getFormattedLabel(tick, idx, tpl);
      };
    }(labelFormatter);
  } else if (isString(labelFormatter)) {
    return function(tpl) {
      return function(tick) {
        var label = axis.scale.getLabel(tick);
        var text = tpl.replace("{value}", label != null ? label : "");
        return text;
      };
    }(labelFormatter);
  } else if (isFunction$1(labelFormatter)) {
    return function(cb) {
      return function(tick, idx) {
        if (categoryTickStart != null) {
          idx = tick.value - categoryTickStart;
        }
        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
          level: tick.level
        } : null);
      };
    }(labelFormatter);
  } else {
    return function(tick) {
      return axis.scale.getLabel(tick);
    };
  }
}
function getAxisRawValue(axis, tick) {
  return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
function estimateLabelUnionRect(axis) {
  var axisModel = axis.model;
  var scale2 = axis.scale;
  if (!axisModel.get(["axisLabel", "show"]) || scale2.isBlank()) {
    return;
  }
  var realNumberScaleTicks;
  var tickCount;
  var categoryScaleExtent = scale2.getExtent();
  if (scale2 instanceof OrdinalScale$1) {
    tickCount = scale2.count();
  } else {
    realNumberScaleTicks = scale2.getTicks();
    tickCount = realNumberScaleTicks.length;
  }
  var axisLabelModel = axis.getLabelModel();
  var labelFormatter = makeLabelFormatter(axis);
  var rect;
  var step = 1;
  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }
  for (var i = 0; i < tickCount; i += step) {
    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {
      value: categoryScaleExtent[0] + i
    };
    var label = labelFormatter(tick, i);
    var unrotatedSingleRect = axisLabelModel.getTextRect(label);
    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }
  return rect;
}
function rotateTextRect(textRect, rotate2) {
  var rotateRadians = rotate2 * Math.PI / 180;
  var beforeWidth = textRect.width;
  var beforeHeight = textRect.height;
  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
  var rotatedRect = new BoundingRect$1(textRect.x, textRect.y, afterWidth, afterHeight);
  return rotatedRect;
}
function getOptionCategoryInterval(model) {
  var interval = model.get("interval");
  return interval == null ? "auto" : interval;
}
function shouldShowAllLabels(axis) {
  return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
  var dataDimMap = {};
  each$f(data.mapDimensionsAll(axisDim), function(dataDim) {
    dataDimMap[getStackedDimension(data, dataDim)] = true;
  });
  return keys(dataDimMap);
}
function unionAxisExtentFromData(dataExtent, data, axisDim) {
  if (data) {
    each$f(getDataDimensionsOnAxis(data, axisDim), function(dim) {
      var seriesExtent = data.getApproximateExtent(dim);
      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
    });
  }
}
var AxisModelCommonMixin = function() {
  function AxisModelCommonMixin2() {
  }
  AxisModelCommonMixin2.prototype.getNeedCrossZero = function() {
    var option = this.option;
    return !option.scale;
  };
  AxisModelCommonMixin2.prototype.getCoordSysModel = function() {
    return;
  };
  return AxisModelCommonMixin2;
}();
function createList$3(seriesModel) {
  return createSeriesData(null, seriesModel);
}
var dataStack = {
  isDimensionStacked: isDimensionStacked$2,
  enableDataStack,
  getStackedDimension
};
function createScale(dataExtent, option) {
  var axisModel = option;
  if (!(option instanceof Model$1)) {
    axisModel = new Model$1(option);
  }
  var scale2 = createScaleByModel$1(axisModel);
  scale2.setExtent(dataExtent[0], dataExtent[1]);
  niceScaleExtent(scale2, axisModel);
  return scale2;
}
function mixinAxisModelCommonMethods(Model2) {
  mixin(Model2, AxisModelCommonMixin);
}
function createTextStyle(textStyleModel, opts) {
  opts = opts || {};
  return createTextStyle$1(textStyleModel, null, null, opts.state !== "normal");
}
var EPSILON$1 = 1e-8;
function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON$1;
}
function contain(points2, x, y) {
  var w = 0;
  var p = points2[0];
  if (!p) {
    return false;
  }
  for (var i = 1; i < points2.length; i++) {
    var p22 = points2[i];
    w += windingLine(p[0], p[1], p22[0], p22[1], x, y);
    p = p22;
  }
  var p02 = points2[0];
  if (!isAroundEqual(p[0], p02[0]) || !isAroundEqual(p[1], p02[1])) {
    w += windingLine(p[0], p[1], p02[0], p02[1], x, y);
  }
  return w !== 0;
}
var TMP_TRANSFORM = [];
function transformPoints(points2, transform2) {
  for (var p = 0; p < points2.length; p++) {
    applyTransform$1(points2[p], points2[p], transform2);
  }
}
function updateBBoxFromPoints(points2, min3, max3, projection) {
  for (var i = 0; i < points2.length; i++) {
    var p = points2[i];
    if (projection) {
      p = projection.project(p);
    }
    if (p && isFinite(p[0]) && isFinite(p[1])) {
      min$1(min3, min3, p);
      max$1(max3, max3, p);
    }
  }
}
function centroid$1(points2) {
  var signedArea2 = 0;
  var cx = 0;
  var cy = 0;
  var len2 = points2.length;
  var x0 = points2[len2 - 1][0];
  var y0 = points2[len2 - 1][1];
  for (var i = 0; i < len2; i++) {
    var x1 = points2[i][0];
    var y1 = points2[i][1];
    var a = x0 * y1 - x1 * y0;
    signedArea2 += a;
    cx += (x0 + x1) * a;
    cy += (y0 + y1) * a;
    x0 = x1;
    y0 = y1;
  }
  return signedArea2 ? [cx / signedArea2 / 3, cy / signedArea2 / 3, signedArea2] : [points2[0][0] || 0, points2[0][1] || 0];
}
var Region = function() {
  function Region2(name) {
    this.name = name;
  }
  Region2.prototype.setCenter = function(center2) {
    this._center = center2;
  };
  Region2.prototype.getCenter = function() {
    var center2 = this._center;
    if (!center2) {
      center2 = this._center = this.calcCenter();
    }
    return center2;
  };
  return Region2;
}();
var GeoJSONPolygonGeometry = function() {
  function GeoJSONPolygonGeometry2(exterior, interiors) {
    this.type = "polygon";
    this.exterior = exterior;
    this.interiors = interiors;
  }
  return GeoJSONPolygonGeometry2;
}();
var GeoJSONLineStringGeometry = function() {
  function GeoJSONLineStringGeometry2(points2) {
    this.type = "linestring";
    this.points = points2;
  }
  return GeoJSONLineStringGeometry2;
}();
var GeoJSONRegion = function(_super) {
  __extends(GeoJSONRegion2, _super);
  function GeoJSONRegion2(name, geometries, cp) {
    var _this = _super.call(this, name) || this;
    _this.type = "geoJSON";
    _this.geometries = geometries;
    _this._center = cp && [cp[0], cp[1]];
    return _this;
  }
  GeoJSONRegion2.prototype.calcCenter = function() {
    var geometries = this.geometries;
    var largestGeo;
    var largestGeoSize = 0;
    for (var i = 0; i < geometries.length; i++) {
      var geo = geometries[i];
      var exterior = geo.exterior;
      var size = exterior && exterior.length;
      if (size > largestGeoSize) {
        largestGeo = geo;
        largestGeoSize = size;
      }
    }
    if (largestGeo) {
      return centroid$1(largestGeo.exterior);
    }
    var rect = this.getBoundingRect();
    return [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };
  GeoJSONRegion2.prototype.getBoundingRect = function(projection) {
    var rect = this._rect;
    if (rect && !projection) {
      return rect;
    }
    var min3 = [Infinity, Infinity];
    var max3 = [-Infinity, -Infinity];
    var geometries = this.geometries;
    each$f(geometries, function(geo) {
      if (geo.type === "polygon") {
        updateBBoxFromPoints(geo.exterior, min3, max3, projection);
      } else {
        each$f(geo.points, function(points2) {
          updateBBoxFromPoints(points2, min3, max3, projection);
        });
      }
    });
    if (!(isFinite(min3[0]) && isFinite(min3[1]) && isFinite(max3[0]) && isFinite(max3[1]))) {
      min3[0] = min3[1] = max3[0] = max3[1] = 0;
    }
    rect = new BoundingRect$1(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    if (!projection) {
      this._rect = rect;
    }
    return rect;
  };
  GeoJSONRegion2.prototype.contain = function(coord) {
    var rect = this.getBoundingRect();
    var geometries = this.geometries;
    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }
    loopGeo:
      for (var i = 0, len2 = geometries.length; i < len2; i++) {
        var geo = geometries[i];
        if (geo.type !== "polygon") {
          continue;
        }
        var exterior = geo.exterior;
        var interiors = geo.interiors;
        if (contain(exterior, coord[0], coord[1])) {
          for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
            if (contain(interiors[k], coord[0], coord[1])) {
              continue loopGeo;
            }
          }
          return true;
        }
      }
    return false;
  };
  GeoJSONRegion2.prototype.transformTo = function(x, y, width, height) {
    var rect = this.getBoundingRect();
    var aspect = rect.width / rect.height;
    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }
    var target = new BoundingRect$1(x, y, width, height);
    var transform2 = rect.calculateTransform(target);
    var geometries = this.geometries;
    for (var i = 0; i < geometries.length; i++) {
      var geo = geometries[i];
      if (geo.type === "polygon") {
        transformPoints(geo.exterior, transform2);
        each$f(geo.interiors, function(interior) {
          transformPoints(interior, transform2);
        });
      } else {
        each$f(geo.points, function(points2) {
          transformPoints(points2, transform2);
        });
      }
    }
    rect = this._rect;
    rect.copy(target);
    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  };
  GeoJSONRegion2.prototype.cloneShallow = function(name) {
    name == null && (name = this.name);
    var newRegion = new GeoJSONRegion2(name, this.geometries, this._center);
    newRegion._rect = this._rect;
    newRegion.transformTo = null;
    return newRegion;
  };
  return GeoJSONRegion2;
}(Region);
var GeoSVGRegion = function(_super) {
  __extends(GeoSVGRegion2, _super);
  function GeoSVGRegion2(name, elOnlyForCalculate) {
    var _this = _super.call(this, name) || this;
    _this.type = "geoSVG";
    _this._elOnlyForCalculate = elOnlyForCalculate;
    return _this;
  }
  GeoSVGRegion2.prototype.calcCenter = function() {
    var el = this._elOnlyForCalculate;
    var rect = el.getBoundingRect();
    var center2 = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    var mat = identity(TMP_TRANSFORM);
    var target = el;
    while (target && !target.isGeoSVGGraphicRoot) {
      mul(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    invert(mat, mat);
    applyTransform$1(center2, center2, mat);
    return center2;
  };
  return GeoSVGRegion2;
}(Region);
function decode$1(json) {
  if (!json.UTF8Encoding) {
    return json;
  }
  var jsonCompressed = json;
  var encodeScale = jsonCompressed.UTF8Scale;
  if (encodeScale == null) {
    encodeScale = 1024;
  }
  var features2 = jsonCompressed.features;
  each$f(features2, function(feature) {
    var geometry = feature.geometry;
    var encodeOffsets = geometry.encodeOffsets;
    var coordinates = geometry.coordinates;
    if (!encodeOffsets) {
      return;
    }
    switch (geometry.type) {
      case "LineString":
        geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
        break;
      case "Polygon":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiLineString":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiPolygon":
        each$f(coordinates, function(rings, idx) {
          return decodeRings(rings, encodeOffsets[idx], encodeScale);
        });
    }
  });
  jsonCompressed.UTF8Encoding = false;
  return jsonCompressed;
}
function decodeRings(rings, encodeOffsets, encodeScale) {
  for (var c = 0; c < rings.length; c++) {
    rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
  }
}
function decodeRing(coordinate, encodeOffsets, encodeScale) {
  var result = [];
  var prevX = encodeOffsets[0];
  var prevY = encodeOffsets[1];
  for (var i = 0; i < coordinate.length; i += 2) {
    var x = coordinate.charCodeAt(i) - 64;
    var y = coordinate.charCodeAt(i + 1) - 64;
    x = x >> 1 ^ -(x & 1);
    y = y >> 1 ^ -(y & 1);
    x += prevX;
    y += prevY;
    prevX = x;
    prevY = y;
    result.push([x / encodeScale, y / encodeScale]);
  }
  return result;
}
function parseGeoJSON(geoJson, nameProperty) {
  geoJson = decode$1(geoJson);
  return map$1(filter(geoJson.features, function(featureObj) {
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function(featureObj) {
    var properties = featureObj.properties;
    var geo = featureObj.geometry;
    var geometries = [];
    switch (geo.type) {
      case "Polygon":
        var coordinates = geo.coordinates;
        geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
        break;
      case "MultiPolygon":
        each$f(geo.coordinates, function(item) {
          if (item[0]) {
            geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
          }
        });
        break;
      case "LineString":
        geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
        break;
      case "MultiLineString":
        geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
    }
    var region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}
var inner$g = makeInner();
function createAxisLabels(axis) {
  return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
}
function createAxisTicks(axis, tickModel) {
  return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
    ticks: map$1(axis.scale.getTicks(), function(tick) {
      return tick.value;
    })
  };
}
function makeCategoryLabels(axis) {
  var labelModel = axis.getLabelModel();
  var result = makeCategoryLabelsActually(axis, labelModel);
  return !labelModel.get("show") || axis.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: result.labelCategoryInterval
  } : result;
}
function makeCategoryLabelsActually(axis, labelModel) {
  var labelsCache = getListCache(axis, "labels");
  var optionLabelInterval = getOptionCategoryInterval(labelModel);
  var result = listCacheGet(labelsCache, optionLabelInterval);
  if (result) {
    return result;
  }
  var labels;
  var numericLabelInterval;
  if (isFunction$1(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  }
  return listCacheSet(labelsCache, optionLabelInterval, {
    labels,
    labelCategoryInterval: numericLabelInterval
  });
}
function makeCategoryTicks(axis, tickModel) {
  var ticksCache = getListCache(axis, "ticks");
  var optionTickInterval = getOptionCategoryInterval(tickModel);
  var result = listCacheGet(ticksCache, optionTickInterval);
  if (result) {
    return result;
  }
  var ticks;
  var tickCategoryInterval;
  if (!tickModel.get("show") || axis.scale.isBlank()) {
    ticks = [];
  }
  if (isFunction$1(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } else if (optionTickInterval === "auto") {
    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
    tickCategoryInterval = labelsResult.labelCategoryInterval;
    ticks = map$1(labelsResult.labels, function(labelItem) {
      return labelItem.tickValue;
    });
  } else {
    tickCategoryInterval = optionTickInterval;
    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
  }
  return listCacheSet(ticksCache, optionTickInterval, {
    ticks,
    tickCategoryInterval
  });
}
function makeRealNumberLabels(axis) {
  var ticks = axis.scale.getTicks();
  var labelFormatter = makeLabelFormatter(axis);
  return {
    labels: map$1(ticks, function(tick, idx) {
      return {
        level: tick.level,
        formattedLabel: labelFormatter(tick, idx),
        rawLabel: axis.scale.getLabel(tick),
        tickValue: tick.value
      };
    })
  };
}
function getListCache(axis, prop) {
  return inner$g(axis)[prop] || (inner$g(axis)[prop] = []);
}
function listCacheGet(cache2, key) {
  for (var i = 0; i < cache2.length; i++) {
    if (cache2[i].key === key) {
      return cache2[i].value;
    }
  }
}
function listCacheSet(cache2, key, value) {
  cache2.push({
    key,
    value
  });
  return value;
}
function makeAutoCategoryInterval(axis) {
  var result = inner$g(axis).autoInterval;
  return result != null ? result : inner$g(axis).autoInterval = axis.calculateCategoryInterval();
}
function calculateCategoryInterval(axis) {
  var params = fetchAutoCategoryIntervalCalculationParams(axis);
  var labelFormatter = makeLabelFormatter(axis);
  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var tickCount = ordinalScale.count();
  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }
  var step = 1;
  if (tickCount > 40) {
    step = Math.max(1, Math.floor(tickCount / 40));
  }
  var tickValue = ordinalExtent[0];
  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  var unitW = Math.abs(unitSpan * Math.cos(rotation));
  var unitH = Math.abs(unitSpan * Math.sin(rotation));
  var maxW = 0;
  var maxH = 0;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    var width = 0;
    var height = 0;
    var rect = getBoundingRect(labelFormatter({
      value: tickValue
    }), params.font, "center", "top");
    width = rect.width * 1.3;
    height = rect.height * 1.3;
    maxW = Math.max(maxW, width, 7);
    maxH = Math.max(maxH, height, 7);
  }
  var dw = maxW / unitW;
  var dh = maxH / unitH;
  isNaN(dw) && (dw = Infinity);
  isNaN(dh) && (dh = Infinity);
  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
  var cache2 = inner$g(axis.model);
  var axisExtent = axis.getExtent();
  var lastAutoInterval = cache2.lastAutoInterval;
  var lastTickCount = cache2.lastTickCount;
  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache2.axisExtent0 === axisExtent[0] && cache2.axisExtent1 === axisExtent[1]) {
    interval = lastAutoInterval;
  } else {
    cache2.lastTickCount = tickCount;
    cache2.lastAutoInterval = interval;
    cache2.axisExtent0 = axisExtent[0];
    cache2.axisExtent1 = axisExtent[1];
  }
  return interval;
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
  var labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get("rotate") || 0,
    font: labelModel.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  var labelFormatter = makeLabelFormatter(axis);
  var ordinalScale = axis.scale;
  var ordinalExtent = ordinalScale.getExtent();
  var labelModel = axis.getLabelModel();
  var result = [];
  var step = Math.max((categoryInterval || 0) + 1, 1);
  var startTick = ordinalExtent[0];
  var tickCount = ordinalScale.count();
  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  }
  var showAllLabel = shouldShowAllLabels(axis);
  var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
  var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
  if (includeMinLabel && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  }
  var tickValue = startTick;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }
  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }
  function addItem(tickValue2) {
    var tickObj = {
      value: tickValue2
    };
    result.push(onlyTick ? tickValue2 : {
      formattedLabel: labelFormatter(tickObj),
      rawLabel: ordinalScale.getLabel(tickObj),
      tickValue: tickValue2
    });
  }
  return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  var ordinalScale = axis.scale;
  var labelFormatter = makeLabelFormatter(axis);
  var result = [];
  each$f(ordinalScale.getTicks(), function(tick) {
    var rawLabel = ordinalScale.getLabel(tick);
    var tickValue = tick.value;
    if (categoryInterval(tick.value, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tick),
        rawLabel,
        tickValue
      });
    }
  });
  return result;
}
var NORMALIZED_EXTENT = [0, 1];
var Axis = function() {
  function Axis2(dim, scale2, extent3) {
    this.onBand = false;
    this.inverse = false;
    this.dim = dim;
    this.scale = scale2;
    this._extent = extent3 || [0, 0];
  }
  Axis2.prototype.contain = function(coord) {
    var extent3 = this._extent;
    var min3 = Math.min(extent3[0], extent3[1]);
    var max3 = Math.max(extent3[0], extent3[1]);
    return coord >= min3 && coord <= max3;
  };
  Axis2.prototype.containData = function(data) {
    return this.scale.contain(data);
  };
  Axis2.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Axis2.prototype.getPixelPrecision = function(dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  };
  Axis2.prototype.setExtent = function(start2, end2) {
    var extent3 = this._extent;
    extent3[0] = start2;
    extent3[1] = end2;
  };
  Axis2.prototype.dataToCoord = function(data, clamp2) {
    var extent3 = this._extent;
    var scale2 = this.scale;
    data = scale2.normalize(data);
    if (this.onBand && scale2.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale2.count());
    }
    return linearMap$2(data, NORMALIZED_EXTENT, extent3, clamp2);
  };
  Axis2.prototype.coordToData = function(coord, clamp2) {
    var extent3 = this._extent;
    var scale2 = this.scale;
    if (this.onBand && scale2.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale2.count());
    }
    var t = linearMap$2(coord, extent3, NORMALIZED_EXTENT, clamp2);
    return this.scale.scale(t);
  };
  Axis2.prototype.pointToData = function(point, clamp2) {
    return;
  };
  Axis2.prototype.getTicksCoords = function(opt) {
    opt = opt || {};
    var tickModel = opt.tickModel || this.getTickModel();
    var result = createAxisTicks(this, tickModel);
    var ticks = result.ticks;
    var ticksCoords = map$1(ticks, function(tickVal) {
      return {
        coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
        tickValue: tickVal
      };
    }, this);
    var alignWithLabel = tickModel.get("alignWithLabel");
    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
    return ticksCoords;
  };
  Axis2.prototype.getMinorTicksCoords = function() {
    if (this.scale.type === "ordinal") {
      return [];
    }
    var minorTickModel = this.model.getModel("minorTick");
    var splitNumber = minorTickModel.get("splitNumber");
    if (!(splitNumber > 0 && splitNumber < 100)) {
      splitNumber = 5;
    }
    var minorTicks = this.scale.getMinorTicks(splitNumber);
    var minorTicksCoords = map$1(minorTicks, function(minorTicksGroup) {
      return map$1(minorTicksGroup, function(minorTick) {
        return {
          coord: this.dataToCoord(minorTick),
          tickValue: minorTick
        };
      }, this);
    }, this);
    return minorTicksCoords;
  };
  Axis2.prototype.getViewLabels = function() {
    return createAxisLabels(this).labels;
  };
  Axis2.prototype.getLabelModel = function() {
    return this.model.getModel("axisLabel");
  };
  Axis2.prototype.getTickModel = function() {
    return this.model.getModel("axisTick");
  };
  Axis2.prototype.getBandWidth = function() {
    var axisExtent = this._extent;
    var dataExtent = this.scale.getExtent();
    var len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
    len2 === 0 && (len2 = 1);
    var size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len2;
  };
  Axis2.prototype.calculateCategoryInterval = function() {
    return calculateCategoryInterval(this);
  };
  return Axis2;
}();
function fixExtentWithBands(extent3, nTick) {
  var size = extent3[1] - extent3[0];
  var len2 = nTick;
  var margin = size / len2 / 2;
  extent3[0] += margin;
  extent3[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
  var ticksLen = ticksCoords.length;
  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }
  var axisExtent = axis.getExtent();
  var last;
  var diffSize;
  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    last = ticksCoords[1] = {
      coord: axisExtent[0]
    };
  } else {
    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
    each$f(ticksCoords, function(ticksItem) {
      ticksItem.coord -= shift_1 / 2;
    });
    var dataExtent = axis.scale.getExtent();
    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
    last = {
      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize
    };
    ticksCoords.push(last);
  }
  var inverse = axisExtent[0] > axisExtent[1];
  if (littleThan2(ticksCoords[0].coord, axisExtent[0])) {
    clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }
  if (clamp2 && littleThan2(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({
      coord: axisExtent[0]
    });
  }
  if (littleThan2(axisExtent[1], last.coord)) {
    clamp2 ? last.coord = axisExtent[1] : ticksCoords.pop();
  }
  if (clamp2 && littleThan2(last.coord, axisExtent[1])) {
    ticksCoords.push({
      coord: axisExtent[1]
    });
  }
  function littleThan2(a, b) {
    a = round$3(a);
    b = round$3(b);
    return inverse ? a > b : a < b;
  }
}
var Axis$1 = Axis;
function extendSeriesModel(proto) {
  var Model2 = SeriesModel$1.extend(proto);
  SeriesModel$1.registerClass(Model2);
  return Model2;
}
function extendChartView(proto) {
  var View2 = ChartView$1.extend(proto);
  ChartView$1.registerClass(View2);
  return View2;
}
var PI2$3 = Math.PI * 2;
var CMD$1 = PathProxy$1.CMD;
var DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
function getCandidateAnchor(pos, distance2, rect, outPt, outDir) {
  var width = rect.width;
  var height = rect.height;
  switch (pos) {
    case "top":
      outPt.set(rect.x + width / 2, rect.y - distance2);
      outDir.set(0, -1);
      break;
    case "bottom":
      outPt.set(rect.x + width / 2, rect.y + height + distance2);
      outDir.set(0, 1);
      break;
    case "left":
      outPt.set(rect.x - distance2, rect.y + height / 2);
      outDir.set(-1, 0);
      break;
    case "right":
      outPt.set(rect.x + width + distance2, rect.y + height / 2);
      outDir.set(1, 0);
      break;
  }
}
function projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out2) {
  x -= cx;
  y -= cy;
  var d = Math.sqrt(x * x + y * y);
  x /= d;
  y /= d;
  var ox = x * r + cx;
  var oy = y * r + cy;
  if (Math.abs(startAngle - endAngle) % PI2$3 < 1e-4) {
    out2[0] = ox;
    out2[1] = oy;
    return d - r;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2$3;
  }
  var angle = Math.atan2(y, x);
  if (angle < 0) {
    angle += PI2$3;
  }
  if (angle >= startAngle && angle <= endAngle || angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle) {
    out2[0] = ox;
    out2[1] = oy;
    return d - r;
  }
  var x1 = r * Math.cos(startAngle) + cx;
  var y1 = r * Math.sin(startAngle) + cy;
  var x2 = r * Math.cos(endAngle) + cx;
  var y2 = r * Math.sin(endAngle) + cy;
  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);
  if (d1 < d2) {
    out2[0] = x1;
    out2[1] = y1;
    return Math.sqrt(d1);
  } else {
    out2[0] = x2;
    out2[1] = y2;
    return Math.sqrt(d2);
  }
}
function projectPointToLine(x1, y1, x2, y2, x, y, out2, limitToEnds) {
  var dx = x - x1;
  var dy = y - y1;
  var dx1 = x2 - x1;
  var dy1 = y2 - y1;
  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  dx1 /= lineLen;
  dy1 /= lineLen;
  var projectedLen = dx * dx1 + dy * dy1;
  var t = projectedLen / lineLen;
  if (limitToEnds) {
    t = Math.min(Math.max(t, 0), 1);
  }
  t *= lineLen;
  var ox = out2[0] = x1 + t * dx1;
  var oy = out2[1] = y1 + t * dy1;
  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}
function projectPointToRect(x1, y1, width, height, x, y, out2) {
  if (width < 0) {
    x1 = x1 + width;
    width = -width;
  }
  if (height < 0) {
    y1 = y1 + height;
    height = -height;
  }
  var x2 = x1 + width;
  var y2 = y1 + height;
  var ox = out2[0] = Math.min(Math.max(x, x1), x2);
  var oy = out2[1] = Math.min(Math.max(y, y1), y2);
  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}
var tmpPt = [];
function nearestPointOnRect(pt, rect, out2) {
  var dist2 = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);
  out2.set(tmpPt[0], tmpPt[1]);
  return dist2;
}
function nearestPointOnPath(pt, path, out2) {
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;
  var x1;
  var y1;
  var minDist = Infinity;
  var data = path.data;
  var x = pt.x;
  var y = pt.y;
  for (var i = 0; i < data.length; ) {
    var cmd = data[i++];
    if (i === 1) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }
    var d = minDist;
    switch (cmd) {
      case CMD$1.M:
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;
      case CMD$1.L:
        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.C:
        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.Q:
        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++];
        i += 1;
        var anticlockwise = !!(1 - data[i++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (i <= 1) {
          x0 = x1;
          y0 = y1;
        }
        var _x = (x - cx) * ry / rx + cx;
        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD$1.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);
        break;
      case CMD$1.Z:
        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);
        xi = x0;
        yi = y0;
        break;
    }
    if (d < minDist) {
      minDist = d;
      out2.set(tmpPt[0], tmpPt[1]);
    }
  }
  return minDist;
}
var pt0 = new Point$1();
var pt1 = new Point$1();
var pt2 = new Point$1();
var dir = new Point$1();
var dir2 = new Point$1();
function updateLabelLinePoints(target, labelLineModel) {
  if (!target) {
    return;
  }
  var labelLine = target.getTextGuideLine();
  var label = target.getTextContent();
  if (!(label && labelLine)) {
    return;
  }
  var labelGuideConfig = target.textGuideLineConfig || {};
  var points2 = [[0, 0], [0, 0], [0, 0]];
  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
  var labelRect = label.getBoundingRect().clone();
  labelRect.applyTransform(label.getComputedTransform());
  var minDist = Infinity;
  var anchorPoint = labelGuideConfig.anchor;
  var targetTransform = target.getComputedTransform();
  var targetInversedTransform = targetTransform && invert([], targetTransform);
  var len2 = labelLineModel.get("length2") || 0;
  if (anchorPoint) {
    pt2.copy(anchorPoint);
  }
  for (var i = 0; i < searchSpace.length; i++) {
    var candidate = searchSpace[i];
    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
    Point$1.scaleAndAdd(pt1, pt0, dir, len2);
    pt1.transform(targetInversedTransform);
    var boundingRect = target.getBoundingRect();
    var dist2 = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path$1 ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
    if (dist2 < minDist) {
      minDist = dist2;
      pt1.transform(targetTransform);
      pt2.transform(targetTransform);
      pt2.toArray(points2[0]);
      pt1.toArray(points2[1]);
      pt0.toArray(points2[2]);
    }
  }
  limitTurnAngle(points2, labelLineModel.get("minTurnAngle"));
  labelLine.setShape({
    points: points2
  });
}
var tmpArr = [];
var tmpProjPoint = new Point$1();
function limitTurnAngle(linePoints, minTurnAngle) {
  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
    return;
  }
  minTurnAngle = minTurnAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$1.sub(dir, pt0, pt1);
  Point$1.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(dir2);
  var minTurnAngleCos = Math.cos(minTurnAngle);
  if (minTurnAngleCos < angleCos) {
    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));
    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
    if (isNaN(t)) {
      return;
    }
    if (t < 0) {
      Point$1.copy(tmpProjPoint, pt1);
    } else if (t > 1) {
      Point$1.copy(tmpProjPoint, pt2);
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
    return;
  }
  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point$1.sub(dir, pt1, pt0);
  Point$1.sub(dir2, pt2, pt1);
  var len1 = dir.len();
  var len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  var angleCos = dir.dot(surfaceNormal);
  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
  if (angleCos < maxSurfaceAngleCos) {
    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    var HALF_PI = Math.PI / 2;
    var angle2 = Math.acos(dir2.dot(surfaceNormal));
    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;
    if (newAngle >= HALF_PI) {
      Point$1.copy(tmpProjPoint, pt2);
    } else {
      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));
      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t)) {
        return;
      }
      if (t < 0) {
        Point$1.copy(tmpProjPoint, pt1);
      } else if (t > 1) {
        Point$1.copy(tmpProjPoint, pt2);
      }
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function setLabelLineState(labelLine, ignore, stateName, stateModel) {
  var isNormal = stateName === "normal";
  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
  stateObj.ignore = ignore;
  var smooth = stateModel.get("smooth");
  if (smooth && smooth === true) {
    smooth = 0.3;
  }
  stateObj.shape = stateObj.shape || {};
  if (smooth > 0) {
    stateObj.shape.smooth = smooth;
  }
  var styleObj = stateModel.getModel("lineStyle").getLineStyle();
  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}
function buildLabelLinePath(path, shape) {
  var smooth = shape.smooth;
  var points2 = shape.points;
  if (!points2) {
    return;
  }
  path.moveTo(points2[0][0], points2[0][1]);
  if (smooth > 0 && points2.length >= 3) {
    var len1 = dist$1(points2[0], points2[1]);
    var len2 = dist$1(points2[1], points2[2]);
    if (!len1 || !len2) {
      path.lineTo(points2[1][0], points2[1][1]);
      path.lineTo(points2[2][0], points2[2][1]);
      return;
    }
    var moveLen = Math.min(len1, len2) * smooth;
    var midPoint0 = lerp$1([], points2[1], points2[0], moveLen / len1);
    var midPoint2 = lerp$1([], points2[1], points2[2], moveLen / len2);
    var midPoint1 = lerp$1([], midPoint0, midPoint2, 0.5);
    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points2[2][0], points2[2][1]);
  } else {
    for (var i = 1; i < points2.length; i++) {
      path.lineTo(points2[i][0], points2[i][1]);
    }
  }
}
function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
  var labelLine = targetEl.getTextGuideLine();
  var label = targetEl.getTextContent();
  if (!label) {
    if (labelLine) {
      targetEl.removeTextGuideLine();
    }
    return;
  }
  var normalModel = statesModels.normal;
  var showNormal = normalModel.get("show");
  var labelIgnoreNormal = label.ignore;
  for (var i = 0; i < DISPLAY_STATES.length; i++) {
    var stateName = DISPLAY_STATES[i];
    var stateModel = statesModels[stateName];
    var isNormal = stateName === "normal";
    if (stateModel) {
      var stateShow = stateModel.get("show");
      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
      if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
        var stateObj = isNormal ? labelLine : labelLine && labelLine.states.normal;
        if (stateObj) {
          stateObj.ignore = true;
        }
        continue;
      }
      if (!labelLine) {
        labelLine = new Polyline$3();
        targetEl.setTextGuideLine(labelLine);
        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
          setLabelLineState(labelLine, true, "normal", statesModels.normal);
        }
        if (targetEl.stateProxy) {
          labelLine.stateProxy = targetEl.stateProxy;
        }
      }
      setLabelLineState(labelLine, false, stateName, stateModel);
    }
  }
  if (labelLine) {
    defaults(labelLine.style, defaultStyle);
    labelLine.style.fill = null;
    var showAbove = normalModel.get("showAbove");
    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
    labelLineConfig.showAbove = showAbove || false;
    labelLine.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(itemModel, labelLineName) {
  labelLineName = labelLineName || "labelLine";
  var statesModels = {
    normal: itemModel.getModel(labelLineName)
  };
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
  }
  return statesModels;
}
function prepareLayoutList(input) {
  var list = [];
  for (var i = 0; i < input.length; i++) {
    var rawItem = input[i];
    if (rawItem.defaultAttr.ignore) {
      continue;
    }
    var label = rawItem.label;
    var transform2 = label.getComputedTransform();
    var localRect = label.getBoundingRect();
    var isAxisAligned = !transform2 || transform2[1] < 1e-5 && transform2[2] < 1e-5;
    var minMargin = label.style.margin || 0;
    var globalRect = localRect.clone();
    globalRect.applyTransform(transform2);
    globalRect.x -= minMargin / 2;
    globalRect.y -= minMargin / 2;
    globalRect.width += minMargin;
    globalRect.height += minMargin;
    var obb = isAxisAligned ? new OrientedBoundingRect$1(localRect, transform2) : null;
    list.push({
      label,
      labelLine: rawItem.labelLine,
      rect: globalRect,
      localRect,
      obb,
      priority: rawItem.priority,
      defaultAttr: rawItem.defaultAttr,
      layoutOption: rawItem.computedLayoutOption,
      axisAligned: isAxisAligned,
      transform: transform2
    });
  }
  return list;
}
function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
  var len2 = list.length;
  if (len2 < 2) {
    return;
  }
  list.sort(function(a, b) {
    return a.rect[xyDim] - b.rect[xyDim];
  });
  var lastPos = 0;
  var delta;
  var adjusted = false;
  var totalShifts = 0;
  for (var i = 0; i < len2; i++) {
    var item = list[i];
    var rect = item.rect;
    delta = rect[xyDim] - lastPos;
    if (delta < 0) {
      rect[xyDim] -= delta;
      item.label[xyDim] -= delta;
      adjusted = true;
    }
    var shift = Math.max(-delta, 0);
    totalShifts += shift;
    lastPos = rect[xyDim] + rect[sizeDim];
  }
  if (totalShifts > 0 && balanceShift) {
    shiftList(-totalShifts / len2, 0, len2);
  }
  var first = list[0];
  var last = list[len2 - 1];
  var minGap;
  var maxGap;
  updateMinMaxGap();
  minGap < 0 && squeezeGaps(-minGap, 0.8);
  maxGap < 0 && squeezeGaps(maxGap, 0.8);
  updateMinMaxGap();
  takeBoundsGap(minGap, maxGap, 1);
  takeBoundsGap(maxGap, minGap, -1);
  updateMinMaxGap();
  if (minGap < 0) {
    squeezeWhenBailout(-minGap);
  }
  if (maxGap < 0) {
    squeezeWhenBailout(maxGap);
  }
  function updateMinMaxGap() {
    minGap = first.rect[xyDim] - minBound;
    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
  }
  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
    if (gapThisBound < 0) {
      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
      if (moveFromMaxGap > 0) {
        shiftList(moveFromMaxGap * moveDir, 0, len2);
        var remained = moveFromMaxGap + gapThisBound;
        if (remained < 0) {
          squeezeGaps(-remained * moveDir, 1);
        }
      } else {
        squeezeGaps(-gapThisBound * moveDir, 1);
      }
    }
  }
  function shiftList(delta2, start2, end2) {
    if (delta2 !== 0) {
      adjusted = true;
    }
    for (var i2 = start2; i2 < end2; i2++) {
      var item2 = list[i2];
      var rect2 = item2.rect;
      rect2[xyDim] += delta2;
      item2.label[xyDim] += delta2;
    }
  }
  function squeezeGaps(delta2, maxSqeezePercent) {
    var gaps = [];
    var totalGaps = 0;
    for (var i2 = 1; i2 < len2; i2++) {
      var prevItemRect = list[i2 - 1].rect;
      var gap = Math.max(list[i2].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
      gaps.push(gap);
      totalGaps += gap;
    }
    if (!totalGaps) {
      return;
    }
    var squeezePercent = Math.min(Math.abs(delta2) / totalGaps, maxSqeezePercent);
    if (delta2 > 0) {
      for (var i2 = 0; i2 < len2 - 1; i2++) {
        var movement = gaps[i2] * squeezePercent;
        shiftList(movement, 0, i2 + 1);
      }
    } else {
      for (var i2 = len2 - 1; i2 > 0; i2--) {
        var movement = gaps[i2 - 1] * squeezePercent;
        shiftList(-movement, i2, len2);
      }
    }
  }
  function squeezeWhenBailout(delta2) {
    var dir3 = delta2 < 0 ? -1 : 1;
    delta2 = Math.abs(delta2);
    var moveForEachLabel = Math.ceil(delta2 / (len2 - 1));
    for (var i2 = 0; i2 < len2 - 1; i2++) {
      if (dir3 > 0) {
        shiftList(moveForEachLabel, 0, i2 + 1);
      } else {
        shiftList(-moveForEachLabel, len2 - i2 - 1, len2);
      }
      delta2 -= moveForEachLabel;
      if (delta2 <= 0) {
        return;
      }
    }
  }
  return adjusted;
}
function shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {
  return shiftLayout(list, "x", "width", leftBound, rightBound, balanceShift);
}
function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {
  return shiftLayout(list, "y", "height", topBound, bottomBound, balanceShift);
}
function hideOverlap(labelList) {
  var displayedLabels = [];
  labelList.sort(function(a, b) {
    return b.priority - a.priority;
  });
  var globalRect = new BoundingRect$1(0, 0, 0, 0);
  function hideEl(el) {
    if (!el.ignore) {
      var emphasisState = el.ensureState("emphasis");
      if (emphasisState.ignore == null) {
        emphasisState.ignore = false;
      }
    }
    el.ignore = true;
  }
  for (var i = 0; i < labelList.length; i++) {
    var labelItem = labelList[i];
    var isAxisAligned = labelItem.axisAligned;
    var localRect = labelItem.localRect;
    var transform2 = labelItem.transform;
    var label = labelItem.label;
    var labelLine = labelItem.labelLine;
    globalRect.copy(labelItem.rect);
    globalRect.width -= 0.1;
    globalRect.height -= 0.1;
    globalRect.x += 0.05;
    globalRect.y += 0.05;
    var obb = labelItem.obb;
    var overlapped = false;
    for (var j = 0; j < displayedLabels.length; j++) {
      var existsTextCfg = displayedLabels[j];
      if (!globalRect.intersect(existsTextCfg.rect)) {
        continue;
      }
      if (isAxisAligned && existsTextCfg.axisAligned) {
        overlapped = true;
        break;
      }
      if (!existsTextCfg.obb) {
        existsTextCfg.obb = new OrientedBoundingRect$1(existsTextCfg.localRect, existsTextCfg.transform);
      }
      if (!obb) {
        obb = new OrientedBoundingRect$1(localRect, transform2);
      }
      if (obb.intersect(existsTextCfg.obb)) {
        overlapped = true;
        break;
      }
    }
    if (overlapped) {
      hideEl(label);
      labelLine && hideEl(labelLine);
    } else {
      label.attr("ignore", labelItem.defaultAttr.ignore);
      labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
      displayedLabels.push(labelItem);
    }
  }
}
function cloneArr(points2) {
  if (points2) {
    var newPoints = [];
    for (var i = 0; i < points2.length; i++) {
      newPoints.push(points2[i].slice());
    }
    return newPoints;
  }
}
function prepareLayoutCallbackParams(labelItem, hostEl) {
  var label = labelItem.label;
  var labelLine = hostEl && hostEl.getTextGuideLine();
  return {
    dataIndex: labelItem.dataIndex,
    dataType: labelItem.dataType,
    seriesIndex: labelItem.seriesModel.seriesIndex,
    text: labelItem.label.style.text,
    rect: labelItem.hostRect,
    labelRect: labelItem.rect,
    align: label.style.align,
    verticalAlign: label.style.verticalAlign,
    labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
  };
}
var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"];
var dummyTransformable = new Transformable();
var labelLayoutInnerStore = makeInner();
var labelLineAnimationStore = makeInner();
function extendWithKeys(target, source, keys2) {
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    if (source[key] != null) {
      target[key] = source[key];
    }
  }
}
var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"];
var LabelManager = function() {
  function LabelManager2() {
    this._labelList = [];
    this._chartViewList = [];
  }
  LabelManager2.prototype.clearLabels = function() {
    this._labelList = [];
    this._chartViewList = [];
  };
  LabelManager2.prototype._addLabel = function(dataIndex, dataType, seriesModel, label, layoutOption) {
    var labelStyle = label.style;
    var hostEl = label.__hostTarget;
    var textConfig = hostEl.textConfig || {};
    var labelTransform = label.getComputedTransform();
    var labelRect = label.getBoundingRect().plain();
    BoundingRect$1.applyTransform(labelRect, labelRect, labelTransform);
    if (labelTransform) {
      dummyTransformable.setLocalTransform(labelTransform);
    } else {
      dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
      dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
    }
    var host = label.__hostTarget;
    var hostRect;
    if (host) {
      hostRect = host.getBoundingRect().plain();
      var transform2 = host.getComputedTransform();
      BoundingRect$1.applyTransform(hostRect, hostRect, transform2);
    }
    var labelGuide = hostRect && host.getTextGuideLine();
    this._labelList.push({
      label,
      labelLine: labelGuide,
      seriesModel,
      dataIndex,
      dataType,
      layoutOption,
      computedLayoutOption: null,
      rect: labelRect,
      hostRect,
      priority: hostRect ? hostRect.width * hostRect.height : 0,
      defaultAttr: {
        ignore: label.ignore,
        labelGuideIgnore: labelGuide && labelGuide.ignore,
        x: dummyTransformable.x,
        y: dummyTransformable.y,
        scaleX: dummyTransformable.scaleX,
        scaleY: dummyTransformable.scaleY,
        rotation: dummyTransformable.rotation,
        style: {
          x: labelStyle.x,
          y: labelStyle.y,
          align: labelStyle.align,
          verticalAlign: labelStyle.verticalAlign,
          width: labelStyle.width,
          height: labelStyle.height,
          fontSize: labelStyle.fontSize
        },
        cursor: label.cursor,
        attachedPos: textConfig.position,
        attachedRot: textConfig.rotation
      }
    });
  };
  LabelManager2.prototype.addLabelsOfSeries = function(chartView) {
    var _this = this;
    this._chartViewList.push(chartView);
    var seriesModel = chartView.__model;
    var layoutOption = seriesModel.get("labelLayout");
    if (!(isFunction$1(layoutOption) || keys(layoutOption).length)) {
      return;
    }
    chartView.group.traverse(function(child) {
      if (child.ignore) {
        return true;
      }
      var textEl = child.getTextContent();
      var ecData = getECData(child);
      if (textEl && !textEl.disableLabelLayout) {
        _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
      }
    });
  };
  LabelManager2.prototype.updateLayoutConfig = function(api) {
    var width = api.getWidth();
    var height = api.getHeight();
    function createDragHandler(el, labelLineModel) {
      return function() {
        updateLabelLinePoints(el, labelLineModel);
      };
    }
    for (var i = 0; i < this._labelList.length; i++) {
      var labelItem = this._labelList[i];
      var label = labelItem.label;
      var hostEl = label.__hostTarget;
      var defaultLabelAttr = labelItem.defaultAttr;
      var layoutOption = void 0;
      if (isFunction$1(labelItem.layoutOption)) {
        layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));
      } else {
        layoutOption = labelItem.layoutOption;
      }
      layoutOption = layoutOption || {};
      labelItem.computedLayoutOption = layoutOption;
      var degreeToRadian = Math.PI / 180;
      if (hostEl) {
        hostEl.setTextConfig({
          local: false,
          position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
          rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
          offset: [layoutOption.dx || 0, layoutOption.dy || 0]
        });
      }
      var needsUpdateLabelLine = false;
      if (layoutOption.x != null) {
        label.x = parsePercent$1(layoutOption.x, width);
        label.setStyle("x", 0);
        needsUpdateLabelLine = true;
      } else {
        label.x = defaultLabelAttr.x;
        label.setStyle("x", defaultLabelAttr.style.x);
      }
      if (layoutOption.y != null) {
        label.y = parsePercent$1(layoutOption.y, height);
        label.setStyle("y", 0);
        needsUpdateLabelLine = true;
      } else {
        label.y = defaultLabelAttr.y;
        label.setStyle("y", defaultLabelAttr.style.y);
      }
      if (layoutOption.labelLinePoints) {
        var guideLine = hostEl.getTextGuideLine();
        if (guideLine) {
          guideLine.setShape({
            points: layoutOption.labelLinePoints
          });
          needsUpdateLabelLine = false;
        }
      }
      var labelLayoutStore = labelLayoutInnerStore(label);
      labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
      label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
      label.scaleX = defaultLabelAttr.scaleX;
      label.scaleY = defaultLabelAttr.scaleY;
      for (var k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {
        var key = LABEL_OPTION_TO_STYLE_KEYS[k];
        label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);
      }
      if (layoutOption.draggable) {
        label.draggable = true;
        label.cursor = "move";
        if (hostEl) {
          var hostModel = labelItem.seriesModel;
          if (labelItem.dataIndex != null) {
            var data = labelItem.seriesModel.getData(labelItem.dataType);
            hostModel = data.getItemModel(labelItem.dataIndex);
          }
          label.on("drag", createDragHandler(hostEl, hostModel.getModel("labelLine")));
        }
      } else {
        label.off("drag");
        label.cursor = defaultLabelAttr.cursor;
      }
    }
  };
  LabelManager2.prototype.layout = function(api) {
    var width = api.getWidth();
    var height = api.getHeight();
    var labelList = prepareLayoutList(this._labelList);
    var labelsNeedsAdjustOnX = filter(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftX";
    });
    var labelsNeedsAdjustOnY = filter(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftY";
    });
    shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);
    shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);
    var labelsNeedsHideOverlap = filter(labelList, function(item) {
      return item.layoutOption.hideOverlap;
    });
    hideOverlap(labelsNeedsHideOverlap);
  };
  LabelManager2.prototype.processLabelsOverall = function() {
    var _this = this;
    each$f(this._chartViewList, function(chartView) {
      var seriesModel = chartView.__model;
      var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
      var animationEnabled = seriesModel.isAnimationEnabled();
      chartView.group.traverse(function(child) {
        if (child.ignore && !child.forceLabelAnimation) {
          return true;
        }
        var needsUpdateLabelLine = !ignoreLabelLineUpdate;
        var label = child.getTextContent();
        if (!needsUpdateLabelLine && label) {
          needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
        }
        if (needsUpdateLabelLine) {
          _this._updateLabelLine(child, seriesModel);
        }
        if (animationEnabled) {
          _this._animateLabels(child, seriesModel);
        }
      });
    });
  };
  LabelManager2.prototype._updateLabelLine = function(el, seriesModel) {
    var textEl = el.getTextContent();
    var ecData = getECData(el);
    var dataIndex = ecData.dataIndex;
    if (textEl && dataIndex != null) {
      var data = seriesModel.getData(ecData.dataType);
      var itemModel = data.getItemModel(dataIndex);
      var defaultStyle = {};
      var visualStyle = data.getItemVisual(dataIndex, "style");
      var visualType = data.getVisual("drawType");
      defaultStyle.stroke = visualStyle[visualType];
      var labelLineModel = itemModel.getModel("labelLine");
      setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);
      updateLabelLinePoints(el, labelLineModel);
    }
  };
  LabelManager2.prototype._animateLabels = function(el, seriesModel) {
    var textEl = el.getTextContent();
    var guideLine = el.getTextGuideLine();
    if (textEl && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {
      var layoutStore = labelLayoutInnerStore(textEl);
      var oldLayout = layoutStore.oldLayout;
      var ecData = getECData(el);
      var dataIndex = ecData.dataIndex;
      var newProps = {
        x: textEl.x,
        y: textEl.y,
        rotation: textEl.rotation
      };
      var data = seriesModel.getData(ecData.dataType);
      if (!oldLayout) {
        textEl.attr(newProps);
        if (!labelInner(textEl).valueAnimation) {
          var oldOpacity = retrieve2(textEl.style.opacity, 1);
          textEl.style.opacity = 0;
          initProps(textEl, {
            style: {
              opacity: oldOpacity
            }
          }, seriesModel, dataIndex);
        }
      } else {
        textEl.attr(oldLayout);
        var prevStates = el.prevStates;
        if (prevStates) {
          if (indexOf(prevStates, "select") >= 0) {
            textEl.attr(layoutStore.oldLayoutSelect);
          }
          if (indexOf(prevStates, "emphasis") >= 0) {
            textEl.attr(layoutStore.oldLayoutEmphasis);
          }
        }
        updateProps$1(textEl, newProps, seriesModel, dataIndex);
      }
      layoutStore.oldLayout = newProps;
      if (textEl.states.select) {
        var layoutSelect = layoutStore.oldLayoutSelect = {};
        extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
      }
      if (textEl.states.emphasis) {
        var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
        extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
      }
      animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);
    }
    if (guideLine && !guideLine.ignore && !guideLine.invisible) {
      var layoutStore = labelLineAnimationStore(guideLine);
      var oldLayout = layoutStore.oldLayout;
      var newLayout = {
        points: guideLine.shape.points
      };
      if (!oldLayout) {
        guideLine.setShape(newLayout);
        guideLine.style.strokePercent = 0;
        initProps(guideLine, {
          style: {
            strokePercent: 1
          }
        }, seriesModel);
      } else {
        guideLine.attr({
          shape: oldLayout
        });
        updateProps$1(guideLine, {
          shape: newLayout
        }, seriesModel);
      }
      layoutStore.oldLayout = newLayout;
    }
  };
  return LabelManager2;
}();
var LabelManager$1 = LabelManager;
var getLabelManager = makeInner();
function installLabelLayout(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", function(ecModel, api, params) {
    var labelManager = getLabelManager(api).labelManager;
    if (!labelManager) {
      labelManager = getLabelManager(api).labelManager = new LabelManager$1();
    }
    labelManager.clearLabels();
  });
  registers.registerUpdateLifecycle("series:layoutlabels", function(ecModel, api, params) {
    var labelManager = getLabelManager(api).labelManager;
    params.updatedSeries.forEach(function(series) {
      labelManager.addLabelsOfSeries(api.getViewOfSeriesModel(series));
    });
    labelManager.updateLayoutConfig(api);
    labelManager.layout(api);
    labelManager.processLabelsOverall();
  });
}
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI$6 = Math.PI;
var PI2$2 = Math.PI * 2;
var degree = 180 / PI$6;
var SVGPathRebuilder = function() {
  function SVGPathRebuilder2() {
  }
  SVGPathRebuilder2.prototype.reset = function(precision) {
    this._start = true;
    this._d = [];
    this._str = "";
    this._p = Math.pow(10, precision || 4);
  };
  SVGPathRebuilder2.prototype.moveTo = function(x, y) {
    this._add("M", x, y);
  };
  SVGPathRebuilder2.prototype.lineTo = function(x, y) {
    this._add("L", x, y);
  };
  SVGPathRebuilder2.prototype.bezierCurveTo = function(x, y, x2, y2, x3, y3) {
    this._add("C", x, y, x2, y2, x3, y3);
  };
  SVGPathRebuilder2.prototype.quadraticCurveTo = function(x, y, x2, y2) {
    this._add("Q", x, y, x2, y2);
  };
  SVGPathRebuilder2.prototype.arc = function(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
  };
  SVGPathRebuilder2.prototype.ellipse = function(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
    var dTheta = endAngle - startAngle;
    var clockwise = !anticlockwise;
    var dThetaPositive = Math.abs(dTheta);
    var isCircle = isAroundZero(dThetaPositive - PI2$2) || (clockwise ? dTheta >= PI2$2 : -dTheta >= PI2$2);
    var unifiedTheta = dTheta > 0 ? dTheta % PI2$2 : dTheta % PI2$2 + PI2$2;
    var large = false;
    if (isCircle) {
      large = true;
    } else if (isAroundZero(dThetaPositive)) {
      large = false;
    } else {
      large = unifiedTheta >= PI$6 === !!clockwise;
    }
    var x0 = cx + rx * mathCos(startAngle);
    var y0 = cy + ry * mathSin(startAngle);
    if (this._start) {
      this._add("M", x0, y0);
    }
    var xRot = Math.round(psi * degree);
    if (isCircle) {
      var p = 1 / this._p;
      var dTheta_1 = (clockwise ? 1 : -1) * (PI2$2 - p);
      this._add("A", rx, ry, xRot, 1, +clockwise, cx + rx * mathCos(startAngle + dTheta_1), cy + ry * mathSin(startAngle + dTheta_1));
      if (p > 0.01) {
        this._add("A", rx, ry, xRot, 0, +clockwise, x0, y0);
      }
    } else {
      var x = cx + rx * mathCos(endAngle);
      var y = cy + ry * mathSin(endAngle);
      this._add("A", rx, ry, xRot, +large, +clockwise, x, y);
    }
  };
  SVGPathRebuilder2.prototype.rect = function(x, y, w, h) {
    this._add("M", x, y);
    this._add("l", w, 0);
    this._add("l", 0, h);
    this._add("l", -w, 0);
    this._add("Z");
  };
  SVGPathRebuilder2.prototype.closePath = function() {
    if (this._d.length > 0) {
      this._add("Z");
    }
  };
  SVGPathRebuilder2.prototype._add = function(cmd, a, b, c, d, e2, f, g2, h) {
    var vals = [];
    var p = this._p;
    for (var i = 1; i < arguments.length; i++) {
      var val = arguments[i];
      if (isNaN(val)) {
        this._invalid = true;
        return;
      }
      vals.push(Math.round(val * p) / p);
    }
    this._d.push(cmd + vals.join(" "));
    this._start = cmd === "Z";
  };
  SVGPathRebuilder2.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join("");
    this._d = [];
  };
  SVGPathRebuilder2.prototype.getStr = function() {
    return this._str;
  };
  return SVGPathRebuilder2;
}();
var SVGPathRebuilder$1 = SVGPathRebuilder;
var NONE = "none";
var mathRound = Math.round;
function pathHasFill(style) {
  var fill = style.fill;
  return fill != null && fill !== NONE;
}
function pathHasStroke(style) {
  var stroke = style.stroke;
  return stroke != null && stroke !== NONE;
}
var strokeProps = ["lineCap", "miterLimit", "lineJoin"];
var svgStrokeProps = map$1(strokeProps, function(prop) {
  return "stroke-" + prop.toLowerCase();
});
function mapStyleToAttrs(updateAttr2, style, el, forceUpdate) {
  var opacity = style.opacity == null ? 1 : style.opacity;
  if (el instanceof ZRImage$1) {
    updateAttr2("opacity", opacity);
    return;
  }
  if (pathHasFill(style)) {
    var fill = normalizeColor(style.fill);
    updateAttr2("fill", fill.color);
    var fillOpacity = style.fillOpacity != null ? style.fillOpacity * fill.opacity * opacity : fill.opacity * opacity;
    if (forceUpdate || fillOpacity < 1) {
      updateAttr2("fill-opacity", fillOpacity);
    }
  } else {
    updateAttr2("fill", NONE);
  }
  if (pathHasStroke(style)) {
    var stroke = normalizeColor(style.stroke);
    updateAttr2("stroke", stroke.color);
    var strokeScale = style.strokeNoScale ? el.getLineScale() : 1;
    var strokeWidth = strokeScale ? (style.lineWidth || 0) / strokeScale : 0;
    var strokeOpacity = style.strokeOpacity != null ? style.strokeOpacity * stroke.opacity * opacity : stroke.opacity * opacity;
    var strokeFirst = style.strokeFirst;
    if (forceUpdate || strokeWidth !== 1) {
      updateAttr2("stroke-width", strokeWidth);
    }
    if (forceUpdate || strokeFirst) {
      updateAttr2("paint-order", strokeFirst ? "stroke" : "fill");
    }
    if (forceUpdate || strokeOpacity < 1) {
      updateAttr2("stroke-opacity", strokeOpacity);
    }
    if (style.lineDash) {
      var _a2 = getLineDash(el), lineDash = _a2[0], lineDashOffset = _a2[1];
      if (lineDash) {
        lineDashOffset = mathRound(lineDashOffset || 0);
        updateAttr2("stroke-dasharray", lineDash.join(","));
        if (lineDashOffset || forceUpdate) {
          updateAttr2("stroke-dashoffset", lineDashOffset);
        }
      }
    } else if (forceUpdate) {
      updateAttr2("stroke-dasharray", NONE);
    }
    for (var i = 0; i < strokeProps.length; i++) {
      var propName = strokeProps[i];
      if (forceUpdate || style[propName] !== DEFAULT_PATH_STYLE[propName]) {
        var val = style[propName] || DEFAULT_PATH_STYLE[propName];
        val && updateAttr2(svgStrokeProps[i], val);
      }
    }
  } else if (forceUpdate) {
    updateAttr2("stroke", NONE);
  }
}
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
function createElement(name) {
  return document.createElementNS(SVGNS, name);
}
function createVNode(tag, key, attrs, children, text) {
  return {
    tag,
    attrs: attrs || {},
    children,
    text,
    key
  };
}
function createElementOpen(name, attrs) {
  var attrsStr = [];
  if (attrs) {
    for (var key in attrs) {
      var val = attrs[key];
      var part = key;
      if (val === false) {
        continue;
      } else if (val !== true && val != null) {
        part += '="' + val + '"';
      }
      attrsStr.push(part);
    }
  }
  return "<" + name + " " + attrsStr.join(" ") + ">";
}
function createElementClose(name) {
  return "</" + name + ">";
}
function vNodeToString(el, opts) {
  opts = opts || {};
  var S = opts.newline ? "\n" : "";
  function convertElToString(el2) {
    var children = el2.children, tag = el2.tag, attrs = el2.attrs;
    return createElementOpen(tag, attrs) + (el2.text || "") + (children ? "" + S + map$1(children, function(child) {
      return convertElToString(child);
    }).join(S) + S : "") + createElementClose(tag);
  }
  return convertElToString(el);
}
function getCssString(selectorNodes, animationNodes, opts) {
  opts = opts || {};
  var S = opts.newline ? "\n" : "";
  var bracketBegin = " {" + S;
  var bracketEnd = S + "}";
  var selectors = map$1(keys(selectorNodes), function(className) {
    return className + bracketBegin + map$1(keys(selectorNodes[className]), function(attrName) {
      return attrName + ":" + selectorNodes[className][attrName] + ";";
    }).join(S) + bracketEnd;
  }).join(S);
  var animations = map$1(keys(animationNodes), function(animationName) {
    return "@keyframes " + animationName + bracketBegin + map$1(keys(animationNodes[animationName]), function(percent) {
      return percent + bracketBegin + map$1(keys(animationNodes[animationName][percent]), function(attrName) {
        var val = animationNodes[animationName][percent][attrName];
        if (attrName === "d") {
          val = 'path("' + val + '")';
        }
        return attrName + ":" + val + ";";
      }).join(S) + bracketEnd;
    }).join(S) + bracketEnd;
  }).join(S);
  if (!selectors && !animations) {
    return "";
  }
  return ["<![CDATA[", selectors, animations, "]]>"].join(S);
}
function createBrushScope(zrId) {
  return {
    zrId,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssClassIdx: 0,
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function createSVGVNode(width, height, children, useViewBox) {
  return createVNode("svg", "root", {
    "width": width,
    "height": height,
    "xmlns": SVGNS,
    "xmlns:xlink": XLINKNS,
    "version": "1.1",
    "baseProfile": "full",
    "viewBox": useViewBox ? "0 0 " + width + " " + height : false
  }, children);
}
var EASING_MAP = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
};
var transformOriginKey = "transform-origin";
function buildPathString(el, kfShape, path) {
  var shape = extend$1({}, el.shape);
  extend$1(shape, kfShape);
  el.buildPath(path, shape);
  var svgPathBuilder = new SVGPathRebuilder$1();
  svgPathBuilder.reset(getPathPrecision(el));
  path.rebuildPath(svgPathBuilder, 1);
  svgPathBuilder.generateStr();
  return svgPathBuilder.getStr();
}
function setTransformOrigin(target, transform2) {
  var originX = transform2.originX, originY = transform2.originY;
  if (originX || originY) {
    target[transformOriginKey] = originX + "px " + originY + "px";
  }
}
var ANIMATE_STYLE_MAP = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function addAnimation(cssAnim, scope) {
  var animationName = scope.zrId + "-ani-" + scope.cssAnimIdx++;
  scope.cssAnims[animationName] = cssAnim;
  return animationName;
}
function createCompoundPathCSSAnimation(el, attrs, scope) {
  var paths = el.shape.paths;
  var composedAnim = {};
  var cssAnimationCfg;
  var cssAnimationName;
  each$f(paths, function(path) {
    var subScope = createBrushScope(scope.zrId);
    subScope.animation = true;
    createCSSAnimation(path, {}, subScope, true);
    var cssAnims = subScope.cssAnims;
    var cssNodes = subScope.cssNodes;
    var animNames = keys(cssAnims);
    var len2 = animNames.length;
    if (!len2) {
      return;
    }
    cssAnimationName = animNames[len2 - 1];
    var lastAnim = cssAnims[cssAnimationName];
    for (var percent in lastAnim) {
      var kf = lastAnim[percent];
      composedAnim[percent] = composedAnim[percent] || { d: "" };
      composedAnim[percent].d += kf.d || "";
    }
    for (var className in cssNodes) {
      var val = cssNodes[className].animation;
      if (val.indexOf(cssAnimationName) >= 0) {
        cssAnimationCfg = val;
      }
    }
  });
  if (!cssAnimationCfg) {
    return;
  }
  attrs.d = false;
  var animationName = addAnimation(composedAnim, scope);
  return cssAnimationCfg.replace(cssAnimationName, animationName);
}
function getEasingFunc(easing) {
  return isString(easing) ? EASING_MAP[easing] ? "cubic-bezier(" + EASING_MAP[easing] + ")" : createCubicEasingFunc(easing) ? easing : "" : "";
}
function createCSSAnimation(el, attrs, scope, onlyShape) {
  var animators = el.animators;
  var len2 = animators.length;
  var cssAnimations = [];
  if (el instanceof CompoundPath$1) {
    var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    } else if (!len2) {
      return;
    }
  } else if (!len2) {
    return;
  }
  var groupAnimators = {};
  for (var i = 0; i < len2; i++) {
    var animator = animators[i];
    var cfgArr = [animator.getMaxTime() / 1e3 + "s"];
    var easing = getEasingFunc(animator.getClip().easing);
    var delay = animator.getDelay();
    if (easing) {
      cfgArr.push(easing);
    } else {
      cfgArr.push("linear");
    }
    if (delay) {
      cfgArr.push(delay / 1e3 + "s");
    }
    if (animator.getLoop()) {
      cfgArr.push("infinite");
    }
    var cfg = cfgArr.join(" ");
    groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];
    groupAnimators[cfg][1].push(animator);
  }
  function createSingleCSSAnimation(groupAnimator) {
    var animators2 = groupAnimator[1];
    var len3 = animators2.length;
    var transformKfs = {};
    var shapeKfs = {};
    var finalKfs = {};
    var animationTimingFunctionAttrName = "animation-timing-function";
    function saveAnimatorTrackToCssKfs(animator3, cssKfs, toCssAttrName) {
      var tracks = animator3.getTracks();
      var maxTime = animator3.getMaxTime();
      for (var k = 0; k < tracks.length; k++) {
        var track = tracks[k];
        if (track.needsAnimate()) {
          var kfs = track.keyframes;
          var attrName = track.propName;
          toCssAttrName && (attrName = toCssAttrName(attrName));
          if (attrName) {
            for (var i3 = 0; i3 < kfs.length; i3++) {
              var kf = kfs[i3];
              var percent2 = Math.round(kf.time / maxTime * 100) + "%";
              var kfEasing = getEasingFunc(kf.easing);
              var rawValue = kf.rawValue;
              if (isString(rawValue) || isNumber(rawValue)) {
                cssKfs[percent2] = cssKfs[percent2] || {};
                cssKfs[percent2][attrName] = kf.rawValue;
                if (kfEasing) {
                  cssKfs[percent2][animationTimingFunctionAttrName] = kfEasing;
                }
              }
            }
          }
        }
      }
    }
    for (var i2 = 0; i2 < len3; i2++) {
      var animator2 = animators2[i2];
      var targetProp = animator2.targetName;
      if (!targetProp) {
        !onlyShape && saveAnimatorTrackToCssKfs(animator2, transformKfs);
      } else if (targetProp === "shape") {
        saveAnimatorTrackToCssKfs(animator2, shapeKfs);
      }
    }
    for (var percent in transformKfs) {
      var transform2 = {};
      copyTransform(transform2, el);
      extend$1(transform2, transformKfs[percent]);
      var str = getSRTTransformString(transform2);
      var timingFunction = transformKfs[percent][animationTimingFunctionAttrName];
      finalKfs[percent] = str ? {
        transform: str
      } : {};
      setTransformOrigin(finalKfs[percent], transform2);
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    var path;
    var canAnimateShape = true;
    for (var percent in shapeKfs) {
      finalKfs[percent] = finalKfs[percent] || {};
      var isFirst = !path;
      var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];
      if (isFirst) {
        path = new PathProxy$1();
      }
      var len_1 = path.len();
      path.reset();
      finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);
      var newLen = path.len();
      if (!isFirst && len_1 !== newLen) {
        canAnimateShape = false;
        break;
      }
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    if (!canAnimateShape) {
      for (var percent in finalKfs) {
        delete finalKfs[percent].d;
      }
    }
    if (!onlyShape) {
      for (var i2 = 0; i2 < len3; i2++) {
        var animator2 = animators2[i2];
        var targetProp = animator2.targetName;
        if (targetProp === "style") {
          saveAnimatorTrackToCssKfs(animator2, finalKfs, function(propName) {
            return ANIMATE_STYLE_MAP[propName];
          });
        }
      }
    }
    var percents = keys(finalKfs);
    var allTransformOriginSame = true;
    var transformOrigin;
    for (var i2 = 1; i2 < percents.length; i2++) {
      var p02 = percents[i2 - 1];
      var p12 = percents[i2];
      if (finalKfs[p02][transformOriginKey] !== finalKfs[p12][transformOriginKey]) {
        allTransformOriginSame = false;
        break;
      }
      transformOrigin = finalKfs[p02][transformOriginKey];
    }
    if (allTransformOriginSame && transformOrigin) {
      for (var percent in finalKfs) {
        if (finalKfs[percent][transformOriginKey]) {
          delete finalKfs[percent][transformOriginKey];
        }
      }
      attrs[transformOriginKey] = transformOrigin;
    }
    if (filter(percents, function(percent2) {
      return keys(finalKfs[percent2]).length > 0;
    }).length) {
      var animationName = addAnimation(finalKfs, scope);
      return animationName + " " + groupAnimator[0] + " both";
    }
  }
  for (var key in groupAnimators) {
    var animationCfg = createSingleCSSAnimation(groupAnimators[key]);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    }
  }
  if (cssAnimations.length) {
    var className = scope.zrId + "-cls-" + scope.cssClassIdx++;
    scope.cssNodes["." + className] = {
      animation: cssAnimations.join(",")
    };
    attrs["class"] = className;
  }
}
var round$1 = Math.round;
function isImageLike(val) {
  return val && isString(val.src);
}
function isCanvasLike(val) {
  return val && isFunction$1(val.toDataURL);
}
function setStyleAttrs(attrs, style, el, scope) {
  mapStyleToAttrs(function(key, val) {
    var isFillStroke = key === "fill" || key === "stroke";
    if (isFillStroke && isGradient(val)) {
      setGradient(style, attrs, key, scope);
    } else if (isFillStroke && isPattern(val)) {
      setPattern(el, attrs, key, scope);
    } else {
      attrs[key] = val;
    }
  }, style, el, false);
  setShadow(el, attrs, scope);
}
function noRotateScale(m2) {
  return isAroundZero(m2[0] - 1) && isAroundZero(m2[1]) && isAroundZero(m2[2]) && isAroundZero(m2[3] - 1);
}
function noTranslate(m2) {
  return isAroundZero(m2[4]) && isAroundZero(m2[5]);
}
function setTransform(attrs, m2, compress) {
  if (m2 && !(noTranslate(m2) && noRotateScale(m2))) {
    var mul2 = compress ? 10 : 1e4;
    attrs.transform = noRotateScale(m2) ? "translate(" + round$1(m2[4] * mul2) / mul2 + " " + round$1(m2[5] * mul2) / mul2 + ")" : getMatrixStr(m2);
  }
}
function convertPolyShape(shape, attrs, mul2) {
  var points2 = shape.points;
  var strArr = [];
  for (var i = 0; i < points2.length; i++) {
    strArr.push(round$1(points2[i][0] * mul2) / mul2);
    strArr.push(round$1(points2[i][1] * mul2) / mul2);
  }
  attrs.points = strArr.join(" ");
}
function validatePolyShape(shape) {
  return !shape.smooth;
}
function createAttrsConvert(desc) {
  var normalizedDesc = map$1(desc, function(item) {
    return typeof item === "string" ? [item, item] : item;
  });
  return function(shape, attrs, mul2) {
    for (var i = 0; i < normalizedDesc.length; i++) {
      var item = normalizedDesc[i];
      var val = shape[item[0]];
      if (val != null) {
        attrs[item[1]] = round$1(val * mul2) / mul2;
      }
    }
  };
}
var buitinShapesDef = {
  circle: [createAttrsConvert(["cx", "cy", "r"])],
  polyline: [convertPolyShape, validatePolyShape],
  polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(el) {
  var animators = el.animators;
  for (var i = 0; i < animators.length; i++) {
    if (animators[i].targetName === "shape") {
      return true;
    }
  }
  return false;
}
function brushSVGPath(el, scope) {
  var style = el.style;
  var shape = el.shape;
  var builtinShpDef = buitinShapesDef[el.type];
  var attrs = {};
  var needsAnimate = scope.animation;
  var svgElType = "path";
  var strokePercent = el.style.strokePercent;
  var precision = scope.compress && getPathPrecision(el) || 4;
  if (builtinShpDef && !scope.willUpdate && !(builtinShpDef[1] && !builtinShpDef[1](shape)) && !(needsAnimate && hasShapeAnimation(el)) && !(strokePercent < 1)) {
    svgElType = el.type;
    var mul2 = Math.pow(10, precision);
    builtinShpDef[0](shape, attrs, mul2);
  } else {
    if (!el.path) {
      el.createPathProxy();
    }
    var path = el.path;
    if (el.shapeChanged()) {
      path.beginPath();
      el.buildPath(path, el.shape);
      el.pathUpdated();
    }
    var pathVersion = path.getVersion();
    var elExt = el;
    var svgPathBuilder = elExt.__svgPathBuilder;
    if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || strokePercent !== elExt.__svgPathStrokePercent) {
      if (!svgPathBuilder) {
        svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder$1();
      }
      svgPathBuilder.reset(precision);
      path.rebuildPath(svgPathBuilder, strokePercent);
      svgPathBuilder.generateStr();
      elExt.__svgPathVersion = pathVersion;
      elExt.__svgPathStrokePercent = strokePercent;
    }
    attrs.d = svgPathBuilder.getStr();
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode(svgElType, el.id + "", attrs);
}
function brushSVGImage(el, scope) {
  var style = el.style;
  var image = style.image;
  if (image && !isString(image)) {
    if (isImageLike(image)) {
      image = image.src;
    } else if (isCanvasLike(image)) {
      image = image.toDataURL();
    }
  }
  if (!image) {
    return;
  }
  var x = style.x || 0;
  var y = style.y || 0;
  var dw = style.width;
  var dh = style.height;
  var attrs = {
    href: image,
    width: dw,
    height: dh
  };
  if (x) {
    attrs.x = x;
  }
  if (y) {
    attrs.y = y;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("image", el.id + "", attrs);
}
function brushSVGTSpan(el, scope) {
  var style = el.style;
  var text = style.text;
  text != null && (text += "");
  if (!text || isNaN(style.x) || isNaN(style.y)) {
    return;
  }
  var font = style.font || DEFAULT_FONT;
  var x = style.x || 0;
  var y = adjustTextY$1(style.y || 0, getLineHeight(font), style.textBaseline);
  var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;
  var attrs = {
    "dominant-baseline": "central",
    "text-anchor": textAlign
  };
  if (hasSeparateFont(style)) {
    var separatedFontStr = "";
    var fontStyle = style.fontStyle;
    var fontSize = parseFontSize(style.fontSize);
    if (!parseFloat(fontSize)) {
      return;
    }
    var fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;
    var fontWeight = style.fontWeight;
    separatedFontStr += "font-size:" + fontSize + ";font-family:" + fontFamily + ";";
    if (fontStyle && fontStyle !== "normal") {
      separatedFontStr += "font-style:" + fontStyle + ";";
    }
    if (fontWeight && fontWeight !== "normal") {
      separatedFontStr += "font-weight:" + fontWeight + ";";
    }
    attrs.style = separatedFontStr;
  } else {
    attrs.style = "font: " + font;
  }
  if (text.match(/\s/)) {
    attrs["xml:space"] = "preserve";
  }
  if (x) {
    attrs.x = x;
  }
  if (y) {
    attrs.y = y;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("text", el.id + "", attrs, void 0, text);
}
function brush(el, scope) {
  if (el instanceof Path$1) {
    return brushSVGPath(el, scope);
  } else if (el instanceof ZRImage$1) {
    return brushSVGImage(el, scope);
  } else if (el instanceof TSpan$1) {
    return brushSVGTSpan(el, scope);
  }
}
function setShadow(el, attrs, scope) {
  var style = el.style;
  if (hasShadow(style)) {
    var shadowKey = getShadowKey(el);
    var shadowCache = scope.shadowCache;
    var shadowId = shadowCache[shadowKey];
    if (!shadowId) {
      var globalScale = el.getGlobalScale();
      var scaleX = globalScale[0];
      var scaleY = globalScale[1];
      if (!scaleX || !scaleY) {
        return;
      }
      var offsetX = style.shadowOffsetX || 0;
      var offsetY = style.shadowOffsetY || 0;
      var blur_1 = style.shadowBlur;
      var _a2 = normalizeColor(style.shadowColor), opacity = _a2.opacity, color = _a2.color;
      var stdDx = blur_1 / 2 / scaleX;
      var stdDy = blur_1 / 2 / scaleY;
      var stdDeviation = stdDx + " " + stdDy;
      shadowId = scope.zrId + "-s" + scope.shadowIdx++;
      scope.defs[shadowId] = createVNode("filter", shadowId, {
        "id": shadowId,
        "x": "-100%",
        "y": "-100%",
        "width": "300%",
        "height": "300%"
      }, [
        createVNode("feDropShadow", "", {
          "dx": offsetX / scaleX,
          "dy": offsetY / scaleY,
          "stdDeviation": stdDeviation,
          "flood-color": color,
          "flood-opacity": opacity
        })
      ]);
      shadowCache[shadowKey] = shadowId;
    }
    attrs.filter = getIdURL(shadowId);
  }
}
function setGradient(style, attrs, target, scope) {
  var val = style[target];
  var gradientTag;
  var gradientAttrs = {
    "gradientUnits": val.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (isLinearGradient(val)) {
    gradientTag = "linearGradient";
    gradientAttrs.x1 = val.x;
    gradientAttrs.y1 = val.y;
    gradientAttrs.x2 = val.x2;
    gradientAttrs.y2 = val.y2;
  } else if (isRadialGradient(val)) {
    gradientTag = "radialGradient";
    gradientAttrs.cx = retrieve2(val.x, 0.5);
    gradientAttrs.cy = retrieve2(val.y, 0.5);
    gradientAttrs.r = retrieve2(val.r, 0.5);
  } else {
    return;
  }
  var colors = val.colorStops;
  var colorStops = [];
  for (var i = 0, len2 = colors.length; i < len2; ++i) {
    var offset = round4(colors[i].offset) * 100 + "%";
    var stopColor = colors[i].color;
    var _a2 = normalizeColor(stopColor), color = _a2.color, opacity = _a2.opacity;
    var stopsAttrs = {
      "offset": offset
    };
    stopsAttrs["stop-color"] = color;
    if (opacity < 1) {
      stopsAttrs["stop-opacity"] = opacity;
    }
    colorStops.push(createVNode("stop", i + "", stopsAttrs));
  }
  var gradientVNode = createVNode(gradientTag, "", gradientAttrs, colorStops);
  var gradientKey = vNodeToString(gradientVNode);
  var gradientCache = scope.gradientCache;
  var gradientId = gradientCache[gradientKey];
  if (!gradientId) {
    gradientId = scope.zrId + "-g" + scope.gradientIdx++;
    gradientCache[gradientKey] = gradientId;
    gradientAttrs.id = gradientId;
    scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);
  }
  attrs[target] = getIdURL(gradientId);
}
function setPattern(el, attrs, target, scope) {
  var val = el.style[target];
  var patternAttrs = {
    "patternUnits": "userSpaceOnUse"
  };
  var child;
  if (isImagePattern(val)) {
    var imageWidth_1 = val.imageWidth;
    var imageHeight_1 = val.imageHeight;
    var imageSrc = void 0;
    var patternImage = val.image;
    if (isString(patternImage)) {
      imageSrc = patternImage;
    } else if (isImageLike(patternImage)) {
      imageSrc = patternImage.src;
    } else if (isCanvasLike(patternImage)) {
      imageSrc = patternImage.toDataURL();
    }
    if (typeof Image === "undefined") {
      var errMsg = "Image width/height must been given explictly in svg-ssr renderer.";
      assert(imageWidth_1, errMsg);
      assert(imageHeight_1, errMsg);
    } else if (imageWidth_1 == null || imageHeight_1 == null) {
      var setSizeToVNode_1 = function(vNode, img) {
        if (vNode) {
          var svgEl = vNode.elm;
          var width = vNode.attrs.width = imageWidth_1 || img.width;
          var height = vNode.attrs.height = imageHeight_1 || img.height;
          if (svgEl) {
            svgEl.setAttribute("width", width);
            svgEl.setAttribute("height", height);
          }
        }
      };
      var createdImage = createOrUpdateImage(imageSrc, null, el, function(img) {
        setSizeToVNode_1(patternVNode, img);
        setSizeToVNode_1(child, img);
      });
      if (createdImage && createdImage.width && createdImage.height) {
        imageWidth_1 = imageWidth_1 || createdImage.width;
        imageHeight_1 = imageHeight_1 || createdImage.height;
      }
    }
    child = createVNode("image", "img", {
      href: imageSrc,
      width: imageWidth_1,
      height: imageHeight_1
    });
    patternAttrs.width = imageWidth_1;
    patternAttrs.height = imageHeight_1;
  } else if (val.svgElement) {
    child = val.svgElement;
    patternAttrs.width = val.svgWidth;
    patternAttrs.height = val.svgHeight;
  }
  if (!child) {
    return;
  }
  patternAttrs.patternTransform = getSRTTransformString(val);
  var patternVNode = createVNode("pattern", "", patternAttrs, [child]);
  var patternKey = vNodeToString(patternVNode);
  var patternCache = scope.patternCache;
  var patternId = patternCache[patternKey];
  if (!patternId) {
    patternId = scope.zrId + "-p" + scope.patternIdx++;
    patternCache[patternKey] = patternId;
    patternAttrs.id = patternId;
    patternVNode = scope.defs[patternId] = createVNode("pattern", patternId, patternAttrs, [child]);
  }
  attrs[target] = getIdURL(patternId);
}
function setClipPath(clipPath, attrs, scope) {
  var clipPathCache = scope.clipPathCache, defs = scope.defs;
  var clipPathId = clipPathCache[clipPath.id];
  if (!clipPathId) {
    clipPathId = scope.zrId + "-c" + scope.clipPathIdx++;
    var clipPathAttrs = {
      id: clipPathId
    };
    clipPathCache[clipPath.id] = clipPathId;
    defs[clipPathId] = createVNode("clipPath", clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);
  }
  attrs["clip-path"] = getIdURL(clipPathId);
}
function createTextNode(text) {
  return document.createTextNode(text);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function setTextContent(node, text) {
  node.textContent = text;
}
var colonChar = 58;
var xChar = 120;
var emptyNode = createVNode("", "");
function isUndef(s) {
  return s === void 0;
}
function isDef(s) {
  return s !== void 0;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  var map2 = {};
  for (var i = beginIdx; i <= endIdx; ++i) {
    var key = children[i].key;
    if (key !== void 0) {
      map2[key] = i;
    }
  }
  return map2;
}
function sameVnode(vnode1, vnode2) {
  var isSameKey = vnode1.key === vnode2.key;
  var isSameTag = vnode1.tag === vnode2.tag;
  return isSameTag && isSameKey;
}
function createElm(vnode) {
  var i;
  var children = vnode.children;
  var tag = vnode.tag;
  if (isDef(tag)) {
    var elm = vnode.elm = createElement(tag);
    updateAttrs(emptyNode, vnode);
    if (isArray$1(children)) {
      for (i = 0; i < children.length; ++i) {
        var ch = children[i];
        if (ch != null) {
          appendChild(elm, createElm(ch));
        }
      }
    } else if (isDef(vnode.text) && !isObject$3(vnode.text)) {
      appendChild(elm, createTextNode(vnode.text));
    }
  } else {
    vnode.elm = createTextNode(vnode.text);
  }
  return vnode.elm;
}
function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    var ch = vnodes[startIdx];
    if (ch != null) {
      insertBefore(parentElm, createElm(ch), before);
    }
  }
}
function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    var ch = vnodes[startIdx];
    if (ch != null) {
      if (isDef(ch.tag)) {
        var parent_1 = parentNode(ch.elm);
        removeChild(parent_1, ch.elm);
      } else {
        removeChild(parentElm, ch.elm);
      }
    }
  }
}
function updateAttrs(oldVnode, vnode) {
  var key;
  var elm = vnode.elm;
  var oldAttrs = oldVnode && oldVnode.attrs || {};
  var attrs = vnode.attrs || {};
  if (oldAttrs === attrs) {
    return;
  }
  for (key in attrs) {
    var cur = attrs[key];
    var old = oldAttrs[key];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key, "");
      } else if (cur === false) {
        elm.removeAttribute(key);
      } else {
        if (key.charCodeAt(0) !== xChar) {
          elm.setAttribute(key, cur);
        } else if (key === "xmlns:xlink" || key === "xmlns") {
          elm.setAttributeNS(XMLNS, key, cur);
        } else if (key.charCodeAt(3) === colonChar) {
          elm.setAttributeNS(XML_NAMESPACE, key, cur);
        } else if (key.charCodeAt(5) === colonChar) {
          elm.setAttributeNS(XLINKNS, key, cur);
        } else {
          elm.setAttribute(key, cur);
        }
      }
    }
  }
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}
function updateChildren(parentElm, oldCh, newCh) {
  var oldStartIdx = 0;
  var newStartIdx = 0;
  var oldEndIdx = oldCh.length - 1;
  var oldStartVnode = oldCh[0];
  var oldEndVnode = oldCh[oldEndIdx];
  var newEndIdx = newCh.length - 1;
  var newStartVnode = newCh[0];
  var newEndVnode = newCh[newEndIdx];
  var oldKeyToIdx;
  var idxInOld;
  var elmToMove;
  var before;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode);
      insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm));
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode);
      insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      if (isUndef(oldKeyToIdx)) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      }
      idxInOld = oldKeyToIdx[newStartVnode.key];
      if (isUndef(idxInOld)) {
        insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
      } else {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.tag !== newStartVnode.tag) {
          insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
        } else {
          patchVnode(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
        }
      }
      newStartVnode = newCh[++newStartIdx];
    }
  }
  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
    if (oldStartIdx > oldEndIdx) {
      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
    } else {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }
}
function patchVnode(oldVnode, vnode) {
  var elm = vnode.elm = oldVnode.elm;
  var oldCh = oldVnode.children;
  var ch = vnode.children;
  if (oldVnode === vnode) {
    return;
  }
  updateAttrs(oldVnode, vnode);
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) {
        updateChildren(elm, oldCh, ch);
      }
    } else if (isDef(ch)) {
      if (isDef(oldVnode.text)) {
        setTextContent(elm, "");
      }
      addVnodes(elm, null, ch, 0, ch.length - 1);
    } else if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    } else if (isDef(oldVnode.text)) {
      setTextContent(elm, "");
    }
  } else if (oldVnode.text !== vnode.text) {
    if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    }
    setTextContent(elm, vnode.text);
  }
}
function patch(oldVnode, vnode) {
  if (sameVnode(oldVnode, vnode)) {
    patchVnode(oldVnode, vnode);
  } else {
    var elm = oldVnode.elm;
    var parent_2 = parentNode(elm);
    createElm(vnode);
    if (parent_2 !== null) {
      insertBefore(parent_2, vnode.elm, nextSibling(elm));
      removeVnodes(parent_2, [oldVnode], 0, 0);
    }
  }
  return vnode;
}
var svgId = 0;
var SVGPainter = function() {
  function SVGPainter2(root2, storage2, opts) {
    this.type = "svg";
    this.refreshHover = createMethodNotSupport();
    this.configLayer = createMethodNotSupport();
    this.storage = storage2;
    this._opts = opts = extend$1({}, opts);
    this.root = root2;
    this._id = "zr" + svgId++;
    this._oldVNode = createSVGVNode(opts.width, opts.height);
    if (root2 && !opts.ssr) {
      var viewport = this._viewport = document.createElement("div");
      viewport.style.cssText = "position:relative;overflow:hidden";
      var svgDom = this._svgDom = this._oldVNode.elm = createElement("svg");
      updateAttrs(null, this._oldVNode);
      viewport.appendChild(svgDom);
      root2.appendChild(viewport);
    }
    this.resize(opts.width, opts.height);
  }
  SVGPainter2.prototype.getType = function() {
    return this.type;
  };
  SVGPainter2.prototype.getViewportRoot = function() {
    return this._viewport;
  };
  SVGPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  SVGPainter2.prototype.getSvgDom = function() {
    return this._svgDom;
  };
  SVGPainter2.prototype.refresh = function() {
    if (this.root) {
      var vnode = this.renderToVNode({
        willUpdate: true
      });
      vnode.attrs.style = "position:absolute;left:0;top:0;user-select:none";
      patch(this._oldVNode, vnode);
      this._oldVNode = vnode;
    }
  };
  SVGPainter2.prototype.renderOneToVNode = function(el) {
    return brush(el, createBrushScope(this._id));
  };
  SVGPainter2.prototype.renderToVNode = function(opts) {
    opts = opts || {};
    var list = this.storage.getDisplayList(true);
    var bgColor = this._backgroundColor;
    var width = this._width;
    var height = this._height;
    var scope = createBrushScope(this._id);
    scope.animation = opts.animation;
    scope.willUpdate = opts.willUpdate;
    scope.compress = opts.compress;
    var children = [];
    if (bgColor && bgColor !== "none") {
      var _a2 = normalizeColor(bgColor), color = _a2.color, opacity = _a2.opacity;
      this._bgVNode = createVNode("rect", "bg", {
        width,
        height,
        x: "0",
        y: "0",
        id: "0",
        fill: color,
        "fill-opacity": opacity
      });
      children.push(this._bgVNode);
    } else {
      this._bgVNode = null;
    }
    var mainVNode = !opts.compress ? this._mainVNode = createVNode("g", "main", {}, []) : null;
    this._paintList(list, scope, mainVNode ? mainVNode.children : children);
    mainVNode && children.push(mainVNode);
    var defs = map$1(keys(scope.defs), function(id) {
      return scope.defs[id];
    });
    if (defs.length) {
      children.push(createVNode("defs", "defs", {}, defs));
    }
    if (opts.animation) {
      var animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, { newline: true });
      if (animationCssStr) {
        var styleNode = createVNode("style", "stl", {}, [], animationCssStr);
        children.push(styleNode);
      }
    }
    return createSVGVNode(width, height, children, opts.useViewBox);
  };
  SVGPainter2.prototype.renderToString = function(opts) {
    opts = opts || {};
    return vNodeToString(this.renderToVNode({
      animation: retrieve2(opts.cssAnimation, true),
      willUpdate: false,
      compress: true,
      useViewBox: retrieve2(opts.useViewBox, true)
    }), { newline: true });
  };
  SVGPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    var bgVNode = this._bgVNode;
    if (bgVNode && bgVNode.elm) {
      var _a2 = normalizeColor(backgroundColor2), color = _a2.color, opacity = _a2.opacity;
      bgVNode.elm.setAttribute("fill", color);
      if (opacity < 1) {
        bgVNode.elm.setAttribute("fill-opacity", opacity);
      }
    }
  };
  SVGPainter2.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  };
  SVGPainter2.prototype._paintList = function(list, scope, out2) {
    var listLen = list.length;
    var clipPathsGroupsStack = [];
    var clipPathsGroupsStackDepth = 0;
    var currentClipPathGroup;
    var prevClipPaths;
    var clipGroupNodeIdx = 0;
    for (var i = 0; i < listLen; i++) {
      var displayable = list[i];
      if (!displayable.invisible) {
        var clipPaths = displayable.__clipPaths;
        var len2 = clipPaths && clipPaths.length || 0;
        var prevLen = prevClipPaths && prevClipPaths.length || 0;
        var lca = void 0;
        for (lca = Math.max(len2 - 1, prevLen - 1); lca >= 0; lca--) {
          if (clipPaths && prevClipPaths && clipPaths[lca] === prevClipPaths[lca]) {
            break;
          }
        }
        for (var i_1 = prevLen - 1; i_1 > lca; i_1--) {
          clipPathsGroupsStackDepth--;
          currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];
        }
        for (var i_2 = lca + 1; i_2 < len2; i_2++) {
          var groupAttrs = {};
          setClipPath(clipPaths[i_2], groupAttrs, scope);
          var g2 = createVNode("g", "clip-g-" + clipGroupNodeIdx++, groupAttrs, []);
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(g2);
          clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g2;
          currentClipPathGroup = g2;
        }
        prevClipPaths = clipPaths;
        var ret2 = brush(displayable, scope);
        if (ret2) {
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(ret2);
        }
      }
    }
  };
  SVGPainter2.prototype.resize = function(width, height) {
    var opts = this._opts;
    var root2 = this.root;
    var viewport = this._viewport;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    if (root2 && viewport) {
      viewport.style.display = "none";
      width = getSize$1(root2, 0, opts);
      height = getSize$1(root2, 1, opts);
      viewport.style.display = "";
    }
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      if (viewport) {
        var viewportStyle = viewport.style;
        viewportStyle.width = width + "px";
        viewportStyle.height = height + "px";
      }
      var svgDom = this._svgDom;
      if (svgDom) {
        svgDom.setAttribute("width", width);
        svgDom.setAttribute("height", height);
      }
    }
  };
  SVGPainter2.prototype.getWidth = function() {
    return this._width;
  };
  SVGPainter2.prototype.getHeight = function() {
    return this._height;
  };
  SVGPainter2.prototype.dispose = function() {
    if (this.root) {
      this.root.innerHTML = "";
    }
    this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  };
  SVGPainter2.prototype.clear = function() {
    if (this._svgDom) {
      this._svgDom.innerHTML = null;
    }
    this._oldVNode = null;
  };
  SVGPainter2.prototype.toDataURL = function(base64) {
    var str = encodeURIComponent(this.renderToString());
    var prefix = "data:image/svg+xml;";
    if (base64) {
      str = encodeBase64(str);
      return str && prefix + "base64," + str;
    }
    return prefix + "charset=UTF-8," + str;
  };
  return SVGPainter2;
}();
function createMethodNotSupport(method) {
  return function() {
  };
}
var SVGPainter$1 = SVGPainter;
function install$16(registers) {
  registers.registerPainter("svg", SVGPainter$1);
}
function createDom(id, painter, dpr2) {
  var newDom = platformApi.createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style;
  if (newDomStyle) {
    newDomStyle.position = "absolute";
    newDomStyle.left = "0";
    newDomStyle.top = "0";
    newDomStyle.width = width + "px";
    newDomStyle.height = height + "px";
    newDom.setAttribute("data-zr-dom-id", id);
  }
  newDom.width = width * dpr2;
  newDom.height = height * dpr2;
  return newDom;
}
var Layer = function(_super) {
  __extends(Layer2, _super);
  function Layer2(id, painter, dpr2) {
    var _this = _super.call(this) || this;
    _this.motionBlur = false;
    _this.lastFrameAlpha = 0.7;
    _this.dpr = 1;
    _this.virtual = false;
    _this.config = {};
    _this.incremental = false;
    _this.zlevel = 0;
    _this.maxRepaintRectCount = 5;
    _this.__dirty = true;
    _this.__firstTimePaint = true;
    _this.__used = false;
    _this.__drawIndex = 0;
    _this.__startIndex = 0;
    _this.__endIndex = 0;
    _this.__prevStartIndex = null;
    _this.__prevEndIndex = null;
    var dom;
    dpr2 = dpr2 || devicePixelRatio;
    if (typeof id === "string") {
      dom = createDom(id, painter, dpr2);
    } else if (isObject$3(id)) {
      dom = id;
      id = dom.id;
    }
    _this.id = id;
    _this.dom = dom;
    var domStyle = dom.style;
    if (domStyle) {
      disableUserSelect(dom);
      dom.onselectstart = function() {
        return false;
      };
      domStyle.padding = "0";
      domStyle.margin = "0";
      domStyle.borderWidth = "0";
    }
    _this.painter = painter;
    _this.dpr = dpr2;
    return _this;
  }
  Layer2.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  };
  Layer2.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex;
    this.__prevEndIndex = this.__endIndex;
  };
  Layer2.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d");
    this.ctx.dpr = this.dpr;
  };
  Layer2.prototype.setUnpainted = function() {
    this.__firstTimePaint = true;
  };
  Layer2.prototype.createBackBuffer = function() {
    var dpr2 = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, dpr2);
    this.ctxBack = this.domBack.getContext("2d");
    if (dpr2 !== 1) {
      this.ctxBack.scale(dpr2, dpr2);
    }
  };
  Layer2.prototype.createRepaintRects = function(displayList, prevList, viewWidth, viewHeight) {
    if (this.__firstTimePaint) {
      this.__firstTimePaint = false;
      return null;
    }
    var mergedRepaintRects = [];
    var maxRepaintRectCount = this.maxRepaintRectCount;
    var full = false;
    var pendingRect = new BoundingRect$1(0, 0, 0, 0);
    function addRectToMergePool(rect) {
      if (!rect.isFinite() || rect.isZero()) {
        return;
      }
      if (mergedRepaintRects.length === 0) {
        var boundingRect = new BoundingRect$1(0, 0, 0, 0);
        boundingRect.copy(rect);
        mergedRepaintRects.push(boundingRect);
      } else {
        var isMerged = false;
        var minDeltaArea = Infinity;
        var bestRectToMergeIdx = 0;
        for (var i2 = 0; i2 < mergedRepaintRects.length; ++i2) {
          var mergedRect = mergedRepaintRects[i2];
          if (mergedRect.intersect(rect)) {
            var pendingRect_1 = new BoundingRect$1(0, 0, 0, 0);
            pendingRect_1.copy(mergedRect);
            pendingRect_1.union(rect);
            mergedRepaintRects[i2] = pendingRect_1;
            isMerged = true;
            break;
          } else if (full) {
            pendingRect.copy(rect);
            pendingRect.union(mergedRect);
            var aArea = rect.width * rect.height;
            var bArea = mergedRect.width * mergedRect.height;
            var pendingArea = pendingRect.width * pendingRect.height;
            var deltaArea = pendingArea - aArea - bArea;
            if (deltaArea < minDeltaArea) {
              minDeltaArea = deltaArea;
              bestRectToMergeIdx = i2;
            }
          }
        }
        if (full) {
          mergedRepaintRects[bestRectToMergeIdx].union(rect);
          isMerged = true;
        }
        if (!isMerged) {
          var boundingRect = new BoundingRect$1(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        }
        if (!full) {
          full = mergedRepaintRects.length >= maxRepaintRectCount;
        }
      }
    }
    for (var i = this.__startIndex; i < this.__endIndex; ++i) {
      var el = displayList[i];
      if (el) {
        var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
        var prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
        var curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
        if (curRect) {
          addRectToMergePool(curRect);
        }
      }
    }
    for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
      var el = prevList[i];
      var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
      if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
        var prevRect = el.getPrevPaintRect();
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
      }
    }
    var hasIntersections;
    do {
      hasIntersections = false;
      for (var i = 0; i < mergedRepaintRects.length; ) {
        if (mergedRepaintRects[i].isZero()) {
          mergedRepaintRects.splice(i, 1);
          continue;
        }
        for (var j = i + 1; j < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
            hasIntersections = true;
            mergedRepaintRects[i].union(mergedRepaintRects[j]);
            mergedRepaintRects.splice(j, 1);
          } else {
            j++;
          }
        }
        i++;
      }
    } while (hasIntersections);
    this._paintRects = mergedRepaintRects;
    return mergedRepaintRects;
  };
  Layer2.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  };
  Layer2.prototype.resize = function(width, height) {
    var dpr2 = this.dpr;
    var dom = this.dom;
    var domStyle = dom.style;
    var domBack = this.domBack;
    if (domStyle) {
      domStyle.width = width + "px";
      domStyle.height = height + "px";
    }
    dom.width = width * dpr2;
    dom.height = height * dpr2;
    if (domBack) {
      domBack.width = width * dpr2;
      domBack.height = height * dpr2;
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    }
  };
  Layer2.prototype.clear = function(clearAll, clearColor, repaintRects) {
    var dom = this.dom;
    var ctx = this.ctx;
    var width = dom.width;
    var height = dom.height;
    clearColor = clearColor || this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr2 = this.dpr;
    var self2 = this;
    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }
      this.ctxBack.globalCompositeOperation = "copy";
      this.ctxBack.drawImage(dom, 0, 0, width / dpr2, height / dpr2);
    }
    var domBack = this.domBack;
    function doClear(x, y, width2, height2) {
      ctx.clearRect(x, y, width2, height2);
      if (clearColor && clearColor !== "transparent") {
        var clearColorGradientOrPattern = void 0;
        if (isGradientObject(clearColor)) {
          clearColorGradientOrPattern = clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width2,
            height: height2
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
        } else if (isImagePatternObject(clearColor)) {
          clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
            dirty: function() {
              self2.setUnpainted();
              self2.__painter.refresh();
            }
          });
        }
        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(x, y, width2, height2);
        ctx.restore();
      }
      if (haveMotionBLur) {
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, x, y, width2, height2);
        ctx.restore();
      }
    }
    if (!repaintRects || haveMotionBLur) {
      doClear(0, 0, width, height);
    } else if (repaintRects.length) {
      each$f(repaintRects, function(rect) {
        doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
      });
    }
  };
  return Layer2;
}(Eventful$1);
var Layer$1 = Layer;
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 1e-3;
function isLayerValid(layer) {
  if (!layer) {
    return false;
  }
  if (layer.__builtin__) {
    return true;
  }
  if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
    return false;
  }
  return true;
}
function createRoot(width, height) {
  var domRoot = document.createElement("div");
  domRoot.style.cssText = [
    "position:relative",
    "width:" + width + "px",
    "height:" + height + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";";
  return domRoot;
}
var CanvasPainter = function() {
  function CanvasPainter2(root2, storage2, opts, id) {
    this.type = "canvas";
    this._zlevelList = [];
    this._prevDisplayList = [];
    this._layers = {};
    this._layerConfig = {};
    this._needsManuallyCompositing = false;
    this.type = "canvas";
    var singleCanvas = !root2.nodeName || root2.nodeName.toUpperCase() === "CANVAS";
    this._opts = opts = extend$1({}, opts || {});
    this.dpr = opts.devicePixelRatio || devicePixelRatio;
    this._singleCanvas = singleCanvas;
    this.root = root2;
    var rootStyle = root2.style;
    if (rootStyle) {
      disableUserSelect(root2);
      root2.innerHTML = "";
    }
    this.storage = storage2;
    var zlevelList = this._zlevelList;
    this._prevDisplayList = [];
    var layers = this._layers;
    if (!singleCanvas) {
      this._width = getSize$1(root2, 0, opts);
      this._height = getSize$1(root2, 1, opts);
      var domRoot = this._domRoot = createRoot(this._width, this._height);
      root2.appendChild(domRoot);
    } else {
      var rootCanvas = root2;
      var width = rootCanvas.width;
      var height = rootCanvas.height;
      if (opts.width != null) {
        width = opts.width;
      }
      if (opts.height != null) {
        height = opts.height;
      }
      this.dpr = opts.devicePixelRatio || 1;
      rootCanvas.width = width * this.dpr;
      rootCanvas.height = height * this.dpr;
      this._width = width;
      this._height = height;
      var mainLayer = new Layer$1(rootCanvas, this, this.dpr);
      mainLayer.__builtin__ = true;
      mainLayer.initContext();
      layers[CANVAS_ZLEVEL] = mainLayer;
      mainLayer.zlevel = CANVAS_ZLEVEL;
      zlevelList.push(CANVAS_ZLEVEL);
      this._domRoot = root2;
    }
  }
  CanvasPainter2.prototype.getType = function() {
    return "canvas";
  };
  CanvasPainter2.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  };
  CanvasPainter2.prototype.getViewportRoot = function() {
    return this._domRoot;
  };
  CanvasPainter2.prototype.getViewportRootOffset = function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  };
  CanvasPainter2.prototype.refresh = function(paintAll) {
    var list = this.storage.getDisplayList(true);
    var prevList = this._prevDisplayList;
    var zlevelList = this._zlevelList;
    this._redrawId = Math.random();
    this._paintList(list, prevList, paintAll, this._redrawId);
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];
      if (!layer.__builtin__ && layer.refresh) {
        var clearColor = i === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }
    if (this._opts.useDirtyRect) {
      this._prevDisplayList = list.slice();
    }
    return this;
  };
  CanvasPainter2.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(false));
  };
  CanvasPainter2.prototype._paintHoverList = function(list) {
    var len2 = list.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();
    if (!len2) {
      return;
    }
    var scope = {
      inHover: true,
      viewWidth: this._width,
      viewHeight: this._height
    };
    var ctx;
    for (var i = 0; i < len2; i++) {
      var el = list[i];
      if (el.__inHover) {
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        if (!ctx) {
          ctx = hoverLayer.ctx;
          ctx.save();
        }
        brush$1(ctx, el, scope, i === len2 - 1);
      }
    }
    if (ctx) {
      ctx.restore();
    }
  };
  CanvasPainter2.prototype.getHoverLayer = function() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  };
  CanvasPainter2.prototype.paintOne = function(ctx, el) {
    brushSingle(ctx, el);
  };
  CanvasPainter2.prototype._paintList = function(list, prevList, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }
    paintAll = paintAll || false;
    this._updateLayerStatus(list);
    var _a2 = this._doPaintList(list, prevList, paintAll), finished = _a2.finished, needsRefreshHover = _a2.needsRefreshHover;
    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }
    if (needsRefreshHover) {
      this._paintHoverList(list);
    }
    if (!finished) {
      var self_1 = this;
      requestAnimationFrame$2(function() {
        self_1._paintList(list, prevList, paintAll, redrawId);
      });
    } else {
      this.eachLayer(function(layer) {
        layer.afterBrush && layer.afterBrush();
      });
    }
  };
  CanvasPainter2.prototype._compositeManually = function() {
    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    var width = this._domRoot.width;
    var height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height);
    this.eachBuiltinLayer(function(layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width, height);
      }
    });
  };
  CanvasPainter2.prototype._doPaintList = function(list, prevList, paintAll) {
    var _this = this;
    var layerList = [];
    var useDirtyRect = this._opts.useDirtyRect;
    for (var zi = 0; zi < this._zlevelList.length; zi++) {
      var zlevel = this._zlevelList[zi];
      var layer = this._layers[zlevel];
      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }
    var finished = true;
    var needsRefreshHover = false;
    var _loop_1 = function(k2) {
      var layer2 = layerList[k2];
      var ctx = layer2.ctx;
      var repaintRects = useDirtyRect && layer2.createRepaintRects(list, prevList, this_1._width, this_1._height);
      var start2 = paintAll ? layer2.__startIndex : layer2.__drawIndex;
      var useTimer = !paintAll && layer2.incremental && Date.now;
      var startTime = useTimer && Date.now();
      var clearColor = layer2.zlevel === this_1._zlevelList[0] ? this_1._backgroundColor : null;
      if (layer2.__startIndex === layer2.__endIndex) {
        layer2.clear(false, clearColor, repaintRects);
      } else if (start2 === layer2.__startIndex) {
        var firstEl = list[start2];
        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer2.clear(false, clearColor, repaintRects);
        }
      }
      if (start2 === -1) {
        console.error("For some unknown reason. drawIndex is -1");
        start2 = layer2.__startIndex;
      }
      var i;
      var repaint = function(repaintRect) {
        var scope = {
          inHover: false,
          allClipped: false,
          prevEl: null,
          viewWidth: _this._width,
          viewHeight: _this._height
        };
        for (i = start2; i < layer2.__endIndex; i++) {
          var el = list[i];
          if (el.__inHover) {
            needsRefreshHover = true;
          }
          _this._doPaintEl(el, layer2, useDirtyRect, repaintRect, scope, i === layer2.__endIndex - 1);
          if (useTimer) {
            var dTime = Date.now() - startTime;
            if (dTime > 15) {
              break;
            }
          }
        }
        if (scope.prevElClipPaths) {
          ctx.restore();
        }
      };
      if (repaintRects) {
        if (repaintRects.length === 0) {
          i = layer2.__endIndex;
        } else {
          var dpr2 = this_1.dpr;
          for (var r = 0; r < repaintRects.length; ++r) {
            var rect = repaintRects[r];
            ctx.save();
            ctx.beginPath();
            ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
            ctx.clip();
            repaint(rect);
            ctx.restore();
          }
        }
      } else {
        ctx.save();
        repaint();
        ctx.restore();
      }
      layer2.__drawIndex = i;
      if (layer2.__drawIndex < layer2.__endIndex) {
        finished = false;
      }
    };
    var this_1 = this;
    for (var k = 0; k < layerList.length; k++) {
      _loop_1(k);
    }
    if (env$1.wxa) {
      each$f(this._layers, function(layer2) {
        if (layer2 && layer2.ctx && layer2.ctx.draw) {
          layer2.ctx.draw();
        }
      });
    }
    return {
      finished,
      needsRefreshHover
    };
  };
  CanvasPainter2.prototype._doPaintEl = function(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
    var ctx = currentLayer.ctx;
    if (useDirtyRect) {
      var paintRect = el.getPaintRect();
      if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
        brush$1(ctx, el, scope, isLast);
        el.setPrevPaintRect(paintRect);
      }
    } else {
      brush$1(ctx, el, scope, isLast);
    }
  };
  CanvasPainter2.prototype.getLayer = function(zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }
    var layer = this._layers[zlevel];
    if (!layer) {
      layer = new Layer$1("zr_" + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;
      if (this._layerConfig[zlevel]) {
        merge(layer, this._layerConfig[zlevel], true);
      } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
        merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
      }
      if (virtual) {
        layer.virtual = virtual;
      }
      this.insertLayer(zlevel, layer);
      layer.initContext();
    }
    return layer;
  };
  CanvasPainter2.prototype.insertLayer = function(zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len2 = zlevelList.length;
    var domRoot = this._domRoot;
    var prevLayer = null;
    var i = -1;
    if (layersMap[zlevel]) {
      return;
    }
    if (!isLayerValid(layer)) {
      return;
    }
    if (len2 > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len2 - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }
      prevLayer = layersMap[zlevelList[i]];
    }
    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer;
    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
    layer.__painter = this;
  };
  CanvasPainter2.prototype.eachLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  };
  CanvasPainter2.prototype.eachBuiltinLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];
      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  };
  CanvasPainter2.prototype.eachOtherLayer = function(cb, context) {
    var zlevelList = this._zlevelList;
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];
      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  };
  CanvasPainter2.prototype.getLayers = function() {
    return this._layers;
  };
  CanvasPainter2.prototype._updateLayerStatus = function(list) {
    this.eachBuiltinLayer(function(layer2, z) {
      layer2.__dirty = layer2.__used = false;
    });
    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }
        prevLayer.__endIndex = idx;
      }
    }
    if (this._singleCanvas) {
      for (var i_1 = 1; i_1 < list.length; i_1++) {
        var el = list[i_1];
        if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }
    var prevLayer = null;
    var incrementalLayerCount = 0;
    var prevZlevel;
    var i;
    for (i = 0; i < list.length; i++) {
      var el = list[i];
      var zlevel = el.zlevel;
      var layer = void 0;
      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      }
      if (el.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }
      if (!layer.__builtin__) {
        logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
      }
      if (layer !== prevLayer) {
        layer.__used = true;
        if (layer.__startIndex !== i) {
          layer.__dirty = true;
        }
        layer.__startIndex = i;
        if (!layer.incremental) {
          layer.__drawIndex = i;
        } else {
          layer.__drawIndex = -1;
        }
        updatePrevLayer(i);
        prevLayer = layer;
      }
      if (el.__dirty & REDRAW_BIT && !el.__inHover) {
        layer.__dirty = true;
        if (layer.incremental && layer.__drawIndex < 0) {
          layer.__drawIndex = i;
        }
      }
    }
    updatePrevLayer(i);
    this.eachBuiltinLayer(function(layer2, z) {
      if (!layer2.__used && layer2.getElementCount() > 0) {
        layer2.__dirty = true;
        layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
      }
      if (layer2.__dirty && layer2.__drawIndex < 0) {
        layer2.__drawIndex = layer2.__startIndex;
      }
    });
  };
  CanvasPainter2.prototype.clear = function() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  };
  CanvasPainter2.prototype._clearLayer = function(layer) {
    layer.clear();
  };
  CanvasPainter2.prototype.setBackgroundColor = function(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    each$f(this._layers, function(layer) {
      layer.setUnpainted();
    });
  };
  CanvasPainter2.prototype.configLayer = function(zlevel, config) {
    if (config) {
      var layerConfig = this._layerConfig;
      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        merge(layerConfig[zlevel], config, true);
      }
      for (var i = 0; i < this._zlevelList.length; i++) {
        var _zlevel = this._zlevelList[i];
        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer = this._layers[_zlevel];
          merge(layer, layerConfig[zlevel], true);
        }
      }
    }
  };
  CanvasPainter2.prototype.delLayer = function(zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];
    if (!layer) {
      return;
    }
    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(indexOf(zlevelList, zlevel), 1);
  };
  CanvasPainter2.prototype.resize = function(width, height) {
    if (!this._domRoot.style) {
      if (width == null || height == null) {
        return;
      }
      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      var domRoot = this._domRoot;
      domRoot.style.display = "none";
      var opts = this._opts;
      var root2 = this.root;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = getSize$1(root2, 0, opts);
      height = getSize$1(root2, 1, opts);
      domRoot.style.display = "";
      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + "px";
        domRoot.style.height = height + "px";
        for (var id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }
        this.refresh(true);
      }
      this._width = width;
      this._height = height;
    }
    return this;
  };
  CanvasPainter2.prototype.clearLayer = function(zlevel) {
    var layer = this._layers[zlevel];
    if (layer) {
      layer.clear();
    }
  };
  CanvasPainter2.prototype.dispose = function() {
    this.root.innerHTML = "";
    this.root = this.storage = this._domRoot = this._layers = null;
  };
  CanvasPainter2.prototype.getRenderedCanvas = function(opts) {
    opts = opts || {};
    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }
    var imageLayer = new Layer$1("image", this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
    var ctx = imageLayer.ctx;
    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      var width_1 = imageLayer.dom.width;
      var height_1 = imageLayer.dom.height;
      this.eachLayer(function(layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width_1, height_1);
        } else if (layer.renderToCanvas) {
          ctx.save();
          layer.renderToCanvas(ctx);
          ctx.restore();
        }
      });
    } else {
      var scope = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      };
      var displayList = this.storage.getDisplayList(true);
      for (var i = 0, len2 = displayList.length; i < len2; i++) {
        var el = displayList[i];
        brush$1(ctx, el, scope, i === len2 - 1);
      }
    }
    return imageLayer.dom;
  };
  CanvasPainter2.prototype.getWidth = function() {
    return this._width;
  };
  CanvasPainter2.prototype.getHeight = function() {
    return this._height;
  };
  return CanvasPainter2;
}();
var CanvasPainter$1 = CanvasPainter;
function install$15(registers) {
  registers.registerPainter("canvas", CanvasPainter$1);
}
var LineSeriesModel = function(_super) {
  __extends(LineSeriesModel2, _super);
  function LineSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LineSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  LineSeriesModel2.prototype.getInitialData = function(option) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  LineSeriesModel2.prototype.getLegendIcon = function(opt) {
    var group = new Group$4();
    var line = createSymbol$1("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
    group.add(line);
    line.setStyle(opt.lineStyle);
    var visualType = this.getData().getVisual("symbol");
    var visualRotate = this.getData().getVisual("symbolRotate");
    var symbolType = visualType === "none" ? "circle" : visualType;
    var size = opt.itemHeight * 0.8;
    var symbol = createSymbol$1(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
    group.add(symbol);
    symbol.setStyle(opt.itemStyle);
    var symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
    symbol.rotation = symbolRotate * Math.PI / 180;
    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symbolType.indexOf("empty") > -1) {
      symbol.style.stroke = symbol.style.fill;
      symbol.style.fill = "#fff";
      symbol.style.lineWidth = 2;
    }
    return group;
  };
  LineSeriesModel2.type = "series.line";
  LineSeriesModel2.dependencies = ["grid", "polar"];
  LineSeriesModel2.defaultOption = {
    z: 3,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    clip: true,
    label: {
      position: "top"
    },
    endLabel: {
      show: false,
      valueAnimation: true,
      distance: 8
    },
    lineStyle: {
      width: 2,
      type: "solid"
    },
    emphasis: {
      scale: true
    },
    step: false,
    smooth: false,
    smoothMonotone: null,
    symbol: "emptyCircle",
    symbolSize: 4,
    symbolRotate: null,
    showSymbol: true,
    showAllSymbol: "auto",
    connectNulls: false,
    sampling: "none",
    animationEasing: "linear",
    progressive: 0,
    hoverLayerThreshold: Infinity,
    universalTransition: {
      divideShape: "clone"
    },
    triggerLineEvent: false
  };
  return LineSeriesModel2;
}(SeriesModel$1);
var LineSeries = LineSeriesModel;
function getDefaultLabel(data, dataIndex) {
  var labelDims = data.mapDimensionsAll("defaultedLabel");
  var len2 = labelDims.length;
  if (len2 === 1) {
    var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + "" : null;
  } else if (len2) {
    var vals = [];
    for (var i = 0; i < labelDims.length; i++) {
      vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));
    }
    return vals.join(" ");
  }
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
  var labelDims = data.mapDimensionsAll("defaultedLabel");
  if (!isArray$1(interpolatedValue)) {
    return interpolatedValue + "";
  }
  var vals = [];
  for (var i = 0; i < labelDims.length; i++) {
    var dimIndex = data.getDimensionIndex(labelDims[i]);
    if (dimIndex >= 0) {
      vals.push(interpolatedValue[dimIndex]);
    }
  }
  return vals.join(" ");
}
var Symbol$1 = function(_super) {
  __extends(Symbol2, _super);
  function Symbol2(data, idx, seriesScope, opts) {
    var _this = _super.call(this) || this;
    _this.updateData(data, idx, seriesScope, opts);
    return _this;
  }
  Symbol2.prototype._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
    this.removeAll();
    var symbolPath = createSymbol$1(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    });
    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  Symbol2.prototype.stopSymbolAnimation = function(toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  };
  Symbol2.prototype.getSymbolType = function() {
    return this._symbolType;
  };
  Symbol2.prototype.getSymbolPath = function() {
    return this.childAt(0);
  };
  Symbol2.prototype.highlight = function() {
    enterEmphasis(this.childAt(0));
  };
  Symbol2.prototype.downplay = function() {
    leaveEmphasis(this.childAt(0));
  };
  Symbol2.prototype.setZ = function(zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  };
  Symbol2.prototype.setDraggable = function(draggable) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = draggable ? "move" : symbolPath.cursor;
  };
  Symbol2.prototype.updateData = function(data, idx, seriesScope, opts) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, "symbol") || "circle";
    var seriesModel = data.hostModel;
    var symbolSize = Symbol2.getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;
    var disableAnimation = opts && opts.disableAnimation;
    if (isInit) {
      var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      var target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : updateProps$1(symbolPath, target, seriesModel, idx);
      saveOldStyle(symbolPath);
    }
    this._updateCommon(data, idx, symbolSize, seriesScope, opts);
    if (isInit) {
      var symbolPath = this.childAt(0);
      if (!disableAnimation) {
        var target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        initProps(symbolPath, target, seriesModel, idx);
      }
    }
    if (disableAnimation) {
      this.childAt(0).stopAnimation("leave");
    }
    this._seriesModel = seriesModel;
  };
  Symbol2.prototype._updateCommon = function(data, idx, symbolSize, seriesScope, opts) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var emphasisItemStyle;
    var blurItemStyle;
    var selectItemStyle;
    var focus;
    var blurScope;
    var emphasisDisabled;
    var labelStatesModels;
    var hoverScale;
    var cursorStyle;
    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
      emphasisDisabled = seriesScope.emphasisDisabled;
    }
    if (!seriesScope || data.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
      blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      emphasisDisabled = emphasisModel.get("disabled");
      labelStatesModels = getLabelStatesModels(itemModel);
      hoverScale = emphasisModel.getShallow("scale");
      cursorStyle = itemModel.getShallow("cursor");
    }
    var symbolRotate = data.getItemVisual(idx, "symbolRotate");
    symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
    var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      symbolPath.x = symbolOffset[0];
      symbolPath.y = symbolOffset[1];
    }
    cursorStyle && symbolPath.attr("cursor", cursorStyle);
    var symbolStyle = data.getItemVisual(idx, "style");
    var visualColor = symbolStyle.fill;
    if (symbolPath instanceof ZRImage$1) {
      var pathStyle = symbolPath.style;
      symbolPath.useStyle(extend$1({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        symbolPath.useStyle(extend$1({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      }
      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }
    var liftZ = data.getItemVisual(idx, "liftZ");
    var z2Origin = this._z2;
    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }
    var useNameLabel = opts && opts.useNameLabel;
    setLabelStyle(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    });
    function getLabelDefaultText(idx2) {
      return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
    }
    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    var emphasisState = symbolPath.ensureState("emphasis");
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState("select").style = selectItemStyle;
    symbolPath.ensureState("blur").style = blurItemStyle;
    if (hoverScale) {
      var scaleRatio = Math.max(1.1, 3 / this._sizeY);
      emphasisState.scaleX = this._sizeX * scaleRatio;
      emphasisState.scaleY = this._sizeY * scaleRatio;
    }
    this.setSymbolScale(1);
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };
  Symbol2.prototype.setSymbolScale = function(scale2) {
    this.scaleX = this.scaleY = scale2;
  };
  Symbol2.prototype.fadeOut = function(cb, opt) {
    var symbolPath = this.childAt(0);
    var seriesModel = this._seriesModel;
    var dataIndex = getECData(this).dataIndex;
    var animationOpt = opt && opt.animation;
    this.silent = symbolPath.silent = true;
    if (opt && opt.fadeLabel) {
      var textContent = symbolPath.getTextContent();
      if (textContent) {
        removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex,
          removeOpt: animationOpt,
          cb: function() {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }
    removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {
      dataIndex,
      cb,
      removeOpt: animationOpt
    });
  };
  Symbol2.getSymbolSize = function(data, idx) {
    return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
  };
  return Symbol2;
}(Group$4);
function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}
var SymbolClz = Symbol$1;
function symbolNeedsDraw$1(data, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
}
function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject$3(opt)) {
    opt = {
      isIgnore: opt
    };
  }
  return opt || {};
}
function makeSeriesScope$2(data) {
  var seriesModel = data.hostModel;
  var emphasisModel = seriesModel.getModel("emphasis");
  return {
    emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
    blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: emphasisModel.get("focus"),
    blurScope: emphasisModel.get("blurScope"),
    emphasisDisabled: emphasisModel.get("disabled"),
    hoverScale: emphasisModel.get("scale"),
    labelStatesModels: getLabelStatesModels(seriesModel),
    cursorStyle: seriesModel.get("cursor")
  };
}
var SymbolDraw = function() {
  function SymbolDraw2(SymbolCtor) {
    this.group = new Group$4();
    this._SymbolCtor = SymbolCtor || SymbolClz;
  }
  SymbolDraw2.prototype.updateData = function(data, opt) {
    this._progressiveEls = null;
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._SymbolCtor;
    var disableAnimation = opt.disableAnimation;
    var seriesScope = makeSeriesScope$2(data);
    var symbolUpdateOpt = {
      disableAnimation
    };
    var getSymbolPoint = opt.getSymbolPoint || function(idx) {
      return data.getItemLayout(idx);
    };
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      var point = getSymbolPoint(newIdx);
      if (symbolNeedsDraw$1(data, point, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = getSymbolPoint(newIdx);
      if (!symbolNeedsDraw$1(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }
      var newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
      var oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
      if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
        group.remove(symbolEl);
        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
        var target = {
          x: point[0],
          y: point[1]
        };
        disableAnimation ? symbolEl.attr(target) : updateProps$1(symbolEl, target, seriesModel);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function() {
        group.remove(el);
      });
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data;
  };
  SymbolDraw2.prototype.updateLayout = function() {
    var _this = this;
    var data = this._data;
    if (data) {
      data.eachItemGraphicEl(function(el, idx) {
        var point = _this._getSymbolPoint(idx);
        el.setPosition(point);
        el.markRedraw();
      });
    }
  };
  SymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
    this._seriesScope = makeSeriesScope$2(data);
    this._data = null;
    this.group.removeAll();
  };
  SymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
    this._progressiveEls = [];
    opt = normalizeUpdateOpt(opt);
    function updateIncrementalAndHover(el2) {
      if (!el2.isGroup) {
        el2.incremental = true;
        el2.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var point = data.getItemLayout(idx);
      if (symbolNeedsDraw$1(data, point, idx, opt)) {
        var el = new this._SymbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.setPosition(point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  };
  SymbolDraw2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  SymbolDraw2.prototype.remove = function(enableAnimation) {
    var group = this.group;
    var data = this._data;
    if (data && enableAnimation) {
      data.eachItemGraphicEl(function(el) {
        el.fadeOut(function() {
          group.remove(el);
        });
      });
    } else {
      group.removeAll();
    }
  };
  return SymbolDraw2;
}();
var SymbolDraw$1 = SymbolDraw;
function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  var baseAxis = coordSys.getBaseAxis();
  var valueAxis2 = coordSys.getOtherAxis(baseAxis);
  var valueStart = getValueStart(valueAxis2, valueOrigin);
  var baseAxisDim = baseAxis.dim;
  var valueAxisDim = valueAxis2.dim;
  var valueDim = data.mapDimension(valueAxisDim);
  var baseDim = data.mapDimension(baseAxisDim);
  var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
  var dims = map$1(coordSys.dimensions, function(coordDim) {
    return data.mapDimension(coordDim);
  });
  var stacked = false;
  var stackResultDim = data.getCalculationInfo("stackResultDimension");
  if (isDimensionStacked$2(data, dims[0])) {
    stacked = true;
    dims[0] = stackResultDim;
  }
  if (isDimensionStacked$2(data, dims[1])) {
    stacked = true;
    dims[1] = stackResultDim;
  }
  return {
    dataDimsForPoint: dims,
    valueStart,
    valueAxisDim,
    baseAxisDim,
    stacked: !!stacked,
    valueDim,
    baseDim,
    baseDataOffset,
    stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(valueAxis2, valueOrigin) {
  var valueStart = 0;
  var extent3 = valueAxis2.scale.getExtent();
  if (valueOrigin === "start") {
    valueStart = extent3[0];
  } else if (valueOrigin === "end") {
    valueStart = extent3[1];
  } else {
    if (extent3[0] > 0) {
      valueStart = extent3[0];
    } else if (extent3[1] < 0) {
      valueStart = extent3[1];
    }
  }
  return valueStart;
}
function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  var value = NaN;
  if (dataCoordInfo.stacked) {
    value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
  }
  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }
  var baseDataOffset = dataCoordInfo.baseDataOffset;
  var stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}
function diffData(oldData, newData) {
  var diffResult = [];
  newData.diff(oldData).add(function(idx) {
    diffResult.push({
      cmd: "+",
      idx
    });
  }).update(function(newIdx, oldIdx) {
    diffResult.push({
      cmd: "=",
      idx: oldIdx,
      idx1: newIdx
    });
  }).remove(function(idx) {
    diffResult.push({
      cmd: "-",
      idx
    });
  }).execute();
  return diffResult;
}
function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  var diff = diffData(oldData, newData);
  var currPoints = [];
  var nextPoints = [];
  var currStackedPoints = [];
  var nextStackedPoints = [];
  var status = [];
  var sortedIndices = [];
  var rawIndices = [];
  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
  var oldPoints = oldData.getLayout("points") || [];
  var newPoints = newData.getLayout("points") || [];
  for (var i = 0; i < diff.length; i++) {
    var diffItem = diff[i];
    var pointAdded = true;
    var oldIdx2 = void 0;
    var newIdx2 = void 0;
    switch (diffItem.cmd) {
      case "=":
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        var currentX = oldPoints[oldIdx2];
        var currentY = oldPoints[oldIdx2 + 1];
        var nextX = newPoints[newIdx2];
        var nextY = newPoints[newIdx2 + 1];
        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }
        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;
      case "+":
        var newIdx = diffItem.idx;
        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;
      case "-":
        pointAdded = false;
    }
    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  }
  sortedIndices.sort(function(a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  var len2 = currPoints.length;
  var sortedCurrPoints = createFloat32Array(len2);
  var sortedNextPoints = createFloat32Array(len2);
  var sortedCurrStackedPoints = createFloat32Array(len2);
  var sortedNextStackedPoints = createFloat32Array(len2);
  var sortedStatus = [];
  for (var i = 0; i < sortedIndices.length; i++) {
    var idx = sortedIndices[i];
    var i2 = i * 2;
    var idx2 = idx * 2;
    sortedCurrPoints[i2] = currPoints[idx2];
    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i2] = nextPoints[idx2];
    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i] = status[idx];
  }
  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}
var mathMin$6 = Math.min;
var mathMax$6 = Math.max;
function isPointNull$1(x, y) {
  return isNaN(x) || isNaN(y);
}
function drawSegment(ctx, points2, start2, segLen, allLen, dir3, smooth, smoothMonotone, connectNulls) {
  var prevX;
  var prevY;
  var cpx0;
  var cpy0;
  var cpx1;
  var cpy1;
  var idx = start2;
  var k = 0;
  for (; k < segLen; k++) {
    var x = points2[idx * 2];
    var y = points2[idx * 2 + 1];
    if (idx >= allLen || idx < 0) {
      break;
    }
    if (isPointNull$1(x, y)) {
      if (connectNulls) {
        idx += dir3;
        continue;
      }
      break;
    }
    if (idx === start2) {
      ctx[dir3 > 0 ? "moveTo" : "lineTo"](x, y);
      cpx0 = x;
      cpy0 = y;
    } else {
      var dx = x - prevX;
      var dy = y - prevY;
      if (dx * dx + dy * dy < 0.5) {
        idx += dir3;
        continue;
      }
      if (smooth > 0) {
        var nextIdx = idx + dir3;
        var nextX = points2[nextIdx * 2];
        var nextY = points2[nextIdx * 2 + 1];
        while (nextX === x && nextY === y && k < segLen) {
          k++;
          nextIdx += dir3;
          idx += dir3;
          nextX = points2[nextIdx * 2];
          nextY = points2[nextIdx * 2 + 1];
          x = points2[idx * 2];
          y = points2[idx * 2 + 1];
          dx = x - prevX;
          dy = y - prevY;
        }
        var tmpK = k + 1;
        if (connectNulls) {
          while (isPointNull$1(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir3;
            nextX = points2[nextIdx * 2];
            nextY = points2[nextIdx * 2 + 1];
          }
        }
        var ratioNextSeg = 0.5;
        var vx = 0;
        var vy = 0;
        var nextCpx0 = void 0;
        var nextCpy0 = void 0;
        if (tmpK >= segLen || isPointNull$1(nextX, nextY)) {
          cpx1 = x;
          cpy1 = y;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          var dx0 = x - prevX;
          var dx1 = nextX - x;
          var dy0 = y - prevY;
          var dy1 = nextY - y;
          var lenPrevSeg = void 0;
          var lenNextSeg = void 0;
          if (smoothMonotone === "x") {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            var dir_1 = vx > 0 ? 1 : -1;
            cpx1 = x - dir_1 * lenPrevSeg * smooth;
            cpy1 = y;
            nextCpx0 = x + dir_1 * lenNextSeg * smooth;
            nextCpy0 = y;
          } else if (smoothMonotone === "y") {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            var dir_2 = vy > 0 ? 1 : -1;
            cpx1 = x;
            cpy1 = y - dir_2 * lenPrevSeg * smooth;
            nextCpx0 = x;
            nextCpy0 = y + dir_2 * lenNextSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y - vy * smooth * (1 - ratioNextSeg);
            nextCpx0 = x + vx * smooth * ratioNextSeg;
            nextCpy0 = y + vy * smooth * ratioNextSeg;
            nextCpx0 = mathMin$6(nextCpx0, mathMax$6(nextX, x));
            nextCpy0 = mathMin$6(nextCpy0, mathMax$6(nextY, y));
            nextCpx0 = mathMax$6(nextCpx0, mathMin$6(nextX, x));
            nextCpy0 = mathMax$6(nextCpy0, mathMin$6(nextY, y));
            vx = nextCpx0 - x;
            vy = nextCpy0 - y;
            cpx1 = x - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y - vy * lenPrevSeg / lenNextSeg;
            cpx1 = mathMin$6(cpx1, mathMax$6(prevX, x));
            cpy1 = mathMin$6(cpy1, mathMax$6(prevY, y));
            cpx1 = mathMax$6(cpx1, mathMin$6(prevX, x));
            cpy1 = mathMax$6(cpy1, mathMin$6(prevY, y));
            vx = x - cpx1;
            vy = y - cpy1;
            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
          }
        }
        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x, y);
      }
    }
    prevX = x;
    prevY = y;
    idx += dir3;
  }
  return k;
}
var ECPolylineShape = function() {
  function ECPolylineShape2() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }
  return ECPolylineShape2;
}();
var ECPolyline = function(_super) {
  __extends(ECPolyline2, _super);
  function ECPolyline2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polyline";
    return _this;
  }
  ECPolyline2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  ECPolyline2.prototype.getDefaultShape = function() {
    return new ECPolylineShape();
  };
  ECPolyline2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var i = 0;
    var len2 = points2.length / 2;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull$1(points2[i * 2], points2[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      i += drawSegment(ctx, points2, i, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  };
  ECPolyline2.prototype.getPointOn = function(xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }
    var path = this.path;
    var data = path.data;
    var CMD2 = PathProxy$1.CMD;
    var x0;
    var y0;
    var isDimX = dim === "x";
    var roots2 = [];
    for (var i = 0; i < data.length; ) {
      var cmd = data[i++];
      var x = void 0;
      var y = void 0;
      var x2 = void 0;
      var y2 = void 0;
      var x3 = void 0;
      var y3 = void 0;
      var t = void 0;
      switch (cmd) {
        case CMD2.M:
          x0 = data[i++];
          y0 = data[i++];
          break;
        case CMD2.L:
          x = data[i++];
          y = data[i++];
          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);
          if (t <= 1 && t >= 0) {
            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
            return isDimX ? [xOrY, val] : [val, xOrY];
          }
          x0 = x;
          y0 = y;
          break;
        case CMD2.C:
          x = data[i++];
          y = data[i++];
          x2 = data[i++];
          y2 = data[i++];
          x3 = data[i++];
          y3 = data[i++];
          var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots2) : cubicRootAt(y0, y, y2, y3, xOrY, roots2);
          if (nRoot > 0) {
            for (var i_1 = 0; i_1 < nRoot; i_1++) {
              var t_1 = roots2[i_1];
              if (t_1 <= 1 && t_1 >= 0) {
                var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
            }
          }
          x0 = x3;
          y0 = y3;
          break;
      }
    }
  };
  return ECPolyline2;
}(Path$1);
var ECPolygonShape = function(_super) {
  __extends(ECPolygonShape2, _super);
  function ECPolygonShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return ECPolygonShape2;
}(ECPolylineShape);
var ECPolygon = function(_super) {
  __extends(ECPolygon2, _super);
  function ECPolygon2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-polygon";
    return _this;
  }
  ECPolygon2.prototype.getDefaultShape = function() {
    return new ECPolygonShape();
  };
  ECPolygon2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var stackedOnPoints = shape.stackedOnPoints;
    var i = 0;
    var len2 = points2.length / 2;
    var smoothMonotone = shape.smoothMonotone;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull$1(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull$1(points2[i * 2], points2[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      var k = drawSegment(ctx, points2, i, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  };
  return ECPolygon2;
}(Path$1);
function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
  var rect = cartesian.getArea();
  var x = rect.x;
  var y = rect.y;
  var width = rect.width;
  var height = rect.height;
  var lineWidth = seriesModel.get(["lineStyle", "width"]) || 2;
  x -= lineWidth / 2;
  y -= lineWidth / 2;
  width += lineWidth;
  height += lineWidth;
  x = Math.floor(x);
  width = Math.round(width);
  var clipPath = new Rect$3({
    shape: {
      x,
      y,
      width,
      height
    }
  });
  if (hasAnimation) {
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var isAxisInversed = baseAxis.inverse;
    if (isHorizontal) {
      if (isAxisInversed) {
        clipPath.shape.x += width;
      }
      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height;
      }
      clipPath.shape.height = 0;
    }
    var duringCb = isFunction$1(during) ? function(percent) {
      during(percent, clipPath);
    } : null;
    initProps(clipPath, {
      shape: {
        width,
        height,
        x,
        y
      }
    }, seriesModel, null, done, duringCb);
  }
  return clipPath;
}
function createPolarClipPath(polar, hasAnimation, seriesModel) {
  var sectorArea = polar.getArea();
  var r0 = round$3(sectorArea.r0, 1);
  var r = round$3(sectorArea.r, 1);
  var clipPath = new Sector$1({
    shape: {
      cx: round$3(polar.cx, 1),
      cy: round$3(polar.cy, 1),
      r0,
      r,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });
  if (hasAnimation) {
    var isRadial = polar.getBaseAxis().dim === "angle";
    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }
    initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r
      }
    }, seriesModel);
  }
  return clipPath;
}
function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === "polar") {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === "cartesian2d") {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }
  return null;
}
function isCoordinateSystemType(coordSys, type) {
  return coordSys.type === type;
}
function isPointsSame(points1, points2) {
  if (points1.length !== points2.length) {
    return;
  }
  for (var i = 0; i < points1.length; i++) {
    if (points1[i] !== points2[i]) {
      return;
    }
  }
  return true;
}
function bboxFromPoints(points2) {
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;
  for (var i = 0; i < points2.length; ) {
    var x = points2[i++];
    var y = points2[i++];
    if (!isNaN(x)) {
      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
    }
    if (!isNaN(y)) {
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
  }
  return [[minX, minY], [maxX, maxY]];
}
function getBoundingDiff(points1, points2) {
  var _a2 = bboxFromPoints(points1), min1 = _a2[0], max1 = _a2[1];
  var _b2 = bboxFromPoints(points2), min22 = _b2[0], max22 = _b2[1];
  return Math.max(Math.abs(min1[0] - min22[0]), Math.abs(min1[1] - min22[1]), Math.abs(max1[0] - max22[0]), Math.abs(max1[1] - max22[1]));
}
function getSmooth(smooth) {
  return isNumber(smooth) ? smooth : smooth ? 0.5 : 0;
}
function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }
  var len2 = data.count();
  var points2 = createFloat32Array(len2 * 2);
  for (var idx = 0; idx < len2; idx++) {
    var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
    points2[idx * 2] = pt[0];
    points2[idx * 2 + 1] = pt[1];
  }
  return points2;
}
function turnPointsIntoStep(points2, coordSys, stepTurnAt) {
  var baseAxis = coordSys.getBaseAxis();
  var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
  var stepPoints = [];
  var i = 0;
  var stepPt = [];
  var pt = [];
  var nextPt = [];
  for (; i < points2.length - 2; i += 2) {
    nextPt[0] = points2[i + 2];
    nextPt[1] = points2[i + 3];
    pt[0] = points2[i];
    pt[1] = points2[i + 1];
    stepPoints.push(pt[0], pt[1]);
    switch (stepTurnAt) {
      case "end":
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;
      case "middle":
        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        var stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;
      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  }
  stepPoints.push(points2[i++], points2[i++]);
  return stepPoints;
}
function clipColorStops(colorStops, maxSize) {
  var newColorStops = [];
  var len2 = colorStops.length;
  var prevOutOfRangeColorStop;
  var prevInRangeColorStop;
  function lerpStop(stop0, stop1, clippedCoord) {
    var coord02 = stop0.coord;
    var p = (clippedCoord - coord02) / (stop1.coord - coord02);
    var color = lerp(p, [stop0.color, stop1.color]);
    return {
      coord: clippedCoord,
      color
    };
  }
  for (var i = 0; i < len2; i++) {
    var stop_1 = colorStops[i];
    var coord = stop_1.coord;
    if (coord < 0) {
      prevOutOfRangeColorStop = stop_1;
    } else if (coord > maxSize) {
      if (prevInRangeColorStop) {
        newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize));
      } else if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize));
      }
      break;
    } else {
      if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0));
        prevOutOfRangeColorStop = null;
      }
      newColorStops.push(stop_1);
      prevInRangeColorStop = stop_1;
    }
  }
  return newColorStops;
}
function getVisualGradient(data, coordSys, api) {
  var visualMetaList = data.getVisual("visualMeta");
  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    return;
  }
  if (coordSys.type !== "cartesian2d") {
    return;
  }
  var coordDim;
  var visualMeta;
  for (var i = visualMetaList.length - 1; i >= 0; i--) {
    var dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);
    coordDim = dimInfo && dimInfo.coordDim;
    if (coordDim === "x" || coordDim === "y") {
      visualMeta = visualMetaList[i];
      break;
    }
  }
  if (!visualMeta) {
    return;
  }
  var axis = coordSys.getAxis(coordDim);
  var colorStops = map$1(visualMeta.stops, function(stop2) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
      color: stop2.color
    };
  });
  var stopLen = colorStops.length;
  var outerColors = visualMeta.outerColors.slice();
  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }
  var colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api.getWidth() : api.getHeight());
  var inRangeStopLen = colorStopsInRange.length;
  if (!inRangeStopLen && stopLen) {
    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
  }
  var tinyExtent = 10;
  var minCoord = colorStopsInRange[0].coord - tinyExtent;
  var maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
  var coordSpan = maxCoord - minCoord;
  if (coordSpan < 1e-3) {
    return "transparent";
  }
  each$f(colorStopsInRange, function(stop2) {
    stop2.offset = (stop2.coord - minCoord) / coordSpan;
  });
  colorStopsInRange.push({
    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
    color: outerColors[1] || "transparent"
  });
  colorStopsInRange.unshift({
    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
    color: outerColors[0] || "transparent"
  });
  var gradient = new LinearGradient$1(0, 0, 0, 0, colorStopsInRange, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + "2"] = maxCoord;
  return gradient;
}
function getIsIgnoreFunc(seriesModel, data, coordSys) {
  var showAllSymbol = seriesModel.get("showAllSymbol");
  var isAuto = showAllSymbol === "auto";
  if (showAllSymbol && !isAuto) {
    return;
  }
  var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
  if (!categoryAxis2) {
    return;
  }
  if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data)) {
    return;
  }
  var categoryDataDim = data.mapDimension(categoryAxis2.dim);
  var labelMap = {};
  each$f(categoryAxis2.getViewLabels(), function(labelItem) {
    var ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function(dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}
function canShowAllSymbolForCategory(categoryAxis2, data) {
  var axisExtent = categoryAxis2.getExtent();
  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
  isNaN(availSize) && (availSize = 0);
  var dataLen = data.count();
  var step = Math.max(1, Math.round(dataLen / 5));
  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (SymbolClz.getSymbolSize(data, dataIndex)[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
      return false;
    }
  }
  return true;
}
function isPointNull(x, y) {
  return isNaN(x) || isNaN(y);
}
function getLastIndexNotNull(points2) {
  var len2 = points2.length / 2;
  for (; len2 > 0; len2--) {
    if (!isPointNull(points2[len2 * 2 - 2], points2[len2 * 2 - 1])) {
      break;
    }
  }
  return len2 - 1;
}
function getPointAtIndex(points2, idx) {
  return [points2[idx * 2], points2[idx * 2 + 1]];
}
function getIndexRange(points2, xOrY, dim) {
  var len2 = points2.length / 2;
  var dimIdx = dim === "x" ? 0 : 1;
  var a;
  var b;
  var prevIndex = 0;
  var nextIndex = -1;
  for (var i = 0; i < len2; i++) {
    b = points2[i * 2 + dimIdx];
    if (isNaN(b) || isNaN(points2[i * 2 + 1 - dimIdx])) {
      continue;
    }
    if (i === 0) {
      a = b;
      continue;
    }
    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
      nextIndex = i;
      break;
    }
    prevIndex = i;
    a = b;
  }
  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a) / (b - a)
  };
}
function anyStateShowEndLabel(seriesModel) {
  if (seriesModel.get(["endLabel", "show"])) {
    return true;
  }
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    if (seriesModel.get([SPECIAL_STATES[i], "endLabel", "show"])) {
      return true;
    }
  }
  return false;
}
function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    var endLabelModel_1 = seriesModel.getModel("endLabel");
    var valueAnimation_1 = endLabelModel_1.get("valueAnimation");
    var data_1 = seriesModel.getData();
    var labelAnimationRecord_1 = {
      lastFrameIndex: 0
    };
    var during = anyStateShowEndLabel(seriesModel) ? function(percent, clipRect) {
      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
    } : null;
    var isHorizontal = coordSys.getBaseAxis().isHorizontal();
    var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function() {
      var endLabel = lineView._endLabel;
      if (endLabel && hasAnimation) {
        if (labelAnimationRecord_1.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord_1.originalX,
            y: labelAnimationRecord_1.originalY
          });
        }
      }
    }, during);
    if (!seriesModel.get("clip", true)) {
      var rectShape = clipPath.shape;
      var expandSize = Math.max(rectShape.width, rectShape.height);
      if (isHorizontal) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    }
    if (during) {
      during(1, clipPath);
    }
    return clipPath;
  } else {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  }
}
function getEndLabelStateSpecified(endLabelModel, coordSys) {
  var baseAxis = coordSys.getBaseAxis();
  var isHorizontal = baseAxis.isHorizontal();
  var isBaseInversed = baseAxis.inverse;
  var align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
  var verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
  return {
    normal: {
      align: endLabelModel.get("align") || align,
      verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
    }
  };
}
var LineView = function(_super) {
  __extends(LineView2, _super);
  function LineView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LineView2.prototype.init = function() {
    var lineGroup = new Group$4();
    var symbolDraw = new SymbolDraw$1();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  };
  LineView2.prototype.render = function(seriesModel, ecModel, api) {
    var _this = this;
    var coordSys = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var lineStyleModel = seriesModel.getModel("lineStyle");
    var areaStyleModel = seriesModel.getModel("areaStyle");
    var points2 = data.getLayout("points") || [];
    var isCoordSysPolar = coordSys.type === "polar";
    var prevCoordSys = this._coordSys;
    var symbolDraw = this._symbolDraw;
    var polyline = this._polyline;
    var polygon = this._polygon;
    var lineGroup = this._lineGroup;
    var hasAnimation = seriesModel.get("animation");
    var isAreaChart = !areaStyleModel.isEmpty();
    var valueOrigin = areaStyleModel.get("origin");
    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
    var showSymbol = seriesModel.get("showSymbol");
    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
    var oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    if (!showSymbol) {
      symbolDraw.remove();
    }
    group.add(lineGroup);
    var step = !isCoordSysPolar ? seriesModel.get("step") : false;
    var clipShapeForSymbol;
    if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
      clipShapeForSymbol = coordSys.getArea();
      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }
    this._clipShapeForSymbol = clipShapeForSymbol;
    var visualColor = getVisualGradient(data, coordSys, api) || data.getVisual("style")[data.getVisual("drawType")];
    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
      if (step) {
        points2 = turnPointsIntoStep(points2, coordSys, step);
        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
        }
      }
      polyline = this._newPolyline(points2);
      if (isAreaChart) {
        polygon = this._newPolygon(points2, stackedOnPoints);
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        polygon = this._newPolygon(points2, stackedOnPoints);
      } else if (polygon && !isAreaChart) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      var oldClipPath = lineGroup.getClipPath();
      if (oldClipPath) {
        var newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
        initProps(oldClipPath, {
          shape: newClipPath.shape
        }, seriesModel);
      } else {
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      }
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint: function(idx) {
          return [points2[idx * 2], points2[idx * 2 + 1]];
        }
      });
      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points2)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
        } else {
          if (step) {
            points2 = turnPointsIntoStep(points2, coordSys, step);
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
            }
          }
          polyline.setShape({
            points: points2
          });
          polygon && polygon.setShape({
            points: points2,
            stackedOnPoints
          });
        }
      }
    }
    var emphasisModel = seriesModel.getModel("emphasis");
    var focus = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var emphasisDisabled = emphasisModel.get("disabled");
    polyline.useStyle(defaults(lineStyleModel.getLineStyle(), {
      fill: "none",
      stroke: visualColor,
      lineJoin: "bevel"
    }));
    setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
    if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
      var emphasisLineStyle = polyline.getState("emphasis").style;
      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
    }
    getECData(polyline).seriesIndex = seriesModel.seriesIndex;
    toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
    var smooth = getSmooth(seriesModel.get("smooth"));
    var smoothMonotone = seriesModel.get("smoothMonotone");
    var connectNulls = seriesModel.get("connectNulls");
    polyline.setShape({
      smooth,
      smoothMonotone,
      connectNulls
    });
    if (polygon) {
      var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
      var stackedOnSmooth = 0;
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: "bevel",
        decal: data.getVisual("style").decal
      }));
      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
      }
      polygon.setShape({
        smooth,
        stackedOnSmooth,
        smoothMonotone,
        connectNulls
      });
      setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
      getECData(polygon).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
    }
    var changePolyState = function(toState) {
      _this._changePolyState(toState);
    };
    data.eachItemGraphicEl(function(el) {
      el && (el.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data;
    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points2;
    this._step = step;
    this._valueOrigin = valueOrigin;
    if (seriesModel.get("triggerLineEvent")) {
      this.packEventData(seriesModel, polyline);
      polygon && this.packEventData(seriesModel, polygon);
    }
  };
  LineView2.prototype.packEventData = function(seriesModel, el) {
    getECData(el).eventData = {
      componentType: "series",
      componentSubType: "line",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: "line"
    };
  };
  LineView2.prototype.highlight = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);
    this._changePolyState("emphasis");
    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      var points2 = data.getLayout("points");
      var symbol = data.getItemGraphicEl(dataIndex);
      if (!symbol) {
        var x = points2[dataIndex * 2];
        var y = points2[dataIndex * 2 + 1];
        if (isNaN(x) || isNaN(y)) {
          return;
        }
        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
          return;
        }
        var zlevel = seriesModel.get("zlevel");
        var z = seriesModel.get("z");
        symbol = new SymbolClz(data, dataIndex);
        symbol.x = x;
        symbol.y = y;
        symbol.setZ(zlevel, z);
        var symbolLabel = symbol.getSymbolPath().getTextContent();
        if (symbolLabel) {
          symbolLabel.zlevel = zlevel;
          symbolLabel.z = z;
          symbolLabel.z2 = this._polyline.z2 + 1;
        }
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol);
        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }
      symbol.highlight();
    } else {
      ChartView$1.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype.downplay = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = queryDataIndex(data, payload);
    this._changePolyState("normal");
    if (dataIndex != null && dataIndex >= 0) {
      var symbol = data.getItemGraphicEl(dataIndex);
      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      ChartView$1.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
    }
  };
  LineView2.prototype._changePolyState = function(toState) {
    var polygon = this._polygon;
    setStatesFlag(this._polyline, toState);
    polygon && setStatesFlag(polygon, toState);
  };
  LineView2.prototype._newPolyline = function(points2) {
    var polyline = this._polyline;
    if (polyline) {
      this._lineGroup.remove(polyline);
    }
    polyline = new ECPolyline({
      shape: {
        points: points2
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });
    this._lineGroup.add(polyline);
    this._polyline = polyline;
    return polyline;
  };
  LineView2.prototype._newPolygon = function(points2, stackedOnPoints) {
    var polygon = this._polygon;
    if (polygon) {
      this._lineGroup.remove(polygon);
    }
    polygon = new ECPolygon({
      shape: {
        points: points2,
        stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });
    this._lineGroup.add(polygon);
    this._polygon = polygon;
    return polygon;
  };
  LineView2.prototype._initSymbolLabelAnimation = function(data, coordSys, clipShape) {
    var isHorizontalOrRadial;
    var isCoordSysPolar;
    var baseAxis = coordSys.getBaseAxis();
    var isAxisInverse = baseAxis.inverse;
    if (coordSys.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
      isCoordSysPolar = true;
    }
    var seriesModel = data.hostModel;
    var seriesDuration = seriesModel.get("animationDuration");
    if (isFunction$1(seriesDuration)) {
      seriesDuration = seriesDuration(null);
    }
    var seriesDalay = seriesModel.get("animationDelay") || 0;
    var seriesDalayValue = isFunction$1(seriesDalay) ? seriesDalay(null) : seriesDalay;
    data.eachItemGraphicEl(function(symbol, idx) {
      var el = symbol;
      if (el) {
        var point = [symbol.x, symbol.y];
        var start2 = void 0;
        var end2 = void 0;
        var current = void 0;
        if (clipShape) {
          if (isCoordSysPolar) {
            var polarClip = clipShape;
            var coord = coordSys.pointToCoord(point);
            if (isHorizontalOrRadial) {
              start2 = polarClip.startAngle;
              end2 = polarClip.endAngle;
              current = -coord[1] / 180 * Math.PI;
            } else {
              start2 = polarClip.r0;
              end2 = polarClip.r;
              current = coord[0];
            }
          } else {
            var gridClip = clipShape;
            if (isHorizontalOrRadial) {
              start2 = gridClip.x;
              end2 = gridClip.x + gridClip.width;
              current = symbol.x;
            } else {
              start2 = gridClip.y + gridClip.height;
              end2 = gridClip.y;
              current = symbol.y;
            }
          }
        }
        var ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
        if (isAxisInverse) {
          ratio = 1 - ratio;
        }
        var delay = isFunction$1(seriesDalay) ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;
        var symbolPath = el.getSymbolPath();
        var text = symbolPath.getTextContent();
        el.attr({
          scaleX: 0,
          scaleY: 0
        });
        el.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          setToFinal: true,
          delay
        });
        if (text) {
          text.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay
          });
        }
        symbolPath.disableLabelAnimation = true;
      }
    });
  };
  LineView2.prototype._initOrUpdateEndLabel = function(seriesModel, coordSys, inheritColor) {
    var endLabelModel = seriesModel.getModel("endLabel");
    if (anyStateShowEndLabel(seriesModel)) {
      var data_2 = seriesModel.getData();
      var polyline = this._polyline;
      var points2 = data_2.getLayout("points");
      if (!points2) {
        polyline.removeTextContent();
        this._endLabel = null;
        return;
      }
      var endLabel = this._endLabel;
      if (!endLabel) {
        endLabel = this._endLabel = new ZRText$1({
          z2: 200
        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      }
      var dataIndex = getLastIndexNotNull(points2);
      if (dataIndex >= 0) {
        setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
          inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText: function(dataIndex2, opt, interpolatedValue) {
            return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex2);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();
      this._endLabel = null;
    }
  };
  LineView2.prototype._endLabelOnDuring = function(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
    var endLabel = this._endLabel;
    var polyline = this._polyline;
    if (endLabel) {
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }
      var points2 = data.getLayout("points");
      var seriesModel = data.hostModel;
      var connectNulls = seriesModel.get("connectNulls");
      var precision = endLabelModel.get("precision");
      var distance2 = endLabelModel.get("distance") || 0;
      var baseAxis = coordSys.getBaseAxis();
      var isHorizontal = baseAxis.isHorizontal();
      var isBaseInversed = baseAxis.inverse;
      var clipShape = clipRect.shape;
      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
      var distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
      var distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
      var dim = isHorizontal ? "x" : "y";
      var dataIndexRange = getIndexRange(points2, xOrY, dim);
      var indices = dataIndexRange.range;
      var diff = indices[1] - indices[0];
      var value = void 0;
      if (diff >= 1) {
        if (diff > 1 && !connectNulls) {
          var pt = getPointAtIndex(points2, indices[0]);
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
        } else {
          var pt = polyline.getPointOn(xOrY, dim);
          pt && endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          var startValue = seriesModel.getRawValue(indices[0]);
          var endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
        }
        animationRecord.lastFrameIndex = indices[0];
      } else {
        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        var pt = getPointAtIndex(points2, idx);
        valueAnimation && (value = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt[0] + distanceX,
          y: pt[1] + distanceY
        });
      }
      if (valueAnimation) {
        labelInner(endLabel).setLabelText(value);
      }
    }
  };
  LineView2.prototype._doUpdateAnimation = function(data, stackedOnPoints, coordSys, api, step, valueOrigin) {
    var polyline = this._polyline;
    var polygon = this._polygon;
    var seriesModel = data.hostModel;
    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin);
    var current = diff.current;
    var stackedOnCurrent = diff.stackedOnCurrent;
    var next = diff.next;
    var stackedOnNext = diff.stackedOnNext;
    if (step) {
      current = turnPointsIntoStep(diff.current, coordSys, step);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
      next = turnPointsIntoStep(diff.next, coordSys, step);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
    }
    if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
      polyline.stopAnimation();
      polyline.setShape({
        points: next
      });
      if (polygon) {
        polygon.stopAnimation();
        polygon.setShape({
          points: next,
          stackedOnPoints: stackedOnNext
        });
      }
      return;
    }
    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    var target = {
      shape: {
        points: next
      }
    };
    if (diff.current !== current) {
      target.shape.__points = diff.next;
    }
    polyline.stopAnimation();
    updateProps$1(polyline, target, seriesModel);
    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon.stopAnimation();
      updateProps$1(polygon, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
      if (polyline.shape.points !== polygon.shape.points) {
        polygon.shape.points = polyline.shape.points;
      }
    }
    var updatedDataInfo = [];
    var diffStatus = diff.status;
    for (var i = 0; i < diffStatus.length; i++) {
      var cmd = diffStatus[i].cmd;
      if (cmd === "=") {
        var el = data.getItemGraphicEl(diffStatus[i].idx1);
        if (el) {
          updatedDataInfo.push({
            el,
            ptIdx: i
          });
        }
      }
    }
    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function() {
        polygon && polygon.dirtyShape();
        var points2 = polyline.shape.__points;
        for (var i2 = 0; i2 < updatedDataInfo.length; i2++) {
          var el2 = updatedDataInfo[i2].el;
          var offset = updatedDataInfo[i2].ptIdx * 2;
          el2.x = points2[offset];
          el2.y = points2[offset + 1];
          el2.markRedraw();
        }
      });
    }
  };
  LineView2.prototype.remove = function(ecModel) {
    var group = this.group;
    var oldData = this._data;
    this._lineGroup.removeAll();
    this._symbolDraw.remove(true);
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  };
  LineView2.type = "line";
  return LineView2;
}(ChartView$1);
var LineView$1 = LineView;
function pointsLayout(seriesType2, forceStoreInTypedArray) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var pipelineContext = seriesModel.pipelineContext;
      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
      if (!coordSys) {
        return;
      }
      var dims = map$1(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      var dimLen = dims.length;
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (isDimensionStacked$2(data, dims[0])) {
        dims[0] = stackResultDim;
      }
      if (isDimensionStacked$2(data, dims[1])) {
        dims[1] = stackResultDim;
      }
      var store = data.getStore();
      var dimIdx0 = data.getDimensionIndex(dims[0]);
      var dimIdx1 = data.getDimensionIndex(dims[1]);
      return dimLen && {
        progress: function(params, data2) {
          var segCount = params.end - params.start;
          var points2 = useTypedArray && createFloat32Array(segCount * dimLen);
          var tmpIn = [];
          var tmpOut = [];
          for (var i = params.start, offset = 0; i < params.end; i++) {
            var point = void 0;
            if (dimLen === 1) {
              var x = store.get(dimIdx0, i);
              point = coordSys.dataToPoint(x, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i);
              tmpIn[1] = store.get(dimIdx1, i);
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (useTypedArray) {
              points2[offset++] = point[0];
              points2[offset++] = point[1];
            } else {
              data2.setItemLayout(i, point.slice());
            }
          }
          useTypedArray && data2.setLayout("points", points2);
        }
      };
    }
  };
}
var samplers = {
  average: function(frame) {
    var sum2 = 0;
    var count2 = 0;
    for (var i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum2 += frame[i];
        count2++;
      }
    }
    return count2 === 0 ? NaN : sum2 / count2;
  },
  sum: function(frame) {
    var sum2 = 0;
    for (var i = 0; i < frame.length; i++) {
      sum2 += frame[i] || 0;
    }
    return sum2;
  },
  max: function(frame) {
    var max3 = -Infinity;
    for (var i = 0; i < frame.length; i++) {
      frame[i] > max3 && (max3 = frame[i]);
    }
    return isFinite(max3) ? max3 : NaN;
  },
  min: function(frame) {
    var min3 = Infinity;
    for (var i = 0; i < frame.length; i++) {
      frame[i] < min3 && (min3 = frame[i]);
    }
    return isFinite(min3) ? min3 : NaN;
  },
  nearest: function(frame) {
    return frame[0];
  }
};
var indexSampler = function(frame) {
  return Math.round(frame.length / 2);
};
function dataSample(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var sampling = seriesModel.get("sampling");
      var coordSys = seriesModel.coordinateSystem;
      var count2 = data.count();
      if (count2 > 10 && coordSys.type === "cartesian2d" && sampling) {
        var baseAxis = coordSys.getBaseAxis();
        var valueAxis2 = coordSys.getOtherAxis(baseAxis);
        var extent3 = baseAxis.getExtent();
        var dpr2 = api.getDevicePixelRatio();
        var size = Math.abs(extent3[1] - extent3[0]) * (dpr2 || 1);
        var rate = Math.round(count2 / size);
        if (rate > 1) {
          if (sampling === "lttb") {
            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
          }
          var sampler = void 0;
          if (isString(sampling)) {
            sampler = samplers[sampling];
          } else if (isFunction$1(sampling)) {
            sampler = sampling;
          }
          if (sampler) {
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}
function install$14(registers) {
  registers.registerChartView(LineView$1);
  registers.registerSeriesModel(LineSeries);
  registers.registerLayout(pointsLayout("line", true));
  registers.registerVisual({
    seriesType: "line",
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
      if (lineStyle && !lineStyle.stroke) {
        lineStyle.stroke = data.getVisual("style").fill;
      }
      data.setVisual("legendLineStyle", lineStyle);
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}
var BaseBarSeriesModel = function(_super) {
  __extends(BaseBarSeriesModel2, _super);
  function BaseBarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BaseBarSeriesModel2.type;
    return _this;
  }
  BaseBarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  BaseBarSeriesModel2.prototype.getMarkerPosition = function(value) {
    var coordSys = this.coordinateSystem;
    if (coordSys && coordSys.clampData) {
      var pt = coordSys.dataToPoint(coordSys.clampData(value));
      var data = this.getData();
      var offset = data.getLayout("offset");
      var size = data.getLayout("size");
      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
      pt[offsetIndex] += offset + size / 2;
      return pt;
    }
    return [NaN, NaN];
  };
  BaseBarSeriesModel2.type = "series.__base_bar__";
  BaseBarSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    barMinHeight: 0,
    barMinAngle: 0,
    large: false,
    largeThreshold: 400,
    progressive: 3e3,
    progressiveChunkMode: "mod"
  };
  return BaseBarSeriesModel2;
}(SeriesModel$1);
SeriesModel$1.registerClass(BaseBarSeriesModel);
var BaseBarSeriesModel$1 = BaseBarSeriesModel;
var BarSeriesModel = function(_super) {
  __extends(BarSeriesModel2, _super);
  function BarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BarSeriesModel2.type;
    return _this;
  }
  BarSeriesModel2.prototype.getInitialData = function() {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get("realtimeSort", true) || null
    });
  };
  BarSeriesModel2.prototype.getProgressive = function() {
    return this.get("large") ? this.get("progressive") : false;
  };
  BarSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.get("progressiveThreshold");
    var largeThreshold = this.get("largeThreshold");
    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }
    return progressiveThreshold;
  };
  BarSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    return selectors.rect(data.getItemLayout(dataIndex));
  };
  BarSeriesModel2.type = "series.bar";
  BarSeriesModel2.dependencies = ["grid", "polar"];
  BarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
    clip: true,
    roundCap: false,
    showBackground: false,
    backgroundStyle: {
      color: "rgba(180, 180, 180, 0.2)",
      borderColor: null,
      borderWidth: 0,
      borderType: "solid",
      borderRadius: 0,
      shadowBlur: 0,
      shadowColor: null,
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    realtimeSort: false
  });
  return BarSeriesModel2;
}(BaseBarSeriesModel$1);
var BarSeries = BarSeriesModel;
var SausageShape = function() {
  function SausageShape2() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
  return SausageShape2;
}();
var SausagePath = function(_super) {
  __extends(SausagePath2, _super);
  function SausagePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "sausage";
    return _this;
  }
  SausagePath2.prototype.getDefaultShape = function() {
    return new SausageShape();
  };
  SausagePath2.prototype.buildPath = function(ctx, shape) {
    var cx = shape.cx;
    var cy = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var dr = (r - r0) * 0.5;
    var rCenter = r0 + dr;
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var PI22 = Math.PI * 2;
    var lessThanCircle = clockwise ? endAngle - startAngle < PI22 : startAngle - endAngle < PI22;
    if (!lessThanCircle) {
      startAngle = endAngle - (clockwise ? PI22 : -PI22);
    }
    var unitStartX = Math.cos(startAngle);
    var unitStartY = Math.sin(startAngle);
    var unitEndX = Math.cos(endAngle);
    var unitEndY = Math.sin(endAngle);
    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
    } else {
      ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);
    }
    ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);
    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
    if (r0 !== 0) {
      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
    }
  };
  return SausagePath2;
}(Path$1);
var Sausage = SausagePath;
function createSectorCalculateTextPosition(positionMapping, opts) {
  opts = opts || {};
  var isRoundCap = opts.isRoundCap;
  return function(out2, opts2, boundingRect) {
    var textPosition = opts2.position;
    if (!textPosition || textPosition instanceof Array) {
      return calculateTextPosition(out2, opts2, boundingRect);
    }
    var mappedSectorPosition = positionMapping(textPosition);
    var distance2 = opts2.distance != null ? opts2.distance : 5;
    var sector = this.shape;
    var cx = sector.cx;
    var cy = sector.cy;
    var r = sector.r;
    var r0 = sector.r0;
    var middleR = (r + r0) / 2;
    var startAngle = sector.startAngle;
    var endAngle = sector.endAngle;
    var middleAngle = (startAngle + endAngle) / 2;
    var extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;
    var mathCos2 = Math.cos;
    var mathSin2 = Math.sin;
    var x = cx + r * mathCos2(startAngle);
    var y = cy + r * mathSin2(startAngle);
    var textAlign = "left";
    var textVerticalAlign = "top";
    switch (mappedSectorPosition) {
      case "startArc":
        x = cx + (r0 - distance2) * mathCos2(middleAngle);
        y = cy + (r0 - distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "insideStartArc":
        x = cx + (r0 + distance2) * mathCos2(middleAngle);
        y = cy + (r0 + distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "startAngle":
        x = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, distance2 + extraDist, false);
        y = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, distance2 + extraDist, false);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideStartAngle":
        x = cx + middleR * mathCos2(startAngle) + adjustAngleDistanceX(startAngle, -distance2 + extraDist, false);
        y = cy + middleR * mathSin2(startAngle) + adjustAngleDistanceY(startAngle, -distance2 + extraDist, false);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "middle":
        x = cx + middleR * mathCos2(middleAngle);
        y = cy + middleR * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "endArc":
        x = cx + (r + distance2) * mathCos2(middleAngle);
        y = cy + (r + distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideEndArc":
        x = cx + (r - distance2) * mathCos2(middleAngle);
        y = cy + (r - distance2) * mathSin2(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "endAngle":
        x = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, distance2 + extraDist, true);
        y = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, distance2 + extraDist, true);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "insideEndAngle":
        x = cx + middleR * mathCos2(endAngle) + adjustAngleDistanceX(endAngle, -distance2 + extraDist, true);
        y = cy + middleR * mathSin2(endAngle) + adjustAngleDistanceY(endAngle, -distance2 + extraDist, true);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      default:
        return calculateTextPosition(out2, opts2, boundingRect);
    }
    out2 = out2 || {};
    out2.x = x;
    out2.y = y;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  };
}
function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
  if (isNumber(rotateType)) {
    sector.setTextConfig({
      rotation: rotateType
    });
    return;
  } else if (isArray$1(textPosition)) {
    sector.setTextConfig({
      rotation: 0
    });
    return;
  }
  var shape = sector.shape;
  var startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
  var endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
  var middleAngle = (startAngle + endAngle) / 2;
  var anchorAngle;
  var mappedSectorPosition = positionMapping(textPosition);
  switch (mappedSectorPosition) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      anchorAngle = middleAngle;
      break;
    case "startAngle":
    case "insideStartAngle":
      anchorAngle = startAngle;
      break;
    case "endAngle":
    case "insideEndAngle":
      anchorAngle = endAngle;
      break;
    default:
      sector.setTextConfig({
        rotation: 0
      });
      return;
  }
  var rotate2 = Math.PI * 1.5 - anchorAngle;
  if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
    rotate2 -= Math.PI;
  }
  sector.setTextConfig({
    rotation: rotate2
  });
}
function adjustAngleDistanceX(angle, distance2, isEnd) {
  return distance2 * Math.sin(angle) * (isEnd ? -1 : 1);
}
function adjustAngleDistanceY(angle, distance2, isEnd) {
  return distance2 * Math.cos(angle) * (isEnd ? 1 : -1);
}
var mathMax$5 = Math.max;
var mathMin$5 = Math.min;
function getClipArea(coord, data) {
  var coordSysClipArea = coord.getArea && coord.getArea();
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var baseAxis = coord.getBaseAxis();
    if (baseAxis.type !== "category" || !baseAxis.onBand) {
      var expandWidth = data.getLayout("bandWidth");
      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }
  return coordSysClipArea;
}
var BarView = function(_super) {
  __extends(BarView2, _super);
  function BarView2() {
    var _this = _super.call(this) || this;
    _this.type = BarView2.type;
    _this._isFirstFrame = true;
    return _this;
  }
  BarView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    this._model = seriesModel;
    this._removeOnRenderedListener(api);
    this._updateDrawMode(seriesModel);
    var coordinateSystemType = seriesModel.get("coordinateSystem");
    if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
      this._progressiveEls = null;
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
    }
  };
  BarView2.prototype.incrementalPrepareRender = function(seriesModel) {
    this._clear();
    this._updateDrawMode(seriesModel);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype.incrementalRender = function(params, seriesModel) {
    this._progressiveEls = [];
    this._incrementalRenderLarge(params, seriesModel);
  };
  BarView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  BarView2.prototype._updateDrawMode = function(seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  };
  BarView2.prototype._renderNormal = function(seriesModel, ecModel, api, payload) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coord = seriesModel.coordinateSystem;
    var baseAxis = coord.getBaseAxis();
    var isHorizontalOrRadial;
    if (coord.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
    }
    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data, api);
    }
    var needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
    var coordSysClipArea = getClipArea(coord, data);
    group.removeClipPath();
    var roundCap = seriesModel.get("roundCap", true);
    var drawBackground = seriesModel.get("showBackground", true);
    var backgroundModel = seriesModel.getModel("backgroundStyle");
    var barBorderRadius = backgroundModel.get("borderRadius") || 0;
    var bgEls = [];
    var oldBgEls = this._backgroundEls;
    var isInitSort = payload && payload.isInitSort;
    var isChangeOrder = payload && payload.type === "changeAxisOrder";
    function createBackground(dataIndex) {
      var bgLayout = getLayout[coord.type](data, dataIndex);
      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle());
      if (coord.type === "cartesian2d") {
        bgEl.setShape("r", barBorderRadius);
      }
      bgEls[dataIndex] = bgEl;
      return bgEl;
    }
    data.diff(oldData).add(function(dataIndex) {
      var itemModel = data.getItemModel(dataIndex);
      var layout2 = getLayout[coord.type](data, dataIndex, itemModel);
      if (drawBackground) {
        createBackground(dataIndex);
      }
      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout2)) {
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
      }
      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      if (isInitSort) {
        el.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        initProps(el, {
          shape: layout2
        }, seriesModel, dataIndex);
      }
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      el.ignore = isClipped;
    }).update(function(newIndex, oldIndex) {
      var itemModel = data.getItemModel(newIndex);
      var layout2 = getLayout[coord.type](data, newIndex, itemModel);
      if (drawBackground) {
        var bgEl = void 0;
        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          }
          bgEls[newIndex] = bgEl;
        }
        var bgLayout = getLayout[coord.type](data, newIndex);
        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        updateProps$1(bgEl, {
          shape
        }, animationModel, newIndex);
      }
      var el = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout2)) {
        group.remove(el);
        return;
      }
      var isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout2);
        if (isClipped) {
          group.remove(el);
        }
      }
      if (!el) {
        el = elementCreator[coord.type](seriesModel, data, newIndex, layout2, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
      } else {
        saveOldStyle(el);
      }
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      if (isChangeOrder) {
        var textEl = el.getTextContent();
        if (textEl) {
          var labelInnerStore = labelInner(textEl);
          if (labelInnerStore.prevValue != null) {
            labelInnerStore.prevValue = labelInnerStore.value;
          }
        }
      } else {
        updateStyle(el, data, newIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }
      if (isInitSort) {
        el.attr({
          shape: layout2
        });
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout2, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        updateProps$1(el, {
          shape: layout2
        }, seriesModel, newIndex, null);
      }
      data.setItemGraphicEl(newIndex, el);
      el.ignore = isClipped;
      group.add(el);
    }).remove(function(dataIndex) {
      var el = oldData.getItemGraphicEl(dataIndex);
      el && removeElementWithFadeOut(el, seriesModel, dataIndex);
    }).execute();
    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group$4());
    bgGroup.removeAll();
    for (var i = 0; i < bgEls.length; ++i) {
      bgGroup.add(bgEls[i]);
    }
    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data;
  };
  BarView2.prototype._renderLarge = function(seriesModel, ecModel, api) {
    this._clear();
    createLarge$1(seriesModel, this.group);
    this._updateLargeClip(seriesModel);
  };
  BarView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
    this._removeBackground();
    createLarge$1(seriesModel, this.group, this._progressiveEls, true);
  };
  BarView2.prototype._updateLargeClip = function(seriesModel) {
    var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    var group = this.group;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
  };
  BarView2.prototype._enableRealtimeSort = function(realtimeSortCfg, data, api) {
    var _this = this;
    if (!data.count()) {
      return;
    }
    var baseAxis = realtimeSortCfg.baseAxis;
    if (this._isFirstFrame) {
      this._dispatchInitSort(data, realtimeSortCfg, api);
      this._isFirstFrame = false;
    } else {
      var orderMapping_1 = function(idx) {
        var el = data.getItemGraphicEl(idx);
        var shape = el && el.shape;
        return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
      };
      this._onRendered = function() {
        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);
      };
      api.getZr().on("rendered", this._onRendered);
    }
  };
  BarView2.prototype._dataSort = function(data, baseAxis, orderMapping) {
    var info = [];
    data.each(data.mapDimension(baseAxis.dim), function(ordinalNumber, dataIdx) {
      var mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info.push({
        dataIndex: dataIdx,
        mappedValue,
        ordinalNumber
      });
    });
    info.sort(function(a, b) {
      return b.mappedValue - a.mappedValue;
    });
    return {
      ordinalNumbers: map$1(info, function(item) {
        return item.ordinalNumber;
      })
    };
  };
  BarView2.prototype._isOrderChangedWithinSameData = function(data, orderMapping, baseAxis) {
    var scale2 = baseAxis.scale;
    var ordinalDataDim = data.mapDimension(baseAxis.dim);
    var lastValue = Number.MAX_VALUE;
    for (var tickNum = 0, len2 = scale2.getOrdinalMeta().categories.length; tickNum < len2; ++tickNum) {
      var rawIdx = data.rawIndexOf(ordinalDataDim, scale2.getRawOrdinalNumber(tickNum));
      var value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
      if (value > lastValue) {
        return true;
      }
      lastValue = value;
    }
    return false;
  };
  BarView2.prototype._isOrderDifferentInView = function(orderInfo, baseAxis) {
    var scale2 = baseAxis.scale;
    var extent3 = scale2.getExtent();
    var tickNum = Math.max(0, extent3[0]);
    var tickMax = Math.min(extent3[1], scale2.getOrdinalMeta().categories.length - 1);
    for (; tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale2.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  };
  BarView2.prototype._updateSortWithinSameData = function(data, orderMapping, baseAxis, api) {
    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
      return;
    }
    var sortInfo = this._dataSort(data, baseAxis, orderMapping);
    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api);
      api.dispatchAction({
        type: "changeAxisOrder",
        componentType: baseAxis.dim + "Axis",
        axisId: baseAxis.index,
        sortInfo
      });
    }
  };
  BarView2.prototype._dispatchInitSort = function(data, realtimeSortCfg, api) {
    var baseAxis = realtimeSortCfg.baseAxis;
    var sortResult = this._dataSort(data, baseAxis, function(dataIdx) {
      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);
    });
    api.dispatchAction({
      type: "changeAxisOrder",
      componentType: baseAxis.dim + "Axis",
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult
    });
  };
  BarView2.prototype.remove = function(ecModel, api) {
    this._clear(this._model);
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype.dispose = function(ecModel, api) {
    this._removeOnRenderedListener(api);
  };
  BarView2.prototype._removeOnRenderedListener = function(api) {
    if (this._onRendered) {
      api.getZr().off("rendered", this._onRendered);
      this._onRendered = null;
    }
  };
  BarView2.prototype._clear = function(model) {
    var group = this.group;
    var data = this._data;
    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
      this._removeBackground();
      this._backgroundEls = [];
      data.eachItemGraphicEl(function(el) {
        removeElementWithFadeOut(el, model, getECData(el).dataIndex);
      });
    } else {
      group.removeAll();
    }
    this._data = null;
    this._isFirstFrame = true;
  };
  BarView2.prototype._removeBackground = function() {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  };
  BarView2.type = "bar";
  return BarView2;
}(ChartView$1);
var clip = {
  cartesian2d: function(coordSysBoundingRect, layout2) {
    var signWidth = layout2.width < 0 ? -1 : 1;
    var signHeight = layout2.height < 0 ? -1 : 1;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    var x = mathMax$5(layout2.x, coordSysBoundingRect.x);
    var x2 = mathMin$5(layout2.x + layout2.width, coordSysX2);
    var y = mathMax$5(layout2.y, coordSysBoundingRect.y);
    var y2 = mathMin$5(layout2.y + layout2.height, coordSysY2);
    var xClipped = x2 < x;
    var yClipped = y2 < y;
    layout2.x = xClipped && x > coordSysX2 ? x2 : x;
    layout2.y = yClipped && y > coordSysY2 ? y2 : y;
    layout2.width = xClipped ? 0 : x2 - x;
    layout2.height = yClipped ? 0 : y2 - y;
    if (signWidth < 0) {
      layout2.x += layout2.width;
      layout2.width = -layout2.width;
    }
    if (signHeight < 0) {
      layout2.y += layout2.height;
      layout2.height = -layout2.height;
    }
    return xClipped || yClipped;
  },
  polar: function(coordSysClipArea, layout2) {
    var signR = layout2.r0 <= layout2.r ? 1 : -1;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    var r = mathMin$5(layout2.r, coordSysClipArea.r);
    var r0 = mathMax$5(layout2.r0, coordSysClipArea.r0);
    layout2.r = r;
    layout2.r0 = r0;
    var clipped = r - r0 < 0;
    if (signR < 0) {
      var tmp = layout2.r;
      layout2.r = layout2.r0;
      layout2.r0 = tmp;
    }
    return clipped;
  }
};
var elementCreator = {
  cartesian2d: function(seriesModel, data, newIndex, layout2, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
    var rect = new Rect$3({
      shape: extend$1({}, layout2),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = "item";
    if (animationModel) {
      var rectShape = rect.shape;
      var animateProperty = isHorizontal ? "height" : "width";
      rectShape[animateProperty] = 0;
    }
    return rect;
  },
  polar: function(seriesModel, data, newIndex, layout2, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    var ShapeClass = !isRadial && roundCap ? Sausage : Sector$1;
    var sector = new ShapeClass({
      shape: layout2,
      z2: 1
    });
    sector.name = "item";
    var positionMap = createPolarPositionMapping(isRadial);
    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
      isRoundCap: ShapeClass === Sausage
    });
    if (animationModel) {
      var sectorShape = sector.shape;
      var animateProperty = isRadial ? "r" : "endAngle";
      var animateTarget = {};
      sectorShape[animateProperty] = isRadial ? 0 : layout2.startAngle;
      animateTarget[animateProperty] = layout2[animateProperty];
      (isUpdate ? updateProps$1 : initProps)(sector, {
        shape: animateTarget
      }, animationModel);
    }
    return sector;
  }
};
function shouldRealtimeSort(seriesModel, coordSys) {
  var realtimeSortOption = seriesModel.get("realtimeSort", true);
  var baseAxis = coordSys.getBaseAxis();
  if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
    return {
      baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}
function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout2, newIndex, isHorizontal, isUpdate, isChangeOrder) {
  var seriesTarget;
  var axisTarget;
  if (isHorizontal) {
    axisTarget = {
      x: layout2.x,
      width: layout2.width
    };
    seriesTarget = {
      y: layout2.y,
      height: layout2.height
    };
  } else {
    axisTarget = {
      y: layout2.y,
      height: layout2.height
    };
    seriesTarget = {
      x: layout2.x,
      width: layout2.width
    };
  }
  if (!isChangeOrder) {
    (isUpdate ? updateProps$1 : initProps)(el, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }
  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? updateProps$1 : initProps)(el, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}
function checkPropertiesNotValid(obj, props) {
  for (var i = 0; i < props.length; i++) {
    if (!isFinite(obj[props[i]])) {
      return true;
    }
  }
  return false;
}
var rectPropties = ["x", "y", "width", "height"];
var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
var isValidLayout = {
  cartesian2d: function(layout2) {
    return !checkPropertiesNotValid(layout2, rectPropties);
  },
  polar: function(layout2) {
    return !checkPropertiesNotValid(layout2, polarPropties);
  }
};
var getLayout = {
  cartesian2d: function(data, dataIndex, itemModel) {
    var layout2 = data.getItemLayout(dataIndex);
    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout2) : 0;
    var signX = layout2.width > 0 ? 1 : -1;
    var signY = layout2.height > 0 ? 1 : -1;
    return {
      x: layout2.x + signX * fixedLineWidth / 2,
      y: layout2.y + signY * fixedLineWidth / 2,
      width: layout2.width - signX * fixedLineWidth,
      height: layout2.height - signY * fixedLineWidth
    };
  },
  polar: function(data, dataIndex, itemModel) {
    var layout2 = data.getItemLayout(dataIndex);
    return {
      cx: layout2.cx,
      cy: layout2.cy,
      r0: layout2.r0,
      r: layout2.r,
      startAngle: layout2.startAngle,
      endAngle: layout2.endAngle,
      clockwise: layout2.clockwise
    };
  }
};
function isZeroOnPolar(layout2) {
  return layout2.startAngle != null && layout2.endAngle != null && layout2.startAngle === layout2.endAngle;
}
function createPolarPositionMapping(isRadial) {
  return function(isRadial2) {
    var arcOrAngle = isRadial2 ? "Arc" : "Angle";
    return function(position2) {
      switch (position2) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return position2 + arcOrAngle;
        default:
          return position2;
      }
    };
  }(isRadial);
}
function updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, isPolar) {
  var style = data.getItemVisual(dataIndex, "style");
  if (!isPolar) {
    el.setShape("r", itemModel.get(["itemStyle", "borderRadius"]) || 0);
  }
  el.useStyle(style);
  var cursorStyle = itemModel.getShallow("cursor");
  cursorStyle && el.attr("cursor", cursorStyle);
  var labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout2.r >= layout2.r0 ? "endArc" : "startArc" : layout2.endAngle >= layout2.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout2.height >= 0 ? "bottom" : "top" : layout2.width >= 0 ? "right" : "left";
  var labelStatesModels = getLabelStatesModels(itemModel);
  setLabelStyle(el, labelStatesModels, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    inheritColor: style.fill,
    defaultOpacity: style.opacity,
    defaultOutsidePosition: labelPositionOutside
  });
  var label = el.getTextContent();
  if (isPolar && label) {
    var position2 = itemModel.get(["label", "position"]);
    el.textConfig.inside = position2 === "middle" ? true : null;
    setSectorTextRotation(el, position2 === "outside" ? labelPositionOutside : position2, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
  }
  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function(value) {
    return getDefaultInterpolatedLabel(data, value);
  });
  var emphasisModel = itemModel.getModel(["emphasis"]);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  setStatesStylesFromModel(el, itemModel);
  if (isZeroOnPolar(layout2)) {
    el.style.fill = "none";
    el.style.stroke = "none";
    each$f(el.states, function(state) {
      if (state.style) {
        state.style.fill = state.style.stroke = "none";
      }
    });
  }
}
function getLineWidth(itemModel, rawLayout) {
  var borderColor = itemModel.get(["itemStyle", "borderColor"]);
  if (!borderColor || borderColor === "none") {
    return 0;
  }
  var lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width, height);
}
var LagePathShape = function() {
  function LagePathShape2() {
  }
  return LagePathShape2;
}();
var LargePath = function(_super) {
  __extends(LargePath2, _super);
  function LargePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "largeBar";
    return _this;
  }
  LargePath2.prototype.getDefaultShape = function() {
    return new LagePathShape();
  };
  LargePath2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    var baseDimIdx = this.baseDimIdx;
    var valueDimIdx = 1 - this.baseDimIdx;
    var startPoint = [];
    var size = [];
    var barWidth = this.barWidth;
    for (var i = 0; i < points2.length; i += 3) {
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points2[i + 2];
      startPoint[baseDimIdx] = points2[i + baseDimIdx];
      startPoint[valueDimIdx] = points2[i + valueDimIdx];
      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
    }
  };
  return LargePath2;
}(Path$1);
function createLarge$1(seriesModel, group, progressiveEls, incremental) {
  var data = seriesModel.getData();
  var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
  var largeDataIndices = data.getLayout("largeDataIndices");
  var barWidth = data.getLayout("size");
  var backgroundModel = seriesModel.getModel("backgroundStyle");
  var bgPoints = data.getLayout("largeBackgroundPoints");
  if (bgPoints) {
    var bgEl = new LargePath({
      shape: {
        points: bgPoints
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.baseDimIdx = baseDimIdx;
    bgEl.largeDataIndices = largeDataIndices;
    bgEl.barWidth = barWidth;
    bgEl.useStyle(backgroundModel.getItemStyle());
    group.add(bgEl);
    progressiveEls && progressiveEls.push(bgEl);
  }
  var el = new LargePath({
    shape: {
      points: data.getLayout("largePoints")
    },
    incremental: !!incremental,
    z2: 1
  });
  el.baseDimIdx = baseDimIdx;
  el.largeDataIndices = largeDataIndices;
  el.barWidth = barWidth;
  group.add(el);
  el.useStyle(data.getVisual("style"));
  getECData(el).seriesIndex = seriesModel.seriesIndex;
  if (!seriesModel.get("silent")) {
    el.on("mousedown", largePathUpdateDataIndex);
    el.on("mousemove", largePathUpdateDataIndex);
  }
  progressiveEls && progressiveEls.push(el);
}
var largePathUpdateDataIndex = throttle(function(event) {
  var largePath = this;
  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);
function largePathFindDataIndex(largePath, x, y) {
  var baseDimIdx = largePath.baseDimIdx;
  var valueDimIdx = 1 - baseDimIdx;
  var points2 = largePath.shape.points;
  var largeDataIndices = largePath.largeDataIndices;
  var startPoint = [];
  var size = [];
  var barWidth = largePath.barWidth;
  for (var i = 0, len2 = points2.length / 3; i < len2; i++) {
    var ii = i * 3;
    size[baseDimIdx] = barWidth;
    size[valueDimIdx] = points2[ii + 2];
    startPoint[baseDimIdx] = points2[ii + baseDimIdx];
    startPoint[valueDimIdx] = points2[ii + valueDimIdx];
    if (size[valueDimIdx] < 0) {
      startPoint[valueDimIdx] += size[valueDimIdx];
      size[valueDimIdx] = -size[valueDimIdx];
    }
    if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {
      return largeDataIndices[i];
    }
  }
  return -1;
}
function createBackgroundShape(isHorizontalOrRadial, layout2, coord) {
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    var rectShape = layout2;
    var coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    var coordLayout = coord.getArea();
    var sectorShape = layout2;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(coord, isHorizontalOrRadial, layout2) {
  var ElementClz = coord.type === "polar" ? Sector$1 : Rect$3;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout2, coord),
    silent: true,
    z2: 0
  });
}
var BarView$1 = BarView;
function install$13(registers) {
  registers.registerChartView(BarView$1);
  registers.registerSeriesModel(BarSeries);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, "bar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
  registers.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(payload, ecModel) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}
var PI2$1 = Math.PI * 2;
var RADIAN$2 = Math.PI / 180;
function getViewRect$5(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function getBasicPieLayout(seriesModel, api) {
  var viewRect2 = getViewRect$5(seriesModel, api);
  var center2 = seriesModel.get("center");
  var radius = seriesModel.get("radius");
  if (!isArray$1(radius)) {
    radius = [0, radius];
  }
  if (!isArray$1(center2)) {
    center2 = [center2, center2];
  }
  var width = parsePercent$1(viewRect2.width, api.getWidth());
  var height = parsePercent$1(viewRect2.height, api.getHeight());
  var size = Math.min(width, height);
  var cx = parsePercent$1(center2[0], width) + viewRect2.x;
  var cy = parsePercent$1(center2[1], height) + viewRect2.y;
  var r0 = parsePercent$1(radius[0], size / 2);
  var r = parsePercent$1(radius[1], size / 2);
  return {
    cx,
    cy,
    r0,
    r
  };
}
function pieLayout(seriesType2, ecModel, api) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var viewRect2 = getViewRect$5(seriesModel, api);
    var _a2 = getBasicPieLayout(seriesModel, api), cx = _a2.cx, cy = _a2.cy, r = _a2.r, r0 = _a2.r0;
    var startAngle = -seriesModel.get("startAngle") * RADIAN$2;
    var minAngle = seriesModel.get("minAngle") * RADIAN$2;
    var validDataCount = 0;
    data.each(valueDim, function(value) {
      !isNaN(value) && validDataCount++;
    });
    var sum2 = data.getSum(valueDim);
    var unitRadian = Math.PI / (sum2 || validDataCount) * 2;
    var clockwise = seriesModel.get("clockwise");
    var roseType = seriesModel.get("roseType");
    var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    var extent3 = data.getDataExtent(valueDim);
    extent3[0] = 0;
    var restAngle = PI2$1;
    var valueSumLargerThanMinAngle = 0;
    var currentAngle = startAngle;
    var dir3 = clockwise ? 1 : -1;
    data.setLayout({
      viewRect: viewRect2,
      r
    });
    data.each(valueDim, function(value, idx) {
      var angle;
      if (isNaN(value)) {
        data.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? NaN : r
        });
        return;
      }
      if (roseType !== "area") {
        angle = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
      } else {
        angle = PI2$1 / validDataCount;
      }
      if (angle < minAngle) {
        angle = minAngle;
        restAngle -= minAngle;
      } else {
        valueSumLargerThanMinAngle += value;
      }
      var endAngle = currentAngle + dir3 * angle;
      data.setItemLayout(idx, {
        angle,
        startAngle: currentAngle,
        endAngle,
        clockwise,
        cx,
        cy,
        r0,
        r: roseType ? linearMap$2(value, extent3, [r0, r]) : r
      });
      currentAngle = endAngle;
    });
    if (restAngle < PI2$1 && validDataCount) {
      if (restAngle <= 1e-3) {
        var angle_1 = PI2$1 / validDataCount;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            var layout_1 = data.getItemLayout(idx);
            layout_1.angle = angle_1;
            layout_1.startAngle = startAngle + dir3 * idx * angle_1;
            layout_1.endAngle = startAngle + dir3 * (idx + 1) * angle_1;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            var layout_2 = data.getItemLayout(idx);
            var angle = layout_2.angle === minAngle ? minAngle : value * unitRadian;
            layout_2.startAngle = currentAngle;
            layout_2.endAngle = currentAngle + dir3 * angle;
            currentAngle += dir3 * angle;
          }
        });
      }
    }
  });
}
function dataFilter$1(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        var name = data.getName(idx);
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(name)) {
            return false;
          }
        }
        return true;
      });
    }
  };
}
var RADIAN$1 = Math.PI / 180;
function adjustSingleSide(list, cx, cy, r, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list.length < 2) {
    return;
  }
  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    var rB = semi.rB;
    var rB2 = rB * rB;
    for (var i2 = 0; i2 < semi.list.length; i2++) {
      var item = semi.list[i2];
      var dy = Math.abs(item.label.y - cy);
      var rA = r + item.len;
      var rA2 = rA * rA;
      var dx2 = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);
      var newX = cx + (dx2 + item.len2) * dir3;
      var deltaX = newX - item.label.x;
      var newTargetWidth = item.targetTextWidth - deltaX * dir3;
      constrainTextWidth(item, newTargetWidth, true);
      item.label.x = newX;
    }
  }
  function recalculateX(items) {
    var topSemi = {
      list: [],
      maxY: 0
    };
    var bottomSemi = {
      list: [],
      maxY: 0
    };
    for (var i2 = 0; i2 < items.length; i2++) {
      if (items[i2].labelAlignTo !== "none") {
        continue;
      }
      var item = items[i2];
      var semi = item.label.y > cy ? bottomSemi : topSemi;
      var dy = Math.abs(item.label.y - cy);
      if (dy >= semi.maxY) {
        var dx2 = item.label.x - cx - item.len2 * dir3;
        var rA = r + item.len;
        var rB = Math.abs(dx2) < rA ? Math.sqrt(dy * dy / (1 - dx2 * dx2 / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }
      semi.list.push(item);
    }
    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }
  var len2 = list.length;
  for (var i = 0; i < len2; i++) {
    if (list[i].position === "outer" && list[i].labelAlignTo === "labelLine") {
      var dx = list[i].label.x - farthestX;
      list[i].linePoints[1][0] += dx;
      list[i].label.x = farthestX;
    }
  }
  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
    recalculateX(list);
  }
}
function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
  var leftList = [];
  var rightList = [];
  var leftmostX = Number.MAX_VALUE;
  var rightmostX = -Number.MAX_VALUE;
  for (var i = 0; i < labelLayoutList.length; i++) {
    var label = labelLayoutList[i].label;
    if (isPositionCenter(labelLayoutList[i])) {
      continue;
    }
    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i]);
    }
  }
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      if (layout2.labelStyleWidth != null) {
        continue;
      }
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var targetTextWidth = void 0;
      if (layout2.labelAlignTo === "edge") {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout2.labelDistance - viewLeft - layout2.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout2.edgeDistance - linePoints[2][0] - layout2.labelDistance;
        }
      } else if (layout2.labelAlignTo === "labelLine") {
        if (label.x < cx) {
          targetTextWidth = leftmostX - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - rightmostX - layout2.bleedMargin;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout2.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout2.bleedMargin;
        }
      }
      layout2.targetTextWidth = targetTextWidth;
      constrainTextWidth(layout2, targetTextWidth);
    }
  }
  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    if (!isPositionCenter(layout2) && layout2.linePoints) {
      var label = layout2.label;
      var linePoints = layout2.linePoints;
      var isAlignToEdge = layout2.labelAlignTo === "edge";
      var padding = label.style.padding;
      var paddingH = padding ? padding[1] + padding[3] : 0;
      var extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
      var realTextWidth = layout2.rect.width + extraPaddingH;
      var dist2 = linePoints[1][0] - linePoints[2][0];
      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout2.edgeDistance + realTextWidth + layout2.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout2.edgeDistance - realTextWidth - layout2.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout2.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout2.labelDistance;
        }
        linePoints[1][0] = linePoints[2][0] + dist2;
      }
      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}
function constrainTextWidth(layout2, availableWidth, forceRecalculate) {
  if (forceRecalculate === void 0) {
    forceRecalculate = false;
  }
  if (layout2.labelStyleWidth != null) {
    return;
  }
  var label = layout2.label;
  var style = label.style;
  var textRect = layout2.rect;
  var bgColor = style.backgroundColor;
  var padding = style.padding;
  var paddingH = padding ? padding[1] + padding[3] : 0;
  var overflow = style.overflow;
  var oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
  if (availableWidth < oldOuterWidth || forceRecalculate) {
    var oldHeight = textRect.height;
    if (overflow && overflow.match("break")) {
      label.setStyle("backgroundColor", null);
      label.setStyle("width", availableWidth - paddingH);
      var innerRect = label.getBoundingRect();
      label.setStyle("width", Math.ceil(innerRect.width));
      label.setStyle("backgroundColor", bgColor);
    } else {
      var availableInnerWidth = availableWidth - paddingH;
      var newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout2.unconstrainedWidth ? null : availableInnerWidth : null;
      label.setStyle("width", newWidth);
    }
    var newRect = label.getBoundingRect();
    textRect.width = newRect.width;
    var margin = (label.style.margin || 0) + 2.1;
    textRect.height = newRect.height + margin;
    textRect.y -= (textRect.height - oldHeight) / 2;
  }
}
function isPositionCenter(sectorShape) {
  return sectorShape.position === "center";
}
function pieLabelLayout(seriesModel) {
  var data = seriesModel.getData();
  var labelLayoutList = [];
  var cx;
  var cy;
  var hasLabelRotate = false;
  var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN$1;
  var viewRect2 = data.getLayout("viewRect");
  var r = data.getLayout("r");
  var viewWidth = viewRect2.width;
  var viewLeft = viewRect2.x;
  var viewTop = viewRect2.y;
  var viewHeight = viewRect2.height;
  function setNotShow(el) {
    el.ignore = true;
  }
  function isLabelShown(label2) {
    if (!label2.ignore) {
      return true;
    }
    for (var key in label2.states) {
      if (label2.states[key].ignore === false) {
        return true;
      }
    }
    return false;
  }
  data.each(function(idx) {
    var sector = data.getItemGraphicEl(idx);
    var sectorShape = sector.shape;
    var label2 = sector.getTextContent();
    var labelLine2 = sector.getTextGuideLine();
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel("label");
    var labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
    var labelDistance = labelModel.get("distanceToLabelLine");
    var labelAlignTo = labelModel.get("alignTo");
    var edgeDistance = parsePercent$1(labelModel.get("edgeDistance"), viewWidth);
    var bleedMargin = labelModel.get("bleedMargin");
    var labelLineModel = itemModel.getModel("labelLine");
    var labelLineLen = labelLineModel.get("length");
    labelLineLen = parsePercent$1(labelLineLen, viewWidth);
    var labelLineLen2 = labelLineModel.get("length2");
    labelLineLen2 = parsePercent$1(labelLineLen2, viewWidth);
    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      each$f(label2.states, setNotShow);
      label2.ignore = true;
      return;
    }
    if (!isLabelShown(label2)) {
      return;
    }
    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    var nx = Math.cos(midAngle);
    var ny = Math.sin(midAngle);
    var textX;
    var textY;
    var linePoints2;
    var textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
    if (labelPosition === "center") {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = "center";
    } else {
      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x1 + nx * 3;
      textY = y1 + ny * 3;
      if (!isLabelInside) {
        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);
        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);
        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
        var y3 = y2;
        if (labelAlignTo === "edge") {
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }
        textY = y3;
        linePoints2 = [[x1, y1], [x2, y2], [x3, y3]];
      }
      textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
    }
    var PI3 = Math.PI;
    var labelRotate = 0;
    var rotate2 = labelModel.get("rotate");
    if (isNumber(rotate2)) {
      labelRotate = rotate2 * (PI3 / 180);
    } else if (labelPosition === "center") {
      labelRotate = 0;
    } else if (rotate2 === "radial" || rotate2 === true) {
      var radialAngle = nx < 0 ? -midAngle + PI3 : -midAngle;
      labelRotate = radialAngle;
    } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
      var rad2 = Math.atan2(nx, ny);
      if (rad2 < 0) {
        rad2 = PI3 * 2 + rad2;
      }
      var isDown = ny > 0;
      if (isDown) {
        rad2 = PI3 + rad2;
      }
      labelRotate = rad2 - PI3;
    }
    hasLabelRotate = !!labelRotate;
    label2.x = textX;
    label2.y = textY;
    label2.rotation = labelRotate;
    label2.setStyle({
      verticalAlign: "middle"
    });
    if (!isLabelInside) {
      var textRect = label2.getBoundingRect().clone();
      textRect.applyTransform(label2.getComputedTransform());
      var margin = (label2.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label: label2,
        labelLine: labelLine2,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get("minTurnAngle"),
        maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
        surfaceNormal: new Point$1(nx, ny),
        linePoints: linePoints2,
        textAlign,
        labelDistance,
        labelAlignTo,
        edgeDistance,
        bleedMargin,
        rect: textRect,
        unconstrainedWidth: textRect.width,
        labelStyleWidth: label2.style.width
      });
    } else {
      label2.setStyle({
        align: textAlign
      });
      var selectState2 = label2.states.select;
      if (selectState2) {
        selectState2.x += label2.x;
        selectState2.y += label2.y;
      }
    }
    sector.setTextConfig({
      inside: isLabelInside
    });
  });
  if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
  }
  for (var i = 0; i < labelLayoutList.length; i++) {
    var layout2 = labelLayoutList[i];
    var label = layout2.label;
    var labelLine = layout2.labelLine;
    var notShowLabel = isNaN(label.x) || isNaN(label.y);
    if (label) {
      label.setStyle({
        align: layout2.textAlign
      });
      if (notShowLabel) {
        each$f(label.states, setNotShow);
        label.ignore = true;
      }
      var selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    if (labelLine) {
      var linePoints = layout2.linePoints;
      if (notShowLabel || !linePoints) {
        each$f(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        limitTurnAngle(linePoints, layout2.minTurnAngle);
        limitSurfaceAngle(linePoints, layout2.surfaceNormal, layout2.maxSurfaceAngle);
        labelLine.setShape({
          points: linePoints
        });
        label.__hostTarget.textGuideLineConfig = {
          anchor: new Point$1(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}
function getSectorCornerRadius(model, shape, zeroIfNull) {
  var cornerRadius = model.get("borderRadius");
  if (cornerRadius == null) {
    return zeroIfNull ? {
      cornerRadius: 0
    } : null;
  }
  if (!isArray$1(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
  }
  var dr = Math.abs(shape.r || 0 - shape.r0 || 0);
  return {
    cornerRadius: map$1(cornerRadius, function(cr) {
      return parsePercent$2(cr, dr);
    })
  };
}
var PiePiece = function(_super) {
  __extends(PiePiece2, _super);
  function PiePiece2(data, idx, startAngle) {
    var _this = _super.call(this) || this;
    _this.z2 = 2;
    var text = new ZRText$1();
    _this.setTextContent(text);
    _this.updateData(data, idx, startAngle, true);
    return _this;
  }
  PiePiece2.prototype.updateData = function(data, idx, startAngle, firstCreate) {
    var sector = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var emphasisModel = itemModel.getModel("emphasis");
    var layout2 = data.getItemLayout(idx);
    var sectorShape = extend$1(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout2, true), layout2);
    if (isNaN(sectorShape.startAngle)) {
      sector.setShape(sectorShape);
      return;
    }
    if (firstCreate) {
      sector.setShape(sectorShape);
      var animationType = seriesModel.getShallow("animationType");
      if (seriesModel.ecModel.ssr) {
        initProps(sector, {
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex: idx,
          isFrom: true
        });
        sector.originX = sectorShape.cx;
        sector.originY = sectorShape.cy;
      } else if (animationType === "scale") {
        sector.shape.r = layout2.r0;
        initProps(sector, {
          shape: {
            r: layout2.r
          }
        }, seriesModel, idx);
      } else {
        if (startAngle != null) {
          sector.setShape({
            startAngle,
            endAngle: startAngle
          });
          initProps(sector, {
            shape: {
              startAngle: layout2.startAngle,
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        } else {
          sector.shape.endAngle = layout2.startAngle;
          updateProps$1(sector, {
            shape: {
              endAngle: layout2.endAngle
            }
          }, seriesModel, idx);
        }
      }
    } else {
      saveOldStyle(sector);
      updateProps$1(sector, {
        shape: sectorShape
      }, seriesModel, idx);
    }
    sector.useStyle(data.getItemVisual(idx, "style"));
    setStatesStylesFromModel(sector, itemModel);
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var offset = seriesModel.get("selectedOffset");
    var dx = Math.cos(midAngle) * offset;
    var dy = Math.sin(midAngle) * offset;
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._updateLabel(seriesModel, data, idx);
    sector.ensureState("emphasis").shape = extend$1({
      r: layout2.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
    }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout2));
    extend$1(sector.ensureState("select"), {
      x: dx,
      y: dy,
      shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout2)
    });
    extend$1(sector.ensureState("blur"), {
      shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout2)
    });
    var labelLine = sector.getTextGuideLine();
    var labelText = sector.getTextContent();
    labelLine && extend$1(labelLine.ensureState("select"), {
      x: dx,
      y: dy
    });
    extend$1(labelText.ensureState("select"), {
      x: dx,
      y: dy
    });
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  PiePiece2.prototype._updateLabel = function(seriesModel, data, idx) {
    var sector = this;
    var itemModel = data.getItemModel(idx);
    var labelLineModel = itemModel.getModel("labelLine");
    var style = data.getItemVisual(idx, "style");
    var visualColor = style && style.fill;
    var visualOpacity = style && style.opacity;
    setLabelStyle(sector, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
    });
    var labelText = sector.getTextContent();
    sector.setTextConfig({
      position: null,
      rotation: null
    });
    labelText.attr({
      z2: 10
    });
    var labelPosition = seriesModel.get(["label", "position"]);
    if (labelPosition !== "outside" && labelPosition !== "outer") {
      sector.removeTextGuideLine();
    } else {
      var polyline = this.getTextGuideLine();
      if (!polyline) {
        polyline = new Polyline$3();
        this.setTextGuideLine(polyline);
      }
      setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
        stroke: visualColor,
        opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
      });
    }
  };
  return PiePiece2;
}(Sector$1);
var PieView = function(_super) {
  __extends(PieView2, _super);
  function PieView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ignoreLabelLineUpdate = true;
    return _this;
  }
  PieView2.prototype.init = function() {
    var sectorGroup = new Group$4();
    this._sectorGroup = sectorGroup;
  };
  PieView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var startAngle;
    if (!oldData && data.count() > 0) {
      var shape = data.getItemLayout(0);
      for (var s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {
        shape = data.getItemLayout(s);
      }
      if (shape) {
        startAngle = shape.startAngle;
      }
    }
    if (this._emptyCircleSector) {
      group.remove(this._emptyCircleSector);
    }
    if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
      var sector = new Sector$1({
        shape: getBasicPieLayout(seriesModel, api)
      });
      sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
      this._emptyCircleSector = sector;
      group.add(sector);
    }
    data.diff(oldData).add(function(idx) {
      var piePiece = new PiePiece(data, idx, startAngle);
      data.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function(newIdx, oldIdx) {
      var piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data, newIdx, startAngle);
      piePiece.off("click");
      group.add(piePiece);
      data.setItemGraphicEl(newIdx, piePiece);
    }).remove(function(idx) {
      var piePiece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    pieLabelLayout(seriesModel);
    if (seriesModel.get("animationTypeUpdate") !== "expansion") {
      this._data = data;
    }
  };
  PieView2.prototype.dispose = function() {
  };
  PieView2.prototype.containPoint = function(point, seriesModel) {
    var data = seriesModel.getData();
    var itemLayout = data.getItemLayout(0);
    if (itemLayout) {
      var dx = point[0] - itemLayout.cx;
      var dy = point[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };
  PieView2.type = "pie";
  return PieView2;
}(ChartView$1);
var PieView$1 = PieView;
function createSeriesDataSimply(seriesModel, opt, nameList) {
  opt = isArray$1(opt) && {
    coordDimensions: opt
  } || extend$1({
    encodeDefine: seriesModel.getEncode()
  }, opt);
  var source = seriesModel.getSource();
  var dimensions = prepareSeriesDataSchema(source, opt).dimensions;
  var list = new SeriesData$1(dimensions, seriesModel);
  list.initData(source, nameList);
  return list;
}
var LegendVisualProvider = function() {
  function LegendVisualProvider2(getDataWithEncodedVisual, getRawData2) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData2;
  }
  LegendVisualProvider2.prototype.getAllNames = function() {
    var rawData = this._getRawData();
    return rawData.mapArray(rawData.getName);
  };
  LegendVisualProvider2.prototype.containName = function(name) {
    var rawData = this._getRawData();
    return rawData.indexOfName(name) >= 0;
  };
  LegendVisualProvider2.prototype.indexOfName = function(name) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.indexOfName(name);
  };
  LegendVisualProvider2.prototype.getItemVisual = function(dataIndex, key) {
    var dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.getItemVisual(dataIndex, key);
  };
  return LegendVisualProvider2;
}();
var LegendVisualProvider$1 = LegendVisualProvider;
var PieSeriesModel = function(_super) {
  __extends(PieSeriesModel2, _super);
  function PieSeriesModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PieSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    this._defaultLabelLine(option);
  };
  PieSeriesModel2.prototype.mergeOption = function() {
    _super.prototype.mergeOption.apply(this, arguments);
  };
  PieSeriesModel2.prototype.getInitialData = function() {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
  };
  PieSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var data = this.getData();
    var params = _super.prototype.getDataParams.call(this, dataIndex);
    var valueList = [];
    data.each(data.mapDimension("value"), function(value) {
      valueList.push(value);
    });
    params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get("percentPrecision"));
    params.$vars.push("percent");
    return params;
  };
  PieSeriesModel2.prototype._defaultLabelLine = function(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };
  PieSeriesModel2.type = "series.pie";
  PieSeriesModel2.defaultOption = {
    z: 2,
    legendHoverLink: true,
    colorBy: "data",
    center: ["50%", "50%"],
    radius: [0, "75%"],
    clockwise: true,
    startAngle: 90,
    minAngle: 0,
    minShowLabelAngle: 0,
    selectedOffset: 10,
    percentPrecision: 2,
    stillShowZeroSum: true,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    width: null,
    height: null,
    label: {
      rotate: 0,
      show: true,
      overflow: "truncate",
      position: "outer",
      alignTo: "none",
      edgeDistance: "25%",
      bleedMargin: 10,
      distanceToLabelLine: 5
    },
    labelLine: {
      show: true,
      length: 15,
      length2: 15,
      smooth: false,
      minTurnAngle: 90,
      maxSurfaceAngle: 90,
      lineStyle: {
        width: 1,
        type: "solid"
      }
    },
    itemStyle: {
      borderWidth: 1,
      borderJoin: "round"
    },
    showEmptyCircle: true,
    emptyCircleStyle: {
      color: "lightgray",
      opacity: 1
    },
    labelLayout: {
      hideOverlap: true
    },
    emphasis: {
      scale: true,
      scaleSize: 5
    },
    avoidLabelOverlap: true,
    animationType: "expansion",
    animationDuration: 1e3,
    animationTypeUpdate: "transition",
    animationEasingUpdate: "cubicInOut",
    animationDurationUpdate: 500,
    animationEasing: "cubicInOut"
  };
  return PieSeriesModel2;
}(SeriesModel$1);
var PieSeriesModel$1 = PieSeriesModel;
function negativeDataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        var valueDim = data.mapDimension("value");
        var curValue = data.get(valueDim, idx);
        if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) {
          return false;
        }
        return true;
      });
    }
  };
}
function install$12(registers) {
  registers.registerChartView(PieView$1);
  registers.registerSeriesModel(PieSeriesModel$1);
  createLegacyDataSelectAction("pie", registers.registerAction);
  registers.registerLayout(curry$1(pieLayout, "pie"));
  registers.registerProcessor(dataFilter$1("pie"));
  registers.registerProcessor(negativeDataFilter("pie"));
}
var ScatterSeriesModel = function(_super) {
  __extends(ScatterSeriesModel2, _super);
  function ScatterSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScatterSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  ScatterSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  ScatterSeriesModel2.prototype.getProgressive = function() {
    var progressive = this.option.progressive;
    if (progressive == null) {
      return this.option.large ? 5e3 : this.get("progressive");
    }
    return progressive;
  };
  ScatterSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.option.progressiveThreshold;
    if (progressiveThreshold == null) {
      return this.option.large ? 1e4 : this.get("progressiveThreshold");
    }
    return progressiveThreshold;
  };
  ScatterSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  };
  ScatterSeriesModel2.prototype.getZLevelKey = function() {
    return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
  };
  ScatterSeriesModel2.type = "series.scatter";
  ScatterSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
  ScatterSeriesModel2.defaultOption = {
    coordinateSystem: "cartesian2d",
    z: 2,
    legendHoverLink: true,
    symbolSize: 10,
    large: false,
    largeThreshold: 2e3,
    itemStyle: {
      opacity: 0.8
    },
    emphasis: {
      scale: true
    },
    clip: true,
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    universalTransition: {
      divideShape: "clone"
    }
  };
  return ScatterSeriesModel2;
}(SeriesModel$1);
var ScatterSeriesModel$1 = ScatterSeriesModel;
var BOOST_SIZE_THRESHOLD = 4;
var LargeSymbolPathShape = function() {
  function LargeSymbolPathShape2() {
  }
  return LargeSymbolPathShape2;
}();
var LargeSymbolPath = function(_super) {
  __extends(LargeSymbolPath2, _super);
  function LargeSymbolPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this._off = 0;
    _this.hoverDataIdx = -1;
    return _this;
  }
  LargeSymbolPath2.prototype.getDefaultShape = function() {
    return new LargeSymbolPathShape();
  };
  LargeSymbolPath2.prototype.reset = function() {
    this.notClear = false;
    this._off = 0;
  };
  LargeSymbolPath2.prototype.buildPath = function(path, shape) {
    var points2 = shape.points;
    var size = shape.size;
    var symbolProxy = this.symbolProxy;
    var symbolProxyShape = symbolProxy.shape;
    var ctx = path.getContext ? path.getContext() : path;
    var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
    var softClipShape = this.softClipShape;
    var i;
    if (canBoost) {
      this._ctx = ctx;
      return;
    }
    this._ctx = null;
    for (i = this._off; i < points2.length; ) {
      var x = points2[i++];
      var y = points2[i++];
      if (isNaN(x) || isNaN(y)) {
        continue;
      }
      if (softClipShape && !softClipShape.contain(x, y)) {
        continue;
      }
      symbolProxyShape.x = x - size[0] / 2;
      symbolProxyShape.y = y - size[1] / 2;
      symbolProxyShape.width = size[0];
      symbolProxyShape.height = size[1];
      symbolProxy.buildPath(path, symbolProxyShape, true);
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  };
  LargeSymbolPath2.prototype.afterBrush = function() {
    var shape = this.shape;
    var points2 = shape.points;
    var size = shape.size;
    var ctx = this._ctx;
    var softClipShape = this.softClipShape;
    var i;
    if (!ctx) {
      return;
    }
    for (i = this._off; i < points2.length; ) {
      var x = points2[i++];
      var y = points2[i++];
      if (isNaN(x) || isNaN(y)) {
        continue;
      }
      if (softClipShape && !softClipShape.contain(x, y)) {
        continue;
      }
      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  };
  LargeSymbolPath2.prototype.findDataIndex = function(x, y) {
    var shape = this.shape;
    var points2 = shape.points;
    var size = shape.size;
    var w = Math.max(size[0], 4);
    var h = Math.max(size[1], 4);
    for (var idx = points2.length / 2 - 1; idx >= 0; idx--) {
      var i = idx * 2;
      var x0 = points2[i] - w / 2;
      var y0 = points2[i + 1] - h / 2;
      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
        return idx;
      }
    }
    return -1;
  };
  LargeSymbolPath2.prototype.contain = function(x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      var dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
      return dataIdx >= 0;
    }
    this.hoverDataIdx = -1;
    return false;
  };
  LargeSymbolPath2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    if (!rect) {
      var shape = this.shape;
      var points2 = shape.points;
      var size = shape.size;
      var w = size[0];
      var h = size[1];
      var minX = Infinity;
      var minY = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      for (var i = 0; i < points2.length; ) {
        var x = points2[i++];
        var y = points2[i++];
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      }
      rect = this._rect = new BoundingRect$1(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h);
    }
    return rect;
  };
  return LargeSymbolPath2;
}(Path$1);
var LargeSymbolDraw = function() {
  function LargeSymbolDraw2() {
    this.group = new Group$4();
  }
  LargeSymbolDraw2.prototype.updateData = function(data, opt) {
    this._clear();
    var symbolEl = this._create();
    symbolEl.setShape({
      points: data.getLayout("points")
    });
    this._setCommon(symbolEl, data, opt);
  };
  LargeSymbolDraw2.prototype.updateLayout = function(data) {
    var points2 = data.getLayout("points");
    this.group.eachChild(function(child) {
      if (child.startIndex != null) {
        var len2 = (child.endIndex - child.startIndex) * 2;
        var byteOffset = child.startIndex * 4 * 2;
        points2 = new Float32Array(points2.buffer, byteOffset, len2);
      }
      child.setShape("points", points2);
      child.reset();
    });
  };
  LargeSymbolDraw2.prototype.incrementalPrepareUpdate = function(data) {
    this._clear();
  };
  LargeSymbolDraw2.prototype.incrementalUpdate = function(taskParams, data, opt) {
    var lastAdded = this._newAdded[0];
    var points2 = data.getLayout("points");
    var oldPoints = lastAdded && lastAdded.shape.points;
    if (oldPoints && oldPoints.length < 2e4) {
      var oldLen = oldPoints.length;
      var newPoints = new Float32Array(oldLen + points2.length);
      newPoints.set(oldPoints);
      newPoints.set(points2, oldLen);
      lastAdded.endIndex = taskParams.end;
      lastAdded.setShape({
        points: newPoints
      });
    } else {
      this._newAdded = [];
      var symbolEl = this._create();
      symbolEl.startIndex = taskParams.start;
      symbolEl.endIndex = taskParams.end;
      symbolEl.incremental = true;
      symbolEl.setShape({
        points: points2
      });
      this._setCommon(symbolEl, data, opt);
    }
  };
  LargeSymbolDraw2.prototype.eachRendered = function(cb) {
    this._newAdded[0] && cb(this._newAdded[0]);
  };
  LargeSymbolDraw2.prototype._create = function() {
    var symbolEl = new LargeSymbolPath({
      cursor: "default"
    });
    this.group.add(symbolEl);
    this._newAdded.push(symbolEl);
    return symbolEl;
  };
  LargeSymbolDraw2.prototype._setCommon = function(symbolEl, data, opt) {
    var hostModel = data.hostModel;
    opt = opt || {};
    var size = data.getVisual("symbolSize");
    symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
    symbolEl.softClipShape = opt.clipShape || null;
    symbolEl.symbolProxy = createSymbol$1(data.getVisual("symbol"), 0, 0, 0, 0);
    symbolEl.setColor = symbolEl.symbolProxy.setColor;
    var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
    symbolEl.useStyle(hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
    var globalStyle = data.getVisual("style");
    var visualColor = globalStyle && globalStyle.fill;
    if (visualColor) {
      symbolEl.setColor(visualColor);
    }
    var ecData = getECData(symbolEl);
    ecData.seriesIndex = hostModel.seriesIndex;
    symbolEl.on("mousemove", function(e2) {
      ecData.dataIndex = null;
      var dataIndex = symbolEl.hoverDataIdx;
      if (dataIndex >= 0) {
        ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);
      }
    });
  };
  LargeSymbolDraw2.prototype.remove = function() {
    this._clear();
  };
  LargeSymbolDraw2.prototype._clear = function() {
    this._newAdded = [];
    this.group.removeAll();
  };
  return LargeSymbolDraw2;
}();
var LargeSymbolDraw$1 = LargeSymbolDraw;
var ScatterView = function(_super) {
  __extends(ScatterView2, _super);
  function ScatterView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScatterView2.type;
    return _this;
  }
  ScatterView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var symbolDraw = this._updateSymbolDraw(data, seriesModel);
    symbolDraw.updateData(data, {
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = true;
  };
  ScatterView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var symbolDraw = this._updateSymbolDraw(data, seriesModel);
    symbolDraw.incrementalPrepareUpdate(data);
    this._finished = false;
  };
  ScatterView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
    this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = taskParams.end === seriesModel.getData().count();
  };
  ScatterView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    this.group.dirty();
    if (!this._finished || data.count() > 1e4) {
      return {
        update: true
      };
    } else {
      var res = pointsLayout("").reset(seriesModel, ecModel, api);
      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      }
      this._symbolDraw.updateLayout(data);
    }
  };
  ScatterView2.prototype.eachRendered = function(cb) {
    this._symbolDraw && this._symbolDraw.eachRendered(cb);
  };
  ScatterView2.prototype._getClipShape = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
    return seriesModel.get("clip", true) ? clipArea : null;
  };
  ScatterView2.prototype._updateSymbolDraw = function(data, seriesModel) {
    var symbolDraw = this._symbolDraw;
    var pipelineContext = seriesModel.pipelineContext;
    var isLargeDraw = pipelineContext.large;
    if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
      symbolDraw && symbolDraw.remove();
      symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw$1() : new SymbolDraw$1();
      this._isLargeDraw = isLargeDraw;
      this.group.removeAll();
    }
    this.group.add(symbolDraw.group);
    return symbolDraw;
  };
  ScatterView2.prototype.remove = function(ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove(true);
    this._symbolDraw = null;
  };
  ScatterView2.prototype.dispose = function() {
  };
  ScatterView2.type = "scatter";
  return ScatterView2;
}(ChartView$1);
var ScatterView$1 = ScatterView;
var GridModel = function(_super) {
  __extends(GridModel2, _super);
  function GridModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GridModel2.type = "grid";
  GridModel2.dependencies = ["xAxis", "yAxis"];
  GridModel2.layoutMode = "box";
  GridModel2.defaultOption = {
    show: false,
    z: 0,
    left: "10%",
    top: 60,
    right: "10%",
    bottom: 70,
    containLabel: false,
    backgroundColor: "rgba(0,0,0,0)",
    borderWidth: 1,
    borderColor: "#ccc"
  };
  return GridModel2;
}(ComponentModel$1);
var GridModel$1 = GridModel;
var CartesianAxisModel = function(_super) {
  __extends(CartesianAxisModel2, _super);
  function CartesianAxisModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisModel2.prototype.getCoordSysModel = function() {
    return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
  };
  CartesianAxisModel2.type = "cartesian2dAxis";
  return CartesianAxisModel2;
}(ComponentModel$1);
mixin(CartesianAxisModel, AxisModelCommonMixin);
var defaultOption$2 = {
  show: true,
  z: 0,
  inverse: false,
  name: "",
  nameLocation: "end",
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  nameTextStyle: {},
  nameGap: 15,
  silent: false,
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    inside: false,
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    inside: false,
    rotate: 0,
    showMinLabel: null,
    showMaxLabel: null,
    margin: 8,
    fontSize: 12
  },
  splitLine: {
    show: true,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
};
var categoryAxis$1 = merge({
  boundaryGap: true,
  deduplication: null,
  splitLine: {
    show: false
  },
  axisTick: {
    alignWithLabel: false,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption$2);
var valueAxis$1 = merge({
  boundaryGap: [0, 0],
  axisLine: {
    show: "auto"
  },
  axisTick: {
    show: "auto"
  },
  splitNumber: 5,
  minorTick: {
    show: false,
    splitNumber: 5,
    length: 3,
    lineStyle: {}
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, defaultOption$2);
var timeAxis$1 = merge({
  splitNumber: 6,
  axisLabel: {
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis$1);
var logAxis$1 = defaults({
  logBase: 10
}, valueAxis$1);
var axisDefault$1 = {
  category: categoryAxis$1,
  value: valueAxis$1,
  time: timeAxis$1,
  log: logAxis$1
};
var AXIS_TYPES$1 = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  each$f(AXIS_TYPES$1, function(v, axisType) {
    var defaultOption2 = merge(merge({}, axisDefault$1[axisType], true), extraDefaultOption, true);
    var AxisModel = function(_super) {
      __extends(AxisModel2, _super);
      function AxisModel2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = axisName + "Axis." + axisType;
        return _this;
      }
      AxisModel2.prototype.mergeDefaultAndTheme = function(option, ecModel) {
        var layoutMode = fetchLayoutMode(this);
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        merge(option, themeModel.get(axisType + "Axis"));
        merge(option, this.getDefaultOption());
        option.type = getAxisType$1(option);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      };
      AxisModel2.prototype.optionUpdated = function() {
        var thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta$1.createByAxisModel(this);
        }
      };
      AxisModel2.prototype.getCategories = function(rawData) {
        var option = this.option;
        if (option.type === "category") {
          if (rawData) {
            return option.data;
          }
          return this.__ordinalMeta.categories;
        }
      };
      AxisModel2.prototype.getOrdinalMeta = function() {
        return this.__ordinalMeta;
      };
      AxisModel2.type = axisName + "Axis." + axisType;
      AxisModel2.defaultOption = defaultOption2;
      return AxisModel2;
    }(BaseAxisModelClass);
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType$1);
}
function getAxisType$1(option) {
  return option.type || (option.data ? "category" : "value");
}
var Cartesian = function() {
  function Cartesian2(name) {
    this.type = "cartesian";
    this._dimList = [];
    this._axes = {};
    this.name = name || "";
  }
  Cartesian2.prototype.getAxis = function(dim) {
    return this._axes[dim];
  };
  Cartesian2.prototype.getAxes = function() {
    return map$1(this._dimList, function(dim) {
      return this._axes[dim];
    }, this);
  };
  Cartesian2.prototype.getAxesByScale = function(scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter(this.getAxes(), function(axis) {
      return axis.scale.type === scaleType;
    });
  };
  Cartesian2.prototype.addAxis = function(axis) {
    var dim = axis.dim;
    this._axes[dim] = axis;
    this._dimList.push(dim);
  };
  return Cartesian2;
}();
var Cartesian$1 = Cartesian;
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale2) {
  return scale2.type === "interval" || scale2.type === "time";
}
var Cartesian2D = function(_super) {
  __extends(Cartesian2D2, _super);
  function Cartesian2D2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cartesian2d";
    _this.dimensions = cartesian2DDimensions;
    return _this;
  }
  Cartesian2D2.prototype.calcAffineTransform = function() {
    this._transform = this._invTransform = null;
    var xAxisScale = this.getAxis("x").scale;
    var yAxisScale = this.getAxis("y").scale;
    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }
    var xScaleExtent = xAxisScale.getExtent();
    var yScaleExtent = yAxisScale.getExtent();
    var start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    var end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
    if (!xScaleSpan || !yScaleSpan) {
      return;
    }
    var scaleX = (end2[0] - start2[0]) / xScaleSpan;
    var scaleY = (end2[1] - start2[1]) / yScaleSpan;
    var translateX = start2[0] - xScaleExtent[0] * scaleX;
    var translateY = start2[1] - yScaleExtent[0] * scaleY;
    var m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m2);
  };
  Cartesian2D2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
  };
  Cartesian2D2.prototype.containPoint = function(point) {
    var axisX = this.getAxis("x");
    var axisY = this.getAxis("y");
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  };
  Cartesian2D2.prototype.containData = function(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
  };
  Cartesian2D2.prototype.dataToPoint = function(data, clamp2, out2) {
    out2 = out2 || [];
    var xVal = data[0];
    var yVal = data[1];
    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform$1(out2, data, this._transform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
    out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
    return out2;
  };
  Cartesian2D2.prototype.clampData = function(data, out2) {
    var xScale = this.getAxis("x").scale;
    var yScale = this.getAxis("y").scale;
    var xAxisExtent = xScale.getExtent();
    var yAxisExtent = yScale.getExtent();
    var x = xScale.parse(data[0]);
    var y = yScale.parse(data[1]);
    out2 = out2 || [];
    out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out2;
  };
  Cartesian2D2.prototype.pointToData = function(point, clamp2) {
    var out2 = [];
    if (this._invTransform) {
      return applyTransform$1(out2, point, this._invTransform);
    }
    var xAxis = this.getAxis("x");
    var yAxis = this.getAxis("y");
    out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
    out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
    return out2;
  };
  Cartesian2D2.prototype.getOtherAxis = function(axis) {
    return this.getAxis(axis.dim === "x" ? "y" : "x");
  };
  Cartesian2D2.prototype.getArea = function() {
    var xExtent = this.getAxis("x").getGlobalExtent();
    var yExtent = this.getAxis("y").getGlobalExtent();
    var x = Math.min(xExtent[0], xExtent[1]);
    var y = Math.min(yExtent[0], yExtent[1]);
    var width = Math.max(xExtent[0], xExtent[1]) - x;
    var height = Math.max(yExtent[0], yExtent[1]) - y;
    return new BoundingRect$1(x, y, width, height);
  };
  return Cartesian2D2;
}(Cartesian$1);
var Cartesian2D$1 = Cartesian2D;
var Axis2D = function(_super) {
  __extends(Axis2D2, _super);
  function Axis2D2(dim, scale2, coordExtent, axisType, position2) {
    var _this = _super.call(this, dim, scale2, coordExtent) || this;
    _this.index = 0;
    _this.type = axisType || "value";
    _this.position = position2 || "bottom";
    return _this;
  }
  Axis2D2.prototype.isHorizontal = function() {
    var position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  };
  Axis2D2.prototype.getGlobalExtent = function(asc2) {
    var ret2 = this.getExtent();
    ret2[0] = this.toGlobalCoord(ret2[0]);
    ret2[1] = this.toGlobalCoord(ret2[1]);
    asc2 && ret2[0] > ret2[1] && ret2.reverse();
    return ret2;
  };
  Axis2D2.prototype.pointToData = function(point, clamp2) {
    return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
  };
  Axis2D2.prototype.setCategorySortInfo = function(info) {
    if (this.type !== "category") {
      return false;
    }
    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  };
  return Axis2D2;
}(Axis$1);
var Axis2D$1 = Axis2D;
function layout$2(gridModel, axisModel, opt) {
  opt = opt || {};
  var grid = gridModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout2 = {};
  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  var rawAxisPosition = axis.position;
  var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
  var axisDim = axis.dim;
  var rect = grid.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var idx = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  };
  var axisOffset = axisModel.get("offset") || 0;
  var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
  if (otherAxisOnZeroOf) {
    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  }
  layout2.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
  layout2.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
  var dirMap = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = dirMap[rawAxisPosition];
  layout2.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
  if (axisModel.get(["axisTick", "inside"])) {
    layout2.tickDirection = -layout2.tickDirection;
  }
  if (retrieve$2(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout2.labelDirection = -layout2.labelDirection;
  }
  var labelRotate = axisModel.get(["axisLabel", "rotate"]);
  layout2.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
  layout2.z2 = 1;
  return layout2;
}
function isCartesian2DSeries(seriesModel) {
  return seriesModel.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(seriesModel) {
  var axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  each$f(axisModelMap, function(v, key) {
    var axisType = key.replace(/Model$/, "");
    var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
    axisModelMap[key] = axisModel;
  });
  return axisModelMap;
}
var mathLog = Math.log;
function alignScaleTicks(scale2, axisModel, alignToScale) {
  var intervalScaleProto2 = IntervalScale$1.prototype;
  var alignToTicks = intervalScaleProto2.getTicks.call(alignToScale);
  var alignToNicedTicks = intervalScaleProto2.getTicks.call(alignToScale, true);
  var alignToSplitNumber = alignToTicks.length - 1;
  var alignToInterval = intervalScaleProto2.getInterval.call(alignToScale);
  var scaleExtent = getScaleExtent(scale2, axisModel);
  var rawExtent = scaleExtent.extent;
  var isMinFixed = scaleExtent.fixMin;
  var isMaxFixed = scaleExtent.fixMax;
  if (scale2.type === "log") {
    var logBase = mathLog(scale2.base);
    rawExtent = [mathLog(rawExtent[0]) / logBase, mathLog(rawExtent[1]) / logBase];
  }
  scale2.setExtent(rawExtent[0], rawExtent[1]);
  scale2.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  var extent3 = intervalScaleProto2.getExtent.call(scale2);
  if (isMinFixed) {
    rawExtent[0] = extent3[0];
  }
  if (isMaxFixed) {
    rawExtent[1] = extent3[1];
  }
  var interval = intervalScaleProto2.getInterval.call(scale2);
  var min3 = rawExtent[0];
  var max3 = rawExtent[1];
  if (isMinFixed && isMaxFixed) {
    interval = (max3 - min3) / alignToSplitNumber;
  } else if (isMinFixed) {
    max3 = rawExtent[0] + interval * alignToSplitNumber;
    while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max3 = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    min3 = rawExtent[1] - interval * alignToSplitNumber;
    while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min3 = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    var nicedSplitNumber = scale2.getTicks().length - 1;
    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }
    var range = interval * alignToSplitNumber;
    max3 = Math.ceil(rawExtent[1] / interval) * interval;
    min3 = round$3(max3 - range);
    if (min3 < 0 && rawExtent[0] >= 0) {
      min3 = 0;
      max3 = round$3(range);
    } else if (max3 > 0 && rawExtent[1] <= 0) {
      max3 = 0;
      min3 = -round$3(range);
    }
  }
  var t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  var t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
  intervalScaleProto2.setExtent.call(scale2, min3 + interval * t0, max3 + interval * t1);
  intervalScaleProto2.setInterval.call(scale2, interval);
  if (t0 || t1) {
    intervalScaleProto2.setNiceExtent.call(scale2, min3 + interval, max3 - interval);
  }
}
var Grid = function() {
  function Grid2(gridModel, ecModel, api) {
    this.type = "grid";
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;
    this._initCartesian(gridModel, ecModel, api);
    this.model = gridModel;
  }
  Grid2.prototype.getRect = function() {
    return this._rect;
  };
  Grid2.prototype.update = function(ecModel, api) {
    var axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    function updateAxisTicks(axes) {
      var alignTo;
      var axesIndices = keys(axes);
      var len2 = axesIndices.length;
      if (!len2) {
        return;
      }
      var axisNeedsAlign = [];
      for (var i = len2 - 1; i >= 0; i--) {
        var idx = +axesIndices[i];
        var axis = axes[idx];
        var model = axis.model;
        var scale2 = axis.scale;
        if (isIntervalOrLogScale(scale2) && model.get("alignTicks") && model.get("interval") == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale2, model);
          if (isIntervalOrLogScale(scale2)) {
            alignTo = axis;
          }
        }
      }
      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }
        each$f(axisNeedsAlign, function(axis2) {
          alignScaleTicks(axis2.scale, axis2.model, alignTo.scale);
        });
      }
    }
    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y);
    var onZeroRecords = {};
    each$f(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each$f(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api);
  };
  Grid2.prototype.resize = function(gridModel, api, ignoreContainLabel) {
    var boxLayoutParams = gridModel.getBoxLayoutParams();
    var isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
    var gridRect = getLayoutRect(boxLayoutParams, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes();
    if (isContainLabel) {
      each$f(axesList, function(axis) {
        if (!axis.model.get(["axisLabel", "inside"])) {
          var labelUnionRect = estimateLabelUnionRect(axis);
          if (labelUnionRect) {
            var dim = axis.isHorizontal() ? "height" : "width";
            var margin = axis.model.get(["axisLabel", "margin"]);
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis.position === "top") {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === "left") {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    each$f(this._coordsList, function(coord) {
      coord.calcAffineTransform();
    });
    function adjustAxes() {
      each$f(axesList, function(axis) {
        var isHorizontal = axis.isHorizontal();
        var extent3 = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent3[idx], extent3[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };
  Grid2.prototype.getAxis = function(dim, axisIndex) {
    var axesMapOnDim = this._axesMap[dim];
    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  };
  Grid2.prototype.getAxes = function() {
    return this._axesList.slice();
  };
  Grid2.prototype.getCartesian = function(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key];
    }
    if (isObject$3(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
        return coordList[i];
      }
    }
  };
  Grid2.prototype.getCartesians = function() {
    return this._coordsList.slice();
  };
  Grid2.prototype.convertToPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  Grid2.prototype.convertFromPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };
  Grid2.prototype._findConvertTarget = function(finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis;
    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      var grid = gridModel.coordinateSystem;
      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }
    return {
      cartesian,
      axis
    };
  };
  Grid2.prototype.containPoint = function(point) {
    var coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point);
    }
  };
  Grid2.prototype._initCartesian = function(gridModel, ecModel, api) {
    var _this = this;
    var grid = this;
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each$f(axesMap.x, function(xAxis, xAxisIndex) {
      each$f(axesMap.y, function(yAxis, yAxisIndex) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        var cartesian = new Cartesian2D$1(key);
        cartesian.master = _this;
        cartesian.model = gridModel;
        _this._coordsMap[key] = cartesian;
        _this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });
    function createAxisCreator(dimName) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        var axisPosition = axisModel.get("position");
        if (dimName === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        var axis = new Axis2D$1(dimName, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        var isCategory2 = axis.type === "category";
        axis.onBand = isCategory2 && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = grid;
        axis.index = idx;
        grid._axesList.push(axis);
        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  };
  Grid2.prototype._updateScale = function(ecModel, gridModel) {
    each$f(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
      if (axis.type === "category") {
        var categorySortInfo = axis.model.get("categorySortInfo");
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2DSeries(seriesModel)) {
        var axesModelMap = findAxisModels(seriesModel);
        var xAxisModel = axesModelMap.xAxisModel;
        var yAxisModel = axesModelMap.yAxisModel;
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis("x");
        var yAxis = cartesian.getAxis("y");
        unionExtent(data, xAxis);
        unionExtent(data, yAxis);
      }
    }, this);
    function unionExtent(data, axis) {
      each$f(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  };
  Grid2.prototype.getTooltipAxes = function(dim) {
    var baseAxes = [];
    var otherAxes = [];
    each$f(this.getCartesians(), function(cartesian) {
      var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes,
      otherAxes
    };
  };
  Grid2.create = function(ecModel, api) {
    var grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      var grid = new Grid2(gridModel, ecModel, api);
      grid.name = "grid_" + idx;
      grid.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (!isCartesian2DSeries(seriesModel)) {
        return;
      }
      var axesModelMap = findAxisModels(seriesModel);
      var xAxisModel = axesModelMap.xAxisModel;
      var yAxisModel = axesModelMap.yAxisModel;
      var gridModel = xAxisModel.getCoordSysModel();
      var grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  };
  Grid2.dimensions = cartesian2DDimensions;
  return Grid2;
}();
function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
  axis.getAxesOnZeroOf = function() {
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  };
  var otherAxes = axesMap[otherAxisDim];
  var otherAxisOnZeroOf;
  var axisModel = axis.model;
  var onZero = axisModel.get(["axisLine", "onZero"]);
  var onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
  if (!onZero) {
    return;
  }
  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    for (var idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }
  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }
  function getOnZeroRecordKey(axis2) {
    return axis2.dim + "_" + axis2.index;
  }
}
function canOnZeroToAxis(axis) {
  return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
  var axisExtent = axis.getExtent();
  var axisExtentSum = axisExtent[0] + axisExtent[1];
  axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
    return coord + coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === "x" ? function(coord) {
    return coord - coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
}
var Grid$1 = Grid;
var PI$5 = Math.PI;
var AxisBuilder = function() {
  function AxisBuilder2(axisModel, opt) {
    this.group = new Group$4();
    this.opt = opt;
    this.axisModel = axisModel;
    defaults(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true,
      handleAutoShown: function() {
        return true;
      }
    });
    var transformGroup = new Group$4({
      x: opt.position[0],
      y: opt.position[1],
      rotation: opt.rotation
    });
    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
  }
  AxisBuilder2.prototype.hasBuilder = function(name) {
    return !!builders[name];
  };
  AxisBuilder2.prototype.add = function(name) {
    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
  };
  AxisBuilder2.prototype.getGroup = function() {
    return this.group;
  };
  AxisBuilder2.innerTextLayout = function(axisRotation, textRotation, direction) {
    var rotationDiff = remRadian(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      textVerticalAlign = direction > 0 ? "top" : "bottom";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI$5)) {
      textVerticalAlign = direction > 0 ? "bottom" : "top";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff > 0 && rotationDiff < PI$5) {
        textAlign = direction > 0 ? "right" : "left";
      } else {
        textAlign = direction > 0 ? "left" : "right";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  };
  AxisBuilder2.makeAxisEventDataBase = function(axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
    return eventData;
  };
  AxisBuilder2.isLabelSilent = function(axisModel) {
    var tooltipOpt = axisModel.get("tooltip");
    return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
  };
  return AxisBuilder2;
}();
var builders = {
  axisLine: function(opt, axisModel, group, transformGroup) {
    var shown = axisModel.get(["axisLine", "show"]);
    if (shown === "auto" && opt.handleAutoShown) {
      shown = opt.handleAutoShown("axisLine");
    }
    if (!shown) {
      return;
    }
    var extent3 = axisModel.axis.getExtent();
    var matrix = transformGroup.transform;
    var pt12 = [extent3[0], 0];
    var pt22 = [extent3[1], 0];
    if (matrix) {
      applyTransform$1(pt12, pt12, matrix);
      applyTransform$1(pt22, pt22, matrix);
    }
    var lineStyle = extend$1({
      lineCap: "round"
    }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
    var line = new Line$3({
      subPixelOptimize: true,
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    });
    line.anid = "line";
    group.add(line);
    var arrows = axisModel.get(["axisLine", "symbol"]);
    if (arrows != null) {
      var arrowSize = axisModel.get(["axisLine", "symbolSize"]);
      if (isString(arrows)) {
        arrows = [arrows, arrows];
      }
      if (isString(arrowSize) || isNumber(arrowSize)) {
        arrowSize = [arrowSize, arrowSize];
      }
      var arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
      var symbolWidth_1 = arrowSize[0];
      var symbolHeight_1 = arrowSize[1];
      each$f([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
      }], function(point, index) {
        if (arrows[index] !== "none" && arrows[index] != null) {
          var symbol = createSymbol$1(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
          var r = point.r + point.offset;
          symbol.attr({
            rotation: point.rotate,
            x: pt12[0] + r * Math.cos(opt.rotation),
            y: pt12[1] - r * Math.sin(opt.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabel: function(opt, axisModel, group, transformGroup) {
    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
    if (axisModel.get(["axisLabel", "hideOverlap"])) {
      var labelList = prepareLayoutList(map$1(labelEls, function(label) {
        return {
          label,
          priority: label.z2,
          defaultAttr: {
            ignore: label.ignore
          }
        };
      }));
      hideOverlap(labelList);
    }
  },
  axisName: function(opt, axisModel, group, transformGroup) {
    var name = retrieve$2(opt.axisName, axisModel.get("name"));
    if (!name) {
      return;
    }
    var nameLocation = axisModel.get("nameLocation");
    var nameDirection = opt.nameDirection;
    var textStyleModel = axisModel.getModel("nameTextStyle");
    var gap = axisModel.get("nameGap") || 0;
    var extent3 = axisModel.axis.getExtent();
    var gapSignal = extent3[0] > extent3[1] ? -1 : 1;
    var pos = [
      nameLocation === "start" ? extent3[0] - gapSignal * gap : nameLocation === "end" ? extent3[1] + gapSignal * gap : (extent3[0] + extent3[1]) / 2,
      isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
    ];
    var labelLayout2;
    var nameRotation = axisModel.get("nameRotate");
    if (nameRotation != null) {
      nameRotation = nameRotation * PI$5 / 180;
    }
    var axisNameAvailableWidth;
    if (isNameLocationCenter(nameLocation)) {
      labelLayout2 = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);
    } else {
      labelLayout2 = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent3);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;
      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout2.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }
    var textFont = textStyleModel.getFont();
    var truncateOpt = axisModel.get("nameTruncate", true) || {};
    var ellipsis = truncateOpt.ellipsis;
    var maxWidth = retrieve$2(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    var textEl = new ZRText$1({
      x: pos[0],
      y: pos[1],
      rotation: labelLayout2.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: createTextStyle$1(textStyleModel, {
        text: name,
        font: textFont,
        overflow: "truncate",
        width: maxWidth,
        ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
        align: textStyleModel.get("align") || labelLayout2.textAlign,
        verticalAlign: textStyleModel.get("verticalAlign") || labelLayout2.textVerticalAlign
      }),
      z2: 1
    });
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: name
    });
    textEl.__fullText = name;
    textEl.anid = "name";
    if (axisModel.get("triggerEvent")) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisName";
      eventData.name = name;
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    group.add(textEl);
    textEl.decomposeTransform();
  }
};
function endTextLayout(rotation, textPosition, textRotate, extent3) {
  var rotationDiff = remRadian(textRotate - rotation);
  var textAlign;
  var textVerticalAlign;
  var inverse = extent3[0] > extent3[1];
  var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
  if (isRadianAroundZero(rotationDiff - PI$5 / 2)) {
    textVerticalAlign = onLeft ? "bottom" : "top";
    textAlign = "center";
  } else if (isRadianAroundZero(rotationDiff - PI$5 * 1.5)) {
    textVerticalAlign = onLeft ? "top" : "bottom";
    textAlign = "center";
  } else {
    textVerticalAlign = "middle";
    if (rotationDiff < PI$5 * 1.5 && rotationDiff > PI$5 / 2) {
      textAlign = onLeft ? "left" : "right";
    } else {
      textAlign = onLeft ? "right" : "left";
    }
  }
  return {
    rotation: rotationDiff,
    textAlign,
    textVerticalAlign
  };
}
function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  if (shouldShowAllLabels(axisModel.axis)) {
    return;
  }
  var showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
  var showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
  labelEls = labelEls || [];
  tickEls = tickEls || [];
  var firstLabel = labelEls[0];
  var nextLabel = labelEls[1];
  var lastLabel = labelEls[labelEls.length - 1];
  var prevLabel = labelEls[labelEls.length - 2];
  var firstTick = tickEls[0];
  var nextTick2 = tickEls[1];
  var lastTick = tickEls[tickEls.length - 1];
  var prevTick = tickEls[tickEls.length - 2];
  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick2);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }
  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}
function ignoreEl(el) {
  el && (el.ignore = true);
}
function isTwoLabelOverlapped(current, next) {
  var firstRect = current && current.getBoundingRect().clone();
  var nextRect = next && next.getBoundingRect().clone();
  if (!firstRect || !nextRect) {
    return;
  }
  var mRotationBack = identity([]);
  rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(mul([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(mul([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}
function isNameLocationCenter(nameLocation) {
  return nameLocation === "middle" || nameLocation === "center";
}
function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  var tickEls = [];
  var pt12 = [];
  var pt22 = [];
  for (var i = 0; i < ticksCoords.length; i++) {
    var tickCoord = ticksCoords[i].coord;
    pt12[0] = tickCoord;
    pt12[1] = 0;
    pt22[0] = tickCoord;
    pt22[1] = tickEndCoord;
    if (tickTransform) {
      applyTransform$1(pt12, pt12, tickTransform);
      applyTransform$1(pt22, pt22, tickTransform);
    }
    var tickEl = new Line$3({
      subPixelOptimize: true,
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    tickEl.anid = anidPrefix + "_" + ticksCoords[i].tickValue;
    tickEls.push(tickEl);
  }
  return tickEls;
}
function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var tickModel = axisModel.getModel("axisTick");
  var shown = tickModel.get("show");
  if (shown === "auto" && opt.handleAutoShown) {
    shown = opt.handleAutoShown("axisTick");
  }
  if (!shown || axis.scale.isBlank()) {
    return;
  }
  var lineStyleModel = tickModel.getModel("lineStyle");
  var tickEndCoord = opt.tickDirection * tickModel.get("length");
  var ticksCoords = axis.getTicksCoords();
  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }), "ticks");
  for (var i = 0; i < ticksEls.length; i++) {
    group.add(ticksEls[i]);
  }
  return ticksEls;
}
function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
  var axis = axisModel.axis;
  var minorTickModel = axisModel.getModel("minorTick");
  if (!minorTickModel.get("show") || axis.scale.isBlank()) {
    return;
  }
  var minorTicksCoords = axis.getMinorTicksCoords();
  if (!minorTicksCoords.length) {
    return;
  }
  var lineStyleModel = minorTickModel.getModel("lineStyle");
  var tickEndCoord = tickDirection * minorTickModel.get("length");
  var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }));
  for (var i = 0; i < minorTicksCoords.length; i++) {
    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
    for (var k = 0; k < minorTicksEls.length; k++) {
      group.add(minorTicksEls[k]);
    }
  }
}
function buildAxisLabel(group, transformGroup, axisModel, opt) {
  var axis = axisModel.axis;
  var show = retrieve$2(opt.axisLabelShow, axisModel.get(["axisLabel", "show"]));
  if (!show || axis.scale.isBlank()) {
    return;
  }
  var labelModel = axisModel.getModel("axisLabel");
  var labelMargin = labelModel.get("margin");
  var labels = axis.getViewLabels();
  var labelRotation = (retrieve$2(opt.labelRotate, labelModel.get("rotate")) || 0) * PI$5 / 180;
  var labelLayout2 = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  var labelEls = [];
  var silent = AxisBuilder.isLabelSilent(axisModel);
  var triggerEvent = axisModel.get("triggerEvent");
  each$f(labels, function(labelItem, index) {
    var tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    var formattedLabel = labelItem.formattedLabel;
    var rawLabel = labelItem.rawLabel;
    var itemLabelModel = labelModel;
    if (rawCategoryData && rawCategoryData[tickValue]) {
      var rawCategoryItem = rawCategoryData[tickValue];
      if (isObject$3(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new Model$1(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }
    var textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
    var tickCoord = axis.dataToCoord(tickValue);
    var textEl = new ZRText$1({
      x: tickCoord,
      y: opt.labelOffset + opt.labelDirection * labelMargin,
      rotation: labelLayout2.rotation,
      silent,
      z2: 10 + (labelItem.level || 0),
      style: createTextStyle$1(itemLabelModel, {
        text: formattedLabel,
        align: itemLabelModel.getShallow("align", true) || labelLayout2.textAlign,
        verticalAlign: itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout2.textVerticalAlign,
        fill: isFunction$1(textColor) ? textColor(axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue, index) : textColor
      })
    });
    textEl.anid = "label_" + tickValue;
    if (triggerEvent) {
      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisLabel";
      eventData.value = rawLabel;
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    labelEls.push(textEl);
    group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}
var AxisBuilder$1 = AxisBuilder;
function collect(ecModel, api) {
  var result = {
    axesInfo: {},
    seriesInvolved: false,
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api);
  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}
function collectAxesInfo(result, ecModel, api) {
  var globalTooltipModel = ecModel.getComponent("tooltip");
  var globalAxisPointerModel = ecModel.getComponent("axisPointer");
  var linksOption = globalAxisPointerModel.get("link", true) || [];
  var linkGroups = [];
  each$f(api.getCoordinateSystems(), function(coordSys) {
    if (!coordSys.axisPointerEnabled) {
      return;
    }
    var coordSysKey = makeKey(coordSys.model);
    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys;
    var coordSysModel = coordSys.model;
    var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
    each$f(coordSys.getAxes(), curry$1(saveTooltipAxisInfo, false, null));
    if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
      var triggerAxis = baseTooltipModel.get("trigger") === "axis";
      var cross2 = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
      if (triggerAxis || cross2) {
        each$f(tooltipAxes.baseAxes, curry$1(saveTooltipAxisInfo, cross2 ? "cross" : true, triggerAxis));
      }
      if (cross2) {
        each$f(tooltipAxes.otherAxes, curry$1(saveTooltipAxisInfo, "cross", false));
      }
    }
    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
      var axisPointerShow = axisPointerModel.get("show");
      if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }
      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get("triggerTooltip");
      }
      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      var snap = axisPointerModel.get("snap");
      var axisKey = makeKey(axis.model);
      var involveSeries = triggerTooltip || snap || axis.type === "category";
      var axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis,
        coordSys,
        axisPointerModel,
        triggerTooltip,
        involveSeries,
        snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      var groupIndex = getLinkGroupIndex(linksOption, axis);
      if (groupIndex != null) {
        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
          axesInfo: {}
        });
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}
function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
  var fields = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"];
  var volatileOption = {};
  each$f(fields, function(field) {
    volatileOption[field] = clone$4(tooltipAxisPointerModel.get(field));
  });
  volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
  if (tooltipAxisPointerModel.get("type") === "cross") {
    volatileOption.type = "line";
  }
  var labelOption = volatileOption.label || (volatileOption.label = {});
  labelOption.show == null && (labelOption.show = false);
  if (fromTooltip === "cross") {
    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
    if (!triggerTooltip) {
      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
      crossStyle && defaults(labelOption, crossStyle.textStyle);
    }
  }
  return axis.model.getModel("axisPointer", new Model$1(volatileOption, globalAxisPointerModel, ecModel));
}
function collectSeriesInfo(result, ecModel) {
  ecModel.eachSeries(function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
    var seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
    if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
      return;
    }
    each$f(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
      var axis = axisInfo.axis;
      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
function getLinkGroupIndex(linksOption, axis) {
  var axisModel = axis.model;
  var dim = axis.dim;
  for (var i = 0; i < linksOption.length; i++) {
    var linkOption = linksOption[i] || {};
    if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
      return i;
    }
  }
}
function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === "all" || isArray$1(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}
function fixValue(axisModel) {
  var axisInfo = getAxisInfo$1(axisModel);
  if (!axisInfo) {
    return;
  }
  var axisPointerModel = axisInfo.axisPointerModel;
  var scale2 = axisInfo.axis.scale;
  var option = axisPointerModel.option;
  var status = axisPointerModel.get("status");
  var value = axisPointerModel.get("value");
  if (value != null) {
    value = scale2.parse(value);
  }
  var useHandle = isHandleTrigger(axisPointerModel);
  if (status == null) {
    option.status = useHandle ? "show" : "hide";
  }
  var extent3 = scale2.getExtent().slice();
  extent3[0] > extent3[1] && extent3.reverse();
  if (value == null || value > extent3[1]) {
    value = extent3[1];
  }
  if (value < extent3[0]) {
    value = extent3[0];
  }
  option.value = value;
  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
  }
}
function getAxisInfo$1(axisModel) {
  var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  var axisInfo = getAxisInfo$1(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}
function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(["handle", "show"]);
}
function makeKey(model) {
  return model.type + "||" + model.id;
}
var axisPointerClazz = {};
var AxisView = function(_super) {
  __extends(AxisView2, _super);
  function AxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisView2.type;
    return _this;
  }
  AxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.axisPointerClass && fixValue(axisModel);
    _super.prototype.render.apply(this, arguments);
    this._doUpdateAxisPointerClass(axisModel, api, true);
  };
  AxisView2.prototype.updateAxisPointer = function(axisModel, ecModel, api, payload) {
    this._doUpdateAxisPointerClass(axisModel, api, false);
  };
  AxisView2.prototype.remove = function(ecModel, api) {
    var axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api);
  };
  AxisView2.prototype.dispose = function(ecModel, api) {
    this._disposeAxisPointer(api);
    _super.prototype.dispose.apply(this, arguments);
  };
  AxisView2.prototype._doUpdateAxisPointerClass = function(axisModel, api, forceRender) {
    var Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
    if (!Clazz) {
      return;
    }
    var axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
  };
  AxisView2.prototype._disposeAxisPointer = function(api) {
    this._axisPointer && this._axisPointer.dispose(api);
    this._axisPointer = null;
  };
  AxisView2.registerAxisPointerClass = function(type, clazz) {
    axisPointerClazz[type] = clazz;
  };
  AxisView2.getAxisPointerClass = function(type) {
    return type && axisPointerClazz[type];
  };
  AxisView2.type = "axis";
  return AxisView2;
}(ComponentView$1);
var AxisView$1 = AxisView;
var inner$f = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  var axis = axisModel.axis;
  if (axis.scale.isBlank()) {
    return;
  }
  var splitAreaModel = axisModel.getModel("splitArea");
  var areaStyleModel = splitAreaModel.getModel("areaStyle");
  var areaColors = areaStyleModel.get("color");
  var gridRect = gridModel.coordinateSystem.getRect();
  var ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true
  });
  if (!ticksCoords.length) {
    return;
  }
  var areaColorsLen = areaColors.length;
  var lastSplitAreaColors = inner$f(axisView).splitAreaColors;
  var newSplitAreaColors = createHashMap();
  var colorIndex = 0;
  if (lastSplitAreaColors) {
    for (var i = 0; i < ticksCoords.length; i++) {
      var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
        break;
      }
    }
  }
  var prev = axis.toGlobalCoord(ticksCoords[0].coord);
  var areaStyle = areaStyleModel.getAreaStyle();
  areaColors = isArray$1(areaColors) ? areaColors : [areaColors];
  for (var i = 1; i < ticksCoords.length; i++) {
    var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
    var x = void 0;
    var y = void 0;
    var width = void 0;
    var height = void 0;
    if (axis.isHorizontal()) {
      x = prev;
      y = gridRect.y;
      width = tickCoord - x;
      height = gridRect.height;
      prev = x + width;
    } else {
      x = gridRect.x;
      y = prev;
      width = gridRect.width;
      height = tickCoord - y;
      prev = y + height;
    }
    var tickValue = ticksCoords[i - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new Rect$3({
      anid: tickValue != null ? "area_" + tickValue : null,
      shape: {
        x,
        y,
        width,
        height
      },
      style: defaults({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }
  inner$f(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner$f(axisView).splitAreaColors = null;
}
var axisBuilderAttrs$3 = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs$2 = ["splitArea", "splitLine", "minorSplitLine"];
var CartesianAxisView = function(_super) {
  __extends(CartesianAxisView2, _super);
  function CartesianAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianAxisView2.type;
    _this.axisPointerClass = "CartesianAxisPointer";
    return _this;
  }
  CartesianAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$4();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    var gridModel = axisModel.getCoordSysModel();
    var layout2 = layout$2(gridModel, axisModel);
    var axisBuilder = new AxisBuilder$1(axisModel, extend$1({
      handleAutoShown: function(elementType) {
        var cartesians = gridModel.coordinateSystem.getCartesians();
        for (var i = 0; i < cartesians.length; i++) {
          if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
            return true;
          }
        }
        return false;
      }
    }, layout2));
    each$f(axisBuilderAttrs$3, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    each$f(selfBuilderAttrs$2, function(name) {
      if (axisModel.get([name, "show"])) {
        axisElementBuilders$2[name](this, this._axisGroup, axisModel, gridModel);
      }
    }, this);
    var isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
    if (!isInitialSortFromBarRacing) {
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    }
    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };
  CartesianAxisView2.prototype.remove = function() {
    rectCoordAxisHandleRemove(this);
  };
  CartesianAxisView2.type = "cartesianAxis";
  return CartesianAxisView2;
}(AxisView$1);
var axisElementBuilders$2 = {
  splitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    lineColors = isArray$1(lineColors) ? lineColors : [lineColors];
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p12 = [];
    var p22 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (isHorizontal) {
        p12[0] = tickCoord;
        p12[1] = gridRect.y;
        p22[0] = tickCoord;
        p22[1] = gridRect.y + gridRect.height;
      } else {
        p12[0] = gridRect.x;
        p12[1] = tickCoord;
        p22[0] = gridRect.x + gridRect.width;
        p22[1] = tickCoord;
      }
      var colorIndex = lineCount++ % lineColors.length;
      var tickValue = ticksCoords[i].tickValue;
      axisGroup.add(new Line$3({
        anid: tickValue != null ? "line_" + ticksCoords[i].tickValue : null,
        subPixelOptimize: true,
        autoBatch: true,
        shape: {
          x1: p12[0],
          y1: p12[1],
          x2: p22[0],
          y2: p22[1]
        },
        style: defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      }));
    }
  },
  minorSplitLine: function(axisView, axisGroup, axisModel, gridModel) {
    var axis = axisModel.axis;
    var minorSplitLineModel = axisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var gridRect = gridModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var p12 = [];
    var p22 = [];
    var lineStyle = lineStyleModel.getLineStyle();
    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
        if (isHorizontal) {
          p12[0] = tickCoord;
          p12[1] = gridRect.y;
          p22[0] = tickCoord;
          p22[1] = gridRect.y + gridRect.height;
        } else {
          p12[0] = gridRect.x;
          p12[1] = tickCoord;
          p22[0] = gridRect.x + gridRect.width;
          p22[1] = tickCoord;
        }
        axisGroup.add(new Line$3({
          anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
          subPixelOptimize: true,
          autoBatch: true,
          shape: {
            x1: p12[0],
            y1: p12[1],
            x2: p22[0],
            y2: p22[1]
          },
          style: lineStyle,
          silent: true
        }));
      }
    }
  },
  splitArea: function(axisView, axisGroup, axisModel, gridModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
  }
};
var CartesianXAxisView = function(_super) {
  __extends(CartesianXAxisView2, _super);
  function CartesianXAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView2.type;
    return _this;
  }
  CartesianXAxisView2.type = "xAxis";
  return CartesianXAxisView2;
}(CartesianAxisView);
var CartesianYAxisView = function(_super) {
  __extends(CartesianYAxisView2, _super);
  function CartesianYAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CartesianXAxisView.type;
    return _this;
  }
  CartesianYAxisView2.type = "yAxis";
  return CartesianYAxisView2;
}(CartesianAxisView);
var GridView = function(_super) {
  __extends(GridView2, _super);
  function GridView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "grid";
    return _this;
  }
  GridView2.prototype.render = function(gridModel, ecModel) {
    this.group.removeAll();
    if (gridModel.get("show")) {
      this.group.add(new Rect$3({
        shape: gridModel.coordinateSystem.getRect(),
        style: defaults({
          fill: gridModel.get("backgroundColor")
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  };
  GridView2.type = "grid";
  return GridView2;
}(ComponentView$1);
var extraOption = {
  offset: 0
};
function install$11(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(GridModel$1);
  registers.registerCoordinateSystem("cartesian2d", Grid$1);
  axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
  axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
  registers.registerComponentView(CartesianXAxisView);
  registers.registerComponentView(CartesianYAxisView);
  registers.registerPreprocessor(function(option) {
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}
function install$10(registers) {
  use(install$11);
  registers.registerSeriesModel(ScatterSeriesModel$1);
  registers.registerChartView(ScatterView$1);
  registers.registerLayout(pointsLayout("scatter"));
}
function radarLayout(ecModel) {
  ecModel.eachSeriesByType("radar", function(seriesModel) {
    var data = seriesModel.getData();
    var points2 = [];
    var coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      return;
    }
    var axes = coordSys.getIndicatorAxes();
    each$f(axes, function(axis, axisIndex) {
      data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
        points2[dataIndex] = points2[dataIndex] || [];
        var point = coordSys.dataToPoint(val, axisIndex);
        points2[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
      });
    });
    data.each(function(idx) {
      var firstPoint = find(points2[idx], function(point) {
        return isValidPoint(point);
      }) || getValueMissingPoint(coordSys);
      points2[idx].push(firstPoint.slice());
      data.setItemLayout(idx, points2[idx]);
    });
  });
}
function isValidPoint(point) {
  return !isNaN(point[0]) && !isNaN(point[1]);
}
function getValueMissingPoint(coordSys) {
  return [coordSys.cx, coordSys.cy];
}
function radarBackwardCompat(option) {
  var polarOptArr = option.polar;
  if (polarOptArr) {
    if (!isArray$1(polarOptArr)) {
      polarOptArr = [polarOptArr];
    }
    var polarNotRadar_1 = [];
    each$f(polarOptArr, function(polarOpt, idx) {
      if (polarOpt.indicator) {
        if (polarOpt.type && !polarOpt.shape) {
          polarOpt.shape = polarOpt.type;
        }
        option.radar = option.radar || [];
        if (!isArray$1(option.radar)) {
          option.radar = [option.radar];
        }
        option.radar.push(polarOpt);
      } else {
        polarNotRadar_1.push(polarOpt);
      }
    });
    option.polar = polarNotRadar_1;
  }
  each$f(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
      seriesOpt.radarIndex = seriesOpt.polarIndex;
    }
  });
}
var RadarView$2 = function(_super) {
  __extends(RadarView2, _super);
  function RadarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarView2.type;
    return _this;
  }
  RadarView2.prototype.render = function(seriesModel, ecModel, api) {
    var polar = seriesModel.coordinateSystem;
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    function createSymbol2(data2, idx) {
      var symbolType = data2.getItemVisual(idx, "symbol") || "circle";
      if (symbolType === "none") {
        return;
      }
      var symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
      var symbolPath = createSymbol$1(symbolType, -1, -1, 2, 2);
      var symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
      symbolPath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 100,
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2,
        rotation: symbolRotate * Math.PI / 180 || 0
      });
      return symbolPath;
    }
    function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
      symbolGroup.removeAll();
      for (var i = 0; i < newPoints.length - 1; i++) {
        var symbolPath = createSymbol2(data2, idx);
        if (symbolPath) {
          symbolPath.__dimIdx = i;
          if (oldPoints[i]) {
            symbolPath.setPosition(oldPoints[i]);
            graphic[isInit ? "initProps" : "updateProps"](symbolPath, {
              x: newPoints[i][0],
              y: newPoints[i][1]
            }, seriesModel, idx);
          } else {
            symbolPath.setPosition(newPoints[i]);
          }
          symbolGroup.add(symbolPath);
        }
      }
    }
    function getInitialPoints(points2) {
      return map$1(points2, function(pt) {
        return [polar.cx, polar.cy];
      });
    }
    data.diff(oldData).add(function(idx) {
      var points2 = data.getItemLayout(idx);
      if (!points2) {
        return;
      }
      var polygon = new Polygon$1();
      var polyline = new Polyline$3();
      var target = {
        shape: {
          points: points2
        }
      };
      polygon.shape.points = getInitialPoints(points2);
      polyline.shape.points = getInitialPoints(points2);
      initProps(polygon, target, seriesModel, idx);
      initProps(polyline, target, seriesModel, idx);
      var itemGroup = new Group$4();
      var symbolGroup = new Group$4();
      itemGroup.add(polyline);
      itemGroup.add(polygon);
      itemGroup.add(symbolGroup);
      updateSymbols(polyline.shape.points, points2, symbolGroup, data, idx, true);
      data.setItemGraphicEl(idx, itemGroup);
    }).update(function(newIdx, oldIdx) {
      var itemGroup = oldData.getItemGraphicEl(oldIdx);
      var polyline = itemGroup.childAt(0);
      var polygon = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var target = {
        shape: {
          points: data.getItemLayout(newIdx)
        }
      };
      if (!target.shape.points) {
        return;
      }
      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
      saveOldStyle(polygon);
      saveOldStyle(polyline);
      updateProps$1(polyline, target, seriesModel);
      updateProps$1(polygon, target, seriesModel);
      data.setItemGraphicEl(newIdx, itemGroup);
    }).remove(function(idx) {
      group.remove(oldData.getItemGraphicEl(idx));
    }).execute();
    data.eachItemGraphicEl(function(itemGroup, idx) {
      var itemModel = data.getItemModel(idx);
      var polyline = itemGroup.childAt(0);
      var polygon = itemGroup.childAt(1);
      var symbolGroup = itemGroup.childAt(2);
      var itemStyle = data.getItemVisual(idx, "style");
      var color = itemStyle.fill;
      group.add(itemGroup);
      polyline.useStyle(defaults(itemModel.getModel("lineStyle").getLineStyle(), {
        fill: "none",
        stroke: color
      }));
      setStatesStylesFromModel(polyline, itemModel, "lineStyle");
      setStatesStylesFromModel(polygon, itemModel, "areaStyle");
      var areaStyleModel = itemModel.getModel("areaStyle");
      var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
      polygon.ignore = polygonIgnore;
      each$f(["emphasis", "select", "blur"], function(stateName) {
        var stateModel = itemModel.getModel([stateName, "areaStyle"]);
        var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();
        polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
      });
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: color,
        opacity: 0.7,
        decal: itemStyle.decal
      }));
      var emphasisModel = itemModel.getModel("emphasis");
      var itemHoverStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      symbolGroup.eachChild(function(symbolPath) {
        if (symbolPath instanceof ZRImage$1) {
          var pathStyle = symbolPath.style;
          symbolPath.useStyle(extend$1({
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, itemStyle));
        } else {
          symbolPath.useStyle(itemStyle);
          symbolPath.setColor(color);
          symbolPath.style.strokeNoScale = true;
        }
        var pathEmphasisState = symbolPath.ensureState("emphasis");
        pathEmphasisState.style = clone$4(itemHoverStyle);
        var defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
        (defaultText == null || isNaN(defaultText)) && (defaultText = "");
        setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          labelDimIndex: symbolPath.__dimIdx,
          defaultText,
          inheritColor: color,
          defaultOpacity: itemStyle.opacity
        });
      });
      toggleHoverEmphasis(itemGroup, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    this._data = data;
  };
  RadarView2.prototype.remove = function() {
    this.group.removeAll();
    this._data = null;
  };
  RadarView2.type = "radar";
  return RadarView2;
}(ChartView$1);
var RadarView$3 = RadarView$2;
var RadarSeriesModel = function(_super) {
  __extends(RadarSeriesModel2, _super);
  function RadarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  RadarSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
  };
  RadarSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, {
      generateCoord: "indicator_",
      generateCoordCount: Infinity
    });
  };
  RadarSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var coordSys = this.coordinateSystem;
    var indicatorAxes = coordSys.getIndicatorAxes();
    var name = this.getData().getName(dataIndex);
    var nameToDisplay = name === "" ? this.name : name;
    var markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);
    return createTooltipMarkup("section", {
      header: nameToDisplay,
      sortBlocks: true,
      blocks: map$1(indicatorAxes, function(axis) {
        var val = data.get(data.mapDimension(axis.dim), dataIndex);
        return createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor,
          name: axis.name,
          value: val,
          sortParam: val
        });
      })
    });
  };
  RadarSeriesModel2.prototype.getTooltipPosition = function(dataIndex) {
    if (dataIndex != null) {
      var data_1 = this.getData();
      var coordSys = this.coordinateSystem;
      var values = data_1.getValues(map$1(coordSys.dimensions, function(dim) {
        return data_1.mapDimension(dim);
      }), dataIndex);
      for (var i = 0, len2 = values.length; i < len2; i++) {
        if (!isNaN(values[i])) {
          var indicatorAxes = coordSys.getIndicatorAxes();
          return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
        }
      }
    }
  };
  RadarSeriesModel2.type = "series.radar";
  RadarSeriesModel2.dependencies = ["radar"];
  RadarSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    coordinateSystem: "radar",
    legendHoverLink: true,
    radarIndex: 0,
    lineStyle: {
      width: 2,
      type: "solid",
      join: "round"
    },
    label: {
      position: "top"
    },
    symbolSize: 8
  };
  return RadarSeriesModel2;
}(SeriesModel$1);
var RadarSeriesModel$1 = RadarSeriesModel;
var valueAxisDefault = axisDefault$1.value;
function defaultsShow(opt, show) {
  return defaults({
    show
  }, opt);
}
var RadarModel = function(_super) {
  __extends(RadarModel2, _super);
  function RadarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarModel2.type;
    return _this;
  }
  RadarModel2.prototype.optionUpdated = function() {
    var boundaryGap = this.get("boundaryGap");
    var splitNumber = this.get("splitNumber");
    var scale2 = this.get("scale");
    var axisLine = this.get("axisLine");
    var axisTick = this.get("axisTick");
    var axisLabel = this.get("axisLabel");
    var nameTextStyle = this.get("axisName");
    var showName = this.get(["axisName", "show"]);
    var nameFormatter = this.get(["axisName", "formatter"]);
    var nameGap = this.get("axisNameGap");
    var triggerEvent = this.get("triggerEvent");
    var indicatorModels = map$1(this.get("indicator") || [], function(indicatorOpt) {
      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
        indicatorOpt.min = 0;
      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
        indicatorOpt.max = 0;
      }
      var iNameTextStyle = nameTextStyle;
      if (indicatorOpt.color != null) {
        iNameTextStyle = defaults({
          color: indicatorOpt.color
        }, nameTextStyle);
      }
      var innerIndicatorOpt = merge(clone$4(indicatorOpt), {
        boundaryGap,
        splitNumber,
        scale: scale2,
        axisLine,
        axisTick,
        axisLabel,
        name: indicatorOpt.text,
        showName,
        nameLocation: "end",
        nameGap,
        nameTextStyle: iNameTextStyle,
        triggerEvent
      }, false);
      if (!showName) {
        innerIndicatorOpt.name = "";
      }
      if (isString(nameFormatter)) {
        var indName = innerIndicatorOpt.name;
        innerIndicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
      } else if (isFunction$1(nameFormatter)) {
        innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
      }
      var model = new Model$1(innerIndicatorOpt, null, this.ecModel);
      mixin(model, AxisModelCommonMixin.prototype);
      model.mainType = "radar";
      model.componentIndex = this.componentIndex;
      return model;
    }, this);
    this._indicatorModels = indicatorModels;
  };
  RadarModel2.prototype.getIndicatorModels = function() {
    return this._indicatorModels;
  };
  RadarModel2.type = "radar";
  RadarModel2.defaultOption = {
    z: 0,
    center: ["50%", "50%"],
    radius: "75%",
    startAngle: 90,
    axisName: {
      show: true
    },
    boundaryGap: [0, 0],
    splitNumber: 5,
    axisNameGap: 15,
    scale: false,
    shape: "polygon",
    axisLine: merge({
      lineStyle: {
        color: "#bbb"
      }
    }, valueAxisDefault.axisLine),
    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
    axisTick: defaultsShow(valueAxisDefault.axisTick, false),
    splitLine: defaultsShow(valueAxisDefault.splitLine, true),
    splitArea: defaultsShow(valueAxisDefault.splitArea, true),
    indicator: []
  };
  return RadarModel2;
}(ComponentModel$1);
var RadarModel$1 = RadarModel;
var axisBuilderAttrs$2 = ["axisLine", "axisTickLabel", "axisName"];
var RadarView = function(_super) {
  __extends(RadarView2, _super);
  function RadarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadarView2.type;
    return _this;
  }
  RadarView2.prototype.render = function(radarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();
    this._buildAxes(radarModel);
    this._buildSplitLineAndArea(radarModel);
  };
  RadarView2.prototype._buildAxes = function(radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    var axisBuilders = map$1(indicatorAxes, function(indicatorAxis) {
      var axisName = indicatorAxis.model.get("showName") ? indicatorAxis.name : "";
      var axisBuilder = new AxisBuilder$1(indicatorAxis.model, {
        axisName,
        position: [radar.cx, radar.cy],
        rotation: indicatorAxis.angle,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1
      });
      return axisBuilder;
    });
    each$f(axisBuilders, function(axisBuilder) {
      each$f(axisBuilderAttrs$2, axisBuilder.add, axisBuilder);
      this.group.add(axisBuilder.getGroup());
    }, this);
  };
  RadarView2.prototype._buildSplitLineAndArea = function(radarModel) {
    var radar = radarModel.coordinateSystem;
    var indicatorAxes = radar.getIndicatorAxes();
    if (!indicatorAxes.length) {
      return;
    }
    var shape = radarModel.get("shape");
    var splitLineModel = radarModel.getModel("splitLine");
    var splitAreaModel = radarModel.getModel("splitArea");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var showSplitLine = splitLineModel.get("show");
    var showSplitArea = splitAreaModel.get("show");
    var splitLineColors = lineStyleModel.get("color");
    var splitAreaColors = areaStyleModel.get("color");
    var splitLineColorsArr = isArray$1(splitLineColors) ? splitLineColors : [splitLineColors];
    var splitAreaColorsArr = isArray$1(splitAreaColors) ? splitAreaColors : [splitAreaColors];
    var splitLines = [];
    var splitAreas = [];
    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
      var colorIndex2 = idx % areaOrLineColorList.length;
      areaOrLine[colorIndex2] = areaOrLine[colorIndex2] || [];
      return colorIndex2;
    }
    if (shape === "circle") {
      var ticksRadius = indicatorAxes[0].getTicksCoords();
      var cx = radar.cx;
      var cy = radar.cy;
      for (var i = 0; i < ticksRadius.length; i++) {
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Circle$1({
            shape: {
              cx,
              cy,
              r: ticksRadius[i].coord
            }
          }));
        }
        if (showSplitArea && i < ticksRadius.length - 1) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);
          splitAreas[colorIndex].push(new Ring$1({
            shape: {
              cx,
              cy,
              r0: ticksRadius[i].coord,
              r: ticksRadius[i + 1].coord
            }
          }));
        }
      }
    } else {
      var realSplitNumber_1;
      var axesTicksPoints = map$1(indicatorAxes, function(indicatorAxis, idx) {
        var ticksCoords = indicatorAxis.getTicksCoords();
        realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);
        return map$1(ticksCoords, function(tickCoord) {
          return radar.coordToPoint(tickCoord.coord, idx);
        });
      });
      var prevPoints = [];
      for (var i = 0; i <= realSplitNumber_1; i++) {
        var points2 = [];
        for (var j = 0; j < indicatorAxes.length; j++) {
          points2.push(axesTicksPoints[j][i]);
        }
        if (points2[0]) {
          points2.push(points2[0].slice());
        }
        if (showSplitLine) {
          var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Polyline$3({
            shape: {
              points: points2
            }
          }));
        }
        if (showSplitArea && prevPoints) {
          var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);
          splitAreas[colorIndex].push(new Polygon$1({
            shape: {
              points: points2.concat(prevPoints)
            }
          }));
        }
        prevPoints = points2.slice().reverse();
      }
    }
    var lineStyle = lineStyleModel.getLineStyle();
    var areaStyle = areaStyleModel.getAreaStyle();
    each$f(splitAreas, function(splitAreas2, idx) {
      this.group.add(mergePath(splitAreas2, {
        style: defaults({
          stroke: "none",
          fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
        }, areaStyle),
        silent: true
      }));
    }, this);
    each$f(splitLines, function(splitLines2, idx) {
      this.group.add(mergePath(splitLines2, {
        style: defaults({
          fill: "none",
          stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
        }, lineStyle),
        silent: true
      }));
    }, this);
  };
  RadarView2.type = "radar";
  return RadarView2;
}(ComponentView$1);
var RadarView$1 = RadarView;
var IndicatorAxis = function(_super) {
  __extends(IndicatorAxis2, _super);
  function IndicatorAxis2(dim, scale2, radiusExtent) {
    var _this = _super.call(this, dim, scale2, radiusExtent) || this;
    _this.type = "value";
    _this.angle = 0;
    _this.name = "";
    return _this;
  }
  return IndicatorAxis2;
}(Axis$1);
var IndicatorAxis$1 = IndicatorAxis;
var Radar = function() {
  function Radar2(radarModel, ecModel, api) {
    this.dimensions = [];
    this._model = radarModel;
    this._indicatorAxes = map$1(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
      var dim = "indicator_" + idx;
      var indicatorAxis = new IndicatorAxis$1(dim, new IntervalScale$1());
      indicatorAxis.name = indicatorModel.get("name");
      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api);
  }
  Radar2.prototype.getIndicatorAxes = function() {
    return this._indicatorAxes;
  };
  Radar2.prototype.dataToPoint = function(value, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  };
  Radar2.prototype.coordToPoint = function(coord, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    var angle = indicatorAxis.angle;
    var x = this.cx + coord * Math.cos(angle);
    var y = this.cy - coord * Math.sin(angle);
    return [x, y];
  };
  Radar2.prototype.pointToData = function(pt) {
    var dx = pt[0] - this.cx;
    var dy = pt[1] - this.cy;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx);
    var minRadianDiff = Infinity;
    var closestAxis;
    var closestAxisIdx = -1;
    for (var i = 0; i < this._indicatorAxes.length; i++) {
      var indicatorAxis = this._indicatorAxes[i];
      var diff = Math.abs(radian - indicatorAxis.angle);
      if (diff < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff;
      }
    }
    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  };
  Radar2.prototype.resize = function(radarModel, api) {
    var center2 = radarModel.get("center");
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = parsePercent$1(center2[0], viewWidth);
    this.cy = parsePercent$1(center2[1], viewHeight);
    this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
    var radius = radarModel.get("radius");
    if (isString(radius) || isNumber(radius)) {
      radius = [0, radius];
    }
    this.r0 = parsePercent$1(radius[0], viewSize);
    this.r = parsePercent$1(radius[1], viewSize);
    each$f(this._indicatorAxes, function(indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  };
  Radar2.prototype.update = function(ecModel, api) {
    var indicatorAxes = this._indicatorAxes;
    var radarModel = this._model;
    each$f(indicatorAxes, function(indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
      if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
        return;
      }
      var data = radarSeries.getData();
      each$f(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    var splitNumber = radarModel.get("splitNumber");
    var dummyScale = new IntervalScale$1();
    dummyScale.setExtent(0, splitNumber);
    dummyScale.setInterval(1);
    each$f(indicatorAxes, function(indicatorAxis, idx) {
      alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale);
    });
  };
  Radar2.prototype.convertToPixel = function(ecModel, finder, value) {
    console.warn("Not implemented.");
    return null;
  };
  Radar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    console.warn("Not implemented.");
    return null;
  };
  Radar2.prototype.containPoint = function(point) {
    console.warn("Not implemented.");
    return false;
  };
  Radar2.create = function(ecModel, api) {
    var radarList = [];
    ecModel.eachComponent("radar", function(radarModel) {
      var radar = new Radar2(radarModel, ecModel, api);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType("radar", function(radarSeries) {
      if (radarSeries.get("coordinateSystem") === "radar") {
        radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
      }
    });
    return radarList;
  };
  Radar2.dimensions = [];
  return Radar2;
}();
var Radar$1 = Radar;
function install$$(registers) {
  registers.registerCoordinateSystem("radar", Radar$1);
  registers.registerComponentModel(RadarModel$1);
  registers.registerComponentView(RadarView$1);
  registers.registerVisual({
    seriesType: "radar",
    reset: function(seriesModel) {
      var data = seriesModel.getData();
      data.each(function(idx) {
        data.setItemVisual(idx, "legendIcon", "roundRect");
      });
      data.setVisual("legendIcon", "roundRect");
    }
  });
}
function install$_(registers) {
  use(install$$);
  registers.registerChartView(RadarView$3);
  registers.registerSeriesModel(RadarSeriesModel$1);
  registers.registerLayout(radarLayout);
  registers.registerProcessor(dataFilter$1("radar"));
  registers.registerPreprocessor(radarBackwardCompat);
}
var ATTR = "\0_ec_interaction_mutex";
function take(zr, resourceKey, userKey) {
  var store = getStore(zr);
  store[resourceKey] = userKey;
}
function release(zr, resourceKey, userKey) {
  var store = getStore(zr);
  var uKey = store[resourceKey];
  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}
function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}
function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
registerAction({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, noop$1);
var RoamController = function(_super) {
  __extends(RoamController2, _super);
  function RoamController2(zr) {
    var _this = _super.call(this) || this;
    _this._zr = zr;
    var mousedownHandler = bind$1(_this._mousedownHandler, _this);
    var mousemoveHandler = bind$1(_this._mousemoveHandler, _this);
    var mouseupHandler = bind$1(_this._mouseupHandler, _this);
    var mousewheelHandler = bind$1(_this._mousewheelHandler, _this);
    var pinchHandler = bind$1(_this._pinchHandler, _this);
    _this.enable = function(controlType, opt) {
      this.disable();
      this._opt = defaults(clone$4(opt) || {}, {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });
      if (controlType == null) {
        controlType = true;
      }
      if (controlType === true || controlType === "move" || controlType === "pan") {
        zr.on("mousedown", mousedownHandler);
        zr.on("mousemove", mousemoveHandler);
        zr.on("mouseup", mouseupHandler);
      }
      if (controlType === true || controlType === "scale" || controlType === "zoom") {
        zr.on("mousewheel", mousewheelHandler);
        zr.on("pinch", pinchHandler);
      }
    };
    _this.disable = function() {
      zr.off("mousedown", mousedownHandler);
      zr.off("mousemove", mousemoveHandler);
      zr.off("mouseup", mouseupHandler);
      zr.off("mousewheel", mousewheelHandler);
      zr.off("pinch", pinchHandler);
    };
    return _this;
  }
  RoamController2.prototype.isDragging = function() {
    return this._dragging;
  };
  RoamController2.prototype.isPinching = function() {
    return this._pinching;
  };
  RoamController2.prototype.setPointerChecker = function(pointerChecker) {
    this.pointerChecker = pointerChecker;
  };
  RoamController2.prototype.dispose = function() {
    this.disable();
  };
  RoamController2.prototype._mousedownHandler = function(e2) {
    if (isMiddleOrRightButtonOnMouseUpDown(e2) || e2.target && e2.target.draggable) {
      return;
    }
    var x = e2.offsetX;
    var y = e2.offsetY;
    if (this.pointerChecker && this.pointerChecker(e2, x, y)) {
      this._x = x;
      this._y = y;
      this._dragging = true;
    }
  };
  RoamController2.prototype._mousemoveHandler = function(e2) {
    if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e2, this._opt) || e2.gestureEvent === "pinch" || isTaken(this._zr, "globalPan")) {
      return;
    }
    var x = e2.offsetX;
    var y = e2.offsetY;
    var oldX = this._x;
    var oldY = this._y;
    var dx = x - oldX;
    var dy = y - oldY;
    this._x = x;
    this._y = y;
    this._opt.preventDefaultMouseMove && stop(e2.event);
    trigger$1(this, "pan", "moveOnMouseMove", e2, {
      dx,
      dy,
      oldX,
      oldY,
      newX: x,
      newY: y,
      isAvailableBehavior: null
    });
  };
  RoamController2.prototype._mouseupHandler = function(e2) {
    if (!isMiddleOrRightButtonOnMouseUpDown(e2)) {
      this._dragging = false;
    }
  };
  RoamController2.prototype._mousewheelHandler = function(e2) {
    var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e2, this._opt);
    var shouldMove = isAvailableBehavior("moveOnMouseWheel", e2, this._opt);
    var wheelDelta = e2.wheelDelta;
    var absWheelDeltaDelta = Math.abs(wheelDelta);
    var originX = e2.offsetX;
    var originY = e2.offsetY;
    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    }
    if (shouldZoom) {
      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      var scale2 = wheelDelta > 0 ? factor : 1 / factor;
      checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e2, {
        scale: scale2,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
    if (shouldMove) {
      var absDelta = Math.abs(wheelDelta);
      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e2, {
        scrollDelta,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
  };
  RoamController2.prototype._pinchHandler = function(e2) {
    if (isTaken(this._zr, "globalPan")) {
      return;
    }
    var scale2 = e2.pinchScale > 1 ? 1.1 : 1 / 1.1;
    checkPointerAndTrigger(this, "zoom", null, e2, {
      scale: scale2,
      originX: e2.pinchX,
      originY: e2.pinchY,
      isAvailableBehavior: null
    });
  };
  return RoamController2;
}(Eventful$1);
function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  if (controller.pointerChecker && controller.pointerChecker(e2, contollerEvent.originX, contollerEvent.originY)) {
    stop(e2.event);
    trigger$1(controller, eventName, behaviorToCheck, e2, contollerEvent);
  }
}
function trigger$1(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  contollerEvent.isAvailableBehavior = bind$1(isAvailableBehavior, null, behaviorToCheck, e2);
  controller.trigger(eventName, contollerEvent);
}
function isAvailableBehavior(behaviorToCheck, e2, settings) {
  var setting = settings[behaviorToCheck];
  return !behaviorToCheck || setting && (!isString(setting) || e2.event[setting + "Key"]);
}
var RoamController$1 = RoamController;
function updateViewOnPan(controllerHost, dx, dy) {
  var target = controllerHost.target;
  target.x += dx;
  target.y += dy;
  target.dirty();
}
function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
  var target = controllerHost.target;
  var zoomLimit = controllerHost.zoomLimit;
  var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
  newZoom *= zoomDelta;
  if (zoomLimit) {
    var zoomMin = zoomLimit.min || 0;
    var zoomMax = zoomLimit.max || Infinity;
    newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
  }
  var zoomScale = newZoom / controllerHost.zoom;
  controllerHost.zoom = newZoom;
  target.x -= (zoomX - target.x) * (zoomScale - 1);
  target.y -= (zoomY - target.y) * (zoomScale - 1);
  target.scaleX *= zoomScale;
  target.scaleY *= zoomScale;
  target.dirty();
}
var IRRELEVANT_EXCLUDES = {
  "axisPointer": 1,
  "tooltip": 1,
  "brush": 1
};
function onIrrelevantElement(e2, api, targetCoordSysModel) {
  var model = api.getComponentByElement(e2.topTarget);
  var coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;
}
function parseXML(svg) {
  if (isString(svg)) {
    var parser = new DOMParser();
    svg = parser.parseFromString(svg, "text/xml");
  }
  var svgNode = svg;
  if (svgNode.nodeType === 9) {
    svgNode = svgNode.firstChild;
  }
  while (svgNode.nodeName.toLowerCase() !== "svg" || svgNode.nodeType !== 1) {
    svgNode = svgNode.nextSibling;
  }
  return svgNode;
}
var nodeParsers;
var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
  "fill": "fill",
  "stroke": "stroke",
  "stroke-width": "lineWidth",
  "opacity": "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  "visibility": "visibility",
  "display": "display"
};
var INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP);
var SELF_STYLE_ATTRIBUTES_MAP = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
};
var SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP);
var SVGParser = function() {
  function SVGParser2() {
    this._defs = {};
    this._root = null;
  }
  SVGParser2.prototype.parse = function(xml, opt) {
    opt = opt || {};
    var svg = parseXML(xml);
    this._defsUsePending = [];
    var root2 = new Group$4();
    this._root = root2;
    var named = [];
    var viewBox = svg.getAttribute("viewBox") || "";
    var width = parseFloat(svg.getAttribute("width") || opt.width);
    var height = parseFloat(svg.getAttribute("height") || opt.height);
    isNaN(width) && (width = null);
    isNaN(height) && (height = null);
    parseAttributes(svg, root2, null, true, false);
    var child = svg.firstChild;
    while (child) {
      this._parseNode(child, root2, named, null, false, false);
      child = child.nextSibling;
    }
    applyDefs(this._defs, this._defsUsePending);
    this._defsUsePending = [];
    var viewBoxRect;
    var viewBoxTransform;
    if (viewBox) {
      var viewBoxArr = splitNumberSequence(viewBox);
      if (viewBoxArr.length >= 4) {
        viewBoxRect = {
          x: parseFloat(viewBoxArr[0] || 0),
          y: parseFloat(viewBoxArr[1] || 0),
          width: parseFloat(viewBoxArr[2]),
          height: parseFloat(viewBoxArr[3])
        };
      }
    }
    if (viewBoxRect && width != null && height != null) {
      viewBoxTransform = makeViewBoxTransform(viewBoxRect, { x: 0, y: 0, width, height });
      if (!opt.ignoreViewBox) {
        var elRoot = root2;
        root2 = new Group$4();
        root2.add(elRoot);
        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
        elRoot.x = viewBoxTransform.x;
        elRoot.y = viewBoxTransform.y;
      }
    }
    if (!opt.ignoreRootClip && width != null && height != null) {
      root2.setClipPath(new Rect$3({
        shape: { x: 0, y: 0, width, height }
      }));
    }
    return {
      root: root2,
      width,
      height,
      viewBoxRect,
      viewBoxTransform,
      named
    };
  };
  SVGParser2.prototype._parseNode = function(xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
    var nodeName = xmlNode.nodeName.toLowerCase();
    var el;
    var namedFromForSub = namedFrom;
    if (nodeName === "defs") {
      isInDefs = true;
    }
    if (nodeName === "text") {
      isInText = true;
    }
    if (nodeName === "defs" || nodeName === "switch") {
      el = parentGroup;
    } else {
      if (!isInDefs) {
        var parser_1 = nodeParsers[nodeName];
        if (parser_1 && hasOwn(nodeParsers, nodeName)) {
          el = parser_1.call(this, xmlNode, parentGroup);
          var nameAttr = xmlNode.getAttribute("name");
          if (nameAttr) {
            var newNamed = {
              name: nameAttr,
              namedFrom: null,
              svgNodeTagLower: nodeName,
              el
            };
            named.push(newNamed);
            if (nodeName === "g") {
              namedFromForSub = newNamed;
            }
          } else if (namedFrom) {
            named.push({
              name: namedFrom.name,
              namedFrom,
              svgNodeTagLower: nodeName,
              el
            });
          }
          parentGroup.add(el);
        }
      }
      var parser = paintServerParsers[nodeName];
      if (parser && hasOwn(paintServerParsers, nodeName)) {
        var def = parser.call(this, xmlNode);
        var id = xmlNode.getAttribute("id");
        if (id) {
          this._defs[id] = def;
        }
      }
    }
    if (el && el.isGroup) {
      var child = xmlNode.firstChild;
      while (child) {
        if (child.nodeType === 1) {
          this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);
        } else if (child.nodeType === 3 && isInText) {
          this._parseText(child, el);
        }
        child = child.nextSibling;
      }
    }
  };
  SVGParser2.prototype._parseText = function(xmlNode, parentGroup) {
    var text = new TSpan$1({
      style: {
        text: xmlNode.textContent
      },
      silent: true,
      x: this._textX || 0,
      y: this._textY || 0
    });
    inheritStyle(parentGroup, text);
    parseAttributes(xmlNode, text, this._defsUsePending, false, false);
    applyTextAlignment(text, parentGroup);
    var textStyle = text.style;
    var fontSize = textStyle.fontSize;
    if (fontSize && fontSize < 9) {
      textStyle.fontSize = 9;
      text.scaleX *= fontSize / 9;
      text.scaleY *= fontSize / 9;
    }
    var font = (textStyle.fontSize || textStyle.fontFamily) && [
      textStyle.fontStyle,
      textStyle.fontWeight,
      (textStyle.fontSize || 12) + "px",
      textStyle.fontFamily || "sans-serif"
    ].join(" ");
    textStyle.font = font;
    var rect = text.getBoundingRect();
    this._textX += rect.width;
    parentGroup.add(text);
    return text;
  };
  SVGParser2.internalField = function() {
    nodeParsers = {
      "g": function(xmlNode, parentGroup) {
        var g2 = new Group$4();
        inheritStyle(parentGroup, g2);
        parseAttributes(xmlNode, g2, this._defsUsePending, false, false);
        return g2;
      },
      "rect": function(xmlNode, parentGroup) {
        var rect = new Rect$3();
        inheritStyle(parentGroup, rect);
        parseAttributes(xmlNode, rect, this._defsUsePending, false, false);
        rect.setShape({
          x: parseFloat(xmlNode.getAttribute("x") || "0"),
          y: parseFloat(xmlNode.getAttribute("y") || "0"),
          width: parseFloat(xmlNode.getAttribute("width") || "0"),
          height: parseFloat(xmlNode.getAttribute("height") || "0")
        });
        rect.silent = true;
        return rect;
      },
      "circle": function(xmlNode, parentGroup) {
        var circle = new Circle$1();
        inheritStyle(parentGroup, circle);
        parseAttributes(xmlNode, circle, this._defsUsePending, false, false);
        circle.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
          cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
          r: parseFloat(xmlNode.getAttribute("r") || "0")
        });
        circle.silent = true;
        return circle;
      },
      "line": function(xmlNode, parentGroup) {
        var line = new Line$3();
        inheritStyle(parentGroup, line);
        parseAttributes(xmlNode, line, this._defsUsePending, false, false);
        line.setShape({
          x1: parseFloat(xmlNode.getAttribute("x1") || "0"),
          y1: parseFloat(xmlNode.getAttribute("y1") || "0"),
          x2: parseFloat(xmlNode.getAttribute("x2") || "0"),
          y2: parseFloat(xmlNode.getAttribute("y2") || "0")
        });
        line.silent = true;
        return line;
      },
      "ellipse": function(xmlNode, parentGroup) {
        var ellipse = new Ellipse$1();
        inheritStyle(parentGroup, ellipse);
        parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false);
        ellipse.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
          cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
          rx: parseFloat(xmlNode.getAttribute("rx") || "0"),
          ry: parseFloat(xmlNode.getAttribute("ry") || "0")
        });
        ellipse.silent = true;
        return ellipse;
      },
      "polygon": function(xmlNode, parentGroup) {
        var pointsStr = xmlNode.getAttribute("points");
        var pointsArr;
        if (pointsStr) {
          pointsArr = parsePoints(pointsStr);
        }
        var polygon = new Polygon$1({
          shape: {
            points: pointsArr || []
          },
          silent: true
        });
        inheritStyle(parentGroup, polygon);
        parseAttributes(xmlNode, polygon, this._defsUsePending, false, false);
        return polygon;
      },
      "polyline": function(xmlNode, parentGroup) {
        var pointsStr = xmlNode.getAttribute("points");
        var pointsArr;
        if (pointsStr) {
          pointsArr = parsePoints(pointsStr);
        }
        var polyline = new Polyline$3({
          shape: {
            points: pointsArr || []
          },
          silent: true
        });
        inheritStyle(parentGroup, polyline);
        parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);
        return polyline;
      },
      "image": function(xmlNode, parentGroup) {
        var img = new ZRImage$1();
        inheritStyle(parentGroup, img);
        parseAttributes(xmlNode, img, this._defsUsePending, false, false);
        img.setStyle({
          image: xmlNode.getAttribute("xlink:href") || xmlNode.getAttribute("href"),
          x: +xmlNode.getAttribute("x"),
          y: +xmlNode.getAttribute("y"),
          width: +xmlNode.getAttribute("width"),
          height: +xmlNode.getAttribute("height")
        });
        img.silent = true;
        return img;
      },
      "text": function(xmlNode, parentGroup) {
        var x = xmlNode.getAttribute("x") || "0";
        var y = xmlNode.getAttribute("y") || "0";
        var dx = xmlNode.getAttribute("dx") || "0";
        var dy = xmlNode.getAttribute("dy") || "0";
        this._textX = parseFloat(x) + parseFloat(dx);
        this._textY = parseFloat(y) + parseFloat(dy);
        var g2 = new Group$4();
        inheritStyle(parentGroup, g2);
        parseAttributes(xmlNode, g2, this._defsUsePending, false, true);
        return g2;
      },
      "tspan": function(xmlNode, parentGroup) {
        var x = xmlNode.getAttribute("x");
        var y = xmlNode.getAttribute("y");
        if (x != null) {
          this._textX = parseFloat(x);
        }
        if (y != null) {
          this._textY = parseFloat(y);
        }
        var dx = xmlNode.getAttribute("dx") || "0";
        var dy = xmlNode.getAttribute("dy") || "0";
        var g2 = new Group$4();
        inheritStyle(parentGroup, g2);
        parseAttributes(xmlNode, g2, this._defsUsePending, false, true);
        this._textX += parseFloat(dx);
        this._textY += parseFloat(dy);
        return g2;
      },
      "path": function(xmlNode, parentGroup) {
        var d = xmlNode.getAttribute("d") || "";
        var path = createFromString(d);
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defsUsePending, false, false);
        path.silent = true;
        return path;
      }
    };
  }();
  return SVGParser2;
}();
var paintServerParsers = {
  "lineargradient": function(xmlNode) {
    var x1 = parseInt(xmlNode.getAttribute("x1") || "0", 10);
    var y1 = parseInt(xmlNode.getAttribute("y1") || "0", 10);
    var x2 = parseInt(xmlNode.getAttribute("x2") || "10", 10);
    var y2 = parseInt(xmlNode.getAttribute("y2") || "0", 10);
    var gradient = new LinearGradient$1(x1, y1, x2, y2);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  },
  "radialgradient": function(xmlNode) {
    var cx = parseInt(xmlNode.getAttribute("cx") || "0", 10);
    var cy = parseInt(xmlNode.getAttribute("cy") || "0", 10);
    var r = parseInt(xmlNode.getAttribute("r") || "0", 10);
    var gradient = new RadialGradient$1(cx, cy, r);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  }
};
function parsePaintServerUnit(xmlNode, gradient) {
  var gradientUnits = xmlNode.getAttribute("gradientUnits");
  if (gradientUnits === "userSpaceOnUse") {
    gradient.global = true;
  }
}
function parseGradientColorStops(xmlNode, gradient) {
  var stop2 = xmlNode.firstChild;
  while (stop2) {
    if (stop2.nodeType === 1 && stop2.nodeName.toLocaleLowerCase() === "stop") {
      var offsetStr = stop2.getAttribute("offset");
      var offset = void 0;
      if (offsetStr && offsetStr.indexOf("%") > 0) {
        offset = parseInt(offsetStr, 10) / 100;
      } else if (offsetStr) {
        offset = parseFloat(offsetStr);
      } else {
        offset = 0;
      }
      var styleVals = {};
      parseInlineStyle(stop2, styleVals, styleVals);
      var stopColor = styleVals.stopColor || stop2.getAttribute("stop-color") || "#000000";
      gradient.colorStops.push({
        offset,
        color: stopColor
      });
    }
    stop2 = stop2.nextSibling;
  }
}
function inheritStyle(parent, child) {
  if (parent && parent.__inheritedStyle) {
    if (!child.__inheritedStyle) {
      child.__inheritedStyle = {};
    }
    defaults(child.__inheritedStyle, parent.__inheritedStyle);
  }
}
function parsePoints(pointsString) {
  var list = splitNumberSequence(pointsString);
  var points2 = [];
  for (var i = 0; i < list.length; i += 2) {
    var x = parseFloat(list[i]);
    var y = parseFloat(list[i + 1]);
    points2.push([x, y]);
  }
  return points2;
}
function parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
  var disp = el;
  var inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};
  var selfStyle = {};
  if (xmlNode.nodeType === 1) {
    parseTransformAttribute(xmlNode, el);
    parseInlineStyle(xmlNode, inheritedStyle, selfStyle);
    if (!onlyInlineStyle) {
      parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);
    }
  }
  disp.style = disp.style || {};
  if (inheritedStyle.fill != null) {
    disp.style.fill = getFillStrokeStyle(disp, "fill", inheritedStyle.fill, defsUsePending);
  }
  if (inheritedStyle.stroke != null) {
    disp.style.stroke = getFillStrokeStyle(disp, "stroke", inheritedStyle.stroke, defsUsePending);
  }
  each$f([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = parseFloat(inheritedStyle[propName]);
    }
  });
  each$f([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = inheritedStyle[propName];
    }
  });
  if (isTextGroup) {
    disp.__selfStyle = selfStyle;
  }
  if (inheritedStyle.lineDash) {
    disp.style.lineDash = map$1(splitNumberSequence(inheritedStyle.lineDash), function(str) {
      return parseFloat(str);
    });
  }
  if (inheritedStyle.visibility === "hidden" || inheritedStyle.visibility === "collapse") {
    disp.invisible = true;
  }
  if (inheritedStyle.display === "none") {
    disp.ignore = true;
  }
}
function applyTextAlignment(text, parentGroup) {
  var parentSelfStyle = parentGroup.__selfStyle;
  if (parentSelfStyle) {
    var textBaseline = parentSelfStyle.textBaseline;
    var zrTextBaseline = textBaseline;
    if (!textBaseline || textBaseline === "auto") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "baseline") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "before-edge" || textBaseline === "text-before-edge") {
      zrTextBaseline = "top";
    } else if (textBaseline === "after-edge" || textBaseline === "text-after-edge") {
      zrTextBaseline = "bottom";
    } else if (textBaseline === "central" || textBaseline === "mathematical") {
      zrTextBaseline = "middle";
    }
    text.style.textBaseline = zrTextBaseline;
  }
  var parentInheritedStyle = parentGroup.__inheritedStyle;
  if (parentInheritedStyle) {
    var textAlign = parentInheritedStyle.textAlign;
    var zrTextAlign = textAlign;
    if (textAlign) {
      if (textAlign === "middle") {
        zrTextAlign = "center";
      }
      text.style.textAlign = zrTextAlign;
    }
  }
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(el, method, str, defsUsePending) {
  var urlMatch = str && str.match(urlRegex);
  if (urlMatch) {
    var url = trim$1(urlMatch[1]);
    defsUsePending.push([el, method, url]);
    return;
  }
  if (str === "none") {
    str = null;
  }
  return str;
}
function applyDefs(defs, defsUsePending) {
  for (var i = 0; i < defsUsePending.length; i++) {
    var item = defsUsePending[i];
    item[0].style[item[1]] = defs[item[2]];
  }
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(rawStr) {
  return rawStr.match(numberReg) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g;
var DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(xmlNode, node) {
  var transform2 = xmlNode.getAttribute("transform");
  if (transform2) {
    transform2 = transform2.replace(/,/g, " ");
    var transformOps_1 = [];
    var mt = null;
    transform2.replace(transformRegex, function(str, type2, value2) {
      transformOps_1.push(type2, value2);
      return "";
    });
    for (var i = transformOps_1.length - 1; i > 0; i -= 2) {
      var value = transformOps_1[i];
      var type = transformOps_1[i - 1];
      var valueArr = splitNumberSequence(value);
      mt = mt || create$2();
      switch (type) {
        case "translate":
          translate(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || "0")]);
          break;
        case "scale":
          scale$1(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
          break;
        case "rotate":
          rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          break;
        case "skewX":
          var sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul(mt, [1, 0, sx, 1, 0, 0], mt);
          break;
        case "skewY":
          var sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul(mt, [1, sy, 0, 1, 0, 0], mt);
          break;
        case "matrix":
          mt[0] = parseFloat(valueArr[0]);
          mt[1] = parseFloat(valueArr[1]);
          mt[2] = parseFloat(valueArr[2]);
          mt[3] = parseFloat(valueArr[3]);
          mt[4] = parseFloat(valueArr[4]);
          mt[5] = parseFloat(valueArr[5]);
          break;
      }
    }
    node.setLocalTransform(mt);
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  var style = xmlNode.getAttribute("style");
  if (!style) {
    return;
  }
  styleRegex.lastIndex = 0;
  var styleRegResult;
  while ((styleRegResult = styleRegex.exec(style)) != null) {
    var svgStlAttr = styleRegResult[1];
    var zrInheritableStlAttr = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrInheritableStlAttr) {
      inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];
    }
    var zrSelfStlAttr = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrSelfStlAttr) {
      selfStyleResult[zrSelfStlAttr] = styleRegResult[2];
    }
  }
}
function parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  for (var i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    var svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i];
    var attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
  for (var i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    var svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i];
    var attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
}
function makeViewBoxTransform(viewBoxRect, boundingRect) {
  var scaleX = boundingRect.width / viewBoxRect.width;
  var scaleY = boundingRect.height / viewBoxRect.height;
  var scale2 = Math.min(scaleX, scaleY);
  return {
    scale: scale2,
    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale2 + (boundingRect.x + boundingRect.width / 2),
    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale2 + (boundingRect.y + boundingRect.height / 2)
  };
}
function parseSVG(xml, opt) {
  var parser = new SVGParser();
  return parser.parse(xml, opt);
}
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  "text",
  "tspan",
  "g"
]);
var GeoSVGResource = function() {
  function GeoSVGResource2(mapName, svg) {
    this.type = "geoSVG";
    this._usedGraphicMap = createHashMap();
    this._freedGraphics = [];
    this._mapName = mapName;
    this._parsedXML = parseXML(svg);
  }
  GeoSVGResource2.prototype.load = function() {
    var firstGraphic = this._firstGraphic;
    if (!firstGraphic) {
      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);
      this._freedGraphics.push(firstGraphic);
      this._boundingRect = this._firstGraphic.boundingRect.clone();
      var _a2 = createRegions(firstGraphic.named), regions = _a2.regions, regionsMap = _a2.regionsMap;
      this._regions = regions;
      this._regionsMap = regionsMap;
    }
    return {
      boundingRect: this._boundingRect,
      regions: this._regions,
      regionsMap: this._regionsMap
    };
  };
  GeoSVGResource2.prototype._buildGraphic = function(svgXML) {
    var result;
    var rootFromParse;
    try {
      result = svgXML && parseSVG(svgXML, {
        ignoreViewBox: true,
        ignoreRootClip: true
      }) || {};
      rootFromParse = result.root;
      assert(rootFromParse != null);
    } catch (e2) {
      throw new Error("Invalid svg format\n" + e2.message);
    }
    var root2 = new Group$4();
    root2.add(rootFromParse);
    root2.isGeoSVGGraphicRoot = true;
    var svgWidth = result.width;
    var svgHeight = result.height;
    var viewBoxRect = result.viewBoxRect;
    var boundingRect = this._boundingRect;
    if (!boundingRect) {
      var bRectX = void 0;
      var bRectY = void 0;
      var bRectWidth = void 0;
      var bRectHeight = void 0;
      if (svgWidth != null) {
        bRectX = 0;
        bRectWidth = svgWidth;
      } else if (viewBoxRect) {
        bRectX = viewBoxRect.x;
        bRectWidth = viewBoxRect.width;
      }
      if (svgHeight != null) {
        bRectY = 0;
        bRectHeight = svgHeight;
      } else if (viewBoxRect) {
        bRectY = viewBoxRect.y;
        bRectHeight = viewBoxRect.height;
      }
      if (bRectX == null || bRectY == null) {
        var calculatedBoundingRect = rootFromParse.getBoundingRect();
        if (bRectX == null) {
          bRectX = calculatedBoundingRect.x;
          bRectWidth = calculatedBoundingRect.width;
        }
        if (bRectY == null) {
          bRectY = calculatedBoundingRect.y;
          bRectHeight = calculatedBoundingRect.height;
        }
      }
      boundingRect = this._boundingRect = new BoundingRect$1(bRectX, bRectY, bRectWidth, bRectHeight);
    }
    if (viewBoxRect) {
      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect);
      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;
      rootFromParse.x = viewBoxTransform.x;
      rootFromParse.y = viewBoxTransform.y;
    }
    root2.setClipPath(new Rect$3({
      shape: boundingRect.plain()
    }));
    var named = [];
    each$f(result.named, function(namedItem) {
      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
        named.push(namedItem);
        setSilent(namedItem.el);
      }
    });
    return {
      root: root2,
      boundingRect,
      named
    };
  };
  GeoSVGResource2.prototype.useGraphic = function(hostKey) {
    var usedRootMap = this._usedGraphicMap;
    var svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      return svgGraphic;
    }
    svgGraphic = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML);
    usedRootMap.set(hostKey, svgGraphic);
    return svgGraphic;
  };
  GeoSVGResource2.prototype.freeGraphic = function(hostKey) {
    var usedRootMap = this._usedGraphicMap;
    var svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      usedRootMap.removeKey(hostKey);
      this._freedGraphics.push(svgGraphic);
    }
  };
  return GeoSVGResource2;
}();
function setSilent(el) {
  el.silent = false;
  if (el.isGroup) {
    el.traverse(function(child) {
      child.silent = false;
    });
  }
}
function createRegions(named) {
  var regions = [];
  var regionsMap = createHashMap();
  each$f(named, function(namedItem) {
    if (namedItem.namedFrom != null) {
      return;
    }
    var region = new GeoSVGRegion(namedItem.name, namedItem.el);
    regions.push(region);
    regionsMap.set(namedItem.name, region);
  });
  return {
    regions,
    regionsMap
  };
}
var geoCoord = [126, 25];
var nanhaiName = "\u5357\u6D77\u8BF8\u5C9B";
var points$1 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var i = 0; i < points$1.length; i++) {
  for (var k = 0; k < points$1[i].length; k++) {
    points$1[i][k][0] /= 10.5;
    points$1[i][k][1] /= -10.5 / 0.75;
    points$1[i][k][0] += geoCoord[0];
    points$1[i][k][1] += geoCoord[1];
  }
}
function fixNanhai(mapType, regions) {
  if (mapType === "china") {
    for (var i = 0; i < regions.length; i++) {
      if (regions[i].name === nanhaiName) {
        return;
      }
    }
    regions.push(new GeoJSONRegion(nanhaiName, map$1(points$1, function(exterior) {
      return {
        type: "polygon",
        exterior
      };
    }), geoCoord));
  }
}
var coordsOffsetMap = {
  "\u5357\u6D77\u8BF8\u5C9B": [32, 80],
  "\u5E7F\u4E1C": [0, -10],
  "\u9999\u6E2F": [10, 5],
  "\u6FB3\u95E8": [-10, 10],
  "\u5929\u6D25": [5, 5]
};
function fixTextCoords(mapType, region) {
  if (mapType === "china") {
    var coordFix = coordsOffsetMap[region.name];
    if (coordFix) {
      var cp = region.getCenter();
      cp[0] += coordFix[0] / 10.5;
      cp[1] += -coordFix[1] / (10.5 / 0.75);
      region.setCenter(cp);
    }
  }
}
var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function fixDiaoyuIsland(mapType, region) {
  if (mapType === "china" && region.name === "\u53F0\u6E7E") {
    region.geometries.push({
      type: "polygon",
      exterior: points[0]
    });
  }
}
var DEFAULT_NAME_PROPERTY = "name";
var GeoJSONResource = function() {
  function GeoJSONResource2(mapName, geoJSON, specialAreas) {
    this.type = "geoJSON";
    this._parsedMap = createHashMap();
    this._mapName = mapName;
    this._specialAreas = specialAreas;
    this._geoJSON = parseInput(geoJSON);
  }
  GeoJSONResource2.prototype.load = function(nameMap, nameProperty) {
    nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;
    var parsed = this._parsedMap.get(nameProperty);
    if (!parsed) {
      var rawRegions = this._parseToRegions(nameProperty);
      parsed = this._parsedMap.set(nameProperty, {
        regions: rawRegions,
        boundingRect: calculateBoundingRect(rawRegions)
      });
    }
    var regionsMap = createHashMap();
    var finalRegions = [];
    each$f(parsed.regions, function(region) {
      var regionName = region.name;
      if (nameMap && hasOwn(nameMap, regionName)) {
        region = region.cloneShallow(regionName = nameMap[regionName]);
      }
      finalRegions.push(region);
      regionsMap.set(regionName, region);
    });
    return {
      regions: finalRegions,
      boundingRect: parsed.boundingRect || new BoundingRect$1(0, 0, 0, 0),
      regionsMap
    };
  };
  GeoJSONResource2.prototype._parseToRegions = function(nameProperty) {
    var mapName = this._mapName;
    var geoJSON = this._geoJSON;
    var rawRegions;
    try {
      rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];
    } catch (e2) {
      throw new Error("Invalid geoJson format\n" + e2.message);
    }
    fixNanhai(mapName, rawRegions);
    each$f(rawRegions, function(region) {
      var regionName = region.name;
      fixTextCoords(mapName, region);
      fixDiaoyuIsland(mapName, region);
      var specialArea = this._specialAreas && this._specialAreas[regionName];
      if (specialArea) {
        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
      }
    }, this);
    return rawRegions;
  };
  GeoJSONResource2.prototype.getMapForUser = function() {
    return {
      geoJson: this._geoJSON,
      geoJSON: this._geoJSON,
      specialAreas: this._specialAreas
    };
  };
  return GeoJSONResource2;
}();
function calculateBoundingRect(regions) {
  var rect;
  for (var i = 0; i < regions.length; i++) {
    var regionRect = regions[i].getBoundingRect();
    rect = rect || regionRect.clone();
    rect.union(regionRect);
  }
  return rect;
}
function parseInput(source) {
  return !isString(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
}
var storage = createHashMap();
var geoSourceManager = {
  registerMap: function(mapName, rawDef, rawSpecialAreas) {
    if (rawDef.svg) {
      var resource = new GeoSVGResource(mapName, rawDef.svg);
      storage.set(mapName, resource);
    } else {
      var geoJSON = rawDef.geoJson || rawDef.geoJSON;
      if (geoJSON && !rawDef.features) {
        rawSpecialAreas = rawDef.specialAreas;
      } else {
        geoJSON = rawDef;
      }
      var resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);
      storage.set(mapName, resource);
    }
  },
  getGeoResource: function(mapName) {
    return storage.get(mapName);
  },
  getMapForUser: function(mapName) {
    var resource = storage.get(mapName);
    return resource && resource.type === "geoJSON" && resource.getMapForUser();
  },
  load: function(mapName, nameMap, nameProperty) {
    var resource = storage.get(mapName);
    if (!resource) {
      return;
    }
    return resource.load(nameMap, nameProperty);
  }
};
var OPTION_STYLE_ENABLED_TAGS = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"];
var OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS);
var STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var mapLabelRaw = makeInner();
function getFixedItemStyle(model) {
  var itemStyle = model.getItemStyle();
  var areaColor = model.get("areaColor");
  if (areaColor != null) {
    itemStyle.fill = areaColor;
  }
  return itemStyle;
}
function fixLineStyle(styleHost) {
  var style = styleHost.style;
  if (style) {
    style.stroke = style.stroke || style.fill;
    style.fill = null;
  }
}
var MapDraw = function() {
  function MapDraw2(api) {
    var group = new Group$4();
    this.uid = getUID("ec_map_draw");
    this._controller = new RoamController$1(api.getZr());
    this._controllerHost = {
      target: group
    };
    this.group = group;
    group.add(this._regionsGroup = new Group$4());
    group.add(this._svgGroup = new Group$4());
  }
  MapDraw2.prototype.draw = function(mapOrGeoModel, ecModel, api, fromView, payload) {
    var isGeo = mapOrGeoModel.mainType === "geo";
    var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
    isGeo && ecModel.eachComponent({
      mainType: "series",
      subType: "map"
    }, function(mapSeries) {
      if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
        data = mapSeries.getData();
      }
    });
    var geo = mapOrGeoModel.coordinateSystem;
    var regionsGroup = this._regionsGroup;
    var group = this.group;
    var transformInfo = geo.getTransformInfo();
    var transformInfoRaw = transformInfo.raw;
    var transformInfoRoam = transformInfo.roam;
    var isFirstDraw = !regionsGroup.childAt(0) || payload;
    if (isFirstDraw) {
      group.x = transformInfoRoam.x;
      group.y = transformInfoRoam.y;
      group.scaleX = transformInfoRoam.scaleX;
      group.scaleY = transformInfoRoam.scaleY;
      group.dirty();
    } else {
      updateProps$1(group, transformInfoRoam, mapOrGeoModel);
    }
    var isVisualEncodedByVisualMap = data && data.getVisual("visualMeta") && data.getVisual("visualMeta").length > 0;
    var viewBuildCtx = {
      api,
      geo,
      mapOrGeoModel,
      data,
      isVisualEncodedByVisualMap,
      isGeo,
      transformInfoRaw
    };
    if (geo.resourceType === "geoJSON") {
      this._buildGeoJSON(viewBuildCtx);
    } else if (geo.resourceType === "geoSVG") {
      this._buildSVG(viewBuildCtx);
    }
    this._updateController(mapOrGeoModel, ecModel, api);
    this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);
  };
  MapDraw2.prototype._buildGeoJSON = function(viewBuildCtx) {
    var regionsGroupByName = this._regionsGroupByName = createHashMap();
    var regionsInfoByName = createHashMap();
    var regionsGroup = this._regionsGroup;
    var transformInfoRaw = viewBuildCtx.transformInfoRaw;
    var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
    var data = viewBuildCtx.data;
    var projection = viewBuildCtx.geo.projection;
    var projectionStream = projection && projection.stream;
    function transformPoint(point, project) {
      if (project) {
        point = project(point);
      }
      return point && [point[0] * transformInfoRaw.scaleX + transformInfoRaw.x, point[1] * transformInfoRaw.scaleY + transformInfoRaw.y];
    }
    function transformPolygonPoints(inPoints) {
      var outPoints = [];
      var project = !projectionStream && projection && projection.project;
      for (var i = 0; i < inPoints.length; ++i) {
        var newPt = transformPoint(inPoints[i], project);
        newPt && outPoints.push(newPt);
      }
      return outPoints;
    }
    function getPolyShape(points2) {
      return {
        shape: {
          points: transformPolygonPoints(points2)
        }
      };
    }
    regionsGroup.removeAll();
    each$f(viewBuildCtx.geo.regions, function(region) {
      var regionName = region.name;
      var regionGroup = regionsGroupByName.get(regionName);
      var _a2 = regionsInfoByName.get(regionName) || {}, dataIdx = _a2.dataIdx, regionModel = _a2.regionModel;
      if (!regionGroup) {
        regionGroup = regionsGroupByName.set(regionName, new Group$4());
        regionsGroup.add(regionGroup);
        dataIdx = data ? data.indexOfName(regionName) : null;
        regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;
        regionsInfoByName.set(regionName, {
          dataIdx,
          regionModel
        });
      }
      var polygonSubpaths = [];
      var polylineSubpaths = [];
      each$f(region.geometries, function(geometry) {
        if (geometry.type === "polygon") {
          var polys = [geometry.exterior].concat(geometry.interiors || []);
          if (projectionStream) {
            polys = projectPolys(polys, projectionStream);
          }
          each$f(polys, function(poly) {
            polygonSubpaths.push(new Polygon$1(getPolyShape(poly)));
          });
        } else {
          var points2 = geometry.points;
          if (projectionStream) {
            points2 = projectPolys(points2, projectionStream, true);
          }
          each$f(points2, function(points3) {
            polylineSubpaths.push(new Polyline$3(getPolyShape(points3)));
          });
        }
      });
      var centerPt = transformPoint(region.getCenter(), projection && projection.project);
      function createCompoundPath(subpaths, isLine) {
        if (!subpaths.length) {
          return;
        }
        var compoundPath = new CompoundPath$1({
          culling: true,
          segmentIgnoreThreshold: 1,
          shape: {
            paths: subpaths
          }
        });
        regionGroup.add(compoundPath);
        applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);
        resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);
        if (isLine) {
          fixLineStyle(compoundPath);
          each$f(compoundPath.states, fixLineStyle);
        }
      }
      createCompoundPath(polygonSubpaths);
      createCompoundPath(polylineSubpaths, true);
    });
    regionsGroupByName.each(function(regionGroup, regionName) {
      var _a2 = regionsInfoByName.get(regionName), dataIdx = _a2.dataIdx, regionModel = _a2.regionModel;
      resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);
      resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
      resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
    }, this);
  };
  MapDraw2.prototype._buildSVG = function(viewBuildCtx) {
    var mapName = viewBuildCtx.geo.map;
    var transformInfoRaw = viewBuildCtx.transformInfoRaw;
    this._svgGroup.x = transformInfoRaw.x;
    this._svgGroup.y = transformInfoRaw.y;
    this._svgGroup.scaleX = transformInfoRaw.scaleX;
    this._svgGroup.scaleY = transformInfoRaw.scaleY;
    if (this._svgResourceChanged(mapName)) {
      this._freeSVG();
      this._useSVG(mapName);
    }
    var svgDispatcherMap = this._svgDispatcherMap = createHashMap();
    var focusSelf = false;
    each$f(this._svgGraphicRecord.named, function(namedItem) {
      var regionName = namedItem.name;
      var mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
      var data = viewBuildCtx.data;
      var svgNodeTagLower = namedItem.svgNodeTagLower;
      var el = namedItem.el;
      var dataIdx = data ? data.indexOfName(regionName) : null;
      var regionModel = mapOrGeoModel.getRegionModel(regionName);
      if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable$1) {
        applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);
      }
      if (el instanceof Displayable$1) {
        el.culling = true;
      }
      el.z2EmphasisLift = 0;
      if (!namedItem.namedFrom) {
        if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {
          resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);
        }
        resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);
        resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
        if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
          var focus_1 = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
          if (focus_1 === "self") {
            focusSelf = true;
          }
          var els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, []);
          els.push(el);
        }
      }
    }, this);
    this._enableBlurEntireSVG(focusSelf, viewBuildCtx);
  };
  MapDraw2.prototype._enableBlurEntireSVG = function(focusSelf, viewBuildCtx) {
    if (focusSelf && viewBuildCtx.isGeo) {
      var blurStyle = viewBuildCtx.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle();
      var opacity_1 = blurStyle.opacity;
      this._svgGraphicRecord.root.traverse(function(el) {
        if (!el.isGroup) {
          setDefaultStateProxy(el);
          var style = el.ensureState("blur").style || {};
          if (style.opacity == null && opacity_1 != null) {
            style.opacity = opacity_1;
          }
          el.ensureState("emphasis");
        }
      });
    }
  };
  MapDraw2.prototype.remove = function() {
    this._regionsGroup.removeAll();
    this._regionsGroupByName = null;
    this._svgGroup.removeAll();
    this._freeSVG();
    this._controller.dispose();
    this._controllerHost = null;
  };
  MapDraw2.prototype.findHighDownDispatchers = function(name, geoModel) {
    if (name == null) {
      return [];
    }
    var geo = geoModel.coordinateSystem;
    if (geo.resourceType === "geoJSON") {
      var regionsGroupByName = this._regionsGroupByName;
      if (regionsGroupByName) {
        var regionGroup = regionsGroupByName.get(name);
        return regionGroup ? [regionGroup] : [];
      }
    } else if (geo.resourceType === "geoSVG") {
      return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || [];
    }
  };
  MapDraw2.prototype._svgResourceChanged = function(mapName) {
    return this._svgMapName !== mapName;
  };
  MapDraw2.prototype._useSVG = function(mapName) {
    var resource = geoSourceManager.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      var svgGraphic = resource.useGraphic(this.uid);
      this._svgGroup.add(svgGraphic.root);
      this._svgGraphicRecord = svgGraphic;
      this._svgMapName = mapName;
    }
  };
  MapDraw2.prototype._freeSVG = function() {
    var mapName = this._svgMapName;
    if (mapName == null) {
      return;
    }
    var resource = geoSourceManager.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      resource.freeGraphic(this.uid);
    }
    this._svgGraphicRecord = null;
    this._svgDispatcherMap = null;
    this._svgGroup.removeAll();
    this._svgMapName = null;
  };
  MapDraw2.prototype._updateController = function(mapOrGeoModel, ecModel, api) {
    var geo = mapOrGeoModel.coordinateSystem;
    var controller = this._controller;
    var controllerHost = this._controllerHost;
    controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
    controllerHost.zoom = geo.getZoom();
    controller.enable(mapOrGeoModel.get("roam") || false);
    var mainType = mapOrGeoModel.mainType;
    function makeActionBase() {
      var action = {
        type: "geoRoam",
        componentType: mainType
      };
      action[mainType + "Id"] = mapOrGeoModel.id;
      return action;
    }
    controller.off("pan").on("pan", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api.dispatchAction(extend$1(makeActionBase(), {
        dx: e2.dx,
        dy: e2.dy,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.off("zoom").on("zoom", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api.dispatchAction(extend$1(makeActionBase(), {
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.setPointerChecker(function(e2, x, y) {
      return geo.containPoint([x, y]) && !onIrrelevantElement(e2, api, mapOrGeoModel);
    });
  };
  MapDraw2.prototype.resetForLabelLayout = function() {
    this.group.traverse(function(el) {
      var label = el.getTextContent();
      if (label) {
        label.ignore = mapLabelRaw(label).ignore;
      }
    });
  };
  MapDraw2.prototype._updateMapSelectHandler = function(mapOrGeoModel, regionsGroup, api, fromView) {
    var mapDraw = this;
    regionsGroup.off("mousedown");
    regionsGroup.off("click");
    if (mapOrGeoModel.get("selectedMode")) {
      regionsGroup.on("mousedown", function() {
        mapDraw._mouseDownFlag = true;
      });
      regionsGroup.on("click", function(e2) {
        if (!mapDraw._mouseDownFlag) {
          return;
        }
        mapDraw._mouseDownFlag = false;
      });
    }
  };
  return MapDraw2;
}();
function applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {
  var normalStyleModel = regionModel.getModel("itemStyle");
  var emphasisStyleModel = regionModel.getModel(["emphasis", "itemStyle"]);
  var blurStyleModel = regionModel.getModel(["blur", "itemStyle"]);
  var selectStyleModel = regionModel.getModel(["select", "itemStyle"]);
  var normalStyle = getFixedItemStyle(normalStyleModel);
  var emphasisStyle = getFixedItemStyle(emphasisStyleModel);
  var selectStyle = getFixedItemStyle(selectStyleModel);
  var blurStyle = getFixedItemStyle(blurStyleModel);
  var data = viewBuildCtx.data;
  if (data) {
    var style = data.getItemVisual(dataIndex, "style");
    var decal = data.getItemVisual(dataIndex, "decal");
    if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {
      normalStyle.fill = style.fill;
    }
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api);
    }
  }
  el.setStyle(normalStyle);
  el.style.strokeNoScale = true;
  el.ensureState("emphasis").style = emphasisStyle;
  el.ensureState("select").style = selectStyle;
  el.ensureState("blur").style = blurStyle;
  setDefaultStateProxy(el);
}
function resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, labelXY) {
  var data = viewBuildCtx.data;
  var isGeo = viewBuildCtx.isGeo;
  var isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
  var itemLayout = data && data.getItemLayout(dataIdx);
  if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
    var query = !isGeo ? dataIdx : regionName;
    var labelFetcher = void 0;
    if (!data || dataIdx >= 0) {
      labelFetcher = mapOrGeoModel;
    }
    var specifiedTextOpt = labelXY ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    setLabelStyle(el, getLabelStatesModels(regionModel), {
      labelFetcher,
      labelDataIndex: query,
      defaultText: regionName
    }, specifiedTextOpt);
    var textEl = el.getTextContent();
    if (textEl) {
      mapLabelRaw(textEl).ignore = textEl.ignore;
      if (el.textConfig && labelXY) {
        var rect = el.getBoundingRect().clone();
        el.textConfig.layoutRect = rect;
        el.textConfig.position = [(labelXY[0] - rect.x) / rect.width * 100 + "%", (labelXY[1] - rect.y) / rect.height * 100 + "%"];
      }
    }
    el.disableLabelAnimation = true;
  } else {
    el.removeTextContent();
    el.removeTextConfig();
    el.disableLabelAnimation = null;
  }
}
function resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, dataIdx) {
  if (viewBuildCtx.data) {
    viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);
  } else {
    getECData(eventTrigger).eventData = {
      componentType: "geo",
      componentIndex: mapOrGeoModel.componentIndex,
      geoIndex: mapOrGeoModel.componentIndex,
      name: regionName,
      region: regionModel && regionModel.option || {}
    };
  }
}
function resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  if (!viewBuildCtx.data) {
    setTooltipConfig({
      el,
      componentModel: mapOrGeoModel,
      itemName: regionName,
      itemTooltipOption: regionModel.get("tooltip")
    });
  }
}
function resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  el.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
  var emphasisModel = regionModel.getModel("emphasis");
  var focus = emphasisModel.get("focus");
  toggleHoverEmphasis(el, focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  if (viewBuildCtx.isGeo) {
    enableComponentHighDownFeatures(el, mapOrGeoModel, regionName);
  }
  return focus;
}
function projectPolys(rings, createStream, isLine) {
  var polygons = [];
  var curPoly;
  function startPolygon() {
    curPoly = [];
  }
  function endPolygon() {
    if (curPoly.length) {
      polygons.push(curPoly);
      curPoly = [];
    }
  }
  var stream = createStream({
    polygonStart: startPolygon,
    polygonEnd: endPolygon,
    lineStart: startPolygon,
    lineEnd: endPolygon,
    point: function(x, y) {
      if (isFinite(x) && isFinite(y)) {
        curPoly.push([x, y]);
      }
    },
    sphere: function() {
    }
  });
  !isLine && stream.polygonStart();
  each$f(rings, function(ring) {
    stream.lineStart();
    for (var i = 0; i < ring.length; i++) {
      stream.point(ring[i][0], ring[i][1]);
    }
    stream.lineEnd();
  });
  !isLine && stream.polygonEnd();
  return polygons;
}
var MapDraw$1 = MapDraw;
var MapView = function(_super) {
  __extends(MapView2, _super);
  function MapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MapView2.type;
    return _this;
  }
  MapView2.prototype.render = function(mapModel, ecModel, api, payload) {
    if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
      return;
    }
    var group = this.group;
    group.removeAll();
    if (mapModel.getHostGeoModel()) {
      return;
    }
    if (this._mapDraw && payload && payload.type === "geoRoam") {
      this._mapDraw.resetForLabelLayout();
    }
    if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
      if (mapModel.needsDrawMap) {
        var mapDraw = this._mapDraw || new MapDraw$1(api);
        group.add(mapDraw.group);
        mapDraw.draw(mapModel, ecModel, api, this, payload);
        this._mapDraw = mapDraw;
      } else {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      }
    } else {
      var mapDraw = this._mapDraw;
      mapDraw && group.add(mapDraw.group);
    }
    mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api);
  };
  MapView2.prototype.remove = function() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
    this.group.removeAll();
  };
  MapView2.prototype.dispose = function() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
  };
  MapView2.prototype._renderSymbols = function(mapModel, ecModel, api) {
    var originalData = mapModel.originalData;
    var group = this.group;
    originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
      if (isNaN(value)) {
        return;
      }
      var layout2 = originalData.getItemLayout(originalDataIndex);
      if (!layout2 || !layout2.point) {
        return;
      }
      var point = layout2.point;
      var offset = layout2.offset;
      var circle = new Circle$1({
        style: {
          fill: mapModel.getData().getVisual("style").fill
        },
        shape: {
          cx: point[0] + offset * 9,
          cy: point[1],
          r: 3
        },
        silent: true,
        z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)
      });
      if (!offset) {
        var fullData = mapModel.mainSeries.getData();
        var name_1 = originalData.getName(originalDataIndex);
        var fullIndex_1 = fullData.indexOfName(name_1);
        var itemModel = originalData.getItemModel(originalDataIndex);
        var labelModel = itemModel.getModel("label");
        var regionGroup = fullData.getItemGraphicEl(fullIndex_1);
        setLabelStyle(circle, getLabelStatesModels(itemModel), {
          labelFetcher: {
            getFormattedLabel: function(idx, state) {
              return mapModel.getFormattedLabel(fullIndex_1, state);
            }
          },
          defaultText: name_1
        });
        circle.disableLabelAnimation = true;
        if (!labelModel.get("position")) {
          circle.setTextConfig({
            position: "bottom"
          });
        }
        regionGroup.onHoverStateChange = function(toState) {
          setStatesFlag(circle, toState);
        };
      }
      group.add(circle);
    });
  };
  MapView2.type = "map";
  return MapView2;
}(ChartView$1);
var MapView$1 = MapView;
var MapSeries = function(_super) {
  __extends(MapSeries2, _super);
  function MapSeries2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MapSeries2.type;
    _this.needsDrawMap = false;
    _this.seriesGroup = [];
    _this.getTooltipPosition = function(dataIndex) {
      if (dataIndex != null) {
        var name_1 = this.getData().getName(dataIndex);
        var geo = this.coordinateSystem;
        var region = geo.getRegion(name_1);
        return region && geo.dataToPoint(region.getCenter());
      }
    };
    return _this;
  }
  MapSeries2.prototype.getInitialData = function(option) {
    var data = createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
    var dataNameMap = createHashMap();
    var toAppendNames = [];
    for (var i = 0, len2 = data.count(); i < len2; i++) {
      var name_2 = data.getName(i);
      dataNameMap.set(name_2, true);
    }
    var geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
    each$f(geoSource.regions, function(region) {
      var name = region.name;
      if (!dataNameMap.get(name)) {
        toAppendNames.push(name);
      }
    });
    data.appendValues([], toAppendNames);
    return data;
  };
  MapSeries2.prototype.getHostGeoModel = function() {
    var geoIndex = this.option.geoIndex;
    return geoIndex != null ? this.ecModel.getComponent("geo", geoIndex) : null;
  };
  MapSeries2.prototype.getMapType = function() {
    return (this.getHostGeoModel() || this).option.map;
  };
  MapSeries2.prototype.getRawValue = function(dataIndex) {
    var data = this.getData();
    return data.get(data.mapDimension("value"), dataIndex);
  };
  MapSeries2.prototype.getRegionModel = function(regionName) {
    var data = this.getData();
    return data.getItemModel(data.indexOfName(regionName));
  };
  MapSeries2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var name = data.getName(dataIndex);
    var seriesGroup = this.seriesGroup;
    var seriesNames = [];
    for (var i = 0; i < seriesGroup.length; i++) {
      var otherIndex = seriesGroup[i].originalData.indexOfName(name);
      var valueDim = data.mapDimension("value");
      if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
        seriesNames.push(seriesGroup[i].name);
      }
    }
    return createTooltipMarkup("section", {
      header: seriesNames.join(", "),
      noHeader: !seriesNames.length,
      blocks: [createTooltipMarkup("nameValue", {
        name,
        value
      })]
    });
  };
  MapSeries2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  MapSeries2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  MapSeries2.prototype.getLegendIcon = function(opt) {
    var iconType = opt.icon || "roundRect";
    var icon = createSymbol$1(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);
    icon.setStyle(opt.itemStyle);
    icon.style.stroke = "none";
    if (iconType.indexOf("empty") > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = "#fff";
      icon.style.lineWidth = 2;
    }
    return icon;
  };
  MapSeries2.type = "series.map";
  MapSeries2.dependencies = ["geo"];
  MapSeries2.layoutMode = "box";
  MapSeries2.defaultOption = {
    z: 2,
    coordinateSystem: "geo",
    map: "",
    left: "center",
    top: "center",
    aspectScale: null,
    showLegendSymbol: true,
    boundingCoords: null,
    center: null,
    zoom: 1,
    scaleLimit: null,
    selectedMode: true,
    label: {
      show: false,
      color: "#000"
    },
    itemStyle: {
      borderWidth: 0.5,
      borderColor: "#444",
      areaColor: "#eee"
    },
    emphasis: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        areaColor: "rgba(255,215,0,0.8)"
      }
    },
    select: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    nameProperty: "name"
  };
  return MapSeries2;
}(SeriesModel$1);
var MapSeries$1 = MapSeries;
function dataStatistics(datas, statisticType) {
  var dataNameMap = {};
  each$f(datas, function(data) {
    data.each(data.mapDimension("value"), function(value, idx) {
      var mapKey = "ec-" + data.getName(idx);
      dataNameMap[mapKey] = dataNameMap[mapKey] || [];
      if (!isNaN(value)) {
        dataNameMap[mapKey].push(value);
      }
    });
  });
  return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
    var mapKey = "ec-" + datas[0].getName(idx);
    var sum2 = 0;
    var min3 = Infinity;
    var max3 = -Infinity;
    var len2 = dataNameMap[mapKey].length;
    for (var i = 0; i < len2; i++) {
      min3 = Math.min(min3, dataNameMap[mapKey][i]);
      max3 = Math.max(max3, dataNameMap[mapKey][i]);
      sum2 += dataNameMap[mapKey][i];
    }
    var result;
    if (statisticType === "min") {
      result = min3;
    } else if (statisticType === "max") {
      result = max3;
    } else if (statisticType === "average") {
      result = sum2 / len2;
    } else {
      result = sum2;
    }
    return len2 === 0 ? NaN : result;
  });
}
function mapDataStatistic(ecModel) {
  var seriesGroups = {};
  ecModel.eachSeriesByType("map", function(seriesModel) {
    var hostGeoModel = seriesModel.getHostGeoModel();
    var key = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
    (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
  });
  each$f(seriesGroups, function(seriesList, key) {
    var data = dataStatistics(map$1(seriesList, function(seriesModel) {
      return seriesModel.getData();
    }), seriesList[0].get("mapValueCalculation"));
    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].originalData = seriesList[i].getData();
    }
    for (var i = 0; i < seriesList.length; i++) {
      seriesList[i].seriesGroup = seriesList;
      seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
      seriesList[i].setData(data.cloneShallow());
      seriesList[i].mainSeries = seriesList[0];
    }
  });
}
function mapSymbolLayout(ecModel) {
  var processedMapType = {};
  ecModel.eachSeriesByType("map", function(mapSeries) {
    var mapType = mapSeries.getMapType();
    if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
      return;
    }
    var mapSymbolOffsets = {};
    each$f(mapSeries.seriesGroup, function(subMapSeries) {
      var geo = subMapSeries.coordinateSystem;
      var data2 = subMapSeries.originalData;
      if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
        data2.each(data2.mapDimension("value"), function(value, idx) {
          var name = data2.getName(idx);
          var region = geo.getRegion(name);
          if (!region || isNaN(value)) {
            return;
          }
          var offset = mapSymbolOffsets[name] || 0;
          var point = geo.dataToPoint(region.getCenter());
          mapSymbolOffsets[name] = offset + 1;
          data2.setItemLayout(idx, {
            point,
            offset
          });
        });
      }
    });
    var data = mapSeries.getData();
    data.each(function(idx) {
      var name = data.getName(idx);
      var layout2 = data.getItemLayout(idx) || {};
      layout2.showLabel = !mapSymbolOffsets[name];
      data.setItemLayout(idx, layout2);
    });
    processedMapType[mapType] = true;
  });
}
var v2ApplyTransform = applyTransform$1;
var View = function(_super) {
  __extends(View2, _super);
  function View2(name) {
    var _this = _super.call(this) || this;
    _this.type = "view";
    _this.dimensions = ["x", "y"];
    _this._roamTransformable = new Transformable();
    _this._rawTransformable = new Transformable();
    _this.name = name;
    return _this;
  }
  View2.prototype.setBoundingRect = function(x, y, width, height) {
    this._rect = new BoundingRect$1(x, y, width, height);
    return this._rect;
  };
  View2.prototype.getBoundingRect = function() {
    return this._rect;
  };
  View2.prototype.setViewRect = function(x, y, width, height) {
    this._transformTo(x, y, width, height);
    this._viewRect = new BoundingRect$1(x, y, width, height);
  };
  View2.prototype._transformTo = function(x, y, width, height) {
    var rect = this.getBoundingRect();
    var rawTransform = this._rawTransformable;
    rawTransform.transform = rect.calculateTransform(new BoundingRect$1(x, y, width, height));
    var rawParent = rawTransform.parent;
    rawTransform.parent = null;
    rawTransform.decomposeTransform();
    rawTransform.parent = rawParent;
    this._updateTransform();
  };
  View2.prototype.setCenter = function(centerCoord) {
    if (!centerCoord) {
      return;
    }
    this._center = centerCoord;
    this._updateCenterAndZoom();
  };
  View2.prototype.setZoom = function(zoom) {
    zoom = zoom || 1;
    var zoomLimit = this.zoomLimit;
    if (zoomLimit) {
      if (zoomLimit.max != null) {
        zoom = Math.min(zoomLimit.max, zoom);
      }
      if (zoomLimit.min != null) {
        zoom = Math.max(zoomLimit.min, zoom);
      }
    }
    this._zoom = zoom;
    this._updateCenterAndZoom();
  };
  View2.prototype.getDefaultCenter = function() {
    var rawRect = this.getBoundingRect();
    var cx = rawRect.x + rawRect.width / 2;
    var cy = rawRect.y + rawRect.height / 2;
    return [cx, cy];
  };
  View2.prototype.getCenter = function() {
    return this._center || this.getDefaultCenter();
  };
  View2.prototype.getZoom = function() {
    return this._zoom || 1;
  };
  View2.prototype.getRoamTransform = function() {
    return this._roamTransformable.getLocalTransform();
  };
  View2.prototype._updateCenterAndZoom = function() {
    var rawTransformMatrix = this._rawTransformable.getLocalTransform();
    var roamTransform = this._roamTransformable;
    var defaultCenter = this.getDefaultCenter();
    var center2 = this.getCenter();
    var zoom = this.getZoom();
    center2 = applyTransform$1([], center2, rawTransformMatrix);
    defaultCenter = applyTransform$1([], defaultCenter, rawTransformMatrix);
    roamTransform.originX = center2[0];
    roamTransform.originY = center2[1];
    roamTransform.x = defaultCenter[0] - center2[0];
    roamTransform.y = defaultCenter[1] - center2[1];
    roamTransform.scaleX = roamTransform.scaleY = zoom;
    this._updateTransform();
  };
  View2.prototype._updateTransform = function() {
    var roamTransformable = this._roamTransformable;
    var rawTransformable = this._rawTransformable;
    rawTransformable.parent = roamTransformable;
    roamTransformable.updateTransform();
    rawTransformable.updateTransform();
    copy(this.transform || (this.transform = []), rawTransformable.transform || create$2());
    this._rawTransform = rawTransformable.getLocalTransform();
    this.invTransform = this.invTransform || [];
    invert(this.invTransform, this.transform);
    this.decomposeTransform();
  };
  View2.prototype.getTransformInfo = function() {
    var rawTransformable = this._rawTransformable;
    var roamTransformable = this._roamTransformable;
    var dummyTransformable2 = new Transformable();
    dummyTransformable2.transform = roamTransformable.transform;
    dummyTransformable2.decomposeTransform();
    return {
      roam: {
        x: dummyTransformable2.x,
        y: dummyTransformable2.y,
        scaleX: dummyTransformable2.scaleX,
        scaleY: dummyTransformable2.scaleY
      },
      raw: {
        x: rawTransformable.x,
        y: rawTransformable.y,
        scaleX: rawTransformable.scaleX,
        scaleY: rawTransformable.scaleY
      }
    };
  };
  View2.prototype.getViewRect = function() {
    return this._viewRect;
  };
  View2.prototype.getViewRectAfterRoam = function() {
    var rect = this.getBoundingRect().clone();
    rect.applyTransform(this.transform);
    return rect;
  };
  View2.prototype.dataToPoint = function(data, noRoam, out2) {
    var transform2 = noRoam ? this._rawTransform : this.transform;
    out2 = out2 || [];
    return transform2 ? v2ApplyTransform(out2, data, transform2) : copy$1(out2, data);
  };
  View2.prototype.pointToData = function(point) {
    var invTransform = this.invTransform;
    return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
  };
  View2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$4(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  View2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$4(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  View2.prototype.containPoint = function(point) {
    return this.getViewRectAfterRoam().contain(point[0], point[1]);
  };
  View2.dimensions = ["x", "y"];
  return View2;
}(Transformable);
function getCoordSys$4(finder) {
  var seriesModel = finder.seriesModel;
  return seriesModel ? seriesModel.coordinateSystem : null;
}
var View$1 = View;
var GEO_DEFAULT_PARAMS = {
  "geoJSON": {
    aspectScale: 0.75,
    invertLongitute: true
  },
  "geoSVG": {
    aspectScale: 1,
    invertLongitute: false
  }
};
var geo2DDimensions = ["lng", "lat"];
var Geo = function(_super) {
  __extends(Geo2, _super);
  function Geo2(name, map2, opt) {
    var _this = _super.call(this, name) || this;
    _this.dimensions = geo2DDimensions;
    _this.type = "geo";
    _this._nameCoordMap = createHashMap();
    _this.map = map2;
    var projection = opt.projection;
    var source = geoSourceManager.load(map2, opt.nameMap, opt.nameProperty);
    var resource = geoSourceManager.getGeoResource(map2);
    _this.resourceType = resource ? resource.type : null;
    var regions = _this.regions = source.regions;
    var defaultParams2 = GEO_DEFAULT_PARAMS[resource.type];
    _this._regionsMap = source.regionsMap;
    _this.regions = source.regions;
    _this.projection = projection;
    var boundingRect;
    if (projection) {
      for (var i = 0; i < regions.length; i++) {
        var regionRect = regions[i].getBoundingRect(projection);
        boundingRect = boundingRect || regionRect.clone();
        boundingRect.union(regionRect);
      }
    } else {
      boundingRect = source.boundingRect;
    }
    _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);
    _this.aspectScale = projection ? 1 : retrieve2(opt.aspectScale, defaultParams2.aspectScale);
    _this._invertLongitute = projection ? false : defaultParams2.invertLongitute;
    return _this;
  }
  Geo2.prototype._transformTo = function(x, y, width, height) {
    var rect = this.getBoundingRect();
    var invertLongitute = this._invertLongitute;
    rect = rect.clone();
    if (invertLongitute) {
      rect.y = -rect.y - rect.height;
    }
    var rawTransformable = this._rawTransformable;
    rawTransformable.transform = rect.calculateTransform(new BoundingRect$1(x, y, width, height));
    var rawParent = rawTransformable.parent;
    rawTransformable.parent = null;
    rawTransformable.decomposeTransform();
    rawTransformable.parent = rawParent;
    if (invertLongitute) {
      rawTransformable.scaleY = -rawTransformable.scaleY;
    }
    this._updateTransform();
  };
  Geo2.prototype.getRegion = function(name) {
    return this._regionsMap.get(name);
  };
  Geo2.prototype.getRegionByCoord = function(coord) {
    var regions = this.regions;
    for (var i = 0; i < regions.length; i++) {
      var region = regions[i];
      if (region.type === "geoJSON" && region.contain(coord)) {
        return regions[i];
      }
    }
  };
  Geo2.prototype.addGeoCoord = function(name, geoCoord2) {
    this._nameCoordMap.set(name, geoCoord2);
  };
  Geo2.prototype.getGeoCoord = function(name) {
    var region = this._regionsMap.get(name);
    return this._nameCoordMap.get(name) || region && region.getCenter();
  };
  Geo2.prototype.dataToPoint = function(data, noRoam, out2) {
    if (isString(data)) {
      data = this.getGeoCoord(data);
    }
    if (data) {
      var projection = this.projection;
      if (projection) {
        data = projection.project(data);
      }
      return data && this.projectedToPoint(data);
    }
  };
  Geo2.prototype.pointToData = function(point) {
    var projection = this.projection;
    if (projection) {
      point = projection.unproject(point);
    }
    return point && this.pointToProjected(point);
  };
  Geo2.prototype.pointToProjected = function(point) {
    return _super.prototype.pointToData.call(this, point);
  };
  Geo2.prototype.projectedToPoint = function(projected, noRoam, out2) {
    return _super.prototype.dataToPoint.call(this, projected, noRoam, out2);
  };
  Geo2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$3(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  Geo2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$3(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  return Geo2;
}(View$1);
mixin(Geo, View$1);
function getCoordSys$3(finder) {
  var geoModel = finder.geoModel;
  var seriesModel = finder.seriesModel;
  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
var Geo$1 = Geo;
function resizeGeo(geoModel, api) {
  var boundingCoords = geoModel.get("boundingCoords");
  if (boundingCoords != null) {
    var leftTop_1 = boundingCoords[0];
    var rightBottom_1 = boundingCoords[1];
    if (!(isFinite(leftTop_1[0]) && isFinite(leftTop_1[1]) && isFinite(rightBottom_1[0]) && isFinite(rightBottom_1[1])))
      ;
    else {
      var projection_1 = this.projection;
      if (projection_1) {
        var xMin = leftTop_1[0];
        var yMin = leftTop_1[1];
        var xMax = rightBottom_1[0];
        var yMax = rightBottom_1[1];
        leftTop_1 = [Infinity, Infinity];
        rightBottom_1 = [-Infinity, -Infinity];
        var sampleLine = function(x0, y0, x1, y1) {
          var dx = x1 - x0;
          var dy = y1 - y0;
          for (var i = 0; i <= 100; i++) {
            var p = i / 100;
            var pt = projection_1.project([x0 + dx * p, y0 + dy * p]);
            min$1(leftTop_1, leftTop_1, pt);
            max$1(rightBottom_1, rightBottom_1, pt);
          }
        };
        sampleLine(xMin, yMin, xMax, yMin);
        sampleLine(xMax, yMin, xMax, yMax);
        sampleLine(xMax, yMax, xMin, yMax);
        sampleLine(xMin, yMax, xMax, yMin);
      }
      this.setBoundingRect(leftTop_1[0], leftTop_1[1], rightBottom_1[0] - leftTop_1[0], rightBottom_1[1] - leftTop_1[1]);
    }
  }
  var rect = this.getBoundingRect();
  var centerOption = geoModel.get("layoutCenter");
  var sizeOption = geoModel.get("layoutSize");
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  var aspect = rect.width / rect.height * this.aspectScale;
  var useCenterAndSize = false;
  var center2;
  var size;
  if (centerOption && sizeOption) {
    center2 = [parsePercent$1(centerOption[0], viewWidth), parsePercent$1(centerOption[1], viewHeight)];
    size = parsePercent$1(sizeOption, Math.min(viewWidth, viewHeight));
    if (!isNaN(center2[0]) && !isNaN(center2[1]) && !isNaN(size)) {
      useCenterAndSize = true;
    }
  }
  var viewRect2;
  if (useCenterAndSize) {
    viewRect2 = {};
    if (aspect > 1) {
      viewRect2.width = size;
      viewRect2.height = size / aspect;
    } else {
      viewRect2.height = size;
      viewRect2.width = size * aspect;
    }
    viewRect2.y = center2[1] - viewRect2.height / 2;
    viewRect2.x = center2[0] - viewRect2.width / 2;
  } else {
    var boxLayoutOption = geoModel.getBoxLayoutParams();
    boxLayoutOption.aspect = aspect;
    viewRect2 = getLayoutRect(boxLayoutOption, {
      width: viewWidth,
      height: viewHeight
    });
  }
  this.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
  this.setCenter(geoModel.get("center"));
  this.setZoom(geoModel.get("zoom"));
}
function setGeoCoords(geo, model) {
  each$f(model.get("geoCoord"), function(geoCoord2, name) {
    geo.addGeoCoord(name, geoCoord2);
  });
}
var GeoCreator = function() {
  function GeoCreator2() {
    this.dimensions = geo2DDimensions;
  }
  GeoCreator2.prototype.create = function(ecModel, api) {
    var geoList = [];
    function getCommonGeoProperties(model) {
      return {
        nameProperty: model.get("nameProperty"),
        aspectScale: model.get("aspectScale"),
        projection: model.get("projection")
      };
    }
    ecModel.eachComponent("geo", function(geoModel, idx) {
      var mapName = geoModel.get("map");
      var geo = new Geo$1(mapName + idx, mapName, extend$1({
        nameMap: geoModel.get("nameMap")
      }, getCommonGeoProperties(geoModel)));
      geo.zoomLimit = geoModel.get("scaleLimit");
      geoList.push(geo);
      geoModel.coordinateSystem = geo;
      geo.model = geoModel;
      geo.resize = resizeGeo;
      geo.resize(geoModel, api);
    });
    ecModel.eachSeries(function(seriesModel) {
      var coordSys = seriesModel.get("coordinateSystem");
      if (coordSys === "geo") {
        var geoIndex = seriesModel.get("geoIndex") || 0;
        seriesModel.coordinateSystem = geoList[geoIndex];
      }
    });
    var mapModelGroupBySeries = {};
    ecModel.eachSeriesByType("map", function(seriesModel) {
      if (!seriesModel.getHostGeoModel()) {
        var mapType = seriesModel.getMapType();
        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
        mapModelGroupBySeries[mapType].push(seriesModel);
      }
    });
    each$f(mapModelGroupBySeries, function(mapSeries, mapType) {
      var nameMapList = map$1(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("nameMap");
      });
      var geo = new Geo$1(mapType, mapType, extend$1({
        nameMap: mergeAll(nameMapList)
      }, getCommonGeoProperties(mapSeries[0])));
      geo.zoomLimit = retrieve$2.apply(null, map$1(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("scaleLimit");
      }));
      geoList.push(geo);
      geo.resize = resizeGeo;
      geo.resize(mapSeries[0], api);
      each$f(mapSeries, function(singleMapSeries) {
        singleMapSeries.coordinateSystem = geo;
        setGeoCoords(geo, singleMapSeries);
      });
    });
    return geoList;
  };
  GeoCreator2.prototype.getFilledRegions = function(originRegionArr, mapName, nameMap, nameProperty) {
    var regionsArr = (originRegionArr || []).slice();
    var dataNameMap = createHashMap();
    for (var i = 0; i < regionsArr.length; i++) {
      dataNameMap.set(regionsArr[i].name, regionsArr[i]);
    }
    var source = geoSourceManager.load(mapName, nameMap, nameProperty);
    each$f(source.regions, function(region) {
      var name = region.name;
      !dataNameMap.get(name) && regionsArr.push({
        name
      });
    });
    return regionsArr;
  };
  return GeoCreator2;
}();
var geoCreator = new GeoCreator();
var geoCreator$1 = geoCreator;
var GeoModel = function(_super) {
  __extends(GeoModel2, _super);
  function GeoModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GeoModel2.type;
    return _this;
  }
  GeoModel2.prototype.init = function(option, parentModel, ecModel) {
    var source = geoSourceManager.getGeoResource(option.map);
    if (source && source.type === "geoJSON") {
      var itemStyle = option.itemStyle = option.itemStyle || {};
      if (!("color" in itemStyle)) {
        itemStyle.color = "#eee";
      }
    }
    this.mergeDefaultAndTheme(option, ecModel);
    defaultEmphasis(option, "label", ["show"]);
  };
  GeoModel2.prototype.optionUpdated = function() {
    var _this = this;
    var option = this.option;
    option.regions = geoCreator$1.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);
    var selectedMap = {};
    this._optionModelMap = reduce(option.regions || [], function(optionModelMap, regionOpt) {
      var regionName = regionOpt.name;
      if (regionName) {
        optionModelMap.set(regionName, new Model$1(regionOpt, _this, _this.ecModel));
        if (regionOpt.selected) {
          selectedMap[regionName] = true;
        }
      }
      return optionModelMap;
    }, createHashMap());
    if (!option.selectedMap) {
      option.selectedMap = selectedMap;
    }
  };
  GeoModel2.prototype.getRegionModel = function(name) {
    return this._optionModelMap.get(name) || new Model$1(null, this, this.ecModel);
  };
  GeoModel2.prototype.getFormattedLabel = function(name, status) {
    var regionModel = this.getRegionModel(name);
    var formatter = status === "normal" ? regionModel.get(["label", "formatter"]) : regionModel.get(["emphasis", "label", "formatter"]);
    var params = {
      name
    };
    if (isFunction$1(formatter)) {
      params.status = status;
      return formatter(params);
    } else if (isString(formatter)) {
      return formatter.replace("{a}", name != null ? name : "");
    }
  };
  GeoModel2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  GeoModel2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  GeoModel2.prototype.select = function(name) {
    var option = this.option;
    var selectedMode = option.selectedMode;
    if (!selectedMode) {
      return;
    }
    if (selectedMode !== "multiple") {
      option.selectedMap = null;
    }
    var selectedMap = option.selectedMap || (option.selectedMap = {});
    selectedMap[name] = true;
  };
  GeoModel2.prototype.unSelect = function(name) {
    var selectedMap = this.option.selectedMap;
    if (selectedMap) {
      selectedMap[name] = false;
    }
  };
  GeoModel2.prototype.toggleSelected = function(name) {
    this[this.isSelected(name) ? "unSelect" : "select"](name);
  };
  GeoModel2.prototype.isSelected = function(name) {
    var selectedMap = this.option.selectedMap;
    return !!(selectedMap && selectedMap[name]);
  };
  GeoModel2.type = "geo";
  GeoModel2.layoutMode = "box";
  GeoModel2.defaultOption = {
    z: 0,
    show: true,
    left: "center",
    top: "center",
    aspectScale: null,
    silent: false,
    map: "",
    boundingCoords: null,
    center: null,
    zoom: 1,
    scaleLimit: null,
    label: {
      show: false,
      color: "#000"
    },
    itemStyle: {
      borderWidth: 0.5,
      borderColor: "#444"
    },
    emphasis: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    select: {
      label: {
        show: true,
        color: "rgb(100,0,0)"
      },
      itemStyle: {
        color: "rgba(255,215,0,0.8)"
      }
    },
    regions: []
  };
  return GeoModel2;
}(ComponentModel$1);
var GeoModel$1 = GeoModel;
function getCenterCoord(view, point) {
  return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point);
}
function updateCenterAndZoom(view, payload, zoomLimit) {
  var previousZoom = view.getZoom();
  var center2 = view.getCenter();
  var zoom = payload.zoom;
  var point = view.projectedToPoint ? view.projectedToPoint(center2) : view.dataToPoint(center2);
  if (payload.dx != null && payload.dy != null) {
    point[0] -= payload.dx;
    point[1] -= payload.dy;
    view.setCenter(getCenterCoord(view, point));
  }
  if (zoom != null) {
    if (zoomLimit) {
      var zoomMin = zoomLimit.min || 0;
      var zoomMax = zoomLimit.max || Infinity;
      zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
    }
    view.scaleX *= zoom;
    view.scaleY *= zoom;
    var fixX = (payload.originX - view.x) * (zoom - 1);
    var fixY = (payload.originY - view.y) * (zoom - 1);
    view.x -= fixX;
    view.y -= fixY;
    view.updateTransform();
    view.setCenter(getCenterCoord(view, point));
    view.setZoom(zoom * previousZoom);
  }
  return {
    center: view.getCenter(),
    zoom: view.getZoom()
  };
}
var GeoView = function(_super) {
  __extends(GeoView2, _super);
  function GeoView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GeoView2.type;
    _this.focusBlurEnabled = true;
    return _this;
  }
  GeoView2.prototype.init = function(ecModel, api) {
    this._api = api;
  };
  GeoView2.prototype.render = function(geoModel, ecModel, api, payload) {
    this._model = geoModel;
    if (!geoModel.get("show")) {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      return;
    }
    if (!this._mapDraw) {
      this._mapDraw = new MapDraw$1(api);
    }
    var mapDraw = this._mapDraw;
    mapDraw.draw(geoModel, ecModel, api, this, payload);
    mapDraw.group.on("click", this._handleRegionClick, this);
    mapDraw.group.silent = geoModel.get("silent");
    this.group.add(mapDraw.group);
    this.updateSelectStatus(geoModel, ecModel, api);
  };
  GeoView2.prototype._handleRegionClick = function(e2) {
    var eventData;
    findEventDispatcher(e2.target, function(current) {
      return (eventData = getECData(current).eventData) != null;
    }, true);
    if (eventData) {
      this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: eventData.name
      });
    }
  };
  GeoView2.prototype.updateSelectStatus = function(model, ecModel, api) {
    var _this = this;
    this._mapDraw.group.traverse(function(node) {
      var eventData = getECData(node).eventData;
      if (eventData) {
        _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node);
        return true;
      }
    });
  };
  GeoView2.prototype.findHighDownDispatchers = function(name) {
    return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model);
  };
  GeoView2.prototype.dispose = function() {
    this._mapDraw && this._mapDraw.remove();
  };
  GeoView2.type = "geo";
  return GeoView2;
}(ComponentView$1);
var GeoView$1 = GeoView;
function registerMap(mapName, geoJson, specialAreas) {
  geoSourceManager.registerMap(mapName, geoJson, specialAreas);
}
function install$Z(registers) {
  registers.registerCoordinateSystem("geo", geoCreator$1);
  registers.registerComponentModel(GeoModel$1);
  registers.registerComponentView(GeoView$1);
  registers.registerImpl("registerMap", registerMap);
  registers.registerImpl("getMap", function(mapName) {
    return geoSourceManager.getMapForUser(mapName);
  });
  function makeAction(method, actionInfo2) {
    actionInfo2.update = "geo:updateSelectStatus";
    registers.registerAction(actionInfo2, function(payload, ecModel) {
      var selected = {};
      var allSelected = [];
      ecModel.eachComponent({
        mainType: "geo",
        query: payload
      }, function(geoModel) {
        geoModel[method](payload.name);
        var geo = geoModel.coordinateSystem;
        each$f(geo.regions, function(region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        });
        var names = [];
        each$f(selected, function(v, name) {
          selected[name] && names.push(name);
        });
        allSelected.push({
          geoIndex: geoModel.componentIndex,
          name: names
        });
      });
      return {
        selected,
        allSelected,
        name: payload.name
      };
    });
  }
  makeAction("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  });
  makeAction("select", {
    type: "geoSelect",
    event: "geoselected"
  });
  makeAction("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  });
  registers.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(payload, ecModel) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      var geo = componentModel.coordinateSystem;
      if (geo.type !== "geo") {
        return;
      }
      var res = updateCenterAndZoom(geo, payload, componentModel.get("scaleLimit"));
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom);
      if (componentType === "series") {
        each$f(componentModel.seriesGroup, function(seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
}
function install$Y(registers) {
  use(install$Z);
  registers.registerChartView(MapView$1);
  registers.registerSeriesModel(MapSeries$1);
  registers.registerLayout(mapSymbolLayout);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
  createLegacyDataSelectAction("map", registers.registerAction);
}
function init(inRoot) {
  var root2 = inRoot;
  root2.hierNode = {
    defaultAncestor: null,
    ancestor: root2,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  var nodes = [root2];
  var node;
  var children;
  while (node = nodes.pop()) {
    children = node.children;
    if (node.isExpand && children.length) {
      var n = children.length;
      for (var i = n - 1; i >= 0; i--) {
        var child = children[i];
        child.hierNode = {
          defaultAncestor: null,
          ancestor: child,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i,
          thread: null
        };
        nodes.push(child);
      }
    }
  }
}
function firstWalk(node, separation2) {
  var children = node.isExpand ? node.children : [];
  var siblings = node.parentNode.children;
  var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
  if (children.length) {
    executeShifts(node);
    var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
    if (subtreeW) {
      node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
      node.hierNode.modifier = node.hierNode.prelim - midPoint;
    } else {
      node.hierNode.prelim = midPoint;
    }
  } else if (subtreeW) {
    node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
  }
  node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation2);
}
function secondWalk(node) {
  var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
  node.setLayout({
    x: nodeX
  }, true);
  node.hierNode.modifier += node.parentNode.hierNode.modifier;
}
function separation(cb) {
  return arguments.length ? cb : defaultSeparation;
}
function radialCoordinate(rad2, r) {
  rad2 -= Math.PI / 2;
  return {
    x: r * Math.cos(rad2),
    y: r * Math.sin(rad2)
  };
}
function getViewRect$4(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function executeShifts(node) {
  var children = node.children;
  var n = children.length;
  var shift = 0;
  var change = 0;
  while (--n >= 0) {
    var child = children[n];
    child.hierNode.prelim += shift;
    child.hierNode.modifier += shift;
    change += child.hierNode.change;
    shift += child.hierNode.shift + change;
  }
}
function apportion(subtreeV, subtreeW, ancestor, separation2) {
  if (subtreeW) {
    var nodeOutRight = subtreeV;
    var nodeInRight = subtreeV;
    var nodeOutLeft = nodeInRight.parentNode.children[0];
    var nodeInLeft = subtreeW;
    var sumOutRight = nodeOutRight.hierNode.modifier;
    var sumInRight = nodeInRight.hierNode.modifier;
    var sumOutLeft = nodeOutLeft.hierNode.modifier;
    var sumInLeft = nodeInLeft.hierNode.modifier;
    while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
      nodeOutRight = nextRight(nodeOutRight);
      nodeOutLeft = nextLeft(nodeOutLeft);
      nodeOutRight.hierNode.ancestor = subtreeV;
      var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation2(nodeInLeft, nodeInRight);
      if (shift > 0) {
        moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
        sumInRight += shift;
        sumOutRight += shift;
      }
      sumInLeft += nodeInLeft.hierNode.modifier;
      sumInRight += nodeInRight.hierNode.modifier;
      sumOutRight += nodeOutRight.hierNode.modifier;
      sumOutLeft += nodeOutLeft.hierNode.modifier;
    }
    if (nodeInLeft && !nextRight(nodeOutRight)) {
      nodeOutRight.hierNode.thread = nodeInLeft;
      nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
    }
    if (nodeInRight && !nextLeft(nodeOutLeft)) {
      nodeOutLeft.hierNode.thread = nodeInRight;
      nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
      ancestor = subtreeV;
    }
  }
  return ancestor;
}
function nextRight(node) {
  var children = node.children;
  return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
}
function nextLeft(node) {
  var children = node.children;
  return children.length && node.isExpand ? children[0] : node.hierNode.thread;
}
function nextAncestor(nodeInLeft, node, ancestor) {
  return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
}
function moveSubtree(wl, wr, shift) {
  var change = shift / (wr.hierNode.i - wl.hierNode.i);
  wr.hierNode.change -= change;
  wr.hierNode.shift += shift;
  wr.hierNode.modifier += shift;
  wr.hierNode.prelim += shift;
  wl.hierNode.change += change;
}
function defaultSeparation(node1, node2) {
  return node1.parentNode === node2.parentNode ? 1 : 2;
}
var TreeEdgeShape = function() {
  function TreeEdgeShape2() {
    this.parentPoint = [];
    this.childPoints = [];
  }
  return TreeEdgeShape2;
}();
var TreePath = function(_super) {
  __extends(TreePath2, _super);
  function TreePath2(opts) {
    return _super.call(this, opts) || this;
  }
  TreePath2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  TreePath2.prototype.getDefaultShape = function() {
    return new TreeEdgeShape();
  };
  TreePath2.prototype.buildPath = function(ctx, shape) {
    var childPoints = shape.childPoints;
    var childLen = childPoints.length;
    var parentPoint = shape.parentPoint;
    var firstChildPos = childPoints[0];
    var lastChildPos = childPoints[childLen - 1];
    if (childLen === 1) {
      ctx.moveTo(parentPoint[0], parentPoint[1]);
      ctx.lineTo(firstChildPos[0], firstChildPos[1]);
      return;
    }
    var orient = shape.orient;
    var forkDim = orient === "TB" || orient === "BT" ? 0 : 1;
    var otherDim2 = 1 - forkDim;
    var forkPosition = parsePercent$1(shape.forkPosition, 1);
    var tmpPoint = [];
    tmpPoint[forkDim] = parentPoint[forkDim];
    tmpPoint[otherDim2] = parentPoint[otherDim2] + (lastChildPos[otherDim2] - parentPoint[otherDim2]) * forkPosition;
    ctx.moveTo(parentPoint[0], parentPoint[1]);
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.moveTo(firstChildPos[0], firstChildPos[1]);
    tmpPoint[forkDim] = firstChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    tmpPoint[forkDim] = lastChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.lineTo(lastChildPos[0], lastChildPos[1]);
    for (var i = 1; i < childLen - 1; i++) {
      var point = childPoints[i];
      ctx.moveTo(point[0], point[1]);
      tmpPoint[forkDim] = point[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    }
  };
  return TreePath2;
}(Path$1);
var TreeView = function(_super) {
  __extends(TreeView2, _super);
  function TreeView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TreeView2.type;
    _this._mainGroup = new Group$4();
    return _this;
  }
  TreeView2.prototype.init = function(ecModel, api) {
    this._controller = new RoamController$1(api.getZr());
    this._controllerHost = {
      target: this.group
    };
    this.group.add(this._mainGroup);
  };
  TreeView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var layoutInfo = seriesModel.layoutInfo;
    var group = this._mainGroup;
    var layout2 = seriesModel.get("layout");
    if (layout2 === "radial") {
      group.x = layoutInfo.x + layoutInfo.width / 2;
      group.y = layoutInfo.y + layoutInfo.height / 2;
    } else {
      group.x = layoutInfo.x;
      group.y = layoutInfo.y;
    }
    this._updateViewCoordSys(seriesModel);
    this._updateController(seriesModel, ecModel, api);
    var oldData = this._data;
    data.diff(oldData).add(function(newIdx) {
      if (symbolNeedsDraw(data, newIdx)) {
        updateNode(data, newIdx, null, group, seriesModel);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!symbolNeedsDraw(data, newIdx)) {
        symbolEl && removeNode$1(oldData, oldIdx, symbolEl, group, seriesModel);
        return;
      }
      updateNode(data, newIdx, symbolEl, group, seriesModel);
    }).remove(function(oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (symbolEl) {
        removeNode$1(oldData, oldIdx, symbolEl, group, seriesModel);
      }
    }).execute();
    this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
    this._updateNodeAndLinkScale(seriesModel);
    if (seriesModel.get("expandAndCollapse") === true) {
      data.eachItemGraphicEl(function(el, dataIndex) {
        el.off("click").on("click", function() {
          api.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: seriesModel.id,
            dataIndex
          });
        });
      });
    }
    this._data = data;
  };
  TreeView2.prototype._updateViewCoordSys = function(seriesModel) {
    var data = seriesModel.getData();
    var points2 = [];
    data.each(function(idx) {
      var layout2 = data.getItemLayout(idx);
      if (layout2 && !isNaN(layout2.x) && !isNaN(layout2.y)) {
        points2.push([+layout2.x, +layout2.y]);
      }
    });
    var min3 = [];
    var max3 = [];
    fromPoints(points2, min3, max3);
    var oldMin = this._min;
    var oldMax = this._max;
    if (max3[0] - min3[0] === 0) {
      min3[0] = oldMin ? oldMin[0] : min3[0] - 1;
      max3[0] = oldMax ? oldMax[0] : max3[0] + 1;
    }
    if (max3[1] - min3[1] === 0) {
      min3[1] = oldMin ? oldMin[1] : min3[1] - 1;
      max3[1] = oldMax ? oldMax[1] : max3[1] + 1;
    }
    var viewCoordSys = seriesModel.coordinateSystem = new View$1();
    viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
    viewCoordSys.setBoundingRect(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    viewCoordSys.setCenter(seriesModel.get("center"));
    viewCoordSys.setZoom(seriesModel.get("zoom"));
    this.group.attr({
      x: viewCoordSys.x,
      y: viewCoordSys.y,
      scaleX: viewCoordSys.scaleX,
      scaleY: viewCoordSys.scaleY
    });
    this._min = min3;
    this._max = max3;
  };
  TreeView2.prototype._updateController = function(seriesModel, ecModel, api) {
    var _this = this;
    var controller = this._controller;
    var controllerHost = this._controllerHost;
    var group = this.group;
    controller.setPointerChecker(function(e2, x, y) {
      var rect = group.getBoundingRect();
      rect.applyTransform(group.transform);
      return rect.contain(x, y) && !onIrrelevantElement(e2, api, seriesModel);
    });
    controller.enable(seriesModel.get("roam"));
    controllerHost.zoomLimit = seriesModel.get("scaleLimit");
    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
    controller.off("pan").off("zoom").on("pan", function(e2) {
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: "treeRoam",
        dx: e2.dx,
        dy: e2.dy
      });
    }).on("zoom", function(e2) {
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: "treeRoam",
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY
      });
      _this._updateNodeAndLinkScale(seriesModel);
      api.updateLabelLayout();
    });
  };
  TreeView2.prototype._updateNodeAndLinkScale = function(seriesModel) {
    var data = seriesModel.getData();
    var nodeScale = this._getNodeGlobalScale(seriesModel);
    data.eachItemGraphicEl(function(el, idx) {
      el.setSymbolScale(nodeScale);
    });
  };
  TreeView2.prototype._getNodeGlobalScale = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys.type !== "view") {
      return 1;
    }
    var nodeScaleRatio = this._nodeScaleRatio;
    var groupZoom = coordSys.scaleX || 1;
    var roamZoom = coordSys.getZoom();
    var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
    return nodeScale / groupZoom;
  };
  TreeView2.prototype.dispose = function() {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  };
  TreeView2.prototype.remove = function() {
    this._mainGroup.removeAll();
    this._data = null;
  };
  TreeView2.type = "tree";
  return TreeView2;
}(ChartView$1);
function symbolNeedsDraw(data, dataIndex) {
  var layout2 = data.getItemLayout(dataIndex);
  return layout2 && !isNaN(layout2.x) && !isNaN(layout2.y);
}
function updateNode(data, dataIndex, symbolEl, group, seriesModel) {
  var isInit = !symbolEl;
  var node = data.tree.getNodeByDataIndex(dataIndex);
  var itemModel = node.getModel();
  var visualColor = node.getVisual("style").fill;
  var symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : "#fff";
  var virtualRoot = data.tree.root;
  var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
  var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
  var sourceLayout = source.getLayout();
  var sourceOldLayout = sourceSymbolEl ? {
    x: sourceSymbolEl.__oldX,
    y: sourceSymbolEl.__oldY,
    rawX: sourceSymbolEl.__radialOldRawX,
    rawY: sourceSymbolEl.__radialOldRawY
  } : sourceLayout;
  var targetLayout = node.getLayout();
  if (isInit) {
    symbolEl = new SymbolClz(data, dataIndex, null, {
      symbolInnerColor,
      useNameLabel: true
    });
    symbolEl.x = sourceOldLayout.x;
    symbolEl.y = sourceOldLayout.y;
  } else {
    symbolEl.updateData(data, dataIndex, null, {
      symbolInnerColor,
      useNameLabel: true
    });
  }
  symbolEl.__radialOldRawX = symbolEl.__radialRawX;
  symbolEl.__radialOldRawY = symbolEl.__radialRawY;
  symbolEl.__radialRawX = targetLayout.rawX;
  symbolEl.__radialRawY = targetLayout.rawY;
  group.add(symbolEl);
  data.setItemGraphicEl(dataIndex, symbolEl);
  symbolEl.__oldX = symbolEl.x;
  symbolEl.__oldY = symbolEl.y;
  updateProps$1(symbolEl, {
    x: targetLayout.x,
    y: targetLayout.y
  }, seriesModel);
  var symbolPath = symbolEl.getSymbolPath();
  if (seriesModel.get("layout") === "radial") {
    var realRoot = virtualRoot.children[0];
    var rootLayout = realRoot.getLayout();
    var length_1 = realRoot.children.length;
    var rad2 = void 0;
    var isLeft = void 0;
    if (targetLayout.x === rootLayout.x && node.isExpand === true) {
      var center2 = {
        x: (realRoot.children[0].getLayout().x + realRoot.children[length_1 - 1].getLayout().x) / 2,
        y: (realRoot.children[0].getLayout().y + realRoot.children[length_1 - 1].getLayout().y) / 2
      };
      rad2 = Math.atan2(center2.y - rootLayout.y, center2.x - rootLayout.x);
      if (rad2 < 0) {
        rad2 = Math.PI * 2 + rad2;
      }
      isLeft = center2.x < rootLayout.x;
      if (isLeft) {
        rad2 = rad2 - Math.PI;
      }
    } else {
      rad2 = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
      if (rad2 < 0) {
        rad2 = Math.PI * 2 + rad2;
      }
      if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
        isLeft = targetLayout.x < rootLayout.x;
        if (isLeft) {
          rad2 = rad2 - Math.PI;
        }
      } else {
        isLeft = targetLayout.x > rootLayout.x;
        if (!isLeft) {
          rad2 = rad2 - Math.PI;
        }
      }
    }
    var textPosition = isLeft ? "left" : "right";
    var normalLabelModel = itemModel.getModel("label");
    var rotate2 = normalLabelModel.get("rotate");
    var labelRotateRadian = rotate2 * (Math.PI / 180);
    var textContent = symbolPath.getTextContent();
    if (textContent) {
      symbolPath.setTextConfig({
        position: normalLabelModel.get("position") || textPosition,
        rotation: rotate2 == null ? -rad2 : labelRotateRadian,
        origin: "center"
      });
      textContent.setStyle("verticalAlign", "middle");
    }
  }
  var focus = itemModel.get(["emphasis", "focus"]);
  var focusDataIndices = focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : null;
  if (focusDataIndices) {
    getECData(symbolEl).focus = focusDataIndices;
  }
  drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);
  if (symbolEl.__edge) {
    symbolEl.onHoverStateChange = function(toState) {
      if (toState !== "blur") {
        var parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);
        if (!(parentEl && parentEl.hoverState === HOVER_STATE_BLUR)) {
          setStatesFlag(symbolEl.__edge, toState);
        }
      }
    };
  }
}
function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {
  var itemModel = node.getModel();
  var edgeShape = seriesModel.get("edgeShape");
  var layout2 = seriesModel.get("layout");
  var orient = seriesModel.getOrient();
  var curvature = seriesModel.get(["lineStyle", "curveness"]);
  var edgeForkPosition = seriesModel.get("edgeForkPosition");
  var lineStyle = itemModel.getModel("lineStyle").getLineStyle();
  var edge = symbolEl.__edge;
  if (edgeShape === "curve") {
    if (node.parentNode && node.parentNode !== virtualRoot) {
      if (!edge) {
        edge = symbolEl.__edge = new BezierCurve$1({
          shape: getEdgeShape(layout2, orient, curvature, sourceOldLayout, sourceOldLayout)
        });
      }
      updateProps$1(edge, {
        shape: getEdgeShape(layout2, orient, curvature, sourceLayout, targetLayout)
      }, seriesModel);
    }
  } else if (edgeShape === "polyline") {
    if (layout2 === "orthogonal") {
      if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
        var children = node.children;
        var childPoints = [];
        for (var i = 0; i < children.length; i++) {
          var childLayout = children[i].getLayout();
          childPoints.push([childLayout.x, childLayout.y]);
        }
        if (!edge) {
          edge = symbolEl.__edge = new TreePath({
            shape: {
              parentPoint: [targetLayout.x, targetLayout.y],
              childPoints: [[targetLayout.x, targetLayout.y]],
              orient,
              forkPosition: edgeForkPosition
            }
          });
        }
        updateProps$1(edge, {
          shape: {
            parentPoint: [targetLayout.x, targetLayout.y],
            childPoints
          }
        }, seriesModel);
      }
    }
  }
  if (edge) {
    edge.useStyle(defaults({
      strokeNoScale: true,
      fill: null
    }, lineStyle));
    setStatesStylesFromModel(edge, itemModel, "lineStyle");
    setDefaultStateProxy(edge);
    group.add(edge);
  }
}
function removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt) {
  var virtualRoot = data.tree.root;
  var _a2 = getSourceNode(virtualRoot, node), source = _a2.source, sourceLayout = _a2.sourceLayout;
  var symbolEl = data.getItemGraphicEl(node.dataIndex);
  if (!symbolEl) {
    return;
  }
  var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
  var sourceEdge = sourceSymbolEl.__edge;
  var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : void 0);
  var edgeShape = seriesModel.get("edgeShape");
  var layoutOpt = seriesModel.get("layout");
  var orient = seriesModel.get("orient");
  var curvature = seriesModel.get(["lineStyle", "curveness"]);
  if (edge) {
    if (edgeShape === "curve") {
      removeElement(edge, {
        shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb: function() {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    } else if (edgeShape === "polyline" && seriesModel.get("layout") === "orthogonal") {
      removeElement(edge, {
        shape: {
          parentPoint: [sourceLayout.x, sourceLayout.y],
          childPoints: [[sourceLayout.x, sourceLayout.y]]
        },
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb: function() {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    }
  }
}
function getSourceNode(virtualRoot, node) {
  var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
  var sourceLayout;
  while (sourceLayout = source.getLayout(), sourceLayout == null) {
    source = source.parentNode === virtualRoot ? source : source.parentNode || source;
  }
  return {
    source,
    sourceLayout
  };
}
function removeNode$1(data, dataIndex, symbolEl, group, seriesModel) {
  var node = data.tree.getNodeByDataIndex(dataIndex);
  var virtualRoot = data.tree.root;
  var sourceLayout = getSourceNode(virtualRoot, node).sourceLayout;
  var removeAnimationOpt = {
    duration: seriesModel.get("animationDurationUpdate"),
    easing: seriesModel.get("animationEasingUpdate")
  };
  removeElement(symbolEl, {
    x: sourceLayout.x + 1,
    y: sourceLayout.y + 1
  }, seriesModel, {
    cb: function() {
      group.remove(symbolEl);
      data.setItemGraphicEl(dataIndex, null);
    },
    removeOpt: removeAnimationOpt
  });
  symbolEl.fadeOut(null, {
    fadeLabel: true,
    animation: removeAnimationOpt
  });
  node.children.forEach(function(childNode) {
    removeNodeEdge(childNode, data, group, seriesModel, removeAnimationOpt);
  });
  removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt);
}
function getEdgeShape(layoutOpt, orient, curvature, sourceLayout, targetLayout) {
  var cpx1;
  var cpy1;
  var cpx2;
  var cpy2;
  var x1;
  var x2;
  var y1;
  var y2;
  if (layoutOpt === "radial") {
    x1 = sourceLayout.rawX;
    y1 = sourceLayout.rawY;
    x2 = targetLayout.rawX;
    y2 = targetLayout.rawY;
    var radialCoor1 = radialCoordinate(x1, y1);
    var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * curvature);
    var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * curvature);
    var radialCoor4 = radialCoordinate(x2, y2);
    return {
      x1: radialCoor1.x || 0,
      y1: radialCoor1.y || 0,
      x2: radialCoor4.x || 0,
      y2: radialCoor4.y || 0,
      cpx1: radialCoor2.x || 0,
      cpy1: radialCoor2.y || 0,
      cpx2: radialCoor3.x || 0,
      cpy2: radialCoor3.y || 0
    };
  } else {
    x1 = sourceLayout.x;
    y1 = sourceLayout.y;
    x2 = targetLayout.x;
    y2 = targetLayout.y;
    if (orient === "LR" || orient === "RL") {
      cpx1 = x1 + (x2 - x1) * curvature;
      cpy1 = y1;
      cpx2 = x2 + (x1 - x2) * curvature;
      cpy2 = y2;
    }
    if (orient === "TB" || orient === "BT") {
      cpx1 = x1;
      cpy1 = y1 + (y2 - y1) * curvature;
      cpx2 = x2;
      cpy2 = y2 + (y1 - y2) * curvature;
    }
  }
  return {
    x1,
    y1,
    x2,
    y2,
    cpx1,
    cpy1,
    cpx2,
    cpy2
  };
}
var TreeView$1 = TreeView;
var inner$e = makeInner();
function linkSeriesData(opt) {
  var mainData = opt.mainData;
  var datas = opt.datas;
  if (!datas) {
    datas = {
      main: mainData
    };
    opt.datasAttr = {
      main: "data"
    };
  }
  opt.datas = opt.mainData = null;
  linkAll(mainData, datas, opt);
  each$f(datas, function(data) {
    each$f(mainData.TRANSFERABLE_METHODS, function(methodName) {
      data.wrapMethod(methodName, curry$1(transferInjection, opt));
    });
  });
  mainData.wrapMethod("cloneShallow", curry$1(cloneShallowInjection, opt));
  each$f(mainData.CHANGABLE_METHODS, function(methodName) {
    mainData.wrapMethod(methodName, curry$1(changeInjection, opt));
  });
  assert(datas[mainData.dataType] === mainData);
}
function transferInjection(opt, res) {
  if (isMainData(this)) {
    var datas = extend$1({}, inner$e(this).datas);
    datas[this.dataType] = res;
    linkAll(res, datas, opt);
  } else {
    linkSingle(res, this.dataType, inner$e(this).mainData, opt);
  }
  return res;
}
function changeInjection(opt, res) {
  opt.struct && opt.struct.update();
  return res;
}
function cloneShallowInjection(opt, res) {
  each$f(inner$e(res).datas, function(data, dataType) {
    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
  });
  return res;
}
function getLinkedData(dataType) {
  var mainData = inner$e(this).mainData;
  return dataType == null || mainData == null ? mainData : inner$e(mainData).datas[dataType];
}
function getLinkedDataAll() {
  var mainData = inner$e(this).mainData;
  return mainData == null ? [{
    data: mainData
  }] : map$1(keys(inner$e(mainData).datas), function(type) {
    return {
      type,
      data: inner$e(mainData).datas[type]
    };
  });
}
function isMainData(data) {
  return inner$e(data).mainData === data;
}
function linkAll(mainData, datas, opt) {
  inner$e(mainData).datas = {};
  each$f(datas, function(data, dataType) {
    linkSingle(data, dataType, mainData, opt);
  });
}
function linkSingle(data, dataType, mainData, opt) {
  inner$e(mainData).datas[dataType] = data;
  inner$e(data).mainData = mainData;
  data.dataType = dataType;
  if (opt.struct) {
    data[opt.structAttr] = opt.struct;
    opt.struct[opt.datasAttr[dataType]] = data;
  }
  data.getLinkedData = getLinkedData;
  data.getLinkedDataAll = getLinkedDataAll;
}
var TreeNode = function() {
  function TreeNode2(name, hostTree) {
    this.depth = 0;
    this.height = 0;
    this.dataIndex = -1;
    this.children = [];
    this.viewChildren = [];
    this.isExpand = false;
    this.name = name || "";
    this.hostTree = hostTree;
  }
  TreeNode2.prototype.isRemoved = function() {
    return this.dataIndex < 0;
  };
  TreeNode2.prototype.eachNode = function(options, cb, context) {
    if (isFunction$1(options)) {
      context = cb;
      cb = options;
      options = null;
    }
    options = options || {};
    if (isString(options)) {
      options = {
        order: options
      };
    }
    var order = options.order || "preorder";
    var children = this[options.attr || "children"];
    var suppressVisitSub;
    order === "preorder" && (suppressVisitSub = cb.call(context, this));
    for (var i = 0; !suppressVisitSub && i < children.length; i++) {
      children[i].eachNode(options, cb, context);
    }
    order === "postorder" && cb.call(context, this);
  };
  TreeNode2.prototype.updateDepthAndHeight = function(depth) {
    var height = 0;
    this.depth = depth;
    for (var i = 0; i < this.children.length; i++) {
      var child = this.children[i];
      child.updateDepthAndHeight(depth + 1);
      if (child.height > height) {
        height = child.height;
      }
    }
    this.height = height + 1;
  };
  TreeNode2.prototype.getNodeById = function(id) {
    if (this.getId() === id) {
      return this;
    }
    for (var i = 0, children = this.children, len2 = children.length; i < len2; i++) {
      var res = children[i].getNodeById(id);
      if (res) {
        return res;
      }
    }
  };
  TreeNode2.prototype.contains = function(node) {
    if (node === this) {
      return true;
    }
    for (var i = 0, children = this.children, len2 = children.length; i < len2; i++) {
      var res = children[i].contains(node);
      if (res) {
        return res;
      }
    }
  };
  TreeNode2.prototype.getAncestors = function(includeSelf) {
    var ancestors = [];
    var node = includeSelf ? this : this.parentNode;
    while (node) {
      ancestors.push(node);
      node = node.parentNode;
    }
    ancestors.reverse();
    return ancestors;
  };
  TreeNode2.prototype.getAncestorsIndices = function() {
    var indices = [];
    var currNode = this;
    while (currNode) {
      indices.push(currNode.dataIndex);
      currNode = currNode.parentNode;
    }
    indices.reverse();
    return indices;
  };
  TreeNode2.prototype.getDescendantIndices = function() {
    var indices = [];
    this.eachNode(function(childNode) {
      indices.push(childNode.dataIndex);
    });
    return indices;
  };
  TreeNode2.prototype.getValue = function(dimension) {
    var data = this.hostTree.data;
    return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
  };
  TreeNode2.prototype.setLayout = function(layout2, merge2) {
    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout2, merge2);
  };
  TreeNode2.prototype.getLayout = function() {
    return this.hostTree.data.getItemLayout(this.dataIndex);
  };
  TreeNode2.prototype.getModel = function(path) {
    if (this.dataIndex < 0) {
      return;
    }
    var hostTree = this.hostTree;
    var itemModel = hostTree.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };
  TreeNode2.prototype.getLevelModel = function() {
    return (this.hostTree.levelModels || [])[this.depth];
  };
  TreeNode2.prototype.setVisual = function(key, value) {
    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
  };
  TreeNode2.prototype.getVisual = function(key) {
    return this.hostTree.data.getItemVisual(this.dataIndex, key);
  };
  TreeNode2.prototype.getRawIndex = function() {
    return this.hostTree.data.getRawIndex(this.dataIndex);
  };
  TreeNode2.prototype.getId = function() {
    return this.hostTree.data.getId(this.dataIndex);
  };
  TreeNode2.prototype.getChildIndex = function() {
    if (this.parentNode) {
      var children = this.parentNode.children;
      for (var i = 0; i < children.length; ++i) {
        if (children[i] === this) {
          return i;
        }
      }
      return -1;
    }
    return -1;
  };
  TreeNode2.prototype.isAncestorOf = function(node) {
    var parent = node.parentNode;
    while (parent) {
      if (parent === this) {
        return true;
      }
      parent = parent.parentNode;
    }
    return false;
  };
  TreeNode2.prototype.isDescendantOf = function(node) {
    return node !== this && node.isAncestorOf(this);
  };
  return TreeNode2;
}();
var Tree = function() {
  function Tree2(hostModel) {
    this.type = "tree";
    this._nodes = [];
    this.hostModel = hostModel;
  }
  Tree2.prototype.eachNode = function(options, cb, context) {
    this.root.eachNode(options, cb, context);
  };
  Tree2.prototype.getNodeByDataIndex = function(dataIndex) {
    var rawIndex = this.data.getRawIndex(dataIndex);
    return this._nodes[rawIndex];
  };
  Tree2.prototype.getNodeById = function(name) {
    return this.root.getNodeById(name);
  };
  Tree2.prototype.update = function() {
    var data = this.data;
    var nodes = this._nodes;
    for (var i = 0, len2 = nodes.length; i < len2; i++) {
      nodes[i].dataIndex = -1;
    }
    for (var i = 0, len2 = data.count(); i < len2; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
  };
  Tree2.prototype.clearLayouts = function() {
    this.data.clearItemLayouts();
  };
  Tree2.createTree = function(dataRoot, hostModel, beforeLink) {
    var tree = new Tree2(hostModel);
    var listData = [];
    var dimMax = 1;
    buildHierarchy(dataRoot);
    function buildHierarchy(dataNode, parentNode2) {
      var value = dataNode.value;
      dimMax = Math.max(dimMax, isArray$1(value) ? value.length : 1);
      listData.push(dataNode);
      var node = new TreeNode(convertOptionIdName(dataNode.name, ""), tree);
      parentNode2 ? addChild(node, parentNode2) : tree.root = node;
      tree._nodes.push(node);
      var children = dataNode.children;
      if (children) {
        for (var i = 0; i < children.length; i++) {
          buildHierarchy(children[i], node);
        }
      }
    }
    tree.root.updateDepthAndHeight(0);
    var dimensions = prepareSeriesDataSchema(listData, {
      coordDimensions: ["value"],
      dimensionsCount: dimMax
    }).dimensions;
    var list = new SeriesData$1(dimensions, hostModel);
    list.initData(listData);
    beforeLink && beforeLink(list);
    linkSeriesData({
      mainData: list,
      struct: tree,
      structAttr: "tree"
    });
    tree.update();
    return tree;
  };
  return Tree2;
}();
function addChild(child, node) {
  var children = node.children;
  if (child.parentNode === node) {
    return;
  }
  children.push(child);
  child.parentNode = node;
}
var Tree$1 = Tree;
function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
  if (payload && indexOf(validPayloadTypes, payload.type) >= 0) {
    var root2 = seriesModel.getData().tree.root;
    var targetNode = payload.targetNode;
    if (isString(targetNode)) {
      targetNode = root2.getNodeById(targetNode);
    }
    if (targetNode && root2.contains(targetNode)) {
      return {
        node: targetNode
      };
    }
    var targetNodeId = payload.targetNodeId;
    if (targetNodeId != null && (targetNode = root2.getNodeById(targetNodeId))) {
      return {
        node: targetNode
      };
    }
  }
}
function getPathToRoot(node) {
  var path = [];
  while (node) {
    node = node.parentNode;
    node && path.push(node);
  }
  return path.reverse();
}
function aboveViewRoot(viewRoot, node) {
  var viewPath = getPathToRoot(viewRoot);
  return indexOf(viewPath, node) >= 0;
}
function wrapTreePathInfo(node, seriesModel) {
  var treePathInfo = [];
  while (node) {
    var nodeDataIndex = node.dataIndex;
    treePathInfo.push({
      name: node.name,
      dataIndex: nodeDataIndex,
      value: seriesModel.getRawValue(nodeDataIndex)
    });
    node = node.parentNode;
  }
  treePathInfo.reverse();
  return treePathInfo;
}
var TreeSeriesModel = function(_super) {
  __extends(TreeSeriesModel2, _super);
  function TreeSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.hasSymbolVisual = true;
    _this.ignoreStyleOnData = true;
    return _this;
  }
  TreeSeriesModel2.prototype.getInitialData = function(option) {
    var root2 = {
      name: option.name,
      children: option.data
    };
    var leaves = option.leaves || {};
    var leavesModel = new Model$1(leaves, this, this.ecModel);
    var tree = Tree$1.createTree(root2, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        var node = tree.getNodeByDataIndex(idx);
        if (!(node && node.children.length && node.isExpand)) {
          model.parentModel = leavesModel;
        }
        return model;
      });
    }
    var treeDepth = 0;
    tree.eachNode("preorder", function(node) {
      if (node.depth > treeDepth) {
        treeDepth = node.depth;
      }
    });
    var expandAndCollapse = option.expandAndCollapse;
    var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
    tree.root.eachNode("preorder", function(node) {
      var item = node.hostTree.data.getRawDataItem(node.dataIndex);
      node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
    });
    return tree.data;
  };
  TreeSeriesModel2.prototype.getOrient = function() {
    var orient = this.get("orient");
    if (orient === "horizontal") {
      orient = "LR";
    } else if (orient === "vertical") {
      orient = "TB";
    }
    return orient;
  };
  TreeSeriesModel2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  TreeSeriesModel2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  TreeSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var tree = this.getData().tree;
    var realRoot = tree.root.children[0];
    var node = tree.getNodeByDataIndex(dataIndex);
    var value = node.getValue();
    var name = node.name;
    while (node && node !== realRoot) {
      name = node.parentNode.name + "." + name;
      node = node.parentNode;
    }
    return createTooltipMarkup("nameValue", {
      name,
      value,
      noValue: isNaN(value) || value == null
    });
  };
  TreeSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var params = _super.prototype.getDataParams.apply(this, arguments);
    var node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treeAncestors = wrapTreePathInfo(node, this);
    return params;
  };
  TreeSeriesModel2.type = "series.tree";
  TreeSeriesModel2.layoutMode = "box";
  TreeSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "view",
    left: "12%",
    top: "12%",
    right: "12%",
    bottom: "12%",
    layout: "orthogonal",
    edgeShape: "curve",
    edgeForkPosition: "50%",
    roam: false,
    nodeScaleRatio: 0.4,
    center: null,
    zoom: 1,
    orient: "LR",
    symbol: "emptyCircle",
    symbolSize: 7,
    expandAndCollapse: true,
    initialTreeDepth: 2,
    lineStyle: {
      color: "#ccc",
      width: 1.5,
      curveness: 0.5
    },
    itemStyle: {
      color: "lightsteelblue",
      borderWidth: 1.5
    },
    label: {
      show: true
    },
    animationEasing: "linear",
    animationDuration: 700,
    animationDurationUpdate: 500
  };
  return TreeSeriesModel2;
}(SeriesModel$1);
var TreeSeriesModel$1 = TreeSeriesModel;
function eachAfter(root2, callback, separation2) {
  var nodes = [root2];
  var next = [];
  var node;
  while (node = nodes.pop()) {
    next.push(node);
    if (node.isExpand) {
      var children = node.children;
      if (children.length) {
        for (var i = 0; i < children.length; i++) {
          nodes.push(children[i]);
        }
      }
    }
  }
  while (node = next.pop()) {
    callback(node, separation2);
  }
}
function eachBefore(root2, callback) {
  var nodes = [root2];
  var node;
  while (node = nodes.pop()) {
    callback(node);
    if (node.isExpand) {
      var children = node.children;
      if (children.length) {
        for (var i = children.length - 1; i >= 0; i--) {
          nodes.push(children[i]);
        }
      }
    }
  }
}
function treeLayout(ecModel, api) {
  ecModel.eachSeriesByType("tree", function(seriesModel) {
    commonLayout(seriesModel, api);
  });
}
function commonLayout(seriesModel, api) {
  var layoutInfo = getViewRect$4(seriesModel, api);
  seriesModel.layoutInfo = layoutInfo;
  var layout2 = seriesModel.get("layout");
  var width = 0;
  var height = 0;
  var separation$1 = null;
  if (layout2 === "radial") {
    width = 2 * Math.PI;
    height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
    separation$1 = separation(function(node1, node2) {
      return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
    });
  } else {
    width = layoutInfo.width;
    height = layoutInfo.height;
    separation$1 = separation();
  }
  var virtualRoot = seriesModel.getData().tree.root;
  var realRoot = virtualRoot.children[0];
  if (realRoot) {
    init(virtualRoot);
    eachAfter(realRoot, firstWalk, separation$1);
    virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
    eachBefore(realRoot, secondWalk);
    var left_1 = realRoot;
    var right_1 = realRoot;
    var bottom_1 = realRoot;
    eachBefore(realRoot, function(node) {
      var x = node.getLayout().x;
      if (x < left_1.getLayout().x) {
        left_1 = node;
      }
      if (x > right_1.getLayout().x) {
        right_1 = node;
      }
      if (node.depth > bottom_1.depth) {
        bottom_1 = node;
      }
    });
    var delta = left_1 === right_1 ? 1 : separation$1(left_1, right_1) / 2;
    var tx_1 = delta - left_1.getLayout().x;
    var kx_1 = 0;
    var ky_1 = 0;
    var coorX_1 = 0;
    var coorY_1 = 0;
    if (layout2 === "radial") {
      kx_1 = width / (right_1.getLayout().x + delta + tx_1);
      ky_1 = height / (bottom_1.depth - 1 || 1);
      eachBefore(realRoot, function(node) {
        coorX_1 = (node.getLayout().x + tx_1) * kx_1;
        coorY_1 = (node.depth - 1) * ky_1;
        var finalCoor = radialCoordinate(coorX_1, coorY_1);
        node.setLayout({
          x: finalCoor.x,
          y: finalCoor.y,
          rawX: coorX_1,
          rawY: coorY_1
        }, true);
      });
    } else {
      var orient_1 = seriesModel.getOrient();
      if (orient_1 === "RL" || orient_1 === "LR") {
        ky_1 = height / (right_1.getLayout().x + delta + tx_1);
        kx_1 = width / (bottom_1.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorY_1 = (node.getLayout().x + tx_1) * ky_1;
          coorX_1 = orient_1 === "LR" ? (node.depth - 1) * kx_1 : width - (node.depth - 1) * kx_1;
          node.setLayout({
            x: coorX_1,
            y: coorY_1
          }, true);
        });
      } else if (orient_1 === "TB" || orient_1 === "BT") {
        kx_1 = width / (right_1.getLayout().x + delta + tx_1);
        ky_1 = height / (bottom_1.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorX_1 = (node.getLayout().x + tx_1) * kx_1;
          coorY_1 = orient_1 === "TB" ? (node.depth - 1) * ky_1 : height - (node.depth - 1) * ky_1;
          node.setLayout({
            x: coorX_1,
            y: coorY_1
          }, true);
        });
      }
    }
  }
}
function treeVisual(ecModel) {
  ecModel.eachSeriesByType("tree", function(seriesModel) {
    var data = seriesModel.getData();
    var tree = data.tree;
    tree.eachNode(function(node) {
      var model = node.getModel();
      var style = model.getModel("itemStyle").getItemStyle();
      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
      extend$1(existsStyle, style);
    });
  });
}
function installTreeAction(registers) {
  registers.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      var dataIndex = payload.dataIndex;
      var tree = seriesModel.getData().tree;
      var node = tree.getNodeByDataIndex(dataIndex);
      node.isExpand = !node.isExpand;
    });
  });
  registers.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    update: "none"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = updateCenterAndZoom(coordSys, payload);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}
function install$X(registers) {
  registers.registerChartView(TreeView$1);
  registers.registerSeriesModel(TreeSeriesModel$1);
  registers.registerLayout(treeLayout);
  registers.registerVisual(treeVisual);
  installTreeAction(registers);
}
var actionTypes = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function installTreemapAction(registers) {
  for (var i = 0; i < actionTypes.length; i++) {
    registers.registerAction({
      type: actionTypes[i],
      update: "updateView"
    }, noop$1);
  }
  registers.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: payload
    }, handleRootToNode);
    function handleRootToNode(model, index) {
      var types = ["treemapZoomToNode", "treemapRootToNode"];
      var targetInfo = retrieveTargetInfo(payload, types, model);
      if (targetInfo) {
        var originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
}
function enableAriaDecalForTree(seriesModel) {
  var data = seriesModel.getData();
  var tree = data.tree;
  var decalPaletteScope2 = {};
  tree.eachNode(function(node) {
    var current = node;
    while (current && current.depth > 1) {
      current = current.parentNode;
    }
    var decal = getDecalFromPalette(seriesModel.ecModel, current.name || current.dataIndex + "", decalPaletteScope2);
    node.setVisual("decal", decal);
  });
}
var TreemapSeriesModel = function(_super) {
  __extends(TreemapSeriesModel2, _super);
  function TreemapSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TreemapSeriesModel2.type;
    _this.preventUsingHoverLayer = true;
    return _this;
  }
  TreemapSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var root2 = {
      name: option.name,
      children: option.data
    };
    completeTreeValue$1(root2);
    var levels = option.levels || [];
    var designatedVisualItemStyle = this.designatedVisualItemStyle = {};
    var designatedVisualModel = new Model$1({
      itemStyle: designatedVisualItemStyle
    }, this, ecModel);
    levels = option.levels = setDefault(levels, ecModel);
    var levelModels = map$1(levels || [], function(levelDefine) {
      return new Model$1(levelDefine, designatedVisualModel, ecModel);
    }, this);
    var tree = Tree$1.createTree(root2, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        var node = tree.getNodeByDataIndex(idx);
        var levelModel = node ? levelModels[node.depth] : null;
        model.parentModel = levelModel || designatedVisualModel;
        return model;
      });
    }
    return tree.data;
  };
  TreemapSeriesModel2.prototype.optionUpdated = function() {
    this.resetViewRoot();
  };
  TreemapSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var name = data.getName(dataIndex);
    return createTooltipMarkup("nameValue", {
      name,
      value
    });
  };
  TreemapSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var params = _super.prototype.getDataParams.apply(this, arguments);
    var node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treeAncestors = wrapTreePathInfo(node, this);
    params.treePathInfo = params.treeAncestors;
    return params;
  };
  TreemapSeriesModel2.prototype.setLayoutInfo = function(layoutInfo) {
    this.layoutInfo = this.layoutInfo || {};
    extend$1(this.layoutInfo, layoutInfo);
  };
  TreemapSeriesModel2.prototype.mapIdToIndex = function(id) {
    var idIndexMap = this._idIndexMap;
    if (!idIndexMap) {
      idIndexMap = this._idIndexMap = createHashMap();
      this._idIndexMapCount = 0;
    }
    var index = idIndexMap.get(id);
    if (index == null) {
      idIndexMap.set(id, index = this._idIndexMapCount++);
    }
    return index;
  };
  TreemapSeriesModel2.prototype.getViewRoot = function() {
    return this._viewRoot;
  };
  TreemapSeriesModel2.prototype.resetViewRoot = function(viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    var root2 = this.getRawData().tree.root;
    if (!viewRoot || viewRoot !== root2 && !root2.contains(viewRoot)) {
      this._viewRoot = root2;
    }
  };
  TreemapSeriesModel2.prototype.enableAriaDecal = function() {
    enableAriaDecalForTree(this);
  };
  TreemapSeriesModel2.type = "series.treemap";
  TreemapSeriesModel2.layoutMode = "box";
  TreemapSeriesModel2.defaultOption = {
    progressive: 0,
    left: "center",
    top: "middle",
    width: "80%",
    height: "80%",
    sort: true,
    clipWindow: "origin",
    squareRatio: 0.5 * (1 + Math.sqrt(5)),
    leafDepth: null,
    drillDownIcon: "\u25B6",
    zoomToNodeRatio: 0.32 * 0.32,
    roam: true,
    nodeClick: "zoomToNode",
    animation: true,
    animationDurationUpdate: 900,
    animationEasing: "quinticInOut",
    breadcrumb: {
      show: true,
      height: 22,
      left: "center",
      top: "bottom",
      emptyItemWidth: 25,
      itemStyle: {
        color: "rgba(0,0,0,0.7)",
        textStyle: {
          color: "#fff"
        }
      }
    },
    label: {
      show: true,
      distance: 0,
      padding: 5,
      position: "inside",
      color: "#fff",
      overflow: "truncate"
    },
    upperLabel: {
      show: false,
      position: [0, "50%"],
      height: 20,
      overflow: "truncate",
      verticalAlign: "middle"
    },
    itemStyle: {
      color: null,
      colorAlpha: null,
      colorSaturation: null,
      borderWidth: 0,
      gapWidth: 0,
      borderColor: "#fff",
      borderColorSaturation: null
    },
    emphasis: {
      upperLabel: {
        show: true,
        position: [0, "50%"],
        overflow: "truncate",
        verticalAlign: "middle"
      }
    },
    visualDimension: 0,
    visualMin: null,
    visualMax: null,
    color: [],
    colorAlpha: null,
    colorSaturation: null,
    colorMappingBy: "index",
    visibleMin: 10,
    childrenVisibleMin: null,
    levels: []
  };
  return TreemapSeriesModel2;
}(SeriesModel$1);
function completeTreeValue$1(dataNode) {
  var sum2 = 0;
  each$f(dataNode.children, function(child) {
    completeTreeValue$1(child);
    var childValue = child.value;
    isArray$1(childValue) && (childValue = childValue[0]);
    sum2 += childValue;
  });
  var thisValue = dataNode.value;
  if (isArray$1(thisValue)) {
    thisValue = thisValue[0];
  }
  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum2;
  }
  if (thisValue < 0) {
    thisValue = 0;
  }
  isArray$1(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
function setDefault(levels, ecModel) {
  var globalColorList = normalizeToArray(ecModel.get("color"));
  var globalDecalList = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  if (!globalColorList) {
    return;
  }
  levels = levels || [];
  var hasColorDefine;
  var hasDecalDefine;
  each$f(levels, function(levelDefine) {
    var model = new Model$1(levelDefine);
    var modelColor = model.get("color");
    var modelDecal = model.get("decal");
    if (model.get(["itemStyle", "color"]) || modelColor && modelColor !== "none") {
      hasColorDefine = true;
    }
    if (model.get(["itemStyle", "decal"]) || modelDecal && modelDecal !== "none") {
      hasDecalDefine = true;
    }
  });
  var level0 = levels[0] || (levels[0] = {});
  if (!hasColorDefine) {
    level0.color = globalColorList.slice();
  }
  if (!hasDecalDefine && globalDecalList) {
    level0.decal = globalDecalList.slice();
  }
  return levels;
}
var TreemapSeriesModel$1 = TreemapSeriesModel;
var TEXT_PADDING = 8;
var ITEM_GAP = 8;
var ARRAY_LENGTH = 5;
var Breadcrumb = function() {
  function Breadcrumb2(containerGroup) {
    this.group = new Group$4();
    containerGroup.add(this.group);
  }
  Breadcrumb2.prototype.render = function(seriesModel, api, targetNode, onSelect) {
    var model = seriesModel.getModel("breadcrumb");
    var thisGroup = this.group;
    thisGroup.removeAll();
    if (!model.get("show") || !targetNode) {
      return;
    }
    var normalStyleModel = model.getModel("itemStyle");
    var textStyleModel = normalStyleModel.getModel("textStyle");
    var layoutParam = {
      pos: {
        left: model.get("left"),
        right: model.get("right"),
        top: model.get("top"),
        bottom: model.get("bottom")
      },
      box: {
        width: api.getWidth(),
        height: api.getHeight()
      },
      emptyItemWidth: model.get("emptyItemWidth"),
      totalWidth: 0,
      renderList: []
    };
    this._prepare(targetNode, layoutParam, textStyleModel);
    this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);
    positionElement(thisGroup, layoutParam.pos, layoutParam.box);
  };
  Breadcrumb2.prototype._prepare = function(targetNode, layoutParam, textStyleModel) {
    for (var node = targetNode; node; node = node.parentNode) {
      var text = convertOptionIdName(node.getModel().get("name"), "");
      var textRect = textStyleModel.getTextRect(text);
      var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
      layoutParam.totalWidth += itemWidth + ITEM_GAP;
      layoutParam.renderList.push({
        node,
        text,
        width: itemWidth
      });
    }
  };
  Breadcrumb2.prototype._renderContent = function(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
    var lastX = 0;
    var emptyItemWidth = layoutParam.emptyItemWidth;
    var height = seriesModel.get(["breadcrumb", "height"]);
    var availableSize = getAvailableSize(layoutParam.pos, layoutParam.box);
    var totalWidth = layoutParam.totalWidth;
    var renderList = layoutParam.renderList;
    for (var i = renderList.length - 1; i >= 0; i--) {
      var item = renderList[i];
      var itemNode = item.node;
      var itemWidth = item.width;
      var text = item.text;
      if (totalWidth > availableSize.width) {
        totalWidth -= itemWidth - emptyItemWidth;
        itemWidth = emptyItemWidth;
        text = null;
      }
      var el = new Polygon$1({
        shape: {
          points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
        },
        style: defaults(normalStyleModel.getItemStyle(), {
          lineJoin: "bevel"
        }),
        textContent: new ZRText$1({
          style: {
            text,
            fill: textStyleModel.getTextColor(),
            font: textStyleModel.getFont()
          }
        }),
        textConfig: {
          position: "inside"
        },
        z2: Z2_EMPHASIS_LIFT * 1e4,
        onclick: curry$1(onSelect, itemNode)
      });
      el.disableLabelAnimation = true;
      this.group.add(el);
      packEventData(el, seriesModel, itemNode);
      lastX += itemWidth + ITEM_GAP;
    }
  };
  Breadcrumb2.prototype.remove = function() {
    this.group.removeAll();
  };
  return Breadcrumb2;
}();
function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
  var points2 = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
  !tail && points2.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
  !head && points2.push([x, y + itemHeight / 2]);
  return points2;
}
function packEventData(el, seriesModel, itemNode) {
  getECData(el).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: seriesModel.componentIndex,
    seriesIndex: seriesModel.seriesIndex,
    seriesName: seriesModel.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: itemNode && itemNode.dataIndex,
      name: itemNode && itemNode.name
    },
    treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
  };
}
var Breadcrumb$1 = Breadcrumb;
var AnimationWrap = function() {
  function AnimationWrap2() {
    this._storage = [];
    this._elExistsMap = {};
  }
  AnimationWrap2.prototype.add = function(el, target, duration, delay, easing) {
    if (this._elExistsMap[el.id]) {
      return false;
    }
    this._elExistsMap[el.id] = true;
    this._storage.push({
      el,
      target,
      duration,
      delay,
      easing
    });
    return true;
  };
  AnimationWrap2.prototype.finished = function(callback) {
    this._finishedCallback = callback;
    return this;
  };
  AnimationWrap2.prototype.start = function() {
    var _this = this;
    var count2 = this._storage.length;
    var checkTerminate = function() {
      count2--;
      if (count2 <= 0) {
        _this._storage.length = 0;
        _this._elExistsMap = {};
        _this._finishedCallback && _this._finishedCallback();
      }
    };
    for (var i = 0, len2 = this._storage.length; i < len2; i++) {
      var item = this._storage[i];
      item.el.animateTo(item.target, {
        duration: item.duration,
        delay: item.delay,
        easing: item.easing,
        setToFinal: true,
        done: checkTerminate,
        aborted: checkTerminate
      });
    }
    return this;
  };
  return AnimationWrap2;
}();
function createWrap() {
  return new AnimationWrap();
}
var Group$2 = Group$4;
var Rect$1 = Rect$3;
var DRAG_THRESHOLD = 3;
var PATH_LABEL_NOAMAL = "label";
var PATH_UPPERLABEL_NORMAL = "upperLabel";
var Z2_BASE = Z2_EMPHASIS_LIFT * 10;
var Z2_BG = Z2_EMPHASIS_LIFT * 2;
var Z2_CONTENT = Z2_EMPHASIS_LIFT * 3;
var getStateItemStyle = makeStyleMapper([
  ["fill", "color"],
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
]);
var getItemStyleNormal = function(model) {
  var itemStyle = getStateItemStyle(model);
  itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
  return itemStyle;
};
var inner$d = makeInner();
var TreemapView = function(_super) {
  __extends(TreemapView2, _super);
  function TreemapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TreemapView2.type;
    _this._state = "ready";
    _this._storage = createStorage();
    return _this;
  }
  TreemapView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var models = ecModel.findComponents({
      mainType: "series",
      subType: "treemap",
      query: payload
    });
    if (indexOf(models, seriesModel) < 0) {
      return;
    }
    this.seriesModel = seriesModel;
    this.api = api;
    this.ecModel = ecModel;
    var types = ["treemapZoomToNode", "treemapRootToNode"];
    var targetInfo = retrieveTargetInfo(payload, types, seriesModel);
    var payloadType = payload && payload.type;
    var layoutInfo = seriesModel.layoutInfo;
    var isInit = !this._oldTree;
    var thisStorage = this._storage;
    var reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
      rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
      direction: payload.direction
    } : null;
    var containerGroup = this._giveContainerGroup(layoutInfo);
    var hasAnimation = seriesModel.get("animation");
    var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
    hasAnimation && !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
    this._resetController(api);
    this._renderBreadcrumb(seriesModel, api, targetInfo);
  };
  TreemapView2.prototype._giveContainerGroup = function(layoutInfo) {
    var containerGroup = this._containerGroup;
    if (!containerGroup) {
      containerGroup = this._containerGroup = new Group$2();
      this._initEvents(containerGroup);
      this.group.add(containerGroup);
    }
    containerGroup.x = layoutInfo.x;
    containerGroup.y = layoutInfo.y;
    return containerGroup;
  };
  TreemapView2.prototype._doRender = function(containerGroup, seriesModel, reRoot) {
    var thisTree = seriesModel.getData().tree;
    var oldTree = this._oldTree;
    var lastsForAnimation = createStorage();
    var thisStorage = createStorage();
    var oldStorage = this._storage;
    var willInvisibleEls = [];
    function doRenderNode(thisNode, oldNode, parentGroup, depth) {
      return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth);
    }
    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
    var willDeleteEls = clearStorage(oldStorage);
    this._oldTree = thisTree;
    this._storage = thisStorage;
    return {
      lastsForAnimation,
      willDeleteEls,
      renderFinally
    };
    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
      if (sameTree) {
        oldViewChildren = thisViewChildren;
        each$f(thisViewChildren, function(child, index) {
          !child.isRemoved() && processNode(index, index);
        });
      } else {
        new DataDiffer$1(oldViewChildren, thisViewChildren, getKey2, getKey2).add(processNode).update(processNode).remove(curry$1(processNode, null)).execute();
      }
      function getKey2(node) {
        return node.getId();
      }
      function processNode(newIndex, oldIndex) {
        var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
        var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
        var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
        group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
      }
    }
    function clearStorage(storage2) {
      var willDeleteEls2 = createStorage();
      storage2 && each$f(storage2, function(store, storageName) {
        var delEls = willDeleteEls2[storageName];
        each$f(store, function(el) {
          el && (delEls.push(el), inner$d(el).willDelete = true);
        });
      });
      return willDeleteEls2;
    }
    function renderFinally() {
      each$f(willDeleteEls, function(els) {
        each$f(els, function(el) {
          el.parent && el.parent.remove(el);
        });
      });
      each$f(willInvisibleEls, function(el) {
        el.invisible = true;
        el.dirty();
      });
    }
  };
  TreemapView2.prototype._doAnimation = function(containerGroup, renderResult, seriesModel, reRoot) {
    var durationOption = seriesModel.get("animationDurationUpdate");
    var easingOption = seriesModel.get("animationEasing");
    var duration = (isFunction$1(durationOption) ? 0 : durationOption) || 0;
    var easing = (isFunction$1(easingOption) ? null : easingOption) || "cubicOut";
    var animationWrap = createWrap();
    each$f(renderResult.willDeleteEls, function(store, storageName) {
      each$f(store, function(el, rawIndex) {
        if (el.invisible) {
          return;
        }
        var parent = el.parent;
        var target;
        var innerStore = inner$d(parent);
        if (reRoot && reRoot.direction === "drillDown") {
          target = parent === reRoot.rootNodeGroup ? {
            shape: {
              x: 0,
              y: 0,
              width: innerStore.nodeWidth,
              height: innerStore.nodeHeight
            },
            style: {
              opacity: 0
            }
          } : {
            style: {
              opacity: 0
            }
          };
        } else {
          var targetX = 0;
          var targetY = 0;
          if (!innerStore.willDelete) {
            targetX = innerStore.nodeWidth / 2;
            targetY = innerStore.nodeHeight / 2;
          }
          target = storageName === "nodeGroup" ? {
            x: targetX,
            y: targetY,
            style: {
              opacity: 0
            }
          } : {
            shape: {
              x: targetX,
              y: targetY,
              width: 0,
              height: 0
            },
            style: {
              opacity: 0
            }
          };
        }
        target && animationWrap.add(el, target, duration, 0, easing);
      });
    });
    each$f(this._storage, function(store, storageName) {
      each$f(store, function(el, rawIndex) {
        var last = renderResult.lastsForAnimation[storageName][rawIndex];
        var target = {};
        if (!last) {
          return;
        }
        if (el instanceof Group$4) {
          if (last.oldX != null) {
            target.x = el.x;
            target.y = el.y;
            el.x = last.oldX;
            el.y = last.oldY;
          }
        } else {
          if (last.oldShape) {
            target.shape = extend$1({}, el.shape);
            el.setShape(last.oldShape);
          }
          if (last.fadein) {
            el.setStyle("opacity", 0);
            target.style = {
              opacity: 1
            };
          } else if (el.style.opacity !== 1) {
            target.style = {
              opacity: 1
            };
          }
        }
        animationWrap.add(el, target, duration, 0, easing);
      });
    }, this);
    this._state = "animating";
    animationWrap.finished(bind$1(function() {
      this._state = "ready";
      renderResult.renderFinally();
    }, this)).start();
  };
  TreemapView2.prototype._resetController = function(api) {
    var controller = this._controller;
    if (!controller) {
      controller = this._controller = new RoamController$1(api.getZr());
      controller.enable(this.seriesModel.get("roam"));
      controller.on("pan", bind$1(this._onPan, this));
      controller.on("zoom", bind$1(this._onZoom, this));
    }
    var rect = new BoundingRect$1(0, 0, api.getWidth(), api.getHeight());
    controller.setPointerChecker(function(e2, x, y) {
      return rect.contain(x, y);
    });
  };
  TreemapView2.prototype._clearController = function() {
    var controller = this._controller;
    if (controller) {
      controller.dispose();
      controller = null;
    }
  };
  TreemapView2.prototype._onPan = function(e2) {
    if (this._state !== "animating" && (Math.abs(e2.dx) > DRAG_THRESHOLD || Math.abs(e2.dy) > DRAG_THRESHOLD)) {
      var root2 = this.seriesModel.getData().tree.root;
      if (!root2) {
        return;
      }
      var rootLayout = root2.getLayout();
      if (!rootLayout) {
        return;
      }
      this.api.dispatchAction({
        type: "treemapMove",
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rootLayout.x + e2.dx,
          y: rootLayout.y + e2.dy,
          width: rootLayout.width,
          height: rootLayout.height
        }
      });
    }
  };
  TreemapView2.prototype._onZoom = function(e2) {
    var mouseX = e2.originX;
    var mouseY = e2.originY;
    if (this._state !== "animating") {
      var root2 = this.seriesModel.getData().tree.root;
      if (!root2) {
        return;
      }
      var rootLayout = root2.getLayout();
      if (!rootLayout) {
        return;
      }
      var rect = new BoundingRect$1(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
      var layoutInfo = this.seriesModel.layoutInfo;
      mouseX -= layoutInfo.x;
      mouseY -= layoutInfo.y;
      var m2 = create$2();
      translate(m2, m2, [-mouseX, -mouseY]);
      scale$1(m2, m2, [e2.scale, e2.scale]);
      translate(m2, m2, [mouseX, mouseY]);
      rect.applyTransform(m2);
      this.api.dispatchAction({
        type: "treemapRender",
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        }
      });
    }
  };
  TreemapView2.prototype._initEvents = function(containerGroup) {
    var _this = this;
    containerGroup.on("click", function(e2) {
      if (_this._state !== "ready") {
        return;
      }
      var nodeClick = _this.seriesModel.get("nodeClick", true);
      if (!nodeClick) {
        return;
      }
      var targetInfo = _this.findTarget(e2.offsetX, e2.offsetY);
      if (!targetInfo) {
        return;
      }
      var node = targetInfo.node;
      if (node.getLayout().isLeafRoot) {
        _this._rootToNode(targetInfo);
      } else {
        if (nodeClick === "zoomToNode") {
          _this._zoomToNode(targetInfo);
        } else if (nodeClick === "link") {
          var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
          var link = itemModel.get("link", true);
          var linkTarget = itemModel.get("target", true) || "blank";
          link && windowOpen(link, linkTarget);
        }
      }
    }, this);
  };
  TreemapView2.prototype._renderBreadcrumb = function(seriesModel, api, targetInfo) {
    var _this = this;
    if (!targetInfo) {
      targetInfo = seriesModel.get("leafDepth", true) != null ? {
        node: seriesModel.getViewRoot()
      } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
      if (!targetInfo) {
        targetInfo = {
          node: seriesModel.getData().tree.root
        };
      }
    }
    (this._breadcrumb || (this._breadcrumb = new Breadcrumb$1(this.group))).render(seriesModel, api, targetInfo.node, function(node) {
      if (_this._state !== "animating") {
        aboveViewRoot(seriesModel.getViewRoot(), node) ? _this._rootToNode({
          node
        }) : _this._zoomToNode({
          node
        });
      }
    });
  };
  TreemapView2.prototype.remove = function() {
    this._clearController();
    this._containerGroup && this._containerGroup.removeAll();
    this._storage = createStorage();
    this._state = "ready";
    this._breadcrumb && this._breadcrumb.remove();
  };
  TreemapView2.prototype.dispose = function() {
    this._clearController();
  };
  TreemapView2.prototype._zoomToNode = function(targetInfo) {
    this.api.dispatchAction({
      type: "treemapZoomToNode",
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  };
  TreemapView2.prototype._rootToNode = function(targetInfo) {
    this.api.dispatchAction({
      type: "treemapRootToNode",
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  };
  TreemapView2.prototype.findTarget = function(x, y) {
    var targetInfo;
    var viewRoot = this.seriesModel.getViewRoot();
    viewRoot.eachNode({
      attr: "viewChildren",
      order: "preorder"
    }, function(node) {
      var bgEl = this._storage.background[node.getRawIndex()];
      if (bgEl) {
        var point = bgEl.transformCoordToLocal(x, y);
        var shape = bgEl.shape;
        if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
          targetInfo = {
            node,
            offsetX: point[0],
            offsetY: point[1]
          };
        } else {
          return false;
        }
      }
    }, this);
    return targetInfo;
  };
  TreemapView2.type = "treemap";
  return TreemapView2;
}(ChartView$1);
function createStorage() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
  if (!thisNode) {
    return;
  }
  var thisLayout = thisNode.getLayout();
  var data = seriesModel.getData();
  var nodeModel = thisNode.getModel();
  data.setItemGraphicEl(thisNode.dataIndex, null);
  if (!thisLayout || !thisLayout.isInView) {
    return;
  }
  var thisWidth = thisLayout.width;
  var thisHeight = thisLayout.height;
  var borderWidth = thisLayout.borderWidth;
  var thisInvisible = thisLayout.invisible;
  var thisRawIndex = thisNode.getRawIndex();
  var oldRawIndex = oldNode && oldNode.getRawIndex();
  var thisViewChildren = thisNode.viewChildren;
  var upperHeight = thisLayout.upperHeight;
  var isParent = thisViewChildren && thisViewChildren.length;
  var itemStyleNormalModel = nodeModel.getModel("itemStyle");
  var itemStyleEmphasisModel = nodeModel.getModel(["emphasis", "itemStyle"]);
  var itemStyleBlurModel = nodeModel.getModel(["blur", "itemStyle"]);
  var itemStyleSelectModel = nodeModel.getModel(["select", "itemStyle"]);
  var borderRadius = itemStyleNormalModel.get("borderRadius") || 0;
  var group = giveGraphic("nodeGroup", Group$2);
  if (!group) {
    return;
  }
  parentGroup.add(group);
  group.x = thisLayout.x || 0;
  group.y = thisLayout.y || 0;
  group.markRedraw();
  inner$d(group).nodeWidth = thisWidth;
  inner$d(group).nodeHeight = thisHeight;
  if (thisLayout.isAboveViewRoot) {
    return group;
  }
  var bg = giveGraphic("background", Rect$1, depth, Z2_BG);
  bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
  var emphasisModel = nodeModel.getModel("emphasis");
  var focus = emphasisModel.get("focus");
  var blurScope = emphasisModel.get("blurScope");
  var isDisabled = emphasisModel.get("disabled");
  var focusOrIndices = focus === "ancestor" ? thisNode.getAncestorsIndices() : focus === "descendant" ? thisNode.getDescendantIndices() : focus;
  if (isParent) {
    if (isHighDownDispatcher(group)) {
      setAsHighDownDispatcher(group, false);
    }
    if (bg) {
      setAsHighDownDispatcher(bg, !isDisabled);
      data.setItemGraphicEl(thisNode.dataIndex, bg);
      enableHoverFocus(bg, focusOrIndices, blurScope);
    }
  } else {
    var content = giveGraphic("content", Rect$1, depth, Z2_CONTENT);
    content && renderContent(group, content);
    bg.disableMorphing = true;
    if (bg && isHighDownDispatcher(bg)) {
      setAsHighDownDispatcher(bg, false);
    }
    setAsHighDownDispatcher(group, !isDisabled);
    data.setItemGraphicEl(thisNode.dataIndex, group);
    enableHoverFocus(group, focusOrIndices, blurScope);
  }
  return group;
  function renderBackground(group2, bg2, useUpperLabel) {
    var ecData = getECData(bg2);
    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    bg2.setShape({
      x: 0,
      y: 0,
      width: thisWidth,
      height: thisHeight,
      r: borderRadius
    });
    if (thisInvisible) {
      processInvisible(bg2);
    } else {
      bg2.invisible = false;
      var style = thisNode.getVisual("style");
      var visualBorderColor = style.stroke;
      var normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualBorderColor;
      var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      emphasisStyle.fill = itemStyleEmphasisModel.get("borderColor");
      var blurStyle = getStateItemStyle(itemStyleBlurModel);
      blurStyle.fill = itemStyleBlurModel.get("borderColor");
      var selectStyle = getStateItemStyle(itemStyleSelectModel);
      selectStyle.fill = itemStyleSelectModel.get("borderColor");
      if (useUpperLabel) {
        var upperLabelWidth = thisWidth - 2 * borderWidth;
        prepareText(bg2, visualBorderColor, style.opacity, {
          x: borderWidth,
          y: 0,
          width: upperLabelWidth,
          height: upperHeight
        });
      } else {
        bg2.removeTextContent();
      }
      bg2.setStyle(normalStyle);
      bg2.ensureState("emphasis").style = emphasisStyle;
      bg2.ensureState("blur").style = blurStyle;
      bg2.ensureState("select").style = selectStyle;
      setDefaultStateProxy(bg2);
    }
    group2.add(bg2);
  }
  function renderContent(group2, content2) {
    var ecData = getECData(content2);
    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
    var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
    content2.culling = true;
    content2.setShape({
      x: borderWidth,
      y: borderWidth,
      width: contentWidth,
      height: contentHeight,
      r: borderRadius
    });
    if (thisInvisible) {
      processInvisible(content2);
    } else {
      content2.invisible = false;
      var nodeStyle = thisNode.getVisual("style");
      var visualColor = nodeStyle.fill;
      var normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualColor;
      normalStyle.decal = nodeStyle.decal;
      var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      var blurStyle = getStateItemStyle(itemStyleBlurModel);
      var selectStyle = getStateItemStyle(itemStyleSelectModel);
      prepareText(content2, visualColor, nodeStyle.opacity, null);
      content2.setStyle(normalStyle);
      content2.ensureState("emphasis").style = emphasisStyle;
      content2.ensureState("blur").style = blurStyle;
      content2.ensureState("select").style = selectStyle;
      setDefaultStateProxy(content2);
    }
    group2.add(content2);
  }
  function processInvisible(element) {
    !element.invisible && willInvisibleEls.push(element);
  }
  function prepareText(rectEl, visualColor, visualOpacity, upperLabelRect) {
    var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
    var defaultText = convertOptionIdName(nodeModel.get("name"), null);
    var isShow = normalLabelModel.getShallow("show");
    setLabelStyle(rectEl, getLabelStatesModels(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
      defaultText: isShow ? defaultText : null,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      labelFetcher: seriesModel,
      labelDataIndex: thisNode.dataIndex
    });
    var textEl = rectEl.getTextContent();
    if (!textEl) {
      return;
    }
    var textStyle = textEl.style;
    var textPadding = normalizeCssArray$1(textStyle.padding || 0);
    if (upperLabelRect) {
      rectEl.setTextConfig({
        layoutRect: upperLabelRect
      });
      textEl.disableLabelLayout = true;
    }
    textEl.beforeUpdate = function() {
      var width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);
      var height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);
      if (textStyle.width !== width || textStyle.height !== height) {
        textEl.setStyle({
          width,
          height
        });
      }
    };
    textStyle.truncateMinChar = 2;
    textStyle.lineOverflow = "truncate";
    addDrillDownIcon(textStyle, upperLabelRect, thisLayout);
    var textEmphasisState = textEl.getState("emphasis");
    addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);
  }
  function addDrillDownIcon(style, upperLabelRect, thisLayout2) {
    var text = style ? style.text : null;
    if (!upperLabelRect && thisLayout2.isLeafRoot && text != null) {
      var iconChar = seriesModel.get("drillDownIcon", true);
      style.text = iconChar ? iconChar + " " + text : text;
    }
  }
  function giveGraphic(storageName, Ctor, depth2, z) {
    var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
    var lasts = lastsForAnimation[storageName];
    if (element) {
      oldStorage[storageName][oldRawIndex] = null;
      prepareAnimationWhenHasOld(lasts, element);
    } else if (!thisInvisible) {
      element = new Ctor();
      if (element instanceof Displayable$1) {
        element.z2 = calculateZ2(depth2, z);
      }
      prepareAnimationWhenNoOld(lasts, element);
    }
    return thisStorage[storageName][thisRawIndex] = element;
  }
  function prepareAnimationWhenHasOld(lasts, element) {
    var lastCfg = lasts[thisRawIndex] = {};
    if (element instanceof Group$2) {
      lastCfg.oldX = element.x;
      lastCfg.oldY = element.y;
    } else {
      lastCfg.oldShape = extend$1({}, element.shape);
    }
  }
  function prepareAnimationWhenNoOld(lasts, element) {
    var lastCfg = lasts[thisRawIndex] = {};
    var parentNode2 = thisNode.parentNode;
    var isGroup = element instanceof Group$4;
    if (parentNode2 && (!reRoot || reRoot.direction === "drillDown")) {
      var parentOldX = 0;
      var parentOldY = 0;
      var parentOldBg = lastsForAnimation.background[parentNode2.getRawIndex()];
      if (!reRoot && parentOldBg && parentOldBg.oldShape) {
        parentOldX = parentOldBg.oldShape.width;
        parentOldY = parentOldBg.oldShape.height;
      }
      if (isGroup) {
        lastCfg.oldX = 0;
        lastCfg.oldY = parentOldY;
      } else {
        lastCfg.oldShape = {
          x: parentOldX,
          y: parentOldY,
          width: 0,
          height: 0
        };
      }
    }
    lastCfg.fadein = !isGroup;
  }
}
function calculateZ2(depth, z2InLevel) {
  return depth * Z2_BASE + z2InLevel;
}
var TreemapView$1 = TreemapView;
var each$c = each$f;
var isObject = isObject$3;
var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
var VisualMapping = function() {
  function VisualMapping2(option) {
    var mappingMethod = option.mappingMethod;
    var visualType = option.type;
    var thisOption = this.option = clone$4(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    var visualHandler = VisualMapping2.visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];
    if (mappingMethod === "piecewise") {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === "category") {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
    } else {
      assert(mappingMethod !== "linear" || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  }
  VisualMapping2.prototype.mapValueToVisual = function(value) {
    var normalized = this._normalizeData(value);
    return this._normalizedToVisual(normalized, value);
  };
  VisualMapping2.prototype.getNormalizer = function() {
    return bind$1(this._normalizeData, this);
  };
  VisualMapping2.listVisualTypes = function() {
    return keys(VisualMapping2.visualHandlers);
  };
  VisualMapping2.isValidType = function(visualType) {
    return VisualMapping2.visualHandlers.hasOwnProperty(visualType);
  };
  VisualMapping2.eachVisual = function(visual, callback, context) {
    if (isObject$3(visual)) {
      each$f(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  };
  VisualMapping2.mapVisual = function(visual, callback, context) {
    var isPrimary;
    var newVisual = isArray$1(visual) ? [] : isObject$3(visual) ? {} : (isPrimary = true, null);
    VisualMapping2.eachVisual(visual, function(v, key) {
      var newVal = callback.call(context, v, key);
      isPrimary ? newVisual = newVal : newVisual[key] = newVal;
    });
    return newVisual;
  };
  VisualMapping2.retrieveVisuals = function(obj) {
    var ret2 = {};
    var hasVisual;
    obj && each$c(VisualMapping2.visualHandlers, function(h, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret2[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret2 : null;
  };
  VisualMapping2.prepareVisualTypes = function(visualTypes) {
    if (isArray$1(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else if (isObject(visualTypes)) {
      var types_1 = [];
      each$c(visualTypes, function(item, type) {
        types_1.push(type);
      });
      visualTypes = types_1;
    } else {
      return [];
    }
    visualTypes.sort(function(type1, type2) {
      return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
    });
    return visualTypes;
  };
  VisualMapping2.dependsOn = function(visualType1, visualType2) {
    return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  };
  VisualMapping2.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
    var possibleI;
    var abs2 = Infinity;
    for (var i = 0, len2 = pieceList.length; i < len2; i++) {
      var pieceValue = pieceList[i].value;
      if (pieceValue != null) {
        if (pieceValue === value || isString(pieceValue) && pieceValue === value + "") {
          return i;
        }
        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }
    for (var i = 0, len2 = pieceList.length; i < len2; i++) {
      var piece = pieceList[i];
      var interval = piece.interval;
      var close_1 = piece.close;
      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close_1[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close_1[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {
          return i;
        }
        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }
    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }
    function updatePossible(val, index) {
      var newAbs = Math.abs(val - value);
      if (newAbs < abs2) {
        abs2 = newAbs;
        possibleI = index;
      }
    }
  };
  VisualMapping2.visualHandlers = {
    color: {
      applyVisual: makeApplyVisual("color"),
      getColorMapper: function() {
        var thisOption = this.option;
        return bind$1(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
          !isNormalized && (value = this._normalizeData(value));
          return doMapCategory.call(this, value);
        } : function(value, isNormalized, out2) {
          var returnRGBArray = !!out2;
          !isNormalized && (value = this._normalizeData(value));
          out2 = fastLerp(value, thisOption.parsedVisual, out2);
          return returnRGBArray ? out2 : stringify(out2, "rgba");
        }, this);
      },
      _normalizedToVisual: {
        linear: function(normalized) {
          return stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
        },
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    colorHue: makePartialColorVisualHandler(function(color, value) {
      return modifyHSL(color, value);
    }),
    colorSaturation: makePartialColorVisualHandler(function(color, value) {
      return modifyHSL(color, null, value);
    }),
    colorLightness: makePartialColorVisualHandler(function(color, value) {
      return modifyHSL(color, null, null, value);
    }),
    colorAlpha: makePartialColorVisualHandler(function(color, value) {
      return modifyAlpha(color, value);
    }),
    decal: {
      applyVisual: makeApplyVisual("decal"),
      _normalizedToVisual: {
        linear: null,
        category: doMapCategory,
        piecewise: null,
        fixed: null
      }
    },
    opacity: {
      applyVisual: makeApplyVisual("opacity"),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    },
    liftZ: {
      applyVisual: makeApplyVisual("liftZ"),
      _normalizedToVisual: {
        linear: doMapFixed,
        category: doMapFixed,
        piecewise: doMapFixed,
        fixed: doMapFixed
      }
    },
    symbol: {
      applyVisual: function(value, getter, setter) {
        var symbolCfg = this.mapValueToVisual(value);
        setter("symbol", symbolCfg);
      },
      _normalizedToVisual: {
        linear: doMapToArray,
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = doMapToArray.call(this, normalized);
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    symbolSize: {
      applyVisual: makeApplyVisual("symbolSize"),
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    }
  };
  return VisualMapping2;
}();
function preprocessForPiecewise(thisOption) {
  var pieceList = thisOption.pieceList;
  thisOption.hasSpecialVisual = false;
  each$f(pieceList, function(piece, index) {
    piece.originIndex = index;
    if (piece.visual != null) {
      thisOption.hasSpecialVisual = true;
    }
  });
}
function preprocessForSpecifiedCategory(thisOption) {
  var categories = thisOption.categories;
  var categoryMap = thisOption.categoryMap = {};
  var visual = thisOption.visual;
  each$c(categories, function(cate, index) {
    categoryMap[cate] = index;
  });
  if (!isArray$1(visual)) {
    var visualArr_1 = [];
    if (isObject$3(visual)) {
      each$c(visual, function(v, cate) {
        var index = categoryMap[cate];
        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
      });
    } else {
      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
    }
    visual = setVisualToOption(thisOption, visualArr_1);
  }
  for (var i = categories.length - 1; i >= 0; i--) {
    if (visual[i] == null) {
      delete categoryMap[categories[i]];
      categories.pop();
    }
  }
}
function normalizeVisualRange(thisOption, isCategory2) {
  var visual = thisOption.visual;
  var visualArr = [];
  if (isObject$3(visual)) {
    each$c(visual, function(v) {
      visualArr.push(v);
    });
  } else if (visual != null) {
    visualArr.push(visual);
  }
  var doNotNeedPair = {
    color: 1,
    symbol: 1
  };
  if (!isCategory2 && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
    visualArr[1] = visualArr[0];
  }
  setVisualToOption(thisOption, visualArr);
}
function makePartialColorVisualHandler(applyValue) {
  return {
    applyVisual: function(value, getter, setter) {
      var colorChannel = this.mapValueToVisual(value);
      setter("color", applyValue(getter("color"), colorChannel));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}
function doMapToArray(normalized) {
  var visual = this.option.visual;
  return visual[Math.round(linearMap$2(normalized, [0, 1], [0, visual.length - 1], true))] || {};
}
function makeApplyVisual(visualType) {
  return function(value, getter, setter) {
    setter(visualType, this.mapValueToVisual(value));
  };
}
function doMapCategory(normalized) {
  var visual = this.option.visual;
  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
}
function doMapFixed() {
  return this.option.visual[0];
}
function createNormalizedToNumericVisual(sourceExtent) {
  return {
    linear: function(normalized) {
      return linearMap$2(normalized, sourceExtent, this.option.visual, true);
    },
    category: doMapCategory,
    piecewise: function(normalized, value) {
      var result = getSpecifiedVisual.call(this, value);
      if (result == null) {
        result = linearMap$2(normalized, sourceExtent, this.option.visual, true);
      }
      return result;
    },
    fixed: doMapFixed
  };
}
function getSpecifiedVisual(value) {
  var thisOption = this.option;
  var pieceList = thisOption.pieceList;
  if (thisOption.hasSpecialVisual) {
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
    var piece = pieceList[pieceIndex];
    if (piece && piece.visual) {
      return piece.visual[this.type];
    }
  }
}
function setVisualToOption(thisOption, visualArr) {
  thisOption.visual = visualArr;
  if (thisOption.type === "color") {
    thisOption.parsedVisual = map$1(visualArr, function(item) {
      return parse(item);
    });
  }
  return visualArr;
}
var normalizers = {
  linear: function(value) {
    return linearMap$2(value, this.option.dataExtent, [0, 1], true);
  },
  piecewise: function(value) {
    var pieceList = this.option.pieceList;
    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
    if (pieceIndex != null) {
      return linearMap$2(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
    }
  },
  category: function(value) {
    var index = this.option.categories ? this.option.categoryMap[value] : value;
    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
  },
  fixed: noop$1
};
function littleThan(close, a, b) {
  return close ? a <= b : a < b;
}
var VisualMapping$1 = VisualMapping;
var ITEM_STYLE_NORMAL = "itemStyle";
var inner$c = makeInner();
var treemapVisual = {
  seriesType: "treemap",
  reset: function(seriesModel) {
    var tree = seriesModel.getData().tree;
    var root2 = tree.root;
    if (root2.isRemoved()) {
      return;
    }
    travelTree(root2, {}, seriesModel.getViewRoot().getAncestors(), seriesModel);
  }
};
function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
  var nodeModel = node.getModel();
  var nodeLayout = node.getLayout();
  var data = node.hostTree.data;
  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
    return;
  }
  var nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);
  var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
  var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
  var borderColor = nodeItemStyleModel.get("borderColor");
  var borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
  var thisNodeColor;
  if (borderColorSaturation != null) {
    thisNodeColor = calculateColor(visuals);
    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
  }
  existsStyle.stroke = borderColor;
  var viewChildren = node.viewChildren;
  if (!viewChildren || !viewChildren.length) {
    thisNodeColor = calculateColor(visuals);
    existsStyle.fill = thisNodeColor;
  } else {
    var mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
    each$f(viewChildren, function(child, index) {
      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
        var childVisual = mapVisual$1(nodeModel, visuals, child, index, mapping_1, seriesModel);
        travelTree(child, childVisual, viewRootAncestors, seriesModel);
      }
    });
  }
}
function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
  var visuals = extend$1({}, designatedVisual);
  var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
  each$f(["color", "colorAlpha", "colorSaturation"], function(visualName) {
    designatedVisualItemStyle[visualName] = designatedVisual[visualName];
    var val = nodeItemStyleModel.get(visualName);
    designatedVisualItemStyle[visualName] = null;
    val != null && (visuals[visualName] = val);
  });
  return visuals;
}
function calculateColor(visuals) {
  var color = getValueVisualDefine(visuals, "color");
  if (color) {
    var colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
    var colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
    if (colorSaturation) {
      color = modifyHSL(color, null, null, colorSaturation);
    }
    if (colorAlpha) {
      color = modifyAlpha(color, colorAlpha);
    }
    return color;
  }
}
function calculateBorderColor(borderColorSaturation, thisNodeColor) {
  return thisNodeColor != null ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
}
function getValueVisualDefine(visuals, name) {
  var value = visuals[name];
  if (value != null && value !== "none") {
    return value;
  }
}
function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
  if (!viewChildren || !viewChildren.length) {
    return;
  }
  var rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
  if (!rangeVisual) {
    return;
  }
  var visualMin = nodeModel.get("visualMin");
  var visualMax = nodeModel.get("visualMax");
  var dataExtent = nodeLayout.dataExtent.slice();
  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
  var colorMappingBy = nodeModel.get("colorMappingBy");
  var opt = {
    type: rangeVisual.name,
    dataExtent,
    visual: rangeVisual.range
  };
  if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
    opt.mappingMethod = "category";
    opt.loop = true;
  } else {
    opt.mappingMethod = "linear";
  }
  var mapping = new VisualMapping$1(opt);
  inner$c(mapping).drColorMappingBy = colorMappingBy;
  return mapping;
}
function getRangeVisual(nodeModel, name) {
  var range = nodeModel.get(name);
  return isArray$1(range) && range.length ? {
    name,
    range
  } : null;
}
function mapVisual$1(nodeModel, visuals, child, index, mapping, seriesModel) {
  var childVisuals = extend$1({}, visuals);
  if (mapping) {
    var mappingType = mapping.type;
    var colorMappingBy = mappingType === "color" && inner$c(mapping).drColorMappingBy;
    var value = colorMappingBy === "index" ? index : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
    childVisuals[mappingType] = mapping.mapValueToVisual(value);
  }
  return childVisuals;
}
var mathMax$4 = Math.max;
var mathMin$4 = Math.min;
var retrieveValue = retrieve$2;
var each$b = each$f;
var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
var treemapLayout = {
  seriesType: "treemap",
  reset: function(seriesModel, ecModel, api, payload) {
    var ecWidth = api.getWidth();
    var ecHeight = api.getHeight();
    var seriesOption = seriesModel.option;
    var layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    var size = seriesOption.size || [];
    var containerWidth = parsePercent$1(retrieveValue(layoutInfo.width, size[0]), ecWidth);
    var containerHeight = parsePercent$1(retrieveValue(layoutInfo.height, size[1]), ecHeight);
    var payloadType = payload && payload.type;
    var types = ["treemapZoomToNode", "treemapRootToNode"];
    var targetInfo = retrieveTargetInfo(payload, types, seriesModel);
    var rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
    var viewRoot = seriesModel.getViewRoot();
    var viewAbovePath = getPathToRoot(viewRoot);
    if (payloadType !== "treemapMove") {
      var rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
      var sort_1 = seriesOption.sort;
      if (sort_1 && sort_1 !== "asc" && sort_1 !== "desc") {
        sort_1 = "desc";
      }
      var options = {
        squareRatio: seriesOption.squareRatio,
        sort: sort_1,
        leafDepth: seriesOption.leafDepth
      };
      viewRoot.hostTree.clearLayouts();
      var viewRootLayout_1 = {
        x: 0,
        y: 0,
        width: rootSize[0],
        height: rootSize[1],
        area: rootSize[0] * rootSize[1]
      };
      viewRoot.setLayout(viewRootLayout_1);
      squarify(viewRoot, options, false, 0);
      viewRootLayout_1 = viewRoot.getLayout();
      each$b(viewAbovePath, function(node, index) {
        var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
        node.setLayout(extend$1({
          dataExtent: [childValue, childValue],
          borderWidth: 0,
          upperHeight: 0
        }, viewRootLayout_1));
      });
    }
    var treeRoot = seriesModel.getData().tree.root;
    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
    seriesModel.setLayoutInfo(layoutInfo);
    prunning(treeRoot, new BoundingRect$1(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);
  }
};
function squarify(node, options, hideChildren, depth) {
  var width;
  var height;
  if (node.isRemoved()) {
    return;
  }
  var thisLayout = node.getLayout();
  width = thisLayout.width;
  height = thisLayout.height;
  var nodeModel = node.getModel();
  var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
  var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
  var upperLabelHeight = getUpperLabelHeight(nodeModel);
  var upperHeight = Math.max(borderWidth, upperLabelHeight);
  var layoutOffset = borderWidth - halfGapWidth;
  var layoutOffsetUpper = upperHeight - halfGapWidth;
  node.setLayout({
    borderWidth,
    upperHeight,
    upperLabelHeight
  }, true);
  width = mathMax$4(width - 2 * layoutOffset, 0);
  height = mathMax$4(height - layoutOffset - layoutOffsetUpper, 0);
  var totalArea = width * height;
  var viewChildren = initChildren$1(node, nodeModel, totalArea, options, hideChildren, depth);
  if (!viewChildren.length) {
    return;
  }
  var rect = {
    x: layoutOffset,
    y: layoutOffsetUpper,
    width,
    height
  };
  var rowFixedLength = mathMin$4(width, height);
  var best = Infinity;
  var row = [];
  row.area = 0;
  for (var i = 0, len2 = viewChildren.length; i < len2; ) {
    var child = viewChildren[i];
    row.push(child);
    row.area += child.getLayout().area;
    var score = worst(row, rowFixedLength, options.squareRatio);
    if (score <= best) {
      i++;
      best = score;
    } else {
      row.area -= row.pop().getLayout().area;
      position(row, rowFixedLength, rect, halfGapWidth, false);
      rowFixedLength = mathMin$4(rect.width, rect.height);
      row.length = row.area = 0;
      best = Infinity;
    }
  }
  if (row.length) {
    position(row, rowFixedLength, rect, halfGapWidth, true);
  }
  if (!hideChildren) {
    var childrenVisibleMin = nodeModel.get("childrenVisibleMin");
    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
      hideChildren = true;
    }
  }
  for (var i = 0, len2 = viewChildren.length; i < len2; i++) {
    squarify(viewChildren[i], options, hideChildren, depth + 1);
  }
}
function initChildren$1(node, nodeModel, totalArea, options, hideChildren, depth) {
  var viewChildren = node.children || [];
  var orderBy = options.sort;
  orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
  var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
  if (hideChildren && !overLeafDepth) {
    return node.viewChildren = [];
  }
  viewChildren = filter(viewChildren, function(child) {
    return !child.isRemoved();
  });
  sort$1(viewChildren, orderBy);
  var info = statistic(nodeModel, viewChildren, orderBy);
  if (info.sum === 0) {
    return node.viewChildren = [];
  }
  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
  if (info.sum === 0) {
    return node.viewChildren = [];
  }
  for (var i = 0, len2 = viewChildren.length; i < len2; i++) {
    var area2 = viewChildren[i].getValue() / info.sum * totalArea;
    viewChildren[i].setLayout({
      area: area2
    });
  }
  if (overLeafDepth) {
    viewChildren.length && node.setLayout({
      isLeafRoot: true
    }, true);
    viewChildren.length = 0;
  }
  node.viewChildren = viewChildren;
  node.setLayout({
    dataExtent: info.dataExtent
  }, true);
  return viewChildren;
}
function filterByThreshold(nodeModel, totalArea, sum2, orderBy, orderedChildren) {
  if (!orderBy) {
    return sum2;
  }
  var visibleMin = nodeModel.get("visibleMin");
  var len2 = orderedChildren.length;
  var deletePoint = len2;
  for (var i = len2 - 1; i >= 0; i--) {
    var value = orderedChildren[orderBy === "asc" ? len2 - i - 1 : i].getValue();
    if (value / sum2 * totalArea < visibleMin) {
      deletePoint = i;
      sum2 -= value;
    }
  }
  orderBy === "asc" ? orderedChildren.splice(0, len2 - deletePoint) : orderedChildren.splice(deletePoint, len2 - deletePoint);
  return sum2;
}
function sort$1(viewChildren, orderBy) {
  if (orderBy) {
    viewChildren.sort(function(a, b) {
      var diff = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
      return diff === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
    });
  }
  return viewChildren;
}
function statistic(nodeModel, children, orderBy) {
  var sum2 = 0;
  for (var i = 0, len2 = children.length; i < len2; i++) {
    sum2 += children[i].getValue();
  }
  var dimension = nodeModel.get("visualDimension");
  var dataExtent;
  if (!children || !children.length) {
    dataExtent = [NaN, NaN];
  } else if (dimension === "value" && orderBy) {
    dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
    orderBy === "asc" && dataExtent.reverse();
  } else {
    dataExtent = [Infinity, -Infinity];
    each$b(children, function(child) {
      var value = child.getValue(dimension);
      value < dataExtent[0] && (dataExtent[0] = value);
      value > dataExtent[1] && (dataExtent[1] = value);
    });
  }
  return {
    sum: sum2,
    dataExtent
  };
}
function worst(row, rowFixedLength, ratio) {
  var areaMax = 0;
  var areaMin = Infinity;
  for (var i = 0, area2 = void 0, len2 = row.length; i < len2; i++) {
    area2 = row[i].getLayout().area;
    if (area2) {
      area2 < areaMin && (areaMin = area2);
      area2 > areaMax && (areaMax = area2);
    }
  }
  var squareArea = row.area * row.area;
  var f = rowFixedLength * rowFixedLength * ratio;
  return squareArea ? mathMax$4(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
}
function position(row, rowFixedLength, rect, halfGapWidth, flush) {
  var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
  var idx1WhenH = 1 - idx0WhenH;
  var xy = ["x", "y"];
  var wh = ["width", "height"];
  var last = rect[xy[idx0WhenH]];
  var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
    rowOtherLength = rect[wh[idx1WhenH]];
  }
  for (var i = 0, rowLen = row.length; i < rowLen; i++) {
    var node = row[i];
    var nodeLayout = {};
    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax$4(rowOtherLength - 2 * halfGapWidth, 0);
    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
    var modWH = i === rowLen - 1 || remain < step ? remain : step;
    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax$4(modWH - 2 * halfGapWidth, 0);
    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin$4(halfGapWidth, wh1 / 2);
    nodeLayout[xy[idx0WhenH]] = last + mathMin$4(halfGapWidth, wh0 / 2);
    last += modWH;
    node.setLayout(nodeLayout, true);
  }
  rect[xy[idx1WhenH]] += rowOtherLength;
  rect[wh[idx1WhenH]] -= rowOtherLength;
}
function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
  var currNode = (targetInfo || {}).node;
  var defaultSize = [containerWidth, containerHeight];
  if (!currNode || currNode === viewRoot) {
    return defaultSize;
  }
  var parent;
  var viewArea = containerWidth * containerHeight;
  var area2 = viewArea * seriesModel.option.zoomToNodeRatio;
  while (parent = currNode.parentNode) {
    var sum2 = 0;
    var siblings = parent.children;
    for (var i = 0, len2 = siblings.length; i < len2; i++) {
      sum2 += siblings[i].getValue();
    }
    var currNodeValue = currNode.getValue();
    if (currNodeValue === 0) {
      return defaultSize;
    }
    area2 *= sum2 / currNodeValue;
    var parentModel = parent.getModel();
    var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
    var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
    area2 += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area2, 0.5);
    area2 > MAX_SAFE_INTEGER && (area2 = MAX_SAFE_INTEGER);
    currNode = parent;
  }
  area2 < viewArea && (area2 = viewArea);
  var scale2 = Math.pow(area2 / viewArea, 0.5);
  return [containerWidth * scale2, containerHeight * scale2];
}
function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
  if (rootRect) {
    return {
      x: rootRect.x,
      y: rootRect.y
    };
  }
  var defaultPosition = {
    x: 0,
    y: 0
  };
  if (!targetInfo) {
    return defaultPosition;
  }
  var targetNode = targetInfo.node;
  var layout2 = targetNode.getLayout();
  if (!layout2) {
    return defaultPosition;
  }
  var targetCenter = [layout2.width / 2, layout2.height / 2];
  var node = targetNode;
  while (node) {
    var nodeLayout = node.getLayout();
    targetCenter[0] += nodeLayout.x;
    targetCenter[1] += nodeLayout.y;
    node = node.parentNode;
  }
  return {
    x: layoutInfo.width / 2 - targetCenter[0],
    y: layoutInfo.height / 2 - targetCenter[1]
  };
}
function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
  var nodeLayout = node.getLayout();
  var nodeInViewAbovePath = viewAbovePath[depth];
  var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
    return;
  }
  node.setLayout({
    isInView: true,
    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
    isAboveViewRoot
  }, true);
  var childClipRect = new BoundingRect$1(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
  each$b(node.viewChildren || [], function(child) {
    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
  });
}
function getUpperLabelHeight(model) {
  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}
function install$W(registers) {
  registers.registerSeriesModel(TreemapSeriesModel$1);
  registers.registerChartView(TreemapView$1);
  registers.registerVisual(treemapVisual);
  registers.registerLayout(treemapLayout);
  installTreemapAction(registers);
}
function categoryFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (!legendModels || !legendModels.length) {
    return;
  }
  ecModel.eachSeriesByType("graph", function(graphSeries) {
    var categoriesData = graphSeries.getCategoriesData();
    var graph = graphSeries.getGraph();
    var data = graph.data;
    var categoryNames = categoriesData.mapArray(categoriesData.getName);
    data.filterSelf(function(idx) {
      var model = data.getItemModel(idx);
      var category = model.getShallow("category");
      if (category != null) {
        if (isNumber(category)) {
          category = categoryNames[category];
        }
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(category)) {
            return false;
          }
        }
      }
      return true;
    });
  });
}
function categoryVisual(ecModel) {
  var paletteScope = {};
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    var categoriesData = seriesModel.getCategoriesData();
    var data = seriesModel.getData();
    var categoryNameIdxMap = {};
    categoriesData.each(function(idx) {
      var name = categoriesData.getName(idx);
      categoryNameIdxMap["ec-" + name] = idx;
      var itemModel = categoriesData.getItemModel(idx);
      var style = itemModel.getModel("itemStyle").getItemStyle();
      if (!style.fill) {
        style.fill = seriesModel.getColorFromPalette(name, paletteScope);
      }
      categoriesData.setItemVisual(idx, "style", style);
      var symbolVisualList = ["symbol", "symbolSize", "symbolKeepAspect"];
      for (var i = 0; i < symbolVisualList.length; i++) {
        var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);
        if (symbolVisual != null) {
          categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
        }
      }
    });
    if (categoriesData.count()) {
      data.each(function(idx) {
        var model = data.getItemModel(idx);
        var categoryIdx = model.getShallow("category");
        if (categoryIdx != null) {
          if (isString(categoryIdx)) {
            categoryIdx = categoryNameIdxMap["ec-" + categoryIdx];
          }
          var categoryStyle = categoriesData.getItemVisual(categoryIdx, "style");
          var style = data.ensureUniqueItemVisual(idx, "style");
          extend$1(style, categoryStyle);
          var visualList = ["symbol", "symbolSize", "symbolKeepAspect"];
          for (var i = 0; i < visualList.length; i++) {
            data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
          }
        }
      });
    }
  });
}
function normalize$3(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
function graphEdgeVisual(ecModel) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    var graph = seriesModel.getGraph();
    var edgeData = seriesModel.getEdgeData();
    var symbolType = normalize$3(seriesModel.get("edgeSymbol"));
    var symbolSize = normalize$3(seriesModel.get("edgeSymbolSize"));
    edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
    edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
    edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
    edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
    edgeData.setVisual("style", seriesModel.getModel("lineStyle").getLineStyle());
    edgeData.each(function(idx) {
      var itemModel = edgeData.getItemModel(idx);
      var edge = graph.getEdgeByIndex(idx);
      var symbolType2 = normalize$3(itemModel.getShallow("symbol", true));
      var symbolSize2 = normalize$3(itemModel.getShallow("symbolSize", true));
      var style = itemModel.getModel("lineStyle").getLineStyle();
      var existsStyle = edgeData.ensureUniqueItemVisual(idx, "style");
      extend$1(existsStyle, style);
      switch (existsStyle.stroke) {
        case "source": {
          var nodeStyle = edge.node1.getVisual("style");
          existsStyle.stroke = nodeStyle && nodeStyle.fill;
          break;
        }
        case "target": {
          var nodeStyle = edge.node2.getVisual("style");
          existsStyle.stroke = nodeStyle && nodeStyle.fill;
          break;
        }
      }
      symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
      symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
      symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
      symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
    });
  });
}
var KEY_DELIMITER = "-->";
var getAutoCurvenessParams = function(seriesModel) {
  return seriesModel.get("autoCurveness") || null;
};
var createCurveness = function(seriesModel, appendLength) {
  var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
  var length = 20;
  var curvenessList = [];
  if (isNumber(autoCurvenessParmas)) {
    length = autoCurvenessParmas;
  } else if (isArray$1(autoCurvenessParmas)) {
    seriesModel.__curvenessList = autoCurvenessParmas;
    return;
  }
  if (appendLength > length) {
    length = appendLength;
  }
  var len2 = length % 2 ? length + 2 : length + 3;
  curvenessList = [];
  for (var i = 0; i < len2; i++) {
    curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
  }
  seriesModel.__curvenessList = curvenessList;
};
var getKeyOfEdges = function(n1, n2, seriesModel) {
  var source = [n1.id, n1.dataIndex].join(".");
  var target = [n2.id, n2.dataIndex].join(".");
  return [seriesModel.uid, source, target].join(KEY_DELIMITER);
};
var getOppositeKey = function(key) {
  var keys2 = key.split(KEY_DELIMITER);
  return [keys2[0], keys2[2], keys2[1]].join(KEY_DELIMITER);
};
var getEdgeFromMap = function(edge, seriesModel) {
  var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  return seriesModel.__edgeMap[key];
};
var getTotalLengthBetweenNodes = function(edge, seriesModel) {
  var len2 = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
  var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
  return len2 + lenV;
};
var getEdgeMapLengthWithKey = function(key, seriesModel) {
  var edgeMap = seriesModel.__edgeMap;
  return edgeMap[key] ? edgeMap[key].length : 0;
};
function initCurvenessList(seriesModel) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }
  seriesModel.__curvenessList = [];
  seriesModel.__edgeMap = {};
  createCurveness(seriesModel);
}
function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }
  var key = getKeyOfEdges(n1, n2, seriesModel);
  var edgeMap = seriesModel.__edgeMap;
  var oppositeEdges = edgeMap[getOppositeKey(key)];
  if (edgeMap[key] && !oppositeEdges) {
    edgeMap[key].isForward = true;
  } else if (oppositeEdges && edgeMap[key]) {
    oppositeEdges.isForward = true;
    edgeMap[key].isForward = false;
  }
  edgeMap[key] = edgeMap[key] || [];
  edgeMap[key].push(index);
}
function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
  var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
  var isArrayParam = isArray$1(autoCurvenessParams);
  if (!autoCurvenessParams) {
    return null;
  }
  var edgeArray = getEdgeFromMap(edge, seriesModel);
  if (!edgeArray) {
    return null;
  }
  var edgeIndex = -1;
  for (var i = 0; i < edgeArray.length; i++) {
    if (edgeArray[i] === index) {
      edgeIndex = i;
      break;
    }
  }
  var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
  createCurveness(seriesModel, totalLen);
  edge.lineStyle = edge.lineStyle || {};
  var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  var curvenessList = seriesModel.__curvenessList;
  var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
  if (!edgeArray.isForward) {
    var oppositeKey = getOppositeKey(curKey);
    var len2 = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
    var resValue = curvenessList[edgeIndex + len2 + parityCorrection];
    if (needReverse) {
      if (isArrayParam) {
        if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
          return (len2 + parityCorrection) % 2 ? resValue : -resValue;
        } else {
          return ((len2 % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
        }
      } else {
        return (len2 + parityCorrection) % 2 ? resValue : -resValue;
      }
    } else {
      return curvenessList[edgeIndex + len2 + parityCorrection];
    }
  } else {
    return curvenessList[parityCorrection + edgeIndex];
  }
}
function simpleLayout(seriesModel) {
  var coordSys = seriesModel.coordinateSystem;
  if (coordSys && coordSys.type !== "view") {
    return;
  }
  var graph = seriesModel.getGraph();
  graph.eachNode(function(node) {
    var model = node.getModel();
    node.setLayout([+model.get("x"), +model.get("y")]);
  });
  simpleLayoutEdge(graph, seriesModel);
}
function simpleLayoutEdge(graph, seriesModel) {
  graph.eachEdge(function(edge, index) {
    var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, seriesModel, index, true), 0);
    var p12 = clone$3(edge.node1.getLayout());
    var p22 = clone$3(edge.node2.getLayout());
    var points2 = [p12, p22];
    if (+curveness) {
      points2.push([(p12[0] + p22[0]) / 2 - (p12[1] - p22[1]) * curveness, (p12[1] + p22[1]) / 2 - (p22[0] - p12[0]) * curveness]);
    }
    edge.setLayout(points2);
  });
}
function graphSimpleLayout(ecModel, api) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    var layout2 = seriesModel.get("layout");
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      var data_1 = seriesModel.getData();
      var dimensions_1 = [];
      each$f(coordSys.dimensions, function(coordDim) {
        dimensions_1 = dimensions_1.concat(data_1.mapDimensionsAll(coordDim));
      });
      for (var dataIndex = 0; dataIndex < data_1.count(); dataIndex++) {
        var value = [];
        var hasValue = false;
        for (var i = 0; i < dimensions_1.length; i++) {
          var val = data_1.get(dimensions_1[i], dataIndex);
          if (!isNaN(val)) {
            hasValue = true;
          }
          value.push(val);
        }
        if (hasValue) {
          data_1.setItemLayout(dataIndex, coordSys.dataToPoint(value));
        } else {
          data_1.setItemLayout(dataIndex, [NaN, NaN]);
        }
      }
      simpleLayoutEdge(data_1.graph, seriesModel);
    } else if (!layout2 || layout2 === "none") {
      simpleLayout(seriesModel);
    }
  });
}
function getNodeGlobalScale(seriesModel) {
  var coordSys = seriesModel.coordinateSystem;
  if (coordSys.type !== "view") {
    return 1;
  }
  var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
  var groupZoom = coordSys.scaleX;
  var roamZoom = coordSys.getZoom();
  var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
  return nodeScale / groupZoom;
}
function getSymbolSize(node) {
  var symbolSize = node.getVisual("symbolSize");
  if (symbolSize instanceof Array) {
    symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
  }
  return +symbolSize;
}
var PI$4 = Math.PI;
var _symbolRadiansHalf = [];
function circularLayout(seriesModel, basedOn) {
  var coordSys = seriesModel.coordinateSystem;
  if (coordSys && coordSys.type !== "view") {
    return;
  }
  var rect = coordSys.getBoundingRect();
  var nodeData = seriesModel.getData();
  var graph = nodeData.graph;
  var cx = rect.width / 2 + rect.x;
  var cy = rect.height / 2 + rect.y;
  var r = Math.min(rect.width, rect.height) / 2;
  var count2 = nodeData.count();
  nodeData.setLayout({
    cx,
    cy
  });
  if (!count2) {
    return;
  }
  _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count2);
  graph.eachEdge(function(edge, index) {
    var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(edge, seriesModel, index), 0);
    var p12 = clone$3(edge.node1.getLayout());
    var p22 = clone$3(edge.node2.getLayout());
    var cp1;
    var x12 = (p12[0] + p22[0]) / 2;
    var y12 = (p12[1] + p22[1]) / 2;
    if (+curveness) {
      curveness *= 3;
      cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
    }
    edge.setLayout([p12, p22, cp1]);
  });
}
var _layoutNodesBasedOn = {
  value: function(seriesModel, graph, nodeData, r, cx, cy, count2) {
    var angle = 0;
    var sum2 = nodeData.getSum("value");
    var unitAngle = Math.PI * 2 / (sum2 || count2);
    graph.eachNode(function(node) {
      var value = node.getValue("value");
      var radianHalf = unitAngle * (sum2 ? value : 1) / 2;
      angle += radianHalf;
      node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
      angle += radianHalf;
    });
  },
  symbolSize: function(seriesModel, graph, nodeData, r, cx, cy, count2) {
    var sumRadian = 0;
    _symbolRadiansHalf.length = count2;
    var nodeScale = getNodeGlobalScale(seriesModel);
    graph.eachNode(function(node) {
      var symbolSize = getSymbolSize(node);
      isNaN(symbolSize) && (symbolSize = 2);
      symbolSize < 0 && (symbolSize = 0);
      symbolSize *= nodeScale;
      var symbolRadianHalf = Math.asin(symbolSize / 2 / r);
      isNaN(symbolRadianHalf) && (symbolRadianHalf = PI$4 / 2);
      _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
      sumRadian += symbolRadianHalf * 2;
    });
    var halfRemainRadian = (2 * PI$4 - sumRadian) / count2 / 2;
    var angle = 0;
    graph.eachNode(function(node) {
      var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
      angle += radianHalf;
      node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
      angle += radianHalf;
    });
  }
};
function graphCircularLayout(ecModel) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    if (seriesModel.get("layout") === "circular") {
      circularLayout(seriesModel, "symbolSize");
    }
  });
}
var scaleAndAdd = scaleAndAdd$1;
function forceLayout(inNodes, inEdges, opts) {
  var nodes = inNodes;
  var edges = inEdges;
  var rect = opts.rect;
  var width = rect.width;
  var height = rect.height;
  var center2 = [rect.x + width / 2, rect.y + height / 2];
  var gravity = opts.gravity == null ? 0.1 : opts.gravity;
  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    if (!n.p) {
      n.p = create$3(width * (Math.random() - 0.5) + center2[0], height * (Math.random() - 0.5) + center2[1]);
    }
    n.pp = clone$3(n.p);
    n.edges = null;
  }
  var initialFriction = opts.friction == null ? 0.6 : opts.friction;
  var friction = initialFriction;
  var beforeStepCallback;
  var afterStepCallback;
  return {
    warmUp: function() {
      friction = initialFriction * 0.8;
    },
    setFixed: function(idx) {
      nodes[idx].fixed = true;
    },
    setUnfixed: function(idx) {
      nodes[idx].fixed = false;
    },
    beforeStep: function(cb) {
      beforeStepCallback = cb;
    },
    afterStep: function(cb) {
      afterStepCallback = cb;
    },
    step: function(cb) {
      beforeStepCallback && beforeStepCallback(nodes, edges);
      var v12 = [];
      var nLen = nodes.length;
      for (var i2 = 0; i2 < edges.length; i2++) {
        var e2 = edges[i2];
        if (e2.ignoreForceLayout) {
          continue;
        }
        var n1 = e2.n1;
        var n2 = e2.n2;
        sub$1(v12, n2.p, n1.p);
        var d = len(v12) - e2.d;
        var w = n2.w / (n1.w + n2.w);
        if (isNaN(w)) {
          w = 0;
        }
        normalize$5(v12, v12);
        !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
        !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
      }
      for (var i2 = 0; i2 < nLen; i2++) {
        var n3 = nodes[i2];
        if (!n3.fixed) {
          sub$1(v12, center2, n3.p);
          scaleAndAdd(n3.p, n3.p, v12, gravity * friction);
        }
      }
      for (var i2 = 0; i2 < nLen; i2++) {
        var n1 = nodes[i2];
        for (var j = i2 + 1; j < nLen; j++) {
          var n2 = nodes[j];
          sub$1(v12, n2.p, n1.p);
          var d = len(v12);
          if (d === 0) {
            set$1(v12, Math.random() - 0.5, Math.random() - 0.5);
            d = 1;
          }
          var repFact = (n1.rep + n2.rep) / d / d;
          !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
          !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
        }
      }
      var v = [];
      for (var i2 = 0; i2 < nLen; i2++) {
        var n3 = nodes[i2];
        if (!n3.fixed) {
          sub$1(v, n3.p, n3.pp);
          scaleAndAdd(n3.p, n3.p, v, friction);
          copy$1(n3.pp, n3.p);
        }
      }
      friction = friction * 0.992;
      var finished = friction < 0.01;
      afterStepCallback && afterStepCallback(nodes, edges, finished);
      cb && cb(finished);
    }
  };
}
function graphForceLayout(ecModel) {
  ecModel.eachSeriesByType("graph", function(graphSeries) {
    var coordSys = graphSeries.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      return;
    }
    if (graphSeries.get("layout") === "force") {
      var preservedPoints_1 = graphSeries.preservedPoints || {};
      var graph_1 = graphSeries.getGraph();
      var nodeData_1 = graph_1.data;
      var edgeData = graph_1.edgeData;
      var forceModel = graphSeries.getModel("force");
      var initLayout = forceModel.get("initLayout");
      if (graphSeries.preservedPoints) {
        nodeData_1.each(function(idx) {
          var id = nodeData_1.getId(idx);
          nodeData_1.setItemLayout(idx, preservedPoints_1[id] || [NaN, NaN]);
        });
      } else if (!initLayout || initLayout === "none") {
        simpleLayout(graphSeries);
      } else if (initLayout === "circular") {
        circularLayout(graphSeries, "value");
      }
      var nodeDataExtent_1 = nodeData_1.getDataExtent("value");
      var edgeDataExtent_1 = edgeData.getDataExtent("value");
      var repulsion = forceModel.get("repulsion");
      var edgeLength = forceModel.get("edgeLength");
      var repulsionArr_1 = isArray$1(repulsion) ? repulsion : [repulsion, repulsion];
      var edgeLengthArr_1 = isArray$1(edgeLength) ? edgeLength : [edgeLength, edgeLength];
      edgeLengthArr_1 = [edgeLengthArr_1[1], edgeLengthArr_1[0]];
      var nodes_1 = nodeData_1.mapArray("value", function(value, idx) {
        var point = nodeData_1.getItemLayout(idx);
        var rep = linearMap$2(value, nodeDataExtent_1, repulsionArr_1);
        if (isNaN(rep)) {
          rep = (repulsionArr_1[0] + repulsionArr_1[1]) / 2;
        }
        return {
          w: rep,
          rep,
          fixed: nodeData_1.getItemModel(idx).get("fixed"),
          p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
        };
      });
      var edges = edgeData.mapArray("value", function(value, idx) {
        var edge = graph_1.getEdgeByIndex(idx);
        var d = linearMap$2(value, edgeDataExtent_1, edgeLengthArr_1);
        if (isNaN(d)) {
          d = (edgeLengthArr_1[0] + edgeLengthArr_1[1]) / 2;
        }
        var edgeModel = edge.getModel();
        var curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
        return {
          n1: nodes_1[edge.node1.dataIndex],
          n2: nodes_1[edge.node2.dataIndex],
          d,
          curveness,
          ignoreForceLayout: edgeModel.get("ignoreForceLayout")
        };
      });
      var rect = coordSys.getBoundingRect();
      var forceInstance = forceLayout(nodes_1, edges, {
        rect,
        gravity: forceModel.get("gravity"),
        friction: forceModel.get("friction")
      });
      forceInstance.beforeStep(function(nodes, edges2) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].fixed) {
            copy$1(nodes[i].p, graph_1.getNodeByIndex(i).getLayout());
          }
        }
      });
      forceInstance.afterStep(function(nodes, edges2, stopped) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (!nodes[i].fixed) {
            graph_1.getNodeByIndex(i).setLayout(nodes[i].p);
          }
          preservedPoints_1[nodeData_1.getId(i)] = nodes[i].p;
        }
        for (var i = 0, l = edges2.length; i < l; i++) {
          var e2 = edges2[i];
          var edge = graph_1.getEdgeByIndex(i);
          var p12 = e2.n1.p;
          var p22 = e2.n2.p;
          var points2 = edge.getLayout();
          points2 = points2 ? points2.slice() : [];
          points2[0] = points2[0] || [];
          points2[1] = points2[1] || [];
          copy$1(points2[0], p12);
          copy$1(points2[1], p22);
          if (+e2.curveness) {
            points2[2] = [(p12[0] + p22[0]) / 2 - (p12[1] - p22[1]) * e2.curveness, (p12[1] + p22[1]) / 2 - (p22[0] - p12[0]) * e2.curveness];
          }
          edge.setLayout(points2);
        }
      });
      graphSeries.forceLayout = forceInstance;
      graphSeries.preservedPoints = preservedPoints_1;
      forceInstance.step();
    } else {
      graphSeries.forceLayout = null;
    }
  });
}
function getViewRect$3(seriesModel, api, aspect) {
  var option = extend$1(seriesModel.getBoxLayoutParams(), {
    aspect
  });
  return getLayoutRect(option, {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function createViewCoordSys(ecModel, api) {
  var viewList = [];
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    var coordSysType = seriesModel.get("coordinateSystem");
    if (!coordSysType || coordSysType === "view") {
      var data_1 = seriesModel.getData();
      var positions = data_1.mapArray(function(idx) {
        var itemModel = data_1.getItemModel(idx);
        return [+itemModel.get("x"), +itemModel.get("y")];
      });
      var min3 = [];
      var max3 = [];
      fromPoints(positions, min3, max3);
      if (max3[0] - min3[0] === 0) {
        max3[0] += 1;
        min3[0] -= 1;
      }
      if (max3[1] - min3[1] === 0) {
        max3[1] += 1;
        min3[1] -= 1;
      }
      var aspect = (max3[0] - min3[0]) / (max3[1] - min3[1]);
      var viewRect2 = getViewRect$3(seriesModel, api, aspect);
      if (isNaN(aspect)) {
        min3 = [viewRect2.x, viewRect2.y];
        max3 = [viewRect2.x + viewRect2.width, viewRect2.y + viewRect2.height];
      }
      var bbWidth = max3[0] - min3[0];
      var bbHeight = max3[1] - min3[1];
      var viewWidth = viewRect2.width;
      var viewHeight = viewRect2.height;
      var viewCoordSys = seriesModel.coordinateSystem = new View$1();
      viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
      viewCoordSys.setBoundingRect(min3[0], min3[1], bbWidth, bbHeight);
      viewCoordSys.setViewRect(viewRect2.x, viewRect2.y, viewWidth, viewHeight);
      viewCoordSys.setCenter(seriesModel.get("center"));
      viewCoordSys.setZoom(seriesModel.get("zoom"));
      viewList.push(viewCoordSys);
    }
  });
  return viewList;
}
var straightLineProto = Line$3.prototype;
var bezierCurveProto = BezierCurve$1.prototype;
var StraightLineShape = function() {
  function StraightLineShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
  return StraightLineShape2;
}();
(function(_super) {
  __extends(CurveShape, _super);
  function CurveShape() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return CurveShape;
})(StraightLineShape);
function isStraightLine(shape) {
  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}
var ECLinePath = function(_super) {
  __extends(ECLinePath2, _super);
  function ECLinePath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "ec-line";
    return _this;
  }
  ECLinePath2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  ECLinePath2.prototype.getDefaultShape = function() {
    return new StraightLineShape();
  };
  ECLinePath2.prototype.buildPath = function(ctx, shape) {
    if (isStraightLine(shape)) {
      straightLineProto.buildPath.call(this, ctx, shape);
    } else {
      bezierCurveProto.buildPath.call(this, ctx, shape);
    }
  };
  ECLinePath2.prototype.pointAt = function(t) {
    if (isStraightLine(this.shape)) {
      return straightLineProto.pointAt.call(this, t);
    } else {
      return bezierCurveProto.pointAt.call(this, t);
    }
  };
  ECLinePath2.prototype.tangentAt = function(t) {
    var shape = this.shape;
    var p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
    return normalize$5(p, p);
  };
  return ECLinePath2;
}(Path$1);
var ECLinePath$1 = ECLinePath;
var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
function makeSymbolTypeKey(symbolCategory) {
  return "_" + symbolCategory + "Type";
}
function createSymbol(name, lineData, idx) {
  var symbolType = lineData.getItemVisual(idx, name);
  if (!symbolType || symbolType === "none") {
    return;
  }
  var symbolSize = lineData.getItemVisual(idx, name + "Size");
  var symbolRotate = lineData.getItemVisual(idx, name + "Rotate");
  var symbolOffset = lineData.getItemVisual(idx, name + "Offset");
  var symbolKeepAspect = lineData.getItemVisual(idx, name + "KeepAspect");
  var symbolSizeArr = normalizeSymbolSize(symbolSize);
  var symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
  var symbolPath = createSymbol$1(symbolType, -symbolSizeArr[0] / 2 + symbolOffsetArr[0], -symbolSizeArr[1] / 2 + symbolOffsetArr[1], symbolSizeArr[0], symbolSizeArr[1], null, symbolKeepAspect);
  symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
  symbolPath.name = name;
  return symbolPath;
}
function createLine(points2) {
  var line = new ECLinePath$1({
    name: "line",
    subPixelOptimize: true
  });
  setLinePoints(line.shape, points2);
  return line;
}
function setLinePoints(targetShape, points2) {
  targetShape.x1 = points2[0][0];
  targetShape.y1 = points2[0][1];
  targetShape.x2 = points2[1][0];
  targetShape.y2 = points2[1][1];
  targetShape.percent = 1;
  var cp1 = points2[2];
  if (cp1) {
    targetShape.cpx1 = cp1[0];
    targetShape.cpy1 = cp1[1];
  } else {
    targetShape.cpx1 = NaN;
    targetShape.cpy1 = NaN;
  }
}
var Line = function(_super) {
  __extends(Line2, _super);
  function Line2(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;
    _this._createLine(lineData, idx, seriesScope);
    return _this;
  }
  Line2.prototype._createLine = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var linePoints = lineData.getItemLayout(idx);
    var line = createLine(linePoints);
    line.shape.percent = 0;
    initProps(line, {
      shape: {
        percent: 1
      }
    }, seriesModel, idx);
    this.add(line);
    each$f(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbol = createSymbol(symbolCategory, lineData, idx);
      this.add(symbol);
      this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  Line2.prototype.updateData = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName("line");
    var linePoints = lineData.getItemLayout(idx);
    var target = {
      shape: {}
    };
    setLinePoints(target.shape, linePoints);
    updateProps$1(line, target, seriesModel, idx);
    each$f(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbolType = lineData.getItemVisual(idx, symbolCategory);
      var key = makeSymbolTypeKey(symbolCategory);
      if (this[key] !== symbolType) {
        this.remove(this.childOfName(symbolCategory));
        var symbol = createSymbol(symbolCategory, lineData, idx);
        this.add(symbol);
      }
      this[key] = symbolType;
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  Line2.prototype.getLinePath = function() {
    return this.childAt(0);
  };
  Line2.prototype._updateCommonStl = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childOfName("line");
    var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    var blurLineStyle = seriesScope && seriesScope.blurLineStyle;
    var selectLineStyle = seriesScope && seriesScope.selectLineStyle;
    var labelStatesModels = seriesScope && seriesScope.labelStatesModels;
    var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
    var focus = seriesScope && seriesScope.focus;
    var blurScope = seriesScope && seriesScope.blurScope;
    if (!seriesScope || lineData.hasItemOption) {
      var itemModel = lineData.getItemModel(idx);
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
      blurLineStyle = itemModel.getModel(["blur", "lineStyle"]).getLineStyle();
      selectLineStyle = itemModel.getModel(["select", "lineStyle"]).getLineStyle();
      emphasisDisabled = emphasisModel.get("disabled");
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      labelStatesModels = getLabelStatesModels(itemModel);
    }
    var lineStyle = lineData.getItemVisual(idx, "style");
    var visualColor = lineStyle.stroke;
    line.useStyle(lineStyle);
    line.style.fill = null;
    line.style.strokeNoScale = true;
    line.ensureState("emphasis").style = emphasisLineStyle;
    line.ensureState("blur").style = blurLineStyle;
    line.ensureState("select").style = selectLineStyle;
    each$f(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbol = this.childOfName(symbolCategory);
      if (symbol) {
        symbol.setColor(visualColor);
        symbol.style.opacity = lineStyle.opacity;
        for (var i = 0; i < SPECIAL_STATES.length; i++) {
          var stateName = SPECIAL_STATES[i];
          var lineState = line.getState(stateName);
          if (lineState) {
            var lineStateStyle = lineState.style || {};
            var state = symbol.ensureState(stateName);
            var stateStyle = state.style || (state.style = {});
            if (lineStateStyle.stroke != null) {
              stateStyle[symbol.__isEmptyBrush ? "stroke" : "fill"] = lineStateStyle.stroke;
            }
            if (lineStateStyle.opacity != null) {
              stateStyle.opacity = lineStateStyle.opacity;
            }
          }
        }
        symbol.markRedraw();
      }
    }, this);
    var rawVal = seriesModel.getRawValue(idx);
    setLabelStyle(this, labelStatesModels, {
      labelDataIndex: idx,
      labelFetcher: {
        getFormattedLabel: function(dataIndex, stateName) {
          return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);
        }
      },
      inheritColor: visualColor || "#000",
      defaultOpacity: lineStyle.opacity,
      defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round$3(rawVal) : rawVal) + ""
    });
    var label = this.getTextContent();
    if (label) {
      var labelNormalModel = labelStatesModels.normal;
      label.__align = label.style.align;
      label.__verticalAlign = label.style.verticalAlign;
      label.__position = labelNormalModel.get("position") || "middle";
      var distance2 = labelNormalModel.get("distance");
      if (!isArray$1(distance2)) {
        distance2 = [distance2, distance2];
      }
      label.__labelDistance = distance2;
    }
    this.setTextConfig({
      position: null,
      local: true,
      inside: false
    });
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };
  Line2.prototype.highlight = function() {
    enterEmphasis(this);
  };
  Line2.prototype.downplay = function() {
    leaveEmphasis(this);
  };
  Line2.prototype.updateLayout = function(lineData, idx) {
    this.setLinePoints(lineData.getItemLayout(idx));
  };
  Line2.prototype.setLinePoints = function(points2) {
    var linePath = this.childOfName("line");
    setLinePoints(linePath.shape, points2);
    linePath.dirty();
  };
  Line2.prototype.beforeUpdate = function() {
    var lineGroup = this;
    var symbolFrom = lineGroup.childOfName("fromSymbol");
    var symbolTo = lineGroup.childOfName("toSymbol");
    var label = lineGroup.getTextContent();
    if (!symbolFrom && !symbolTo && (!label || label.ignore)) {
      return;
    }
    var invScale = 1;
    var parentNode2 = this.parent;
    while (parentNode2) {
      if (parentNode2.scaleX) {
        invScale /= parentNode2.scaleX;
      }
      parentNode2 = parentNode2.parent;
    }
    var line = lineGroup.childOfName("line");
    if (!this.__dirty && !line.__dirty) {
      return;
    }
    var percent = line.shape.percent;
    var fromPos = line.pointAt(0);
    var toPos = line.pointAt(percent);
    var d = sub$1([], toPos, fromPos);
    normalize$5(d, d);
    function setSymbolRotation(symbol, percent2) {
      var specifiedRotation = symbol.__specifiedRotation;
      if (specifiedRotation == null) {
        var tangent3 = line.tangentAt(percent2);
        symbol.attr("rotation", (percent2 === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent3[1], tangent3[0]));
      } else {
        symbol.attr("rotation", specifiedRotation);
      }
    }
    if (symbolFrom) {
      symbolFrom.setPosition(fromPos);
      setSymbolRotation(symbolFrom, 0);
      symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;
      symbolFrom.markRedraw();
    }
    if (symbolTo) {
      symbolTo.setPosition(toPos);
      setSymbolRotation(symbolTo, 1);
      symbolTo.scaleX = symbolTo.scaleY = invScale * percent;
      symbolTo.markRedraw();
    }
    if (label && !label.ignore) {
      label.x = label.y = 0;
      label.originX = label.originY = 0;
      var textAlign = void 0;
      var textVerticalAlign = void 0;
      var distance2 = label.__labelDistance;
      var distanceX = distance2[0] * invScale;
      var distanceY = distance2[1] * invScale;
      var halfPercent = percent / 2;
      var tangent2 = line.tangentAt(halfPercent);
      var n = [tangent2[1], -tangent2[0]];
      var cp = line.pointAt(halfPercent);
      if (n[1] > 0) {
        n[0] = -n[0];
        n[1] = -n[1];
      }
      var dir3 = tangent2[0] < 0 ? -1 : 1;
      if (label.__position !== "start" && label.__position !== "end") {
        var rotation = -Math.atan2(tangent2[1], tangent2[0]);
        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }
        label.rotation = rotation;
      }
      var dy = void 0;
      switch (label.__position) {
        case "insideStartTop":
        case "insideMiddleTop":
        case "insideEndTop":
        case "middle":
          dy = -distanceY;
          textVerticalAlign = "bottom";
          break;
        case "insideStartBottom":
        case "insideMiddleBottom":
        case "insideEndBottom":
          dy = distanceY;
          textVerticalAlign = "top";
          break;
        default:
          dy = 0;
          textVerticalAlign = "middle";
      }
      switch (label.__position) {
        case "end":
          label.x = d[0] * distanceX + toPos[0];
          label.y = d[1] * distanceY + toPos[1];
          textAlign = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center";
          textVerticalAlign = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
          break;
        case "start":
          label.x = -d[0] * distanceX + fromPos[0];
          label.y = -d[1] * distanceY + fromPos[1];
          textAlign = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center";
          textVerticalAlign = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
          break;
        case "insideStartTop":
        case "insideStart":
        case "insideStartBottom":
          label.x = distanceX * dir3 + fromPos[0];
          label.y = fromPos[1] + dy;
          textAlign = tangent2[0] < 0 ? "right" : "left";
          label.originX = -distanceX * dir3;
          label.originY = -dy;
          break;
        case "insideMiddleTop":
        case "insideMiddle":
        case "insideMiddleBottom":
        case "middle":
          label.x = cp[0];
          label.y = cp[1] + dy;
          textAlign = "center";
          label.originY = -dy;
          break;
        case "insideEndTop":
        case "insideEnd":
        case "insideEndBottom":
          label.x = -distanceX * dir3 + toPos[0];
          label.y = toPos[1] + dy;
          textAlign = tangent2[0] >= 0 ? "right" : "left";
          label.originX = distanceX * dir3;
          label.originY = -dy;
          break;
      }
      label.scaleX = label.scaleY = invScale;
      label.setStyle({
        verticalAlign: label.__verticalAlign || textVerticalAlign,
        align: label.__align || textAlign
      });
    }
  };
  return Line2;
}(Group$4);
var Line$1 = Line;
var LineDraw = function() {
  function LineDraw2(LineCtor) {
    this.group = new Group$4();
    this._LineCtor = LineCtor || Line$1;
  }
  LineDraw2.prototype.updateData = function(lineData) {
    var _this = this;
    this._progressiveEls = null;
    var lineDraw = this;
    var group = lineDraw.group;
    var oldLineData = lineDraw._lineData;
    lineDraw._lineData = lineData;
    if (!oldLineData) {
      group.removeAll();
    }
    var seriesScope = makeSeriesScope$1(lineData);
    lineData.diff(oldLineData).add(function(idx) {
      _this._doAdd(lineData, idx, seriesScope);
    }).update(function(newIdx, oldIdx) {
      _this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);
    }).remove(function(idx) {
      group.remove(oldLineData.getItemGraphicEl(idx));
    }).execute();
  };
  LineDraw2.prototype.updateLayout = function() {
    var lineData = this._lineData;
    if (!lineData) {
      return;
    }
    lineData.eachItemGraphicEl(function(el, idx) {
      el.updateLayout(lineData, idx);
    }, this);
  };
  LineDraw2.prototype.incrementalPrepareUpdate = function(lineData) {
    this._seriesScope = makeSeriesScope$1(lineData);
    this._lineData = null;
    this.group.removeAll();
  };
  LineDraw2.prototype.incrementalUpdate = function(taskParams, lineData) {
    this._progressiveEls = [];
    function updateIncrementalAndHover(el2) {
      if (!el2.isGroup && !isEffectObject(el2)) {
        el2.incremental = true;
        el2.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var itemLayout = lineData.getItemLayout(idx);
      if (lineNeedsDraw(itemLayout)) {
        var el = new this._LineCtor(lineData, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        this.group.add(el);
        lineData.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  };
  LineDraw2.prototype.remove = function() {
    this.group.removeAll();
  };
  LineDraw2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  LineDraw2.prototype._doAdd = function(lineData, idx, seriesScope) {
    var itemLayout = lineData.getItemLayout(idx);
    if (!lineNeedsDraw(itemLayout)) {
      return;
    }
    var el = new this._LineCtor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, el);
    this.group.add(el);
  };
  LineDraw2.prototype._doUpdate = function(oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
    var itemEl = oldLineData.getItemGraphicEl(oldIdx);
    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
      this.group.remove(itemEl);
      return;
    }
    if (!itemEl) {
      itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);
    } else {
      itemEl.updateData(newLineData, newIdx, seriesScope);
    }
    newLineData.setItemGraphicEl(newIdx, itemEl);
    this.group.add(itemEl);
  };
  return LineDraw2;
}();
function isEffectObject(el) {
  return el.animators && el.animators.length > 0;
}
function makeSeriesScope$1(lineData) {
  var hostModel = lineData.hostModel;
  var emphasisModel = hostModel.getModel("emphasis");
  return {
    lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: emphasisModel.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: hostModel.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: hostModel.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: emphasisModel.get("disabled"),
    blurScope: emphasisModel.get("blurScope"),
    focus: emphasisModel.get("focus"),
    labelStatesModels: getLabelStatesModels(hostModel)
  };
}
function isPointNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]);
}
function lineNeedsDraw(pts) {
  return pts && !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}
var LineDraw$1 = LineDraw;
var v1 = [];
var v2 = [];
var v3 = [];
var quadraticAt = quadraticAt$1;
var v2DistSquare = distSquare;
var mathAbs = Math.abs;
function intersectCurveCircle(curvePoints, center2, radius) {
  var p02 = curvePoints[0];
  var p12 = curvePoints[1];
  var p22 = curvePoints[2];
  var d = Infinity;
  var t;
  var radiusSquare = radius * radius;
  var interval = 0.1;
  for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
    v1[0] = quadraticAt(p02[0], p12[0], p22[0], _t);
    v1[1] = quadraticAt(p02[1], p12[1], p22[1], _t);
    var diff = mathAbs(v2DistSquare(v1, center2) - radiusSquare);
    if (diff < d) {
      d = diff;
      t = _t;
    }
  }
  for (var i = 0; i < 32; i++) {
    var next = t + interval;
    v2[0] = quadraticAt(p02[0], p12[0], p22[0], t);
    v2[1] = quadraticAt(p02[1], p12[1], p22[1], t);
    v3[0] = quadraticAt(p02[0], p12[0], p22[0], next);
    v3[1] = quadraticAt(p02[1], p12[1], p22[1], next);
    var diff = v2DistSquare(v2, center2) - radiusSquare;
    if (mathAbs(diff) < 0.01) {
      break;
    }
    var nextDiff = v2DistSquare(v3, center2) - radiusSquare;
    interval /= 2;
    if (diff < 0) {
      if (nextDiff >= 0) {
        t = t + interval;
      } else {
        t = t - interval;
      }
    } else {
      if (nextDiff >= 0) {
        t = t - interval;
      } else {
        t = t + interval;
      }
    }
  }
  return t;
}
function adjustEdge(graph, scale2) {
  var tmp0 = [];
  var quadraticSubdivide$1 = quadraticSubdivide;
  var pts = [[], [], []];
  var pts2 = [[], []];
  var v = [];
  scale2 /= 2;
  graph.eachEdge(function(edge, idx) {
    var linePoints = edge.getLayout();
    var fromSymbol = edge.getVisual("fromSymbol");
    var toSymbol = edge.getVisual("toSymbol");
    if (!linePoints.__original) {
      linePoints.__original = [clone$3(linePoints[0]), clone$3(linePoints[1])];
      if (linePoints[2]) {
        linePoints.__original.push(clone$3(linePoints[2]));
      }
    }
    var originalPoints = linePoints.__original;
    if (linePoints[2] != null) {
      copy$1(pts[0], originalPoints[0]);
      copy$1(pts[1], originalPoints[2]);
      copy$1(pts[2], originalPoints[1]);
      if (fromSymbol && fromSymbol !== "none") {
        var symbolSize = getSymbolSize(edge.node1);
        var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale2);
        quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[0][0] = tmp0[3];
        pts[1][0] = tmp0[4];
        quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[0][1] = tmp0[3];
        pts[1][1] = tmp0[4];
      }
      if (toSymbol && toSymbol !== "none") {
        var symbolSize = getSymbolSize(edge.node2);
        var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale2);
        quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[1][0] = tmp0[1];
        pts[2][0] = tmp0[2];
        quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[1][1] = tmp0[1];
        pts[2][1] = tmp0[2];
      }
      copy$1(linePoints[0], pts[0]);
      copy$1(linePoints[1], pts[2]);
      copy$1(linePoints[2], pts[1]);
    } else {
      copy$1(pts2[0], originalPoints[0]);
      copy$1(pts2[1], originalPoints[1]);
      sub$1(v, pts2[1], pts2[0]);
      normalize$5(v, v);
      if (fromSymbol && fromSymbol !== "none") {
        var symbolSize = getSymbolSize(edge.node1);
        scaleAndAdd$1(pts2[0], pts2[0], v, symbolSize * scale2);
      }
      if (toSymbol && toSymbol !== "none") {
        var symbolSize = getSymbolSize(edge.node2);
        scaleAndAdd$1(pts2[1], pts2[1], v, -symbolSize * scale2);
      }
      copy$1(linePoints[0], pts2[0]);
      copy$1(linePoints[1], pts2[1]);
    }
  });
}
function isViewCoordSys(coordSys) {
  return coordSys.type === "view";
}
var GraphView = function(_super) {
  __extends(GraphView2, _super);
  function GraphView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphView2.type;
    return _this;
  }
  GraphView2.prototype.init = function(ecModel, api) {
    var symbolDraw = new SymbolDraw$1();
    var lineDraw = new LineDraw$1();
    var group = this.group;
    this._controller = new RoamController$1(api.getZr());
    this._controllerHost = {
      target: group
    };
    group.add(symbolDraw.group);
    group.add(lineDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineDraw = lineDraw;
    this._firstRender = true;
  };
  GraphView2.prototype.render = function(seriesModel, ecModel, api) {
    var _this = this;
    var coordSys = seriesModel.coordinateSystem;
    this._model = seriesModel;
    var symbolDraw = this._symbolDraw;
    var lineDraw = this._lineDraw;
    var group = this.group;
    if (isViewCoordSys(coordSys)) {
      var groupNewProp = {
        x: coordSys.x,
        y: coordSys.y,
        scaleX: coordSys.scaleX,
        scaleY: coordSys.scaleY
      };
      if (this._firstRender) {
        group.attr(groupNewProp);
      } else {
        updateProps$1(group, groupNewProp, seriesModel);
      }
    }
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    var data = seriesModel.getData();
    symbolDraw.updateData(data);
    var edgeData = seriesModel.getEdgeData();
    lineDraw.updateData(edgeData);
    this._updateNodeAndLinkScale();
    this._updateController(seriesModel, ecModel, api);
    clearTimeout(this._layoutTimeout);
    var forceLayout2 = seriesModel.forceLayout;
    var layoutAnimation = seriesModel.get(["force", "layoutAnimation"]);
    if (forceLayout2) {
      this._startForceLayoutIteration(forceLayout2, layoutAnimation);
    }
    data.graph.eachNode(function(node) {
      var idx = node.dataIndex;
      var el = node.getGraphicEl();
      var itemModel = node.getModel();
      if (!el) {
        return;
      }
      el.off("drag").off("dragend");
      var draggable = itemModel.get("draggable");
      if (draggable) {
        el.on("drag", function() {
          if (forceLayout2) {
            forceLayout2.warmUp();
            !_this._layouting && _this._startForceLayoutIteration(forceLayout2, layoutAnimation);
            forceLayout2.setFixed(idx);
            data.setItemLayout(idx, [el.x, el.y]);
          }
        }).on("dragend", function() {
          if (forceLayout2) {
            forceLayout2.setUnfixed(idx);
          }
        });
      }
      el.setDraggable(draggable && !!forceLayout2);
      var focus = itemModel.get(["emphasis", "focus"]);
      if (focus === "adjacency") {
        getECData(el).focus = node.getAdjacentDataIndices();
      }
    });
    data.graph.eachEdge(function(edge) {
      var el = edge.getGraphicEl();
      var focus = edge.getModel().get(["emphasis", "focus"]);
      if (!el) {
        return;
      }
      if (focus === "adjacency") {
        getECData(el).focus = {
          edge: [edge.dataIndex],
          node: [edge.node1.dataIndex, edge.node2.dataIndex]
        };
      }
    });
    var circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get(["circular", "rotateLabel"]);
    var cx = data.getLayout("cx");
    var cy = data.getLayout("cy");
    data.eachItemGraphicEl(function(el, idx) {
      var itemModel = data.getItemModel(idx);
      var labelRotate = itemModel.get(["label", "rotate"]) || 0;
      var symbolPath = el.getSymbolPath();
      if (circularRotateLabel) {
        var pos = data.getItemLayout(idx);
        var rad2 = Math.atan2(pos[1] - cy, pos[0] - cx);
        if (rad2 < 0) {
          rad2 = Math.PI * 2 + rad2;
        }
        var isLeft = pos[0] < cx;
        if (isLeft) {
          rad2 = rad2 - Math.PI;
        }
        var textPosition = isLeft ? "left" : "right";
        symbolPath.setTextConfig({
          rotation: -rad2,
          position: textPosition,
          origin: "center"
        });
        var emphasisState = symbolPath.ensureState("emphasis");
        extend$1(emphasisState.textConfig || (emphasisState.textConfig = {}), {
          position: textPosition
        });
      } else {
        symbolPath.setTextConfig({
          rotation: labelRotate *= Math.PI / 180
        });
      }
    });
    this._firstRender = false;
  };
  GraphView2.prototype.dispose = function() {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  };
  GraphView2.prototype._startForceLayoutIteration = function(forceLayout2, layoutAnimation) {
    var self2 = this;
    (function step() {
      forceLayout2.step(function(stopped) {
        self2.updateLayout(self2._model);
        (self2._layouting = !stopped) && (layoutAnimation ? self2._layoutTimeout = setTimeout(step, 16) : step());
      });
    })();
  };
  GraphView2.prototype._updateController = function(seriesModel, ecModel, api) {
    var _this = this;
    var controller = this._controller;
    var controllerHost = this._controllerHost;
    var group = this.group;
    controller.setPointerChecker(function(e2, x, y) {
      var rect = group.getBoundingRect();
      rect.applyTransform(group.transform);
      return rect.contain(x, y) && !onIrrelevantElement(e2, api, seriesModel);
    });
    if (!isViewCoordSys(seriesModel.coordinateSystem)) {
      controller.disable();
      return;
    }
    controller.enable(seriesModel.get("roam"));
    controllerHost.zoomLimit = seriesModel.get("scaleLimit");
    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
    controller.off("pan").off("zoom").on("pan", function(e2) {
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: "graphRoam",
        dx: e2.dx,
        dy: e2.dy
      });
    }).on("zoom", function(e2) {
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api.dispatchAction({
        seriesId: seriesModel.id,
        type: "graphRoam",
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY
      });
      _this._updateNodeAndLinkScale();
      adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
      _this._lineDraw.updateLayout();
      api.updateLabelLayout();
    });
  };
  GraphView2.prototype._updateNodeAndLinkScale = function() {
    var seriesModel = this._model;
    var data = seriesModel.getData();
    var nodeScale = getNodeGlobalScale(seriesModel);
    data.eachItemGraphicEl(function(el, idx) {
      el && el.setSymbolScale(nodeScale);
    });
  };
  GraphView2.prototype.updateLayout = function(seriesModel) {
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    this._symbolDraw.updateLayout();
    this._lineDraw.updateLayout();
  };
  GraphView2.prototype.remove = function(ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove();
    this._lineDraw && this._lineDraw.remove();
  };
  GraphView2.type = "graph";
  return GraphView2;
}(ChartView$1);
var GraphView$1 = GraphView;
function generateNodeKey(id) {
  return "_EC_" + id;
}
var Graph$2 = function() {
  function Graph2(directed) {
    this.type = "graph";
    this.nodes = [];
    this.edges = [];
    this._nodesMap = {};
    this._edgesMap = {};
    this._directed = directed || false;
  }
  Graph2.prototype.isDirected = function() {
    return this._directed;
  };
  Graph2.prototype.addNode = function(id, dataIndex) {
    id = id == null ? "" + dataIndex : "" + id;
    var nodesMap = this._nodesMap;
    if (nodesMap[generateNodeKey(id)]) {
      return;
    }
    var node = new GraphNode(id, dataIndex);
    node.hostGraph = this;
    this.nodes.push(node);
    nodesMap[generateNodeKey(id)] = node;
    return node;
  };
  Graph2.prototype.getNodeByIndex = function(dataIndex) {
    var rawIdx = this.data.getRawIndex(dataIndex);
    return this.nodes[rawIdx];
  };
  Graph2.prototype.getNodeById = function(id) {
    return this._nodesMap[generateNodeKey(id)];
  };
  Graph2.prototype.addEdge = function(n1, n2, dataIndex) {
    var nodesMap = this._nodesMap;
    var edgesMap = this._edgesMap;
    if (isNumber(n1)) {
      n1 = this.nodes[n1];
    }
    if (isNumber(n2)) {
      n2 = this.nodes[n2];
    }
    if (!(n1 instanceof GraphNode)) {
      n1 = nodesMap[generateNodeKey(n1)];
    }
    if (!(n2 instanceof GraphNode)) {
      n2 = nodesMap[generateNodeKey(n2)];
    }
    if (!n1 || !n2) {
      return;
    }
    var key = n1.id + "-" + n2.id;
    var edge = new GraphEdge(n1, n2, dataIndex);
    edge.hostGraph = this;
    if (this._directed) {
      n1.outEdges.push(edge);
      n2.inEdges.push(edge);
    }
    n1.edges.push(edge);
    if (n1 !== n2) {
      n2.edges.push(edge);
    }
    this.edges.push(edge);
    edgesMap[key] = edge;
    return edge;
  };
  Graph2.prototype.getEdgeByIndex = function(dataIndex) {
    var rawIdx = this.edgeData.getRawIndex(dataIndex);
    return this.edges[rawIdx];
  };
  Graph2.prototype.getEdge = function(n1, n2) {
    if (n1 instanceof GraphNode) {
      n1 = n1.id;
    }
    if (n2 instanceof GraphNode) {
      n2 = n2.id;
    }
    var edgesMap = this._edgesMap;
    if (this._directed) {
      return edgesMap[n1 + "-" + n2];
    } else {
      return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
    }
  };
  Graph2.prototype.eachNode = function(cb, context) {
    var nodes = this.nodes;
    var len2 = nodes.length;
    for (var i = 0; i < len2; i++) {
      if (nodes[i].dataIndex >= 0) {
        cb.call(context, nodes[i], i);
      }
    }
  };
  Graph2.prototype.eachEdge = function(cb, context) {
    var edges = this.edges;
    var len2 = edges.length;
    for (var i = 0; i < len2; i++) {
      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
        cb.call(context, edges[i], i);
      }
    }
  };
  Graph2.prototype.breadthFirstTraverse = function(cb, startNode, direction, context) {
    if (!(startNode instanceof GraphNode)) {
      startNode = this._nodesMap[generateNodeKey(startNode)];
    }
    if (!startNode) {
      return;
    }
    var edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].__visited = false;
    }
    if (cb.call(context, startNode, null)) {
      return;
    }
    var queue = [startNode];
    while (queue.length) {
      var currentNode = queue.shift();
      var edges = currentNode[edgeType];
      for (var i = 0; i < edges.length; i++) {
        var e2 = edges[i];
        var otherNode = e2.node1 === currentNode ? e2.node2 : e2.node1;
        if (!otherNode.__visited) {
          if (cb.call(context, otherNode, currentNode)) {
            return;
          }
          queue.push(otherNode);
          otherNode.__visited = true;
        }
      }
    }
  };
  Graph2.prototype.update = function() {
    var data = this.data;
    var edgeData = this.edgeData;
    var nodes = this.nodes;
    var edges = this.edges;
    for (var i = 0, len2 = nodes.length; i < len2; i++) {
      nodes[i].dataIndex = -1;
    }
    for (var i = 0, len2 = data.count(); i < len2; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
    edgeData.filterSelf(function(idx) {
      var edge = edges[edgeData.getRawIndex(idx)];
      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
    });
    for (var i = 0, len2 = edges.length; i < len2; i++) {
      edges[i].dataIndex = -1;
    }
    for (var i = 0, len2 = edgeData.count(); i < len2; i++) {
      edges[edgeData.getRawIndex(i)].dataIndex = i;
    }
  };
  Graph2.prototype.clone = function() {
    var graph = new Graph2(this._directed);
    var nodes = this.nodes;
    var edges = this.edges;
    for (var i = 0; i < nodes.length; i++) {
      graph.addNode(nodes[i].id, nodes[i].dataIndex);
    }
    for (var i = 0; i < edges.length; i++) {
      var e2 = edges[i];
      graph.addEdge(e2.node1.id, e2.node2.id, e2.dataIndex);
    }
    return graph;
  };
  return Graph2;
}();
var GraphNode = function() {
  function GraphNode2(id, dataIndex) {
    this.inEdges = [];
    this.outEdges = [];
    this.edges = [];
    this.dataIndex = -1;
    this.id = id == null ? "" : id;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  GraphNode2.prototype.degree = function() {
    return this.edges.length;
  };
  GraphNode2.prototype.inDegree = function() {
    return this.inEdges.length;
  };
  GraphNode2.prototype.outDegree = function() {
    return this.outEdges.length;
  };
  GraphNode2.prototype.getModel = function(path) {
    if (this.dataIndex < 0) {
      return;
    }
    var graph = this.hostGraph;
    var itemModel = graph.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };
  GraphNode2.prototype.getAdjacentDataIndices = function() {
    var dataIndices = {
      edge: [],
      node: []
    };
    for (var i = 0; i < this.edges.length; i++) {
      var adjacentEdge = this.edges[i];
      if (adjacentEdge.dataIndex < 0) {
        continue;
      }
      dataIndices.edge.push(adjacentEdge.dataIndex);
      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);
    }
    return dataIndices;
  };
  return GraphNode2;
}();
var GraphEdge = function() {
  function GraphEdge2(n1, n2, dataIndex) {
    this.dataIndex = -1;
    this.node1 = n1;
    this.node2 = n2;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  GraphEdge2.prototype.getModel = function(path) {
    if (this.dataIndex < 0) {
      return;
    }
    var graph = this.hostGraph;
    var itemModel = graph.edgeData.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  };
  GraphEdge2.prototype.getAdjacentDataIndices = function() {
    return {
      edge: [this.dataIndex],
      node: [this.node1.dataIndex, this.node2.dataIndex]
    };
  };
  return GraphEdge2;
}();
function createGraphDataProxyMixin(hostName, dataName) {
  return {
    getValue: function(dimension) {
      var data = this[hostName][dataName];
      return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
    },
    setVisual: function(key, value) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
    },
    getVisual: function(key) {
      return this[hostName][dataName].getItemVisual(this.dataIndex, key);
    },
    setLayout: function(layout2, merge2) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout2, merge2);
    },
    getLayout: function() {
      return this[hostName][dataName].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[hostName][dataName].getRawIndex(this.dataIndex);
    }
  };
}
mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data"));
mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
var Graph$3 = Graph$2;
function createGraphFromNodeEdge$1(nodes, edges, seriesModel, directed, beforeLink) {
  var graph = new Graph$3(directed);
  for (var i = 0; i < nodes.length; i++) {
    graph.addNode(retrieve$2(nodes[i].id, nodes[i].name, i), i);
  }
  var linkNameList = [];
  var validEdges = [];
  var linkCount = 0;
  for (var i = 0; i < edges.length; i++) {
    var link = edges[i];
    var source = link.source;
    var target = link.target;
    if (graph.addEdge(source, target, linkCount)) {
      validEdges.push(link);
      linkNameList.push(retrieve$2(convertOptionIdName(link.id, null), source + " > " + target));
      linkCount++;
    }
  }
  var coordSys = seriesModel.get("coordinateSystem");
  var nodeData;
  if (coordSys === "cartesian2d" || coordSys === "polar") {
    nodeData = createSeriesData(nodes, seriesModel);
  } else {
    var coordSysCtor = CoordinateSystem.get(coordSys);
    var coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [];
    if (indexOf(coordDimensions, "value") < 0) {
      coordDimensions.concat(["value"]);
    }
    var dimensions = prepareSeriesDataSchema(nodes, {
      coordDimensions,
      encodeDefine: seriesModel.getEncode()
    }).dimensions;
    nodeData = new SeriesData$1(dimensions, seriesModel);
    nodeData.initData(nodes);
  }
  var edgeData = new SeriesData$1(["value"], seriesModel);
  edgeData.initData(validEdges, linkNameList);
  beforeLink && beforeLink(nodeData, edgeData);
  linkSeriesData({
    mainData: nodeData,
    struct: graph,
    structAttr: "graph",
    datas: {
      node: nodeData,
      edge: edgeData
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  });
  graph.update();
  return graph;
}
var GraphSeriesModel = function(_super) {
  __extends(GraphSeriesModel2, _super);
  function GraphSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  GraphSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    var self2 = this;
    function getCategoriesData() {
      return self2._categoriesData;
    }
    this.legendVisualProvider = new LegendVisualProvider$1(getCategoriesData, getCategoriesData);
    this.fillDataTextStyle(option.edges || option.links);
    this._updateCategoriesData();
  };
  GraphSeriesModel2.prototype.mergeOption = function(option) {
    _super.prototype.mergeOption.apply(this, arguments);
    this.fillDataTextStyle(option.edges || option.links);
    this._updateCategoriesData();
  };
  GraphSeriesModel2.prototype.mergeDefaultAndTheme = function(option) {
    _super.prototype.mergeDefaultAndTheme.apply(this, arguments);
    defaultEmphasis(option, "edgeLabel", ["show"]);
  };
  GraphSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var edges = option.edges || option.links || [];
    var nodes = option.data || option.nodes || [];
    var self2 = this;
    if (nodes && edges) {
      initCurvenessList(this);
      var graph = createGraphFromNodeEdge$1(nodes, edges, this, true, beforeLink);
      each$f(graph.edges, function(edge) {
        createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
      }, this);
      return graph.data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model) {
        var categoriesModels = self2._categoriesModels;
        var categoryIdx = model.getShallow("category");
        var categoryModel = categoriesModels[categoryIdx];
        if (categoryModel) {
          categoryModel.parentModel = model.parentModel;
          model.parentModel = categoryModel;
        }
        return model;
      });
      var oldGetModel = Model$1.prototype.getModel;
      function newGetModel(path, parentModel) {
        var model = oldGetModel.call(this, path, parentModel);
        model.resolveParentPath = resolveParentPath;
        return model;
      }
      edgeData.wrapMethod("getItemModel", function(model) {
        model.resolveParentPath = resolveParentPath;
        model.getModel = newGetModel;
        return model;
      });
      function resolveParentPath(pathArr) {
        if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
          var newPathArr = pathArr.slice();
          if (pathArr[0] === "label") {
            newPathArr[0] = "edgeLabel";
          } else if (pathArr[1] === "label") {
            newPathArr[1] = "edgeLabel";
          }
          return newPathArr;
        }
        return pathArr;
      }
    }
  };
  GraphSeriesModel2.prototype.getGraph = function() {
    return this.getData().graph;
  };
  GraphSeriesModel2.prototype.getEdgeData = function() {
    return this.getGraph().edgeData;
  };
  GraphSeriesModel2.prototype.getCategoriesData = function() {
    return this._categoriesData;
  };
  GraphSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    if (dataType === "edge") {
      var nodeData = this.getData();
      var params = this.getDataParams(dataIndex, dataType);
      var edge = nodeData.graph.getEdgeByIndex(dataIndex);
      var sourceName = nodeData.getName(edge.node1.dataIndex);
      var targetName = nodeData.getName(edge.node2.dataIndex);
      var nameArr = [];
      sourceName != null && nameArr.push(sourceName);
      targetName != null && nameArr.push(targetName);
      return createTooltipMarkup("nameValue", {
        name: nameArr.join(" > "),
        value: params.value,
        noValue: params.value == null
      });
    }
    var nodeMarkup = defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
    return nodeMarkup;
  };
  GraphSeriesModel2.prototype._updateCategoriesData = function() {
    var categories = map$1(this.option.categories || [], function(category) {
      return category.value != null ? category : extend$1({
        value: 0
      }, category);
    });
    var categoriesData = new SeriesData$1(["value"], this);
    categoriesData.initData(categories);
    this._categoriesData = categoriesData;
    this._categoriesModels = categoriesData.mapArray(function(idx) {
      return categoriesData.getItemModel(idx);
    });
  };
  GraphSeriesModel2.prototype.setZoom = function(zoom) {
    this.option.zoom = zoom;
  };
  GraphSeriesModel2.prototype.setCenter = function(center2) {
    this.option.center = center2;
  };
  GraphSeriesModel2.prototype.isAnimationEnabled = function() {
    return _super.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
  };
  GraphSeriesModel2.type = "series.graph";
  GraphSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
  GraphSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "view",
    legendHoverLink: true,
    layout: null,
    circular: {
      rotateLabel: false
    },
    force: {
      initLayout: null,
      repulsion: [0, 50],
      gravity: 0.1,
      friction: 0.6,
      edgeLength: 30,
      layoutAnimation: true
    },
    left: "center",
    top: "center",
    symbol: "circle",
    symbolSize: 10,
    edgeSymbol: ["none", "none"],
    edgeSymbolSize: 10,
    edgeLabel: {
      position: "middle",
      distance: 5
    },
    draggable: false,
    roam: false,
    center: null,
    zoom: 1,
    nodeScaleRatio: 0.6,
    label: {
      show: false,
      formatter: "{b}"
    },
    itemStyle: {},
    lineStyle: {
      color: "#aaa",
      width: 1,
      opacity: 0.5
    },
    emphasis: {
      scale: true,
      label: {
        show: true
      }
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  };
  return GraphSeriesModel2;
}(SeriesModel$1);
var GraphSeriesModel$1 = GraphSeriesModel;
var actionInfo$1 = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function install$V(registers) {
  registers.registerChartView(GraphView$1);
  registers.registerSeriesModel(GraphSeriesModel$1);
  registers.registerProcessor(categoryFilter);
  registers.registerVisual(categoryVisual);
  registers.registerVisual(graphEdgeVisual);
  registers.registerLayout(graphSimpleLayout);
  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout);
  registers.registerLayout(graphForceLayout);
  registers.registerCoordinateSystem("graphView", {
    dimensions: View$1.dimensions,
    create: createViewCoordSys
  });
  registers.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, noop$1);
  registers.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, noop$1);
  registers.registerAction(actionInfo$1, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      query: payload
    }, function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = updateCenterAndZoom(coordSys, payload);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}
var PointerShape = function() {
  function PointerShape2() {
    this.angle = 0;
    this.width = 10;
    this.r = 10;
    this.x = 0;
    this.y = 0;
  }
  return PointerShape2;
}();
var PointerPath = function(_super) {
  __extends(PointerPath2, _super);
  function PointerPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "pointer";
    return _this;
  }
  PointerPath2.prototype.getDefaultShape = function() {
    return new PointerShape();
  };
  PointerPath2.prototype.buildPath = function(ctx, shape) {
    var mathCos2 = Math.cos;
    var mathSin2 = Math.sin;
    var r = shape.r;
    var width = shape.width;
    var angle = shape.angle;
    var x = shape.x - mathCos2(angle) * width * (width >= r / 3 ? 1 : 2);
    var y = shape.y - mathSin2(angle) * width * (width >= r / 3 ? 1 : 2);
    angle = shape.angle - Math.PI / 2;
    ctx.moveTo(x, y);
    ctx.lineTo(shape.x + mathCos2(angle) * width, shape.y + mathSin2(angle) * width);
    ctx.lineTo(shape.x + mathCos2(shape.angle) * r, shape.y + mathSin2(shape.angle) * r);
    ctx.lineTo(shape.x - mathCos2(angle) * width, shape.y - mathSin2(angle) * width);
    ctx.lineTo(x, y);
  };
  return PointerPath2;
}(Path$1);
var PointerPath$1 = PointerPath;
function parsePosition(seriesModel, api) {
  var center2 = seriesModel.get("center");
  var width = api.getWidth();
  var height = api.getHeight();
  var size = Math.min(width, height);
  var cx = parsePercent$1(center2[0], api.getWidth());
  var cy = parsePercent$1(center2[1], api.getHeight());
  var r = parsePercent$1(seriesModel.get("radius"), size / 2);
  return {
    cx,
    cy,
    r
  };
}
function formatLabel(value, labelFormatter) {
  var label = value == null ? "" : value + "";
  if (labelFormatter) {
    if (isString(labelFormatter)) {
      label = labelFormatter.replace("{value}", label);
    } else if (isFunction$1(labelFormatter)) {
      label = labelFormatter(value);
    }
  }
  return label;
}
var PI2 = Math.PI * 2;
var GaugeView = function(_super) {
  __extends(GaugeView2, _super);
  function GaugeView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GaugeView2.type;
    return _this;
  }
  GaugeView2.prototype.render = function(seriesModel, ecModel, api) {
    this.group.removeAll();
    var colorList = seriesModel.get(["axisLine", "lineStyle", "color"]);
    var posInfo = parsePosition(seriesModel, api);
    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
    this._data = seriesModel.getData();
  };
  GaugeView2.prototype.dispose = function() {
  };
  GaugeView2.prototype._renderMain = function(seriesModel, ecModel, api, colorList, posInfo) {
    var group = this.group;
    var clockwise = seriesModel.get("clockwise");
    var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
    var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
    var axisLineModel = seriesModel.getModel("axisLine");
    var roundCap = axisLineModel.get("roundCap");
    var MainPath = roundCap ? Sausage : Sector$1;
    var showAxis = axisLineModel.get("show");
    var lineStyleModel = axisLineModel.getModel("lineStyle");
    var axisLineWidth = lineStyleModel.get("width");
    var angleRangeSpan = !((endAngle - startAngle) % PI2) && endAngle !== startAngle ? PI2 : (endAngle - startAngle) % PI2;
    var prevEndAngle = startAngle;
    for (var i = 0; showAxis && i < colorList.length; i++) {
      var percent = Math.min(Math.max(colorList[i][0], 0), 1);
      endAngle = startAngle + angleRangeSpan * percent;
      var sector = new MainPath({
        shape: {
          startAngle: prevEndAngle,
          endAngle,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0: posInfo.r - axisLineWidth,
          r: posInfo.r
        },
        silent: true
      });
      sector.setStyle({
        fill: colorList[i][1]
      });
      sector.setStyle(lineStyleModel.getLineStyle(["color", "width"]));
      group.add(sector);
      prevEndAngle = endAngle;
    }
    var getColor = function(percent2) {
      if (percent2 <= 0) {
        return colorList[0][1];
      }
      var i2;
      for (i2 = 0; i2 < colorList.length; i2++) {
        if (colorList[i2][0] >= percent2 && (i2 === 0 ? 0 : colorList[i2 - 1][0]) < percent2) {
          return colorList[i2][1];
        }
      }
      return colorList[i2 - 1][1];
    };
    if (!clockwise) {
      var tmp = startAngle;
      startAngle = endAngle;
      endAngle = tmp;
    }
    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);
    this._renderAnchor(seriesModel, posInfo);
    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
  };
  GaugeView2.prototype._renderTicks = function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    var group = this.group;
    var cx = posInfo.cx;
    var cy = posInfo.cy;
    var r = posInfo.r;
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var splitLineModel = seriesModel.getModel("splitLine");
    var tickModel = seriesModel.getModel("axisTick");
    var labelModel = seriesModel.getModel("axisLabel");
    var splitNumber = seriesModel.get("splitNumber");
    var subSplitNumber = tickModel.get("splitNumber");
    var splitLineLen = parsePercent$1(splitLineModel.get("length"), r);
    var tickLen = parsePercent$1(tickModel.get("length"), r);
    var angle = startAngle;
    var step = (endAngle - startAngle) / splitNumber;
    var subStep = step / subSplitNumber;
    var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
    var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
    var splitLineDistance = splitLineModel.get("distance");
    var unitX;
    var unitY;
    for (var i = 0; i <= splitNumber; i++) {
      unitX = Math.cos(angle);
      unitY = Math.sin(angle);
      if (splitLineModel.get("show")) {
        var distance2 = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
        var splitLine = new Line$3({
          shape: {
            x1: unitX * (r - distance2) + cx,
            y1: unitY * (r - distance2) + cy,
            x2: unitX * (r - splitLineLen - distance2) + cx,
            y2: unitY * (r - splitLineLen - distance2) + cy
          },
          style: splitLineStyle,
          silent: true
        });
        if (splitLineStyle.stroke === "auto") {
          splitLine.setStyle({
            stroke: getColor(i / splitNumber)
          });
        }
        group.add(splitLine);
      }
      if (labelModel.get("show")) {
        var distance2 = labelModel.get("distance") + splitLineDistance;
        var label = formatLabel(round$3(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
        var autoColor = getColor(i / splitNumber);
        group.add(new ZRText$1({
          style: createTextStyle$1(labelModel, {
            text: label,
            x: unitX * (r - splitLineLen - distance2) + cx,
            y: unitY * (r - splitLineLen - distance2) + cy,
            verticalAlign: unitY < -0.8 ? "top" : unitY > 0.8 ? "bottom" : "middle",
            align: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
          }, {
            inheritColor: autoColor
          }),
          silent: true
        }));
      }
      if (tickModel.get("show") && i !== splitNumber) {
        var distance2 = tickModel.get("distance");
        distance2 = distance2 ? distance2 + axisLineWidth : axisLineWidth;
        for (var j = 0; j <= subSplitNumber; j++) {
          unitX = Math.cos(angle);
          unitY = Math.sin(angle);
          var tickLine = new Line$3({
            shape: {
              x1: unitX * (r - distance2) + cx,
              y1: unitY * (r - distance2) + cy,
              x2: unitX * (r - tickLen - distance2) + cx,
              y2: unitY * (r - tickLen - distance2) + cy
            },
            silent: true,
            style: tickLineStyle
          });
          if (tickLineStyle.stroke === "auto") {
            tickLine.setStyle({
              stroke: getColor((i + j / subSplitNumber) / splitNumber)
            });
          }
          group.add(tickLine);
          angle += subStep;
        }
        angle -= subStep;
      } else {
        angle += step;
      }
    }
  };
  GaugeView2.prototype._renderPointer = function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    var group = this.group;
    var oldData = this._data;
    var oldProgressData = this._progressEls;
    var progressList = [];
    var showPointer2 = seriesModel.get(["pointer", "show"]);
    var progressModel = seriesModel.getModel("progress");
    var showProgress = progressModel.get("show");
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var valueExtent = [minVal, maxVal];
    var angleExtent = [startAngle, endAngle];
    function createPointer(idx, angle) {
      var itemModel = data.getItemModel(idx);
      var pointerModel = itemModel.getModel("pointer");
      var pointerWidth = parsePercent$1(pointerModel.get("width"), posInfo.r);
      var pointerLength = parsePercent$1(pointerModel.get("length"), posInfo.r);
      var pointerStr = seriesModel.get(["pointer", "icon"]);
      var pointerOffset = pointerModel.get("offsetCenter");
      var pointerOffsetX = parsePercent$1(pointerOffset[0], posInfo.r);
      var pointerOffsetY = parsePercent$1(pointerOffset[1], posInfo.r);
      var pointerKeepAspect = pointerModel.get("keepAspect");
      var pointer;
      if (pointerStr) {
        pointer = createSymbol$1(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
      } else {
        pointer = new PointerPath$1({
          shape: {
            angle: -Math.PI / 2,
            width: pointerWidth,
            r: pointerLength,
            x: pointerOffsetX,
            y: pointerOffsetY
          }
        });
      }
      pointer.rotation = -(angle + Math.PI / 2);
      pointer.x = posInfo.cx;
      pointer.y = posInfo.cy;
      return pointer;
    }
    function createProgress(idx, endAngle2) {
      var roundCap = progressModel.get("roundCap");
      var ProgressPath = roundCap ? Sausage : Sector$1;
      var isOverlap = progressModel.get("overlap");
      var progressWidth = isOverlap ? progressModel.get("width") : axisLineWidth / data.count();
      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
      var progress = new ProgressPath({
        shape: {
          startAngle,
          endAngle: endAngle2,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0,
          r
        }
      });
      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);
      return progress;
    }
    if (showProgress || showPointer2) {
      data.diff(oldData).add(function(idx) {
        var val = data.get(valueDim, idx);
        if (showPointer2) {
          var pointer = createPointer(idx, startAngle);
          initProps(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap$2(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }
        if (showProgress) {
          var progress = createProgress(idx, startAngle);
          var isClip = progressModel.get("clip");
          initProps(progress, {
            shape: {
              endAngle: linearMap$2(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);
          progressList[idx] = progress;
        }
      }).update(function(newIdx, oldIdx) {
        var val = data.get(valueDim, newIdx);
        if (showPointer2) {
          var previousPointer = oldData.getItemGraphicEl(oldIdx);
          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;
          var pointer = createPointer(newIdx, previousRotate);
          pointer.rotation = previousRotate;
          updateProps$1(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap$2(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }
        if (showProgress) {
          var previousProgress = oldProgressData[oldIdx];
          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;
          var progress = createProgress(newIdx, previousEndAngle);
          var isClip = progressModel.get("clip");
          updateProps$1(progress, {
            shape: {
              endAngle: linearMap$2(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);
          progressList[newIdx] = progress;
        }
      }).execute();
      data.each(function(idx) {
        var itemModel = data.getItemModel(idx);
        var emphasisModel = itemModel.getModel("emphasis");
        var focus = emphasisModel.get("focus");
        var blurScope = emphasisModel.get("blurScope");
        var emphasisDisabled = emphasisModel.get("disabled");
        if (showPointer2) {
          var pointer = data.getItemGraphicEl(idx);
          var symbolStyle = data.getItemVisual(idx, "style");
          var visualColor = symbolStyle.fill;
          if (pointer instanceof ZRImage$1) {
            var pathStyle = pointer.style;
            pointer.useStyle(extend$1({
              image: pathStyle.image,
              x: pathStyle.x,
              y: pathStyle.y,
              width: pathStyle.width,
              height: pathStyle.height
            }, symbolStyle));
          } else {
            pointer.useStyle(symbolStyle);
            pointer.type !== "pointer" && pointer.setColor(visualColor);
          }
          pointer.setStyle(itemModel.getModel(["pointer", "itemStyle"]).getItemStyle());
          if (pointer.style.fill === "auto") {
            pointer.setStyle("fill", getColor(linearMap$2(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }
          pointer.z2EmphasisLift = 0;
          setStatesStylesFromModel(pointer, itemModel);
          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);
        }
        if (showProgress) {
          var progress = progressList[idx];
          progress.useStyle(data.getItemVisual(idx, "style"));
          progress.setStyle(itemModel.getModel(["progress", "itemStyle"]).getItemStyle());
          progress.z2EmphasisLift = 0;
          setStatesStylesFromModel(progress, itemModel);
          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);
        }
      });
      this._progressEls = progressList;
    }
  };
  GaugeView2.prototype._renderAnchor = function(seriesModel, posInfo) {
    var anchorModel = seriesModel.getModel("anchor");
    var showAnchor = anchorModel.get("show");
    if (showAnchor) {
      var anchorSize = anchorModel.get("size");
      var anchorType = anchorModel.get("icon");
      var offsetCenter = anchorModel.get("offsetCenter");
      var anchorKeepAspect = anchorModel.get("keepAspect");
      var anchor = createSymbol$1(anchorType, posInfo.cx - anchorSize / 2 + parsePercent$1(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent$1(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
      anchor.z2 = anchorModel.get("showAbove") ? 1 : 0;
      anchor.setStyle(anchorModel.getModel("itemStyle").getItemStyle());
      this.group.add(anchor);
    }
  };
  GaugeView2.prototype._renderTitleAndDetail = function(seriesModel, ecModel, api, getColor, posInfo) {
    var _this = this;
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var minVal = +seriesModel.get("min");
    var maxVal = +seriesModel.get("max");
    var contentGroup = new Group$4();
    var newTitleEls = [];
    var newDetailEls = [];
    var hasAnimation = seriesModel.isAnimationEnabled();
    var showPointerAbove = seriesModel.get(["pointer", "showAbove"]);
    data.diff(this._data).add(function(idx) {
      newTitleEls[idx] = new ZRText$1({
        silent: true
      });
      newDetailEls[idx] = new ZRText$1({
        silent: true
      });
    }).update(function(idx, oldIdx) {
      newTitleEls[idx] = _this._titleEls[oldIdx];
      newDetailEls[idx] = _this._detailEls[oldIdx];
    }).execute();
    data.each(function(idx) {
      var itemModel = data.getItemModel(idx);
      var value = data.get(valueDim, idx);
      var itemGroup = new Group$4();
      var autoColor = getColor(linearMap$2(value, [minVal, maxVal], [0, 1], true));
      var itemTitleModel = itemModel.getModel("title");
      if (itemTitleModel.get("show")) {
        var titleOffsetCenter = itemTitleModel.get("offsetCenter");
        var titleX = posInfo.cx + parsePercent$1(titleOffsetCenter[0], posInfo.r);
        var titleY = posInfo.cy + parsePercent$1(titleOffsetCenter[1], posInfo.r);
        var labelEl = newTitleEls[idx];
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle$1(itemTitleModel, {
            x: titleX,
            y: titleY,
            text: data.getName(idx),
            align: "center",
            verticalAlign: "middle"
          }, {
            inheritColor: autoColor
          })
        });
        itemGroup.add(labelEl);
      }
      var itemDetailModel = itemModel.getModel("detail");
      if (itemDetailModel.get("show")) {
        var detailOffsetCenter = itemDetailModel.get("offsetCenter");
        var detailX = posInfo.cx + parsePercent$1(detailOffsetCenter[0], posInfo.r);
        var detailY = posInfo.cy + parsePercent$1(detailOffsetCenter[1], posInfo.r);
        var width = parsePercent$1(itemDetailModel.get("width"), posInfo.r);
        var height = parsePercent$1(itemDetailModel.get("height"), posInfo.r);
        var detailColor = seriesModel.get(["progress", "show"]) ? data.getItemVisual(idx, "style").fill : autoColor;
        var labelEl = newDetailEls[idx];
        var formatter_1 = itemDetailModel.get("formatter");
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle$1(itemDetailModel, {
            x: detailX,
            y: detailY,
            text: formatLabel(value, formatter_1),
            width: isNaN(width) ? null : width,
            height: isNaN(height) ? null : height,
            align: "center",
            verticalAlign: "middle"
          }, {
            inheritColor: detailColor
          })
        });
        setLabelValueAnimation(labelEl, {
          normal: itemDetailModel
        }, value, function(value2) {
          return formatLabel(value2, formatter_1);
        });
        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {
          getFormattedLabel: function(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);
          }
        });
        itemGroup.add(labelEl);
      }
      contentGroup.add(itemGroup);
    });
    this.group.add(contentGroup);
    this._titleEls = newTitleEls;
    this._detailEls = newDetailEls;
  };
  GaugeView2.type = "gauge";
  return GaugeView2;
}(ChartView$1);
var GaugeView$1 = GaugeView;
var GaugeSeriesModel = function(_super) {
  __extends(GaugeSeriesModel2, _super);
  function GaugeSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GaugeSeriesModel2.type;
    _this.visualStyleAccessPath = "itemStyle";
    return _this;
  }
  GaugeSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, ["value"]);
  };
  GaugeSeriesModel2.type = "series.gauge";
  GaugeSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    center: ["50%", "50%"],
    legendHoverLink: true,
    radius: "75%",
    startAngle: 225,
    endAngle: -45,
    clockwise: true,
    min: 0,
    max: 100,
    splitNumber: 10,
    axisLine: {
      show: true,
      roundCap: false,
      lineStyle: {
        color: [[1, "#E6EBF8"]],
        width: 10
      }
    },
    progress: {
      show: false,
      overlap: true,
      width: 10,
      roundCap: false,
      clip: true
    },
    splitLine: {
      show: true,
      length: 10,
      distance: 10,
      lineStyle: {
        color: "#63677A",
        width: 3,
        type: "solid"
      }
    },
    axisTick: {
      show: true,
      splitNumber: 5,
      length: 6,
      distance: 10,
      lineStyle: {
        color: "#63677A",
        width: 1,
        type: "solid"
      }
    },
    axisLabel: {
      show: true,
      distance: 15,
      color: "#464646",
      fontSize: 12
    },
    pointer: {
      icon: null,
      offsetCenter: [0, 0],
      show: true,
      showAbove: true,
      length: "60%",
      width: 6,
      keepAspect: false
    },
    anchor: {
      show: false,
      showAbove: false,
      size: 6,
      icon: "circle",
      offsetCenter: [0, 0],
      keepAspect: false,
      itemStyle: {
        color: "#fff",
        borderWidth: 0,
        borderColor: "#5470c6"
      }
    },
    title: {
      show: true,
      offsetCenter: [0, "20%"],
      color: "#464646",
      fontSize: 16,
      valueAnimation: false
    },
    detail: {
      show: true,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      borderColor: "#ccc",
      width: 100,
      height: null,
      padding: [5, 10],
      offsetCenter: [0, "40%"],
      color: "#464646",
      fontSize: 30,
      fontWeight: "bold",
      lineHeight: 30,
      valueAnimation: false
    }
  };
  return GaugeSeriesModel2;
}(SeriesModel$1);
var GaugeSeriesModel$1 = GaugeSeriesModel;
function install$U(registers) {
  registers.registerChartView(GaugeView$1);
  registers.registerSeriesModel(GaugeSeriesModel$1);
}
var opacityAccessPath$1 = ["itemStyle", "opacity"];
var FunnelPiece = function(_super) {
  __extends(FunnelPiece2, _super);
  function FunnelPiece2(data, idx) {
    var _this = _super.call(this) || this;
    var polygon = _this;
    var labelLine = new Polyline$3();
    var text = new ZRText$1();
    polygon.setTextContent(text);
    _this.setTextGuideLine(labelLine);
    _this.updateData(data, idx, true);
    return _this;
  }
  FunnelPiece2.prototype.updateData = function(data, idx, firstCreate) {
    var polygon = this;
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout2 = data.getItemLayout(idx);
    var emphasisModel = itemModel.getModel("emphasis");
    var opacity = itemModel.get(opacityAccessPath$1);
    opacity = opacity == null ? 1 : opacity;
    if (!firstCreate) {
      saveOldStyle(polygon);
    }
    polygon.useStyle(data.getItemVisual(idx, "style"));
    polygon.style.lineJoin = "round";
    if (firstCreate) {
      polygon.setShape({
        points: layout2.points
      });
      polygon.style.opacity = 0;
      initProps(polygon, {
        style: {
          opacity
        }
      }, seriesModel, idx);
    } else {
      updateProps$1(polygon, {
        style: {
          opacity
        },
        shape: {
          points: layout2.points
        }
      }, seriesModel, idx);
    }
    setStatesStylesFromModel(polygon, itemModel);
    this._updateLabel(data, idx);
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  FunnelPiece2.prototype._updateLabel = function(data, idx) {
    var polygon = this;
    var labelLine = this.getTextGuideLine();
    var labelText = polygon.getTextContent();
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout2 = data.getItemLayout(idx);
    var labelLayout2 = layout2.label;
    var style = data.getItemVisual(idx, "style");
    var visualColor = style.fill;
    setLabelStyle(labelText, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      defaultOpacity: style.opacity,
      defaultText: data.getName(idx)
    }, {
      normal: {
        align: labelLayout2.textAlign,
        verticalAlign: labelLayout2.verticalAlign
      }
    });
    polygon.setTextConfig({
      local: true,
      inside: !!labelLayout2.inside,
      insideStroke: visualColor,
      outsideFill: visualColor
    });
    var linePoints = labelLayout2.linePoints;
    labelLine.setShape({
      points: linePoints
    });
    polygon.textGuideLineConfig = {
      anchor: linePoints ? new Point$1(linePoints[0][0], linePoints[0][1]) : null
    };
    updateProps$1(labelText, {
      style: {
        x: labelLayout2.x,
        y: labelLayout2.y
      }
    }, seriesModel, idx);
    labelText.attr({
      rotation: labelLayout2.rotation,
      originX: labelLayout2.x,
      originY: labelLayout2.y,
      z2: 10
    });
    setLabelLineStyle(polygon, getLabelLineStatesModels(itemModel), {
      stroke: visualColor
    });
  };
  return FunnelPiece2;
}(Polygon$1);
var FunnelView = function(_super) {
  __extends(FunnelView2, _super);
  function FunnelView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = FunnelView2.type;
    _this.ignoreLabelLineUpdate = true;
    return _this;
  }
  FunnelView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    data.diff(oldData).add(function(idx) {
      var funnelPiece = new FunnelPiece(data, idx);
      data.setItemGraphicEl(idx, funnelPiece);
      group.add(funnelPiece);
    }).update(function(newIdx, oldIdx) {
      var piece = oldData.getItemGraphicEl(oldIdx);
      piece.updateData(data, newIdx);
      group.add(piece);
      data.setItemGraphicEl(newIdx, piece);
    }).remove(function(idx) {
      var piece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piece, seriesModel, idx);
    }).execute();
    this._data = data;
  };
  FunnelView2.prototype.remove = function() {
    this.group.removeAll();
    this._data = null;
  };
  FunnelView2.prototype.dispose = function() {
  };
  FunnelView2.type = "funnel";
  return FunnelView2;
}(ChartView$1);
var FunnelView$1 = FunnelView;
var FunnelSeriesModel = function(_super) {
  __extends(FunnelSeriesModel2, _super);
  function FunnelSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = FunnelSeriesModel2.type;
    return _this;
  }
  FunnelSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
    this._defaultLabelLine(option);
  };
  FunnelSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
    });
  };
  FunnelSeriesModel2.prototype._defaultLabelLine = function(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    var labelLineNormalOpt = option.labelLine;
    var labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  };
  FunnelSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var data = this.getData();
    var params = _super.prototype.getDataParams.call(this, dataIndex);
    var valueDim = data.mapDimension("value");
    var sum2 = data.getSum(valueDim);
    params.percent = !sum2 ? 0 : +(data.get(valueDim, dataIndex) / sum2 * 100).toFixed(2);
    params.$vars.push("percent");
    return params;
  };
  FunnelSeriesModel2.type = "series.funnel";
  FunnelSeriesModel2.defaultOption = {
    z: 2,
    legendHoverLink: true,
    colorBy: "data",
    left: 80,
    top: 60,
    right: 80,
    bottom: 60,
    minSize: "0%",
    maxSize: "100%",
    sort: "descending",
    orient: "vertical",
    gap: 0,
    funnelAlign: "center",
    label: {
      show: true,
      position: "outer"
    },
    labelLine: {
      show: true,
      length: 20,
      lineStyle: {
        width: 1
      }
    },
    itemStyle: {
      borderColor: "#fff",
      borderWidth: 1
    },
    emphasis: {
      label: {
        show: true
      }
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  };
  return FunnelSeriesModel2;
}(SeriesModel$1);
var FunnelSeriesModel$1 = FunnelSeriesModel;
function getViewRect$2(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function getSortedIndices(data, sort2) {
  var valueDim = data.mapDimension("value");
  var valueArr = data.mapArray(valueDim, function(val) {
    return val;
  });
  var indices = [];
  var isAscending = sort2 === "ascending";
  for (var i = 0, len2 = data.count(); i < len2; i++) {
    indices[i] = i;
  }
  if (isFunction$1(sort2)) {
    indices.sort(sort2);
  } else if (sort2 !== "none") {
    indices.sort(function(a, b) {
      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
    });
  }
  return indices;
}
function labelLayout(data) {
  var seriesModel = data.hostModel;
  var orient = seriesModel.get("orient");
  data.each(function(idx) {
    var itemModel = data.getItemModel(idx);
    var labelModel = itemModel.getModel("label");
    var labelPosition = labelModel.get("position");
    var labelLineModel = itemModel.getModel("labelLine");
    var layout2 = data.getItemLayout(idx);
    var points2 = layout2.points;
    var isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
    var textAlign;
    var textX;
    var textY;
    var linePoints;
    if (isLabelInside) {
      if (labelPosition === "insideLeft") {
        textX = (points2[0][0] + points2[3][0]) / 2 + 5;
        textY = (points2[0][1] + points2[3][1]) / 2;
        textAlign = "left";
      } else if (labelPosition === "insideRight") {
        textX = (points2[1][0] + points2[2][0]) / 2 - 5;
        textY = (points2[1][1] + points2[2][1]) / 2;
        textAlign = "right";
      } else {
        textX = (points2[0][0] + points2[1][0] + points2[2][0] + points2[3][0]) / 4;
        textY = (points2[0][1] + points2[1][1] + points2[2][1] + points2[3][1]) / 4;
        textAlign = "center";
      }
      linePoints = [[textX, textY], [textX, textY]];
    } else {
      var x1 = void 0;
      var y1 = void 0;
      var x2 = void 0;
      var y2 = void 0;
      var labelLineLen = labelLineModel.get("length");
      if (labelPosition === "left") {
        x1 = (points2[3][0] + points2[0][0]) / 2;
        y1 = (points2[3][1] + points2[0][1]) / 2;
        x2 = x1 - labelLineLen;
        textX = x2 - 5;
        textAlign = "right";
      } else if (labelPosition === "right") {
        x1 = (points2[1][0] + points2[2][0]) / 2;
        y1 = (points2[1][1] + points2[2][1]) / 2;
        x2 = x1 + labelLineLen;
        textX = x2 + 5;
        textAlign = "left";
      } else if (labelPosition === "top") {
        x1 = (points2[3][0] + points2[0][0]) / 2;
        y1 = (points2[3][1] + points2[0][1]) / 2;
        y2 = y1 - labelLineLen;
        textY = y2 - 5;
        textAlign = "center";
      } else if (labelPosition === "bottom") {
        x1 = (points2[1][0] + points2[2][0]) / 2;
        y1 = (points2[1][1] + points2[2][1]) / 2;
        y2 = y1 + labelLineLen;
        textY = y2 + 5;
        textAlign = "center";
      } else if (labelPosition === "rightTop") {
        x1 = orient === "horizontal" ? points2[3][0] : points2[1][0];
        y1 = orient === "horizontal" ? points2[3][1] : points2[1][1];
        if (orient === "horizontal") {
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "top";
        }
      } else if (labelPosition === "rightBottom") {
        x1 = points2[2][0];
        y1 = points2[2][1];
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "bottom";
        }
      } else if (labelPosition === "leftTop") {
        x1 = points2[0][0];
        y1 = orient === "horizontal" ? points2[0][1] : points2[1][1];
        if (orient === "horizontal") {
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else {
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        }
      } else if (labelPosition === "leftBottom") {
        x1 = orient === "horizontal" ? points2[1][0] : points2[3][0];
        y1 = orient === "horizontal" ? points2[1][1] : points2[2][1];
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        }
      } else {
        x1 = (points2[1][0] + points2[2][0]) / 2;
        y1 = (points2[1][1] + points2[2][1]) / 2;
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "left";
        }
      }
      if (orient === "horizontal") {
        x2 = x1;
        textX = x2;
      } else {
        y2 = y1;
        textY = y2;
      }
      linePoints = [[x1, y1], [x2, y2]];
    }
    layout2.label = {
      linePoints,
      x: textX,
      y: textY,
      verticalAlign: "middle",
      textAlign,
      inside: isLabelInside
    };
  });
}
function funnelLayout(ecModel, api) {
  ecModel.eachSeriesByType("funnel", function(seriesModel) {
    var data = seriesModel.getData();
    var valueDim = data.mapDimension("value");
    var sort2 = seriesModel.get("sort");
    var viewRect2 = getViewRect$2(seriesModel, api);
    var orient = seriesModel.get("orient");
    var viewWidth = viewRect2.width;
    var viewHeight = viewRect2.height;
    var indices = getSortedIndices(data, sort2);
    var x = viewRect2.x;
    var y = viewRect2.y;
    var sizeExtent = orient === "horizontal" ? [parsePercent$1(seriesModel.get("minSize"), viewHeight), parsePercent$1(seriesModel.get("maxSize"), viewHeight)] : [parsePercent$1(seriesModel.get("minSize"), viewWidth), parsePercent$1(seriesModel.get("maxSize"), viewWidth)];
    var dataExtent = data.getDataExtent(valueDim);
    var min3 = seriesModel.get("min");
    var max3 = seriesModel.get("max");
    if (min3 == null) {
      min3 = Math.min(dataExtent[0], 0);
    }
    if (max3 == null) {
      max3 = dataExtent[1];
    }
    var funnelAlign = seriesModel.get("funnelAlign");
    var gap = seriesModel.get("gap");
    var viewSize = orient === "horizontal" ? viewWidth : viewHeight;
    var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();
    var getLinePoints = function(idx2, offset) {
      if (orient === "horizontal") {
        var val_1 = data.get(valueDim, idx2) || 0;
        var itemHeight = linearMap$2(val_1, [min3, max3], sizeExtent, true);
        var y0 = void 0;
        switch (funnelAlign) {
          case "top":
            y0 = y;
            break;
          case "center":
            y0 = y + (viewHeight - itemHeight) / 2;
            break;
          case "bottom":
            y0 = y + (viewHeight - itemHeight);
            break;
        }
        return [[offset, y0], [offset, y0 + itemHeight]];
      }
      var val = data.get(valueDim, idx2) || 0;
      var itemWidth = linearMap$2(val, [min3, max3], sizeExtent, true);
      var x0;
      switch (funnelAlign) {
        case "left":
          x0 = x;
          break;
        case "center":
          x0 = x + (viewWidth - itemWidth) / 2;
          break;
        case "right":
          x0 = x + viewWidth - itemWidth;
          break;
      }
      return [[x0, offset], [x0 + itemWidth, offset]];
    };
    if (sort2 === "ascending") {
      itemSize = -itemSize;
      gap = -gap;
      if (orient === "horizontal") {
        x += viewWidth;
      } else {
        y += viewHeight;
      }
      indices = indices.reverse();
    }
    for (var i = 0; i < indices.length; i++) {
      var idx = indices[i];
      var nextIdx = indices[i + 1];
      var itemModel = data.getItemModel(idx);
      if (orient === "horizontal") {
        var width = itemModel.get(["itemStyle", "width"]);
        if (width == null) {
          width = itemSize;
        } else {
          width = parsePercent$1(width, viewWidth);
          if (sort2 === "ascending") {
            width = -width;
          }
        }
        var start2 = getLinePoints(idx, x);
        var end2 = getLinePoints(nextIdx, x + width);
        x += width + gap;
        data.setItemLayout(idx, {
          points: start2.concat(end2.slice().reverse())
        });
      } else {
        var height = itemModel.get(["itemStyle", "height"]);
        if (height == null) {
          height = itemSize;
        } else {
          height = parsePercent$1(height, viewHeight);
          if (sort2 === "ascending") {
            height = -height;
          }
        }
        var start2 = getLinePoints(idx, y);
        var end2 = getLinePoints(nextIdx, y + height);
        y += height + gap;
        data.setItemLayout(idx, {
          points: start2.concat(end2.slice().reverse())
        });
      }
    }
    labelLayout(data);
  });
}
function install$T(registers) {
  registers.registerChartView(FunnelView$1);
  registers.registerSeriesModel(FunnelSeriesModel$1);
  registers.registerLayout(funnelLayout);
  registers.registerProcessor(dataFilter$1("funnel"));
}
var DEFAULT_SMOOTH = 0.3;
var ParallelView$2 = function(_super) {
  __extends(ParallelView2, _super);
  function ParallelView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelView2.type;
    _this._dataGroup = new Group$4();
    _this._initialized = false;
    return _this;
  }
  ParallelView2.prototype.init = function() {
    this.group.add(this._dataGroup);
  };
  ParallelView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    this._progressiveEls = null;
    var dataGroup = this._dataGroup;
    var data = seriesModel.getData();
    var oldData = this._data;
    var coordSys = seriesModel.coordinateSystem;
    var dimensions = coordSys.dimensions;
    var seriesScope = makeSeriesScope(seriesModel);
    data.diff(oldData).add(add2).update(update).remove(remove).execute();
    function add2(newDataIndex) {
      var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
      updateElCommon(line, data, newDataIndex, seriesScope);
    }
    function update(newDataIndex, oldDataIndex) {
      var line = oldData.getItemGraphicEl(oldDataIndex);
      var points2 = createLinePoints(data, newDataIndex, dimensions, coordSys);
      data.setItemGraphicEl(newDataIndex, line);
      updateProps$1(line, {
        shape: {
          points: points2
        }
      }, seriesModel, newDataIndex);
      saveOldStyle(line);
      updateElCommon(line, data, newDataIndex, seriesScope);
    }
    function remove(oldDataIndex) {
      var line = oldData.getItemGraphicEl(oldDataIndex);
      dataGroup.remove(line);
    }
    if (!this._initialized) {
      this._initialized = true;
      var clipPath = createGridClipShape$2(coordSys, seriesModel, function() {
        setTimeout(function() {
          dataGroup.removeClipPath();
        });
      });
      dataGroup.setClipPath(clipPath);
    }
    this._data = data;
  };
  ParallelView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    this._initialized = true;
    this._data = null;
    this._dataGroup.removeAll();
  };
  ParallelView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    var dimensions = coordSys.dimensions;
    var seriesScope = makeSeriesScope(seriesModel);
    var progressiveEls = this._progressiveEls = [];
    for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
      var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
      line.incremental = true;
      updateElCommon(line, data, dataIndex, seriesScope);
      progressiveEls.push(line);
    }
  };
  ParallelView2.prototype.remove = function() {
    this._dataGroup && this._dataGroup.removeAll();
    this._data = null;
  };
  ParallelView2.type = "parallel";
  return ParallelView2;
}(ChartView$1);
function createGridClipShape$2(coordSys, seriesModel, cb) {
  var parallelModel = coordSys.model;
  var rect = coordSys.getRect();
  var rectEl = new Rect$3({
    shape: {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    }
  });
  var dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
  rectEl.setShape(dim, 0);
  initProps(rectEl, {
    shape: {
      width: rect.width,
      height: rect.height
    }
  }, seriesModel, cb);
  return rectEl;
}
function createLinePoints(data, dataIndex, dimensions, coordSys) {
  var points2 = [];
  for (var i = 0; i < dimensions.length; i++) {
    var dimName = dimensions[i];
    var value = data.get(data.mapDimension(dimName), dataIndex);
    if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
      points2.push(coordSys.dataToPoint(value, dimName));
    }
  }
  return points2;
}
function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
  var points2 = createLinePoints(data, dataIndex, dimensions, coordSys);
  var line = new Polyline$3({
    shape: {
      points: points2
    },
    z2: 10
  });
  dataGroup.add(line);
  data.setItemGraphicEl(dataIndex, line);
  return line;
}
function makeSeriesScope(seriesModel) {
  var smooth = seriesModel.get("smooth", true);
  smooth === true && (smooth = DEFAULT_SMOOTH);
  smooth = numericToNumber(smooth);
  eqNaN(smooth) && (smooth = 0);
  return {
    smooth
  };
}
function updateElCommon(el, data, dataIndex, seriesScope) {
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.fill = null;
  el.setShape("smooth", seriesScope.smooth);
  var itemModel = data.getItemModel(dataIndex);
  var emphasisModel = itemModel.getModel("emphasis");
  setStatesStylesFromModel(el, itemModel, "lineStyle");
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function isEmptyValue(val, axisType) {
  return axisType === "category" ? val == null : val == null || isNaN(val);
}
var ParallelView$3 = ParallelView$2;
var ParallelSeriesModel = function(_super) {
  __extends(ParallelSeriesModel2, _super);
  function ParallelSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelSeriesModel2.type;
    _this.visualStyleAccessPath = "lineStyle";
    _this.visualDrawType = "stroke";
    return _this;
  }
  ParallelSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: bind$1(makeDefaultEncode, null, this)
    });
  };
  ParallelSeriesModel2.prototype.getRawIndicesByActiveState = function(activeState) {
    var coordSys = this.coordinateSystem;
    var data = this.getData();
    var indices = [];
    coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
      if (activeState === theActiveState) {
        indices.push(data.getRawIndex(dataIndex));
      }
    });
    return indices;
  };
  ParallelSeriesModel2.type = "series.parallel";
  ParallelSeriesModel2.dependencies = ["parallel"];
  ParallelSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "parallel",
    parallelIndex: 0,
    label: {
      show: false
    },
    inactiveOpacity: 0.05,
    activeOpacity: 1,
    lineStyle: {
      width: 1,
      opacity: 0.45,
      type: "solid"
    },
    emphasis: {
      label: {
        show: false
      }
    },
    progressive: 500,
    smooth: false,
    animationEasing: "linear"
  };
  return ParallelSeriesModel2;
}(SeriesModel$1);
function makeDefaultEncode(seriesModel) {
  var parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
  if (!parallelModel) {
    return;
  }
  var encodeDefine = {};
  each$f(parallelModel.dimensions, function(axisDim) {
    var dataDimIndex = convertDimNameToNumber(axisDim);
    encodeDefine[axisDim] = dataDimIndex;
  });
  return encodeDefine;
}
function convertDimNameToNumber(dimName) {
  return +dimName.replace("dim", "");
}
var ParallelSeriesModel$1 = ParallelSeriesModel;
var opacityAccessPath = ["lineStyle", "opacity"];
var parallelVisual = {
  seriesType: "parallel",
  reset: function(seriesModel, ecModel) {
    var coordSys = seriesModel.coordinateSystem;
    var opacityMap = {
      normal: seriesModel.get(["lineStyle", "opacity"]),
      active: seriesModel.get("activeOpacity"),
      inactive: seriesModel.get("inactiveOpacity")
    };
    return {
      progress: function(params, data) {
        coordSys.eachActiveState(data, function(activeState, dataIndex) {
          var opacity = opacityMap[activeState];
          if (activeState === "normal" && data.hasItemOption) {
            var itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath, true);
            itemOpacity != null && (opacity = itemOpacity);
          }
          var existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
          existsStyle.opacity = opacity;
        }, params.start, params.end);
      }
    };
  }
};
var parallelVisual$1 = parallelVisual;
function parallelPreprocessor(option) {
  createParallelIfNeeded(option);
  mergeAxisOptionFromParallel(option);
}
function createParallelIfNeeded(option) {
  if (option.parallel) {
    return;
  }
  var hasParallelSeries = false;
  each$f(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "parallel") {
      hasParallelSeries = true;
    }
  });
  if (hasParallelSeries) {
    option.parallel = [{}];
  }
}
function mergeAxisOptionFromParallel(option) {
  var axes = normalizeToArray(option.parallelAxis);
  each$f(axes, function(axisOption) {
    if (!isObject$3(axisOption)) {
      return;
    }
    var parallelIndex = axisOption.parallelIndex || 0;
    var parallelOption = normalizeToArray(option.parallel)[parallelIndex];
    if (parallelOption && parallelOption.parallelAxisDefault) {
      merge(axisOption, parallelOption.parallelAxisDefault, false);
    }
  });
}
var CLICK_THRESHOLD = 5;
var ParallelView = function(_super) {
  __extends(ParallelView2, _super);
  function ParallelView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelView2.type;
    return _this;
  }
  ParallelView2.prototype.render = function(parallelModel, ecModel, api) {
    this._model = parallelModel;
    this._api = api;
    if (!this._handlers) {
      this._handlers = {};
      each$f(handlers$1, function(handler, eventName) {
        api.getZr().on(eventName, this._handlers[eventName] = bind$1(handler, this));
      }, this);
    }
    createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
  };
  ParallelView2.prototype.dispose = function(ecModel, api) {
    clear$1(this, "_throttledDispatchExpand");
    each$f(this._handlers, function(handler, eventName) {
      api.getZr().off(eventName, handler);
    });
    this._handlers = null;
  };
  ParallelView2.prototype._throttledDispatchExpand = function(opt) {
    this._dispatchExpand(opt);
  };
  ParallelView2.prototype._dispatchExpand = function(opt) {
    opt && this._api.dispatchAction(extend$1({
      type: "parallelAxisExpand"
    }, opt));
  };
  ParallelView2.type = "parallel";
  return ParallelView2;
}(ComponentView$1);
var handlers$1 = {
  mousedown: function(e2) {
    if (checkTrigger(this, "click")) {
      this._mouseDownPoint = [e2.offsetX, e2.offsetY];
    }
  },
  mouseup: function(e2) {
    var mouseDownPoint = this._mouseDownPoint;
    if (checkTrigger(this, "click") && mouseDownPoint) {
      var point = [e2.offsetX, e2.offsetY];
      var dist2 = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);
      if (dist2 > CLICK_THRESHOLD) {
        return;
      }
      var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
      result.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: result.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(e2) {
    if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
      return;
    }
    var model = this._model;
    var result = model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
    var behavior = result.behavior;
    behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
    this._throttledDispatchExpand(behavior === "none" ? null : {
      axisExpandWindow: result.axisExpandWindow,
      animation: behavior === "jump" ? null : {
        duration: 0
      }
    });
  }
};
function checkTrigger(view, triggerOn) {
  var model = view._model;
  return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
}
var ParallelView$1 = ParallelView;
var ParallelModel = function(_super) {
  __extends(ParallelModel2, _super);
  function ParallelModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelModel2.type;
    return _this;
  }
  ParallelModel2.prototype.init = function() {
    _super.prototype.init.apply(this, arguments);
    this.mergeOption({});
  };
  ParallelModel2.prototype.mergeOption = function(newOption) {
    var thisOption = this.option;
    newOption && merge(thisOption, newOption, true);
    this._initDimensions();
  };
  ParallelModel2.prototype.contains = function(model, ecModel) {
    var parallelIndex = model.get("parallelIndex");
    return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
  };
  ParallelModel2.prototype.setAxisExpand = function(opt) {
    each$f(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(name) {
      if (opt.hasOwnProperty(name)) {
        this.option[name] = opt[name];
      }
    }, this);
  };
  ParallelModel2.prototype._initDimensions = function() {
    var dimensions = this.dimensions = [];
    var parallelAxisIndex = this.parallelAxisIndex = [];
    var axisModels = filter(this.ecModel.queryComponents({
      mainType: "parallelAxis"
    }), function(axisModel) {
      return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
    }, this);
    each$f(axisModels, function(axisModel) {
      dimensions.push("dim" + axisModel.get("dim"));
      parallelAxisIndex.push(axisModel.componentIndex);
    });
  };
  ParallelModel2.type = "parallel";
  ParallelModel2.dependencies = ["parallelAxis"];
  ParallelModel2.layoutMode = "box";
  ParallelModel2.defaultOption = {
    z: 0,
    left: 80,
    top: 60,
    right: 80,
    bottom: 60,
    layout: "horizontal",
    axisExpandable: false,
    axisExpandCenter: null,
    axisExpandCount: 0,
    axisExpandWidth: 50,
    axisExpandRate: 17,
    axisExpandDebounce: 50,
    axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
    axisExpandTriggerOn: "click",
    parallelAxisDefault: null
  };
  return ParallelModel2;
}(ComponentModel$1);
var ParallelModel$1 = ParallelModel;
var ParallelAxis = function(_super) {
  __extends(ParallelAxis2, _super);
  function ParallelAxis2(dim, scale2, coordExtent, axisType, axisIndex) {
    var _this = _super.call(this, dim, scale2, coordExtent) || this;
    _this.type = axisType || "value";
    _this.axisIndex = axisIndex;
    return _this;
  }
  ParallelAxis2.prototype.isHorizontal = function() {
    return this.coordinateSystem.getModel().get("layout") !== "horizontal";
  };
  return ParallelAxis2;
}(Axis$1);
var ParallelAxis$1 = ParallelAxis;
function sliderMove(delta, handleEnds, extent3, handleIndex, minSpan, maxSpan) {
  delta = delta || 0;
  var extentSpan = extent3[1] - extent3[0];
  if (minSpan != null) {
    minSpan = restrict$1(minSpan, [0, extentSpan]);
  }
  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }
  if (handleIndex === "all") {
    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleSpan = restrict$1(handleSpan, [0, extentSpan]);
    minSpan = maxSpan = restrict$1(handleSpan, [minSpan, maxSpan]);
    handleIndex = 0;
  }
  handleEnds[0] = restrict$1(handleEnds[0], extent3);
  handleEnds[1] = restrict$1(handleEnds[1], extent3);
  var originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta;
  var extentMinSpan = minSpan || 0;
  var realExtent = extent3.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict$1(handleEnds[handleIndex], realExtent);
  var currDistSign;
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  }
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }
  return handleEnds;
}
function getSpanSign(handleEnds, handleIndex) {
  var dist2 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
  return {
    span: Math.abs(dist2),
    sign: dist2 > 0 ? -1 : dist2 < 0 ? 1 : handleIndex ? -1 : 1
  };
}
function restrict$1(value, extend2) {
  return Math.min(extend2[1] != null ? extend2[1] : Infinity, Math.max(extend2[0] != null ? extend2[0] : -Infinity, value));
}
var each$a = each$f;
var mathMin$3 = Math.min;
var mathMax$3 = Math.max;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var round = round$3;
var PI$3 = Math.PI;
var Parallel = function() {
  function Parallel2(parallelModel, ecModel, api) {
    this.type = "parallel";
    this._axesMap = createHashMap();
    this._axesLayout = {};
    this.dimensions = parallelModel.dimensions;
    this._model = parallelModel;
    this._init(parallelModel, ecModel, api);
  }
  Parallel2.prototype._init = function(parallelModel, ecModel, api) {
    var dimensions = parallelModel.dimensions;
    var parallelAxisIndex = parallelModel.parallelAxisIndex;
    each$a(dimensions, function(dim, idx) {
      var axisIndex = parallelAxisIndex[idx];
      var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      var axis = this._axesMap.set(dim, new ParallelAxis$1(dim, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisIndex));
      var isCategory2 = axis.type === "category";
      axis.onBand = isCategory2 && axisModel.get("boundaryGap");
      axis.inverse = axisModel.get("inverse");
      axisModel.axis = axis;
      axis.model = axisModel;
      axis.coordinateSystem = axisModel.coordinateSystem = this;
    }, this);
  };
  Parallel2.prototype.update = function(ecModel, api) {
    this._updateAxesFromSeries(this._model, ecModel);
  };
  Parallel2.prototype.containPoint = function(point) {
    var layoutInfo = this._makeLayoutInfo();
    var axisBase = layoutInfo.axisBase;
    var layoutBase = layoutInfo.layoutBase;
    var pixelDimIndex = layoutInfo.pixelDimIndex;
    var pAxis = point[1 - pixelDimIndex];
    var pLayout = point[pixelDimIndex];
    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
  };
  Parallel2.prototype.getModel = function() {
    return this._model;
  };
  Parallel2.prototype._updateAxesFromSeries = function(parallelModel, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      if (!parallelModel.contains(seriesModel, ecModel)) {
        return;
      }
      var data = seriesModel.getData();
      each$a(this.dimensions, function(dim) {
        var axis = this._axesMap.get(dim);
        axis.scale.unionExtentFromData(data, data.mapDimension(dim));
        niceScaleExtent(axis.scale, axis.model);
      }, this);
    }, this);
  };
  Parallel2.prototype.resize = function(parallelModel, api) {
    this._rect = getLayoutRect(parallelModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._layoutAxes();
  };
  Parallel2.prototype.getRect = function() {
    return this._rect;
  };
  Parallel2.prototype._makeLayoutInfo = function() {
    var parallelModel = this._model;
    var rect = this._rect;
    var xy = ["x", "y"];
    var wh = ["width", "height"];
    var layout2 = parallelModel.get("layout");
    var pixelDimIndex = layout2 === "horizontal" ? 0 : 1;
    var layoutLength = rect[wh[pixelDimIndex]];
    var layoutExtent = [0, layoutLength];
    var axisCount = this.dimensions.length;
    var axisExpandWidth = restrict(parallelModel.get("axisExpandWidth"), layoutExtent);
    var axisExpandCount = restrict(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
    var axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
    var axisExpandWindow = parallelModel.get("axisExpandWindow");
    var winSize;
    if (!axisExpandWindow) {
      winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
      var axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor(axisCount / 2);
      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    } else {
      winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    }
    var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
    axisCollapseWidth < 3 && (axisCollapseWidth = 0);
    var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];
    var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
    return {
      layout: layout2,
      pixelDimIndex,
      layoutBase: rect[xy[pixelDimIndex]],
      layoutLength,
      axisBase: rect[xy[1 - pixelDimIndex]],
      axisLength: rect[wh[1 - pixelDimIndex]],
      axisExpandable,
      axisExpandWidth,
      axisCollapseWidth,
      axisExpandWindow,
      axisCount,
      winInnerIndices,
      axisExpandWindow0Pos
    };
  };
  Parallel2.prototype._layoutAxes = function() {
    var rect = this._rect;
    var axes = this._axesMap;
    var dimensions = this.dimensions;
    var layoutInfo = this._makeLayoutInfo();
    var layout2 = layoutInfo.layout;
    axes.each(function(axis) {
      var axisExtent = [0, layoutInfo.axisLength];
      var idx = axis.inverse ? 1 : 0;
      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
    });
    each$a(dimensions, function(dim, idx) {
      var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
      var positionTable = {
        horizontal: {
          x: posInfo.position,
          y: layoutInfo.axisLength
        },
        vertical: {
          x: 0,
          y: posInfo.position
        }
      };
      var rotationTable = {
        horizontal: PI$3 / 2,
        vertical: 0
      };
      var position2 = [positionTable[layout2].x + rect.x, positionTable[layout2].y + rect.y];
      var rotation = rotationTable[layout2];
      var transform2 = create$2();
      rotate(transform2, transform2, rotation);
      translate(transform2, transform2, position2);
      this._axesLayout[dim] = {
        position: position2,
        rotation,
        transform: transform2,
        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
        axisLabelShow: posInfo.axisLabelShow,
        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
        tickDirection: 1,
        labelDirection: 1
      };
    }, this);
  };
  Parallel2.prototype.getAxis = function(dim) {
    return this._axesMap.get(dim);
  };
  Parallel2.prototype.dataToPoint = function(value, dim) {
    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
  };
  Parallel2.prototype.eachActiveState = function(data, callback, start2, end2) {
    start2 == null && (start2 = 0);
    end2 == null && (end2 = data.count());
    var axesMap = this._axesMap;
    var dimensions = this.dimensions;
    var dataDimensions = [];
    var axisModels = [];
    each$f(dimensions, function(axisDim) {
      dataDimensions.push(data.mapDimension(axisDim));
      axisModels.push(axesMap.get(axisDim).model);
    });
    var hasActiveSet = this.hasAxisBrushed();
    for (var dataIndex = start2; dataIndex < end2; dataIndex++) {
      var activeState = void 0;
      if (!hasActiveSet) {
        activeState = "normal";
      } else {
        activeState = "active";
        var values = data.getValues(dataDimensions, dataIndex);
        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
          var state = axisModels[j].getActiveState(values[j]);
          if (state === "inactive") {
            activeState = "inactive";
            break;
          }
        }
      }
      callback(activeState, dataIndex);
    }
  };
  Parallel2.prototype.hasAxisBrushed = function() {
    var dimensions = this.dimensions;
    var axesMap = this._axesMap;
    var hasActiveSet = false;
    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
      if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
        hasActiveSet = true;
      }
    }
    return hasActiveSet;
  };
  Parallel2.prototype.axisCoordToPoint = function(coord, dim) {
    var axisLayout = this._axesLayout[dim];
    return applyTransform([coord, 0], axisLayout.transform);
  };
  Parallel2.prototype.getAxisLayout = function(dim) {
    return clone$4(this._axesLayout[dim]);
  };
  Parallel2.prototype.getSlidedAxisExpandWindow = function(point) {
    var layoutInfo = this._makeLayoutInfo();
    var pixelDimIndex = layoutInfo.pixelDimIndex;
    var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
    var winSize = axisExpandWindow[1] - axisExpandWindow[0];
    var extent3 = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
    if (!this.containPoint(point)) {
      return {
        behavior: "none",
        axisExpandWindow
      };
    }
    var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
    var delta;
    var behavior = "slide";
    var axisCollapseWidth = layoutInfo.axisCollapseWidth;
    var triggerArea = this._model.get("axisExpandSlideTriggerArea");
    var useJump = triggerArea[0] != null;
    if (axisCollapseWidth) {
      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
        behavior = "jump";
        delta = pointCoord - winSize * triggerArea[2];
      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
        behavior = "jump";
        delta = pointCoord - winSize * (1 - triggerArea[2]);
      } else {
        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
      }
      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
      delta ? sliderMove(delta, axisExpandWindow, extent3, "all") : behavior = "none";
    } else {
      var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];
      var pos = extent3[1] * pointCoord / winSize2;
      axisExpandWindow = [mathMax$3(0, pos - winSize2 / 2)];
      axisExpandWindow[1] = mathMin$3(extent3[1], axisExpandWindow[0] + winSize2);
      axisExpandWindow[0] = axisExpandWindow[1] - winSize2;
    }
    return {
      axisExpandWindow,
      behavior
    };
  };
  return Parallel2;
}();
function restrict(len2, extent3) {
  return mathMin$3(mathMax$3(len2, extent3[0]), extent3[1]);
}
function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
  var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
  return {
    position: step * axisIndex,
    axisNameAvailableWidth: step,
    axisLabelShow: true
  };
}
function layoutAxisWithExpand(axisIndex, layoutInfo) {
  var layoutLength = layoutInfo.layoutLength;
  var axisExpandWidth = layoutInfo.axisExpandWidth;
  var axisCount = layoutInfo.axisCount;
  var axisCollapseWidth = layoutInfo.axisCollapseWidth;
  var winInnerIndices = layoutInfo.winInnerIndices;
  var position2;
  var axisNameAvailableWidth = axisCollapseWidth;
  var axisLabelShow = false;
  var nameTruncateMaxWidth;
  if (axisIndex < winInnerIndices[0]) {
    position2 = axisIndex * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  } else if (axisIndex <= winInnerIndices[1]) {
    position2 = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
    axisNameAvailableWidth = axisExpandWidth;
    axisLabelShow = true;
  } else {
    position2 = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  }
  return {
    position: position2,
    axisNameAvailableWidth,
    axisLabelShow,
    nameTruncateMaxWidth
  };
}
var Parallel$1 = Parallel;
function createParallelCoordSys(ecModel, api) {
  var coordSysList = [];
  ecModel.eachComponent("parallel", function(parallelModel, idx) {
    var coordSys = new Parallel$1(parallelModel, ecModel, api);
    coordSys.name = "parallel_" + idx;
    coordSys.resize(parallelModel, api);
    parallelModel.coordinateSystem = coordSys;
    coordSys.model = parallelModel;
    coordSysList.push(coordSys);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "parallel") {
      var parallelModel = seriesModel.getReferringComponents("parallel", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = parallelModel.coordinateSystem;
    }
  });
  return coordSysList;
}
var parallelCoordSysCreator = {
  create: createParallelCoordSys
};
var parallelCoordSysCreator$1 = parallelCoordSysCreator;
var ParallelAxisModel = function(_super) {
  __extends(ParallelAxisModel2, _super);
  function ParallelAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelAxisModel2.type;
    _this.activeIntervals = [];
    return _this;
  }
  ParallelAxisModel2.prototype.getAreaSelectStyle = function() {
    return makeStyleMapper([
      ["fill", "color"],
      ["lineWidth", "borderWidth"],
      ["stroke", "borderColor"],
      ["width", "width"],
      ["opacity", "opacity"]
    ])(this.getModel("areaSelectStyle"));
  };
  ParallelAxisModel2.prototype.setActiveIntervals = function(intervals) {
    var activeIntervals = this.activeIntervals = clone$4(intervals);
    if (activeIntervals) {
      for (var i = activeIntervals.length - 1; i >= 0; i--) {
        asc$2(activeIntervals[i]);
      }
    }
  };
  ParallelAxisModel2.prototype.getActiveState = function(value) {
    var activeIntervals = this.activeIntervals;
    if (!activeIntervals.length) {
      return "normal";
    }
    if (value == null || isNaN(+value)) {
      return "inactive";
    }
    if (activeIntervals.length === 1) {
      var interval = activeIntervals[0];
      if (interval[0] <= value && value <= interval[1]) {
        return "active";
      }
    } else {
      for (var i = 0, len2 = activeIntervals.length; i < len2; i++) {
        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
          return "active";
        }
      }
    }
    return "inactive";
  };
  return ParallelAxisModel2;
}(ComponentModel$1);
mixin(ParallelAxisModel, AxisModelCommonMixin);
var ParallelAxisModel$1 = ParallelAxisModel;
var BRUSH_PANEL_GLOBAL = true;
var mathMin$2 = Math.min;
var mathMax$2 = Math.max;
var mathPow = Math.pow;
var COVER_Z = 1e4;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = "globalPan";
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: true,
  brushMode: "single",
  removeOnClick: false
};
var baseUID = 0;
var BrushController = function(_super) {
  __extends(BrushController2, _super);
  function BrushController2(zr) {
    var _this = _super.call(this) || this;
    _this._track = [];
    _this._covers = [];
    _this._handlers = {};
    _this._zr = zr;
    _this.group = new Group$4();
    _this._uid = "brushController_" + baseUID++;
    each$f(pointerHandlers, function(handler, eventName) {
      this._handlers[eventName] = bind$1(handler, this);
    }, _this);
    return _this;
  }
  BrushController2.prototype.enableBrush = function(brushOption) {
    this._brushType && this._doDisableBrush();
    brushOption.brushType && this._doEnableBrush(brushOption);
    return this;
  };
  BrushController2.prototype._doEnableBrush = function(brushOption) {
    var zr = this._zr;
    if (!this._enableGlobalPan) {
      take(zr, MUTEX_RESOURCE_KEY, this._uid);
    }
    each$f(this._handlers, function(handler, eventName) {
      zr.on(eventName, handler);
    });
    this._brushType = brushOption.brushType;
    this._brushOption = merge(clone$4(DEFAULT_BRUSH_OPT), brushOption, true);
  };
  BrushController2.prototype._doDisableBrush = function() {
    var zr = this._zr;
    release(zr, MUTEX_RESOURCE_KEY, this._uid);
    each$f(this._handlers, function(handler, eventName) {
      zr.off(eventName, handler);
    });
    this._brushType = this._brushOption = null;
  };
  BrushController2.prototype.setPanels = function(panelOpts) {
    if (panelOpts && panelOpts.length) {
      var panels_1 = this._panels = {};
      each$f(panelOpts, function(panelOpts2) {
        panels_1[panelOpts2.panelId] = clone$4(panelOpts2);
      });
    } else {
      this._panels = null;
    }
    return this;
  };
  BrushController2.prototype.mount = function(opt) {
    opt = opt || {};
    this._enableGlobalPan = opt.enableGlobalPan;
    var thisGroup = this.group;
    this._zr.add(thisGroup);
    thisGroup.attr({
      x: opt.x || 0,
      y: opt.y || 0,
      rotation: opt.rotation || 0,
      scaleX: opt.scaleX || 1,
      scaleY: opt.scaleY || 1
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  };
  BrushController2.prototype.updateCovers = function(coverConfigList) {
    coverConfigList = map$1(coverConfigList, function(coverConfig) {
      return merge(clone$4(DEFAULT_BRUSH_OPT), coverConfig, true);
    });
    var tmpIdPrefix = "\0-brush-index-";
    var oldCovers = this._covers;
    var newCovers = this._covers = [];
    var controller = this;
    var creatingCover = this._creatingCover;
    new DataDiffer$1(oldCovers, coverConfigList, oldGetKey, getKey2).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
    return this;
    function getKey2(brushOption, index) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + "-" + brushOption.brushType;
    }
    function oldGetKey(cover, index) {
      return getKey2(cover.__brushOption, index);
    }
    function addOrUpdate(newIndex, oldIndex) {
      var newBrushInternal = coverConfigList[newIndex];
      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));
        updateCoverAfterCreation(controller, cover);
      }
    }
    function remove(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  };
  BrushController2.prototype.unmount = function() {
    this.enableBrush(false);
    clearCovers(this);
    this._zr.remove(this.group);
    return this;
  };
  BrushController2.prototype.dispose = function() {
    this.unmount();
    this.off();
  };
  return BrushController2;
}(Eventful$1);
function createCover(controller, brushOption) {
  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ$1(cover, brushOption);
  controller.group.add(cover);
  return cover;
}
function endCreating(controller, creatingCover) {
  var coverRenderer = getCoverRenderer(creatingCover);
  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ$1(creatingCover, creatingCover.__brushOption);
  }
  return creatingCover;
}
function updateCoverShape(controller, cover) {
  var brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}
function updateZ$1(cover, brushOption) {
  var z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function(el) {
    el.z = z;
    el.z2 = z;
  });
}
function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}
function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
}
function getPanelByPoint(controller, e2, localCursorPoint) {
  var panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  var panel;
  var transform2 = controller._transform;
  each$f(panels, function(pn) {
    pn.isTargetByCursor(e2, localCursorPoint, transform2) && (panel = pn);
  });
  return panel;
}
function getPanelByCover(controller, cover) {
  var panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  var panelId = cover.__brushOption.panelId;
  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;
}
function clearCovers(controller) {
  var covers = controller._covers;
  var originalLength = covers.length;
  each$f(covers, function(cover) {
    controller.group.remove(cover);
  }, controller);
  covers.length = 0;
  return !!originalLength;
}
function trigger(controller, opt) {
  var areas = map$1(controller._covers, function(cover) {
    var brushOption = cover.__brushOption;
    var range = clone$4(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range
    };
  });
  controller.trigger("brush", {
    areas,
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}
function shouldShowCover(controller) {
  var track = controller._track;
  if (!track.length) {
    return false;
  }
  var p22 = track[track.length - 1];
  var p12 = track[0];
  var dx = p22[0] - p12[0];
  var dy = p22[1] - p12[1];
  var dist2 = mathPow(dx * dx + dy * dy, 0.5);
  return dist2 > UNSELECT_THRESHOLD;
}
function getTrackEnds(track) {
  var tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}
function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {
  var cover = new Group$4();
  cover.add(new Rect$3({
    name: "main",
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: "move",
    drift: curry$1(driftRect, rectRangeConverter, controller, cover, ["n", "s", "w", "e"]),
    ondragend: curry$1(trigger, controller, {
      isEnd: true
    })
  }));
  each$f(edgeNameSequences, function(nameSequence) {
    cover.add(new Rect$3({
      name: nameSequence.join(""),
      style: {
        opacity: 0
      },
      draggable: true,
      silent: true,
      invisible: true,
      drift: curry$1(driftRect, rectRangeConverter, controller, cover, nameSequence),
      ondragend: curry$1(trigger, controller, {
        isEnd: true
      })
    }));
  });
  return cover;
}
function updateBaseRect(controller, cover, localRange, brushOption) {
  var lineWidth = brushOption.brushStyle.lineWidth || 0;
  var handleSize = mathMax$2(lineWidth, MIN_RESIZE_LINE_WIDTH);
  var x = localRange[0][0];
  var y = localRange[1][0];
  var xa = x - lineWidth / 2;
  var ya = y - lineWidth / 2;
  var x2 = localRange[0][1];
  var y2 = localRange[1][1];
  var x2a = x2 - handleSize + lineWidth / 2;
  var y2a = y2 - handleSize + lineWidth / 2;
  var width = x2 - x;
  var height = y2 - y;
  var widtha = width + lineWidth;
  var heighta = height + lineWidth;
  updateRectShape(controller, cover, "main", x, y, width, height);
  if (brushOption.transformable) {
    updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
  }
}
function updateCommon$1(controller, cover) {
  var brushOption = cover.__brushOption;
  var transformable = brushOption.transformable;
  var mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? "move" : "default"
  });
  each$f([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(nameSequence) {
    var el = cover.childOfName(nameSequence.join(""));
    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
    });
  });
}
function updateRectShape(controller, cover, name, x, y, w, h) {
  var el = cover.childOfName(name);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}
function makeStyle(brushOption) {
  return defaults({
    strokeNoScale: true
  }, brushOption.brushStyle);
}
function formatRectRange(x, y, x2, y2) {
  var min3 = [mathMin$2(x, x2), mathMin$2(y, y2)];
  var max3 = [mathMax$2(x, x2), mathMax$2(y, y2)];
  return [
    [min3[0], max3[0]],
    [min3[1], max3[1]]
  ];
}
function getTransform(controller) {
  return getTransform$1(controller.group);
}
function getGlobalDirection1(controller, localDirName) {
  var map2 = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  };
  var inverseMap = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  };
  var dir3 = transformDirection(map2[localDirName], getTransform(controller));
  return inverseMap[dir3];
}
function getGlobalDirection2(controller, localDirNameSeq) {
  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];
  (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
  return globalDir.join("");
}
function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
  var brushOption = cover.__brushOption;
  var rectRange = rectRangeConverter.toRectRange(brushOption.range);
  var localDelta = toLocalDelta(controller, dx, dy);
  each$f(dirNameSequence, function(dirName) {
    var ind = DIRECTION_MAP[dirName];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}
function driftPolygon(controller, cover, dx, dy) {
  var range = cover.__brushOption.range;
  var localDelta = toLocalDelta(controller, dx, dy);
  each$f(range, function(point) {
    point[0] += localDelta[0];
    point[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger(controller, {
    isEnd: false
  });
}
function toLocalDelta(controller, dx, dy) {
  var thisGroup = controller.group;
  var localD = thisGroup.transformCoordToLocal(dx, dy);
  var localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}
function clipByPanel(controller, cover, data) {
  var panel = getPanelByCover(controller, cover);
  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone$4(data);
}
function pointsToRect(points2) {
  var xmin = mathMin$2(points2[0][0], points2[1][0]);
  var ymin = mathMin$2(points2[0][1], points2[1][1]);
  var xmax = mathMax$2(points2[0][0], points2[1][0]);
  var ymax = mathMax$2(points2[0][1], points2[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}
function resetCursor(controller, e2, localCursorPoint) {
  if (!controller._brushType || isOutsideZrArea(controller, e2.offsetX, e2.offsetY)) {
    return;
  }
  var zr = controller._zr;
  var covers = controller._covers;
  var currPanel = getPanelByPoint(controller, e2, localCursorPoint);
  if (!controller._dragging) {
    for (var i = 0; i < covers.length; i++) {
      var brushOption = covers[i].__brushOption;
      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
        return;
      }
    }
  }
  currPanel && zr.setCursorStyle("crosshair");
}
function preventDefault(e2) {
  var rawE = e2.event;
  rawE.preventDefault && rawE.preventDefault();
}
function mainShapeContain(cover, x, y) {
  return cover.childOfName("main").contain(x, y);
}
function updateCoverByMouse(controller, e2, localCursorPoint, isEnd) {
  var creatingCover = controller._creatingCover;
  var panel = controller._creatingPanel;
  var thisBrushOption = controller._brushOption;
  var eventParams;
  controller._track.push(localCursorPoint.slice());
  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === "single" && clearCovers(controller);
      var brushOption = clone$4(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);
      controller._covers.push(creatingCover);
    }
    if (creatingCover) {
      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      var coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }
      updateCoverShape(controller, creatingCover);
      eventParams = {
        isEnd
      };
    }
  } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
    if (getPanelByPoint(controller, e2, localCursorPoint) && clearCovers(controller)) {
      eventParams = {
        isEnd,
        removeOnClick: true
      };
    }
  }
  return eventParams;
}
function determineBrushType(brushType, panel) {
  if (brushType === "auto") {
    return panel.defaultBrushType;
  }
  return brushType;
}
var pointerHandlers = {
  mousedown: function(e2) {
    if (this._dragging) {
      handleDragEnd(this, e2);
    } else if (!e2.target || !e2.target.draggable) {
      preventDefault(e2);
      var localCursorPoint = this.group.transformCoordToLocal(e2.offsetX, e2.offsetY);
      this._creatingCover = null;
      var panel = this._creatingPanel = getPanelByPoint(this, e2, localCursorPoint);
      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function(e2) {
    var x = e2.offsetX;
    var y = e2.offsetY;
    var localCursorPoint = this.group.transformCoordToLocal(x, y);
    resetCursor(this, e2, localCursorPoint);
    if (this._dragging) {
      preventDefault(e2);
      var eventParams = updateCoverByMouse(this, e2, localCursorPoint, false);
      eventParams && trigger(this, eventParams);
    }
  },
  mouseup: function(e2) {
    handleDragEnd(this, e2);
  }
};
function handleDragEnd(controller, e2) {
  if (controller._dragging) {
    preventDefault(e2);
    var x = e2.offsetX;
    var y = e2.offsetY;
    var localCursorPoint = controller.group.transformCoordToLocal(x, y);
    var eventParams = updateCoverByMouse(controller, e2, localCursorPoint, true);
    controller._dragging = false;
    controller._track = [];
    controller._creatingCover = null;
    eventParams && trigger(controller, eventParams);
  }
}
function isOutsideZrArea(controller, x, y) {
  var zr = controller._zr;
  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
}
var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function(controller, brushOption) {
      function returnInput(range) {
        return range;
      }
      return createBaseRectCover({
        toRectRange: returnInput,
        fromRectRange: returnInput
      }, controller, brushOption, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(localTrack) {
      var ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function(controller, brushOption) {
      var cover = new Group$4();
      cover.add(new Polyline$3({
        name: "main",
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function(localTrack) {
      return localTrack;
    },
    endCreating: function(controller, cover) {
      cover.remove(cover.childAt(0));
      cover.add(new Polygon$1({
        name: "main",
        draggable: true,
        drift: curry$1(driftPolygon, controller, cover),
        ondragend: curry$1(trigger, controller, {
          isEnd: true
        })
      }));
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  }
};
function getLineRenderer(xyIndex) {
  return {
    createCover: function(controller, brushOption) {
      return createBaseRectCover({
        toRectRange: function(range) {
          var rectRange = [range, [0, 100]];
          xyIndex && rectRange.reverse();
          return rectRange;
        },
        fromRectRange: function(rectRange) {
          return rectRange[xyIndex];
        }
      }, controller, brushOption, [[["w"], ["e"]], [["n"], ["s"]]][xyIndex]);
    },
    getCreatingRange: function(localTrack) {
      var ends = getTrackEnds(localTrack);
      var min3 = mathMin$2(ends[0][xyIndex], ends[1][xyIndex]);
      var max3 = mathMax$2(ends[0][xyIndex], ends[1][xyIndex]);
      return [min3, max3];
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      var otherExtent;
      var panel = getPanelByCover(controller, cover);
      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);
      } else {
        var zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }
      var rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  };
}
var BrushController$1 = BrushController;
function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function(localPoints) {
    return clipPointsByRect(localPoints, rect);
  };
}
function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function(xyIndex) {
    var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    var brushWidth = idx ? rect.width : rect.height;
    var base2 = idx ? rect.x : rect.y;
    return [base2, base2 + (brushWidth || 0)];
  };
}
function makeRectIsTargetByCursor(rect, api, targetModel) {
  var boundingRect = normalizeRect(rect);
  return function(e2, localCursorPoint) {
    return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e2, api, targetModel);
  };
}
function normalizeRect(rect) {
  return BoundingRect$1.create(rect);
}
var elementList$1 = ["axisLine", "axisTickLabel", "axisName"];
var ParallelAxisView = function(_super) {
  __extends(ParallelAxisView2, _super);
  function ParallelAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ParallelAxisView2.type;
    return _this;
  }
  ParallelAxisView2.prototype.init = function(ecModel, api) {
    _super.prototype.init.apply(this, arguments);
    (this._brushController = new BrushController$1(api.getZr())).on("brush", bind$1(this._onBrush, this));
  };
  ParallelAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
      return;
    }
    this.axisModel = axisModel;
    this.api = api;
    this.group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$4();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    var coordSysModel = getCoordSysModel(axisModel, ecModel);
    var coordSys = coordSysModel.coordinateSystem;
    var areaSelectStyle = axisModel.getAreaSelectStyle();
    var areaWidth = areaSelectStyle.width;
    var dim = axisModel.axis.dim;
    var axisLayout = coordSys.getAxisLayout(dim);
    var builderOpt = extend$1({
      strokeContainThreshold: areaWidth
    }, axisLayout);
    var axisBuilder = new AxisBuilder$1(axisModel, builderOpt);
    each$f(elementList$1, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
  };
  ParallelAxisView2.prototype._refreshBrushController = function(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
    var extent3 = axisModel.axis.getExtent();
    var extentLen = extent3[1] - extent3[0];
    var extra = Math.min(30, Math.abs(extentLen) * 0.1);
    var rect = BoundingRect$1.create({
      x: extent3[0],
      y: -areaWidth / 2,
      width: extentLen,
      height: areaWidth
    });
    rect.x -= extra;
    rect.width += 2 * extra;
    this._brushController.mount({
      enableGlobalPan: true,
      rotation: builderOpt.rotation,
      x: builderOpt.position[0],
      y: builderOpt.position[1]
    }).setPanels([{
      panelId: "pl",
      clipPath: makeRectPanelClipPath(rect),
      isTargetByCursor: makeRectIsTargetByCursor(rect, api, coordSysModel),
      getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)
    }]).enableBrush({
      brushType: "lineX",
      brushStyle: areaSelectStyle,
      removeOnClick: true
    }).updateCovers(getCoverInfoList(axisModel));
  };
  ParallelAxisView2.prototype._onBrush = function(eventParam) {
    var coverInfoList = eventParam.areas;
    var axisModel = this.axisModel;
    var axis = axisModel.axis;
    var intervals = map$1(coverInfoList, function(coverInfo) {
      return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
    });
    if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {
      this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: axisModel.id,
        intervals
      });
    }
  };
  ParallelAxisView2.prototype.dispose = function() {
    this._brushController.dispose();
  };
  ParallelAxisView2.type = "parallelAxis";
  return ParallelAxisView2;
}(ComponentView$1);
function fromAxisAreaSelect(axisModel, ecModel, payload) {
  return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({
    mainType: "parallelAxis",
    query: payload
  })[0] === axisModel;
}
function getCoverInfoList(axisModel) {
  var axis = axisModel.axis;
  return map$1(axisModel.activeIntervals, function(interval) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
    };
  });
}
function getCoordSysModel(axisModel, ecModel) {
  return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
}
var ParallelAxisView$1 = ParallelAxisView;
var actionInfo = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
};
function installParallelActions(registers) {
  registers.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "parallelAxis",
      query: payload
    }, function(parallelAxisModel) {
      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
    });
  });
  registers.registerAction("parallelAxisExpand", function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "parallel",
      query: payload
    }, function(parallelModel) {
      parallelModel.setAxisExpand(payload);
    });
  });
}
var defaultAxisOption = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: true,
  z: 10
};
function install$S(registers) {
  registers.registerComponentView(ParallelView$1);
  registers.registerComponentModel(ParallelModel$1);
  registers.registerCoordinateSystem("parallel", parallelCoordSysCreator$1);
  registers.registerPreprocessor(parallelPreprocessor);
  registers.registerComponentModel(ParallelAxisModel$1);
  registers.registerComponentView(ParallelAxisView$1);
  axisModelCreator(registers, "parallel", ParallelAxisModel$1, defaultAxisOption);
  installParallelActions(registers);
}
function install$R(registers) {
  use(install$S);
  registers.registerChartView(ParallelView$3);
  registers.registerSeriesModel(ParallelSeriesModel$1);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallelVisual$1);
}
var SankeyPathShape = function() {
  function SankeyPathShape2() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.cpx2 = 0;
    this.cpy2 = 0;
    this.extent = 0;
  }
  return SankeyPathShape2;
}();
var SankeyPath = function(_super) {
  __extends(SankeyPath2, _super);
  function SankeyPath2(opts) {
    return _super.call(this, opts) || this;
  }
  SankeyPath2.prototype.getDefaultShape = function() {
    return new SankeyPathShape();
  };
  SankeyPath2.prototype.buildPath = function(ctx, shape) {
    var extent3 = shape.extent;
    ctx.moveTo(shape.x1, shape.y1);
    ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
    if (shape.orient === "vertical") {
      ctx.lineTo(shape.x2 + extent3, shape.y2);
      ctx.bezierCurveTo(shape.cpx2 + extent3, shape.cpy2, shape.cpx1 + extent3, shape.cpy1, shape.x1 + extent3, shape.y1);
    } else {
      ctx.lineTo(shape.x2, shape.y2 + extent3);
      ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent3, shape.cpx1, shape.cpy1 + extent3, shape.x1, shape.y1 + extent3);
    }
    ctx.closePath();
  };
  SankeyPath2.prototype.highlight = function() {
    enterEmphasis(this);
  };
  SankeyPath2.prototype.downplay = function() {
    leaveEmphasis(this);
  };
  return SankeyPath2;
}(Path$1);
var SankeyView = function(_super) {
  __extends(SankeyView2, _super);
  function SankeyView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SankeyView2.type;
    _this._focusAdjacencyDisabled = false;
    return _this;
  }
  SankeyView2.prototype.render = function(seriesModel, ecModel, api) {
    var sankeyView = this;
    var graph = seriesModel.getGraph();
    var group = this.group;
    var layoutInfo = seriesModel.layoutInfo;
    var width = layoutInfo.width;
    var height = layoutInfo.height;
    var nodeData = seriesModel.getData();
    var edgeData = seriesModel.getData("edge");
    var orient = seriesModel.get("orient");
    this._model = seriesModel;
    group.removeAll();
    group.x = layoutInfo.x;
    group.y = layoutInfo.y;
    graph.eachEdge(function(edge) {
      var curve = new SankeyPath();
      var ecData = getECData(curve);
      ecData.dataIndex = edge.dataIndex;
      ecData.seriesIndex = seriesModel.seriesIndex;
      ecData.dataType = "edge";
      var edgeModel = edge.getModel();
      var lineStyleModel = edgeModel.getModel("lineStyle");
      var curvature = lineStyleModel.get("curveness");
      var n1Layout = edge.node1.getLayout();
      var node1Model = edge.node1.getModel();
      var dragX1 = node1Model.get("localX");
      var dragY1 = node1Model.get("localY");
      var n2Layout = edge.node2.getLayout();
      var node2Model = edge.node2.getModel();
      var dragX2 = node2Model.get("localX");
      var dragY2 = node2Model.get("localY");
      var edgeLayout = edge.getLayout();
      var x1;
      var y1;
      var x2;
      var y2;
      var cpx1;
      var cpy1;
      var cpx2;
      var cpy2;
      curve.shape.extent = Math.max(1, edgeLayout.dy);
      curve.shape.orient = orient;
      if (orient === "vertical") {
        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
        x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
        y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
        cpx1 = x1;
        cpy1 = y1 * (1 - curvature) + y2 * curvature;
        cpx2 = x2;
        cpy2 = y1 * curvature + y2 * (1 - curvature);
      } else {
        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
        x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
        y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
        cpx1 = x1 * (1 - curvature) + x2 * curvature;
        cpy1 = y1;
        cpx2 = x1 * curvature + x2 * (1 - curvature);
        cpy2 = y2;
      }
      curve.setShape({
        x1,
        y1,
        x2,
        y2,
        cpx1,
        cpy1,
        cpx2,
        cpy2
      });
      curve.useStyle(lineStyleModel.getItemStyle());
      switch (curve.style.fill) {
        case "source":
          curve.style.fill = edge.node1.getVisual("color");
          curve.style.decal = edge.node1.getVisual("style").decal;
          break;
        case "target":
          curve.style.fill = edge.node2.getVisual("color");
          curve.style.decal = edge.node2.getVisual("style").decal;
          break;
        case "gradient":
          var sourceColor = edge.node1.getVisual("color");
          var targetColor = edge.node2.getVisual("color");
          if (isString(sourceColor) && isString(targetColor)) {
            curve.style.fill = new LinearGradient$1(0, 0, +(orient === "horizontal"), +(orient === "vertical"), [{
              color: sourceColor,
              offset: 0
            }, {
              color: targetColor,
              offset: 1
            }]);
          }
      }
      var emphasisModel = edgeModel.getModel("emphasis");
      setStatesStylesFromModel(curve, edgeModel, "lineStyle", function(model) {
        return model.getItemStyle();
      });
      group.add(curve);
      edgeData.setItemGraphicEl(edge.dataIndex, curve);
      var focus = emphasisModel.get("focus");
      toggleHoverEmphasis(curve, focus === "adjacency" ? edge.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      getECData(curve).dataType = "edge";
    });
    graph.eachNode(function(node) {
      var layout2 = node.getLayout();
      var itemModel = node.getModel();
      var dragX = itemModel.get("localX");
      var dragY = itemModel.get("localY");
      var emphasisModel = itemModel.getModel("emphasis");
      var rect = new Rect$3({
        shape: {
          x: dragX != null ? dragX * width : layout2.x,
          y: dragY != null ? dragY * height : layout2.y,
          width: layout2.dx,
          height: layout2.dy
        },
        style: itemModel.getModel("itemStyle").getItemStyle(),
        z2: 10
      });
      setLabelStyle(rect, getLabelStatesModels(itemModel), {
        labelFetcher: seriesModel,
        labelDataIndex: node.dataIndex,
        defaultText: node.id
      });
      rect.disableLabelAnimation = true;
      rect.setStyle("fill", node.getVisual("color"));
      rect.setStyle("decal", node.getVisual("style").decal);
      setStatesStylesFromModel(rect, itemModel);
      group.add(rect);
      nodeData.setItemGraphicEl(node.dataIndex, rect);
      getECData(rect).dataType = "node";
      var focus = emphasisModel.get("focus");
      toggleHoverEmphasis(rect, focus === "adjacency" ? node.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    nodeData.eachItemGraphicEl(function(el, dataIndex) {
      var itemModel = nodeData.getItemModel(dataIndex);
      if (itemModel.get("draggable")) {
        el.drift = function(dx, dy) {
          sankeyView._focusAdjacencyDisabled = true;
          this.shape.x += dx;
          this.shape.y += dy;
          this.dirty();
          api.dispatchAction({
            type: "dragNode",
            seriesId: seriesModel.id,
            dataIndex: nodeData.getRawIndex(dataIndex),
            localX: this.shape.x / width,
            localY: this.shape.y / height
          });
        };
        el.ondragend = function() {
          sankeyView._focusAdjacencyDisabled = false;
        };
        el.draggable = true;
        el.cursor = "move";
      }
    });
    if (!this._data && seriesModel.isAnimationEnabled()) {
      group.setClipPath(createGridClipShape$1(group.getBoundingRect(), seriesModel, function() {
        group.removeClipPath();
      }));
    }
    this._data = seriesModel.getData();
  };
  SankeyView2.prototype.dispose = function() {
  };
  SankeyView2.type = "sankey";
  return SankeyView2;
}(ChartView$1);
function createGridClipShape$1(rect, seriesModel, cb) {
  var rectEl = new Rect$3({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  initProps(rectEl, {
    shape: {
      width: rect.width + 20
    }
  }, seriesModel, cb);
  return rectEl;
}
var SankeyView$1 = SankeyView;
var SankeySeriesModel = function(_super) {
  __extends(SankeySeriesModel2, _super);
  function SankeySeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SankeySeriesModel2.type;
    return _this;
  }
  SankeySeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var links = option.edges || option.links;
    var nodes = option.data || option.nodes;
    var levels = option.levels;
    this.levelModels = [];
    var levelModels = this.levelModels;
    for (var i = 0; i < levels.length; i++) {
      if (levels[i].depth != null && levels[i].depth >= 0) {
        levelModels[levels[i].depth] = new Model$1(levels[i], this, ecModel);
      }
    }
    if (nodes && links) {
      var graph = createGraphFromNodeEdge$1(nodes, links, this, true, beforeLink);
      return graph.data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        var seriesModel = model.parentModel;
        var layout2 = seriesModel.getData().getItemLayout(idx);
        if (layout2) {
          var nodeDepth = layout2.depth;
          var levelModel = seriesModel.levelModels[nodeDepth];
          if (levelModel) {
            model.parentModel = levelModel;
          }
        }
        return model;
      });
      edgeData.wrapMethod("getItemModel", function(model, idx) {
        var seriesModel = model.parentModel;
        var edge = seriesModel.getGraph().getEdgeByIndex(idx);
        var layout2 = edge.node1.getLayout();
        if (layout2) {
          var depth = layout2.depth;
          var levelModel = seriesModel.levelModels[depth];
          if (levelModel) {
            model.parentModel = levelModel;
          }
        }
        return model;
      });
    }
  };
  SankeySeriesModel2.prototype.setNodePosition = function(dataIndex, localPosition) {
    var nodes = this.option.data || this.option.nodes;
    var dataItem = nodes[dataIndex];
    dataItem.localX = localPosition[0];
    dataItem.localY = localPosition[1];
  };
  SankeySeriesModel2.prototype.getGraph = function() {
    return this.getData().graph;
  };
  SankeySeriesModel2.prototype.getEdgeData = function() {
    return this.getGraph().edgeData;
  };
  SankeySeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    function noValue(val) {
      return isNaN(val) || val == null;
    }
    if (dataType === "edge") {
      var params = this.getDataParams(dataIndex, dataType);
      var rawDataOpt = params.data;
      var edgeValue = params.value;
      var edgeName = rawDataOpt.source + " -- " + rawDataOpt.target;
      return createTooltipMarkup("nameValue", {
        name: edgeName,
        value: edgeValue,
        noValue: noValue(edgeValue)
      });
    } else {
      var node = this.getGraph().getNodeByIndex(dataIndex);
      var value = node.getLayout().value;
      var name_1 = this.getDataParams(dataIndex, dataType).data.name;
      return createTooltipMarkup("nameValue", {
        name: name_1 != null ? name_1 + "" : null,
        value,
        noValue: noValue(value)
      });
    }
  };
  SankeySeriesModel2.prototype.optionUpdated = function() {
  };
  SankeySeriesModel2.prototype.getDataParams = function(dataIndex, dataType) {
    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
    if (params.value == null && dataType === "node") {
      var node = this.getGraph().getNodeByIndex(dataIndex);
      var nodeValue = node.getLayout().value;
      params.value = nodeValue;
    }
    return params;
  };
  SankeySeriesModel2.type = "series.sankey";
  SankeySeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "view",
    left: "5%",
    top: "5%",
    right: "20%",
    bottom: "5%",
    orient: "horizontal",
    nodeWidth: 20,
    nodeGap: 8,
    draggable: true,
    layoutIterations: 32,
    label: {
      show: true,
      position: "right",
      fontSize: 12
    },
    levels: [],
    nodeAlign: "justify",
    lineStyle: {
      color: "#314656",
      opacity: 0.2,
      curveness: 0.5
    },
    emphasis: {
      label: {
        show: true
      },
      lineStyle: {
        opacity: 0.5
      }
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    },
    animationEasing: "linear",
    animationDuration: 1e3
  };
  return SankeySeriesModel2;
}(SeriesModel$1);
var SankeySeriesModel$1 = SankeySeriesModel;
function sankeyLayout(ecModel, api) {
  ecModel.eachSeriesByType("sankey", function(seriesModel) {
    var nodeWidth = seriesModel.get("nodeWidth");
    var nodeGap = seriesModel.get("nodeGap");
    var layoutInfo = getViewRect$1(seriesModel, api);
    seriesModel.layoutInfo = layoutInfo;
    var width = layoutInfo.width;
    var height = layoutInfo.height;
    var graph = seriesModel.getGraph();
    var nodes = graph.nodes;
    var edges = graph.edges;
    computeNodeValues(nodes);
    var filteredNodes = filter(nodes, function(node) {
      return node.getLayout().value === 0;
    });
    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get("layoutIterations");
    var orient = seriesModel.get("orient");
    var nodeAlign = seriesModel.get("nodeAlign");
    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
  });
}
function getViewRect$1(seriesModel, api) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  });
}
function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
  computeEdgeDepths(nodes, orient);
}
function computeNodeValues(nodes) {
  each$f(nodes, function(node) {
    var value1 = sum(node.outEdges, getEdgeValue);
    var value2 = sum(node.inEdges, getEdgeValue);
    var nodeRawValue = node.getValue() || 0;
    var value = Math.max(value1, value2, nodeRawValue);
    node.setLayout({
      value
    }, true);
  });
}
function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
  var remainEdges = [];
  var indegreeArr = [];
  var zeroIndegrees = [];
  var nextTargetNode = [];
  var x = 0;
  for (var i = 0; i < edges.length; i++) {
    remainEdges[i] = 1;
  }
  for (var i = 0; i < nodes.length; i++) {
    indegreeArr[i] = nodes[i].inEdges.length;
    if (indegreeArr[i] === 0) {
      zeroIndegrees.push(nodes[i]);
    }
  }
  var maxNodeDepth = -1;
  while (zeroIndegrees.length) {
    for (var idx = 0; idx < zeroIndegrees.length; idx++) {
      var node = zeroIndegrees[idx];
      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
      var isItemDepth = item.depth != null && item.depth >= 0;
      if (isItemDepth && item.depth > maxNodeDepth) {
        maxNodeDepth = item.depth;
      }
      node.setLayout({
        depth: isItemDepth ? item.depth : x
      }, true);
      orient === "vertical" ? node.setLayout({
        dy: nodeWidth
      }, true) : node.setLayout({
        dx: nodeWidth
      }, true);
      for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
        var edge = node.outEdges[edgeIdx];
        var indexEdge = edges.indexOf(edge);
        remainEdges[indexEdge] = 0;
        var targetNode = edge.node2;
        var nodeIndex = nodes.indexOf(targetNode);
        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
          nextTargetNode.push(targetNode);
        }
      }
    }
    ++x;
    zeroIndegrees = nextTargetNode;
    nextTargetNode = [];
  }
  for (var i = 0; i < remainEdges.length; i++) {
    if (remainEdges[i] === 1) {
      throw new Error("Sankey is a DAG, the original data has cycle!");
    }
  }
  var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;
  if (nodeAlign && nodeAlign !== "left") {
    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
  }
  var kx = orient === "vertical" ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
  scaleNodeBreadths(nodes, kx, orient);
}
function isNodeDepth(node) {
  var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
  return item.depth != null && item.depth >= 0;
}
function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
  if (nodeAlign === "right") {
    var nextSourceNode = [];
    var remainNodes = nodes;
    var nodeHeight = 0;
    while (remainNodes.length) {
      for (var i = 0; i < remainNodes.length; i++) {
        var node = remainNodes[i];
        node.setLayout({
          skNodeHeight: nodeHeight
        }, true);
        for (var j = 0; j < node.inEdges.length; j++) {
          var edge = node.inEdges[j];
          if (nextSourceNode.indexOf(edge.node1) < 0) {
            nextSourceNode.push(edge.node1);
          }
        }
      }
      remainNodes = nextSourceNode;
      nextSourceNode = [];
      ++nodeHeight;
    }
    each$f(nodes, function(node2) {
      if (!isNodeDepth(node2)) {
        node2.setLayout({
          depth: Math.max(0, maxDepth - node2.getLayout().skNodeHeight)
        }, true);
      }
    });
  } else if (nodeAlign === "justify") {
    moveSinksRight(nodes, maxDepth);
  }
}
function moveSinksRight(nodes, maxDepth) {
  each$f(nodes, function(node) {
    if (!isNodeDepth(node) && !node.outEdges.length) {
      node.setLayout({
        depth: maxDepth
      }, true);
    }
  });
}
function scaleNodeBreadths(nodes, kx, orient) {
  each$f(nodes, function(node) {
    var nodeDepth = node.getLayout().depth * kx;
    orient === "vertical" ? node.setLayout({
      y: nodeDepth
    }, true) : node.setLayout({
      x: nodeDepth
    }, true);
  });
}
function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
  var nodesByBreadth = prepareNodesByBreadth(nodes, orient);
  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
  for (var alpha = 1; iterations > 0; iterations--) {
    alpha *= 0.99;
    relaxRightToLeft(nodesByBreadth, alpha, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
    relaxLeftToRight(nodesByBreadth, alpha, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
  }
}
function prepareNodesByBreadth(nodes, orient) {
  var nodesByBreadth = [];
  var keyAttr = orient === "vertical" ? "y" : "x";
  var groupResult = groupData(nodes, function(node) {
    return node.getLayout()[keyAttr];
  });
  groupResult.keys.sort(function(a, b) {
    return a - b;
  });
  each$f(groupResult.keys, function(key) {
    nodesByBreadth.push(groupResult.buckets.get(key));
  });
  return nodesByBreadth;
}
function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
  var minKy = Infinity;
  each$f(nodesByBreadth, function(nodes) {
    var n = nodes.length;
    var sum2 = 0;
    each$f(nodes, function(node) {
      sum2 += node.getLayout().value;
    });
    var ky = orient === "vertical" ? (width - (n - 1) * nodeGap) / sum2 : (height - (n - 1) * nodeGap) / sum2;
    if (ky < minKy) {
      minKy = ky;
    }
  });
  each$f(nodesByBreadth, function(nodes) {
    each$f(nodes, function(node, i) {
      var nodeDy = node.getLayout().value * minKy;
      if (orient === "vertical") {
        node.setLayout({
          x: i
        }, true);
        node.setLayout({
          dx: nodeDy
        }, true);
      } else {
        node.setLayout({
          y: i
        }, true);
        node.setLayout({
          dy: nodeDy
        }, true);
      }
    });
  });
  each$f(edges, function(edge) {
    var edgeDy = +edge.getValue() * minKy;
    edge.setLayout({
      dy: edgeDy
    }, true);
  });
}
function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
  var keyAttr = orient === "vertical" ? "x" : "y";
  each$f(nodesByBreadth, function(nodes) {
    nodes.sort(function(a, b) {
      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
    });
    var nodeX;
    var node;
    var dy;
    var y0 = 0;
    var n = nodes.length;
    var nodeDyAttr = orient === "vertical" ? "dx" : "dy";
    for (var i = 0; i < n; i++) {
      node = nodes[i];
      dy = y0 - node.getLayout()[keyAttr];
      if (dy > 0) {
        nodeX = node.getLayout()[keyAttr] + dy;
        orient === "vertical" ? node.setLayout({
          x: nodeX
        }, true) : node.setLayout({
          y: nodeX
        }, true);
      }
      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
    }
    var viewWidth = orient === "vertical" ? width : height;
    dy = y0 - nodeGap - viewWidth;
    if (dy > 0) {
      nodeX = node.getLayout()[keyAttr] - dy;
      orient === "vertical" ? node.setLayout({
        x: nodeX
      }, true) : node.setLayout({
        y: nodeX
      }, true);
      y0 = nodeX;
      for (var i = n - 2; i >= 0; --i) {
        node = nodes[i];
        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;
        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] - dy;
          orient === "vertical" ? node.setLayout({
            x: nodeX
          }, true) : node.setLayout({
            y: nodeX
          }, true);
        }
        y0 = node.getLayout()[keyAttr];
      }
    }
  });
}
function relaxRightToLeft(nodesByBreadth, alpha, orient) {
  each$f(nodesByBreadth.slice().reverse(), function(nodes) {
    each$f(nodes, function(node) {
      if (node.outEdges.length) {
        var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);
        if (isNaN(y)) {
          var len2 = node.outEdges.length;
          y = len2 ? sum(node.outEdges, centerTarget, orient) / len2 : 0;
        }
        if (orient === "vertical") {
          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
          node.setLayout({
            x: nodeX
          }, true);
        } else {
          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
          node.setLayout({
            y: nodeY
          }, true);
        }
      }
    });
  });
}
function weightedTarget(edge, orient) {
  return center(edge.node2, orient) * edge.getValue();
}
function centerTarget(edge, orient) {
  return center(edge.node2, orient);
}
function weightedSource(edge, orient) {
  return center(edge.node1, orient) * edge.getValue();
}
function centerSource(edge, orient) {
  return center(edge.node1, orient);
}
function center(node, orient) {
  return orient === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
}
function getEdgeValue(edge) {
  return edge.getValue();
}
function sum(array, cb, orient) {
  var sum2 = 0;
  var len2 = array.length;
  var i = -1;
  while (++i < len2) {
    var value = +cb(array[i], orient);
    if (!isNaN(value)) {
      sum2 += value;
    }
  }
  return sum2;
}
function relaxLeftToRight(nodesByBreadth, alpha, orient) {
  each$f(nodesByBreadth, function(nodes) {
    each$f(nodes, function(node) {
      if (node.inEdges.length) {
        var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);
        if (isNaN(y)) {
          var len2 = node.inEdges.length;
          y = len2 ? sum(node.inEdges, centerSource, orient) / len2 : 0;
        }
        if (orient === "vertical") {
          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
          node.setLayout({
            x: nodeX
          }, true);
        } else {
          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
          node.setLayout({
            y: nodeY
          }, true);
        }
      }
    });
  });
}
function computeEdgeDepths(nodes, orient) {
  var keyAttr = orient === "vertical" ? "x" : "y";
  each$f(nodes, function(node) {
    node.outEdges.sort(function(a, b) {
      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
    });
    node.inEdges.sort(function(a, b) {
      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
    });
  });
  each$f(nodes, function(node) {
    var sy = 0;
    var ty = 0;
    each$f(node.outEdges, function(edge) {
      edge.setLayout({
        sy
      }, true);
      sy += edge.getLayout().dy;
    });
    each$f(node.inEdges, function(edge) {
      edge.setLayout({
        ty
      }, true);
      ty += edge.getLayout().dy;
    });
  });
}
function sankeyVisual(ecModel) {
  ecModel.eachSeriesByType("sankey", function(seriesModel) {
    var graph = seriesModel.getGraph();
    var nodes = graph.nodes;
    if (nodes.length) {
      var minValue_1 = Infinity;
      var maxValue_1 = -Infinity;
      each$f(nodes, function(node) {
        var nodeValue = node.getLayout().value;
        if (nodeValue < minValue_1) {
          minValue_1 = nodeValue;
        }
        if (nodeValue > maxValue_1) {
          maxValue_1 = nodeValue;
        }
      });
      each$f(nodes, function(node) {
        var mapping = new VisualMapping$1({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [minValue_1, maxValue_1],
          visual: seriesModel.get("color")
        });
        var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
        var customColor = node.getModel().get(["itemStyle", "color"]);
        if (customColor != null) {
          node.setVisual("color", customColor);
          node.setVisual("style", {
            fill: customColor
          });
        } else {
          node.setVisual("color", mapValueToColor);
          node.setVisual("style", {
            fill: mapValueToColor
          });
        }
      });
    }
  });
}
function install$Q(registers) {
  registers.registerChartView(SankeyView$1);
  registers.registerSeriesModel(SankeySeriesModel$1);
  registers.registerLayout(sankeyLayout);
  registers.registerVisual(sankeyVisual);
  registers.registerAction({
    type: "dragNode",
    event: "dragnode",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: payload
    }, function(seriesModel) {
      seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
    });
  });
}
var WhiskerBoxCommonMixin = function() {
  function WhiskerBoxCommonMixin2() {
  }
  WhiskerBoxCommonMixin2.prototype.getInitialData = function(option, ecModel) {
    var ordinalMeta;
    var xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
    var yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
    var xAxisType = xAxisModel.get("type");
    var yAxisType = yAxisModel.get("type");
    var addOrdinal;
    if (xAxisType === "category") {
      option.layout = "horizontal";
      ordinalMeta = xAxisModel.getOrdinalMeta();
      addOrdinal = true;
    } else if (yAxisType === "category") {
      option.layout = "vertical";
      ordinalMeta = yAxisModel.getOrdinalMeta();
      addOrdinal = true;
    } else {
      option.layout = option.layout || "horizontal";
    }
    var coordDims = ["x", "y"];
    var baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
    var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
    var otherAxisDim = coordDims[1 - baseAxisDimIndex];
    var axisModels = [xAxisModel, yAxisModel];
    var baseAxisType = axisModels[baseAxisDimIndex].get("type");
    var otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
    var data = option.data;
    if (data && addOrdinal) {
      var newOptionData_1 = [];
      each$f(data, function(item, index) {
        var newItem;
        if (isArray$1(item)) {
          newItem = item.slice();
          item.unshift(index);
        } else if (isArray$1(item.value)) {
          newItem = extend$1({}, item);
          newItem.value = newItem.value.slice();
          item.value.unshift(index);
        } else {
          newItem = item;
        }
        newOptionData_1.push(newItem);
      });
      option.data = newOptionData_1;
    }
    var defaultValueDimensions = this.defaultValueDimensions;
    var coordDimensions = [{
      name: baseAxisDim,
      type: getDimensionTypeByAxis(baseAxisType),
      ordinalMeta,
      otherDims: {
        tooltip: false,
        itemName: 0
      },
      dimsDef: ["base"]
    }, {
      name: otherAxisDim,
      type: getDimensionTypeByAxis(otherAxisType),
      dimsDef: defaultValueDimensions.slice()
    }];
    return createSeriesDataSimply(this, {
      coordDimensions,
      dimensionsCount: defaultValueDimensions.length + 1,
      encodeDefaulter: curry$1(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
    });
  };
  WhiskerBoxCommonMixin2.prototype.getBaseAxis = function() {
    var dim = this._baseAxisDim;
    return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
  };
  return WhiskerBoxCommonMixin2;
}();
var BoxplotSeriesModel = function(_super) {
  __extends(BoxplotSeriesModel2, _super);
  function BoxplotSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BoxplotSeriesModel2.type;
    _this.defaultValueDimensions = [{
      name: "min",
      defaultTooltip: true
    }, {
      name: "Q1",
      defaultTooltip: true
    }, {
      name: "median",
      defaultTooltip: true
    }, {
      name: "Q3",
      defaultTooltip: true
    }, {
      name: "max",
      defaultTooltip: true
    }];
    _this.visualDrawType = "stroke";
    return _this;
  }
  BoxplotSeriesModel2.type = "series.boxplot";
  BoxplotSeriesModel2.dependencies = ["xAxis", "yAxis", "grid"];
  BoxplotSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    layout: null,
    boxWidth: [7, 50],
    itemStyle: {
      color: "#fff",
      borderWidth: 1
    },
    emphasis: {
      scale: true,
      itemStyle: {
        borderWidth: 2,
        shadowBlur: 5,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
    },
    animationDuration: 800
  };
  return BoxplotSeriesModel2;
}(SeriesModel$1);
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, true);
var BoxplotSeriesModel$1 = BoxplotSeriesModel;
var BoxplotView = function(_super) {
  __extends(BoxplotView2, _super);
  function BoxplotView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BoxplotView2.type;
    return _this;
  }
  BoxplotView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var group = this.group;
    var oldData = this._data;
    if (!this._data) {
      group.removeAll();
    }
    var constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        var itemLayout = data.getItemLayout(newIdx);
        var symbolEl = createNormalBox$1(itemLayout, data, newIdx, constDim, true);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(symbolEl);
        return;
      }
      var itemLayout = data.getItemLayout(newIdx);
      if (!symbolEl) {
        symbolEl = createNormalBox$1(itemLayout, data, newIdx, constDim);
      } else {
        saveOldStyle(symbolEl);
        updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  };
  BoxplotView2.prototype.remove = function(ecModel) {
    var group = this.group;
    var data = this._data;
    this._data = null;
    data && data.eachItemGraphicEl(function(el) {
      el && group.remove(el);
    });
  };
  BoxplotView2.type = "boxplot";
  return BoxplotView2;
}(ChartView$1);
var BoxPathShape = function() {
  function BoxPathShape2() {
  }
  return BoxPathShape2;
}();
var BoxPath = function(_super) {
  __extends(BoxPath2, _super);
  function BoxPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "boxplotBoxPath";
    return _this;
  }
  BoxPath2.prototype.getDefaultShape = function() {
    return new BoxPathShape();
  };
  BoxPath2.prototype.buildPath = function(ctx, shape) {
    var ends = shape.points;
    var i = 0;
    ctx.moveTo(ends[i][0], ends[i][1]);
    i++;
    for (; i < 4; i++) {
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
    ctx.closePath();
    for (; i < ends.length; i++) {
      ctx.moveTo(ends[i][0], ends[i][1]);
      i++;
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
  };
  return BoxPath2;
}(Path$1);
function createNormalBox$1(itemLayout, data, dataIndex, constDim, isInit) {
  var ends = itemLayout.ends;
  var el = new BoxPath({
    shape: {
      points: isInit ? transInit$1(ends, constDim, itemLayout) : ends
    }
  });
  updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
  return el;
}
function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
  var seriesModel = data.hostModel;
  var updateMethod = graphic[isInit ? "initProps" : "updateProps"];
  updateMethod(el, {
    shape: {
      points: itemLayout.ends
    }
  }, seriesModel, dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.strokeNoScale = true;
  el.z2 = 100;
  var itemModel = data.getItemModel(dataIndex);
  var emphasisModel = itemModel.getModel("emphasis");
  setStatesStylesFromModel(el, itemModel);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function transInit$1(points2, dim, itemLayout) {
  return map$1(points2, function(point) {
    point = point.slice();
    point[dim] = itemLayout.initBaseline;
    return point;
  });
}
var BoxplotView$1 = BoxplotView;
function boxplotVisual(ecModel, api) {
}
var each$9 = each$f;
function boxplotLayout(ecModel) {
  var groupResult = groupSeriesByAxis(ecModel);
  each$9(groupResult, function(groupItem) {
    var seriesModels = groupItem.seriesModels;
    if (!seriesModels.length) {
      return;
    }
    calculateBase(groupItem);
    each$9(seriesModels, function(seriesModel, idx) {
      layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
    });
  });
}
function groupSeriesByAxis(ecModel) {
  var result = [];
  var axisList = [];
  ecModel.eachSeriesByType("boxplot", function(seriesModel) {
    var baseAxis = seriesModel.getBaseAxis();
    var idx = indexOf(axisList, baseAxis);
    if (idx < 0) {
      idx = axisList.length;
      axisList[idx] = baseAxis;
      result[idx] = {
        axis: baseAxis,
        seriesModels: []
      };
    }
    result[idx].seriesModels.push(seriesModel);
  });
  return result;
}
function calculateBase(groupItem) {
  var baseAxis = groupItem.axis;
  var seriesModels = groupItem.seriesModels;
  var seriesCount = seriesModels.length;
  var boxWidthList = groupItem.boxWidthList = [];
  var boxOffsetList = groupItem.boxOffsetList = [];
  var boundList = [];
  var bandWidth;
  if (baseAxis.type === "category") {
    bandWidth = baseAxis.getBandWidth();
  } else {
    var maxDataCount_1 = 0;
    each$9(seriesModels, function(seriesModel) {
      maxDataCount_1 = Math.max(maxDataCount_1, seriesModel.getData().count());
    });
    var extent3 = baseAxis.getExtent();
    bandWidth = Math.abs(extent3[1] - extent3[0]) / maxDataCount_1;
  }
  each$9(seriesModels, function(seriesModel) {
    var boxWidthBound = seriesModel.get("boxWidth");
    if (!isArray$1(boxWidthBound)) {
      boxWidthBound = [boxWidthBound, boxWidthBound];
    }
    boundList.push([parsePercent$1(boxWidthBound[0], bandWidth) || 0, parsePercent$1(boxWidthBound[1], bandWidth) || 0]);
  });
  var availableWidth = bandWidth * 0.8 - 2;
  var boxGap = availableWidth / seriesCount * 0.3;
  var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
  var base2 = boxWidth / 2 - availableWidth / 2;
  each$9(seriesModels, function(seriesModel, idx) {
    boxOffsetList.push(base2);
    base2 += boxGap + boxWidth;
    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
  });
}
function layoutSingleSeries(seriesModel, offset, boxWidth) {
  var coordSys = seriesModel.coordinateSystem;
  var data = seriesModel.getData();
  var halfWidth = boxWidth / 2;
  var cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
  var vDimIdx = 1 - cDimIdx;
  var coordDims = ["x", "y"];
  var cDim = data.mapDimension(coordDims[cDimIdx]);
  var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);
  if (cDim == null || vDims.length < 5) {
    return;
  }
  for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
    var axisDimVal = data.get(cDim, dataIndex);
    var median = getPoint(axisDimVal, vDims[2], dataIndex);
    var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
    var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
    var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
    var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
    var ends = [];
    addBodyEnd(ends, end2, false);
    addBodyEnd(ends, end4, true);
    ends.push(end1, end2, end5, end4);
    layEndLine(ends, end1);
    layEndLine(ends, end5);
    layEndLine(ends, median);
    data.setItemLayout(dataIndex, {
      initBaseline: median[vDimIdx],
      ends
    });
  }
  function getPoint(axisDimVal2, dim, dataIndex2) {
    var val = data.get(dim, dataIndex2);
    var p = [];
    p[cDimIdx] = axisDimVal2;
    p[vDimIdx] = val;
    var point;
    if (isNaN(axisDimVal2) || isNaN(val)) {
      point = [NaN, NaN];
    } else {
      point = coordSys.dataToPoint(p);
      point[cDimIdx] += offset;
    }
    return point;
  }
  function addBodyEnd(ends2, point, start2) {
    var point1 = point.slice();
    var point2 = point.slice();
    point1[cDimIdx] += halfWidth;
    point2[cDimIdx] -= halfWidth;
    start2 ? ends2.push(point1, point2) : ends2.push(point2, point1);
  }
  function layEndLine(ends2, endCenter) {
    var from = endCenter.slice();
    var to = endCenter.slice();
    from[cDimIdx] -= halfWidth;
    to[cDimIdx] += halfWidth;
    ends2.push(from, to);
  }
}
function prepareBoxplotData(rawData, opt) {
  opt = opt || {};
  var boxData = [];
  var outliers = [];
  var boundIQR = opt.boundIQR;
  var useExtreme = boundIQR === "none" || boundIQR === 0;
  for (var i = 0; i < rawData.length; i++) {
    var ascList = asc$2(rawData[i].slice());
    var Q1 = quantile(ascList, 0.25);
    var Q2 = quantile(ascList, 0.5);
    var Q3 = quantile(ascList, 0.75);
    var min3 = ascList[0];
    var max3 = ascList[ascList.length - 1];
    var bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);
    var low = useExtreme ? min3 : Math.max(min3, Q1 - bound);
    var high = useExtreme ? max3 : Math.min(max3, Q3 + bound);
    var itemNameFormatter = opt.itemNameFormatter;
    var itemName = isFunction$1(itemNameFormatter) ? itemNameFormatter({
      value: i
    }) : isString(itemNameFormatter) ? itemNameFormatter.replace("{value}", i + "") : i + "";
    boxData.push([itemName, low, Q1, Q2, Q3, high]);
    for (var j = 0; j < ascList.length; j++) {
      var dataItem = ascList[j];
      if (dataItem < low || dataItem > high) {
        var outlier = [itemName, dataItem];
        outliers.push(outlier);
      }
    }
  }
  return {
    boxData,
    outliers
  };
}
var boxplotTransform = {
  type: "echarts:boxplot",
  transform: function transform(params) {
    var upstream = params.upstream;
    if (upstream.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
      var errMsg = "";
      throwError(errMsg);
    }
    var result = prepareBoxplotData(upstream.getRawData(), params.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: result.boxData
    }, {
      data: result.outliers
    }];
  }
};
function install$P(registers) {
  registers.registerSeriesModel(BoxplotSeriesModel$1);
  registers.registerChartView(BoxplotView$1);
  registers.registerVisual(boxplotVisual);
  registers.registerLayout(boxplotLayout);
  registers.registerTransform(boxplotTransform);
}
var SKIP_PROPS = ["color", "borderColor"];
var CandlestickView = function(_super) {
  __extends(CandlestickView2, _super);
  function CandlestickView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CandlestickView2.type;
    return _this;
  }
  CandlestickView2.prototype.render = function(seriesModel, ecModel, api) {
    this.group.removeClipPath();
    this._progressiveEls = null;
    this._updateDrawMode(seriesModel);
    this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
  };
  CandlestickView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    this._clear();
    this._updateDrawMode(seriesModel);
  };
  CandlestickView2.prototype.incrementalRender = function(params, seriesModel, ecModel, api) {
    this._progressiveEls = [];
    this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
  };
  CandlestickView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  CandlestickView2.prototype._updateDrawMode = function(seriesModel) {
    var isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  };
  CandlestickView2.prototype._renderNormal = function(seriesModel) {
    var data = seriesModel.getData();
    var oldData = this._data;
    var group = this.group;
    var isSimpleBox = data.getLayout("isSimpleBox");
    var needsClip = seriesModel.get("clip", true);
    var coord = seriesModel.coordinateSystem;
    var clipArea = coord.getArea && coord.getArea();
    if (!this._data) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        var itemLayout = data.getItemLayout(newIdx);
        if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
          return;
        }
        var el = createNormalBox(itemLayout, newIdx, true);
        initProps(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, newIdx);
        setBoxCommon(el, data, newIdx, isSimpleBox);
        group.add(el);
        data.setItemGraphicEl(newIdx, el);
      }
    }).update(function(newIdx, oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(el);
        return;
      }
      var itemLayout = data.getItemLayout(newIdx);
      if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
        group.remove(el);
        return;
      }
      if (!el) {
        el = createNormalBox(itemLayout);
      } else {
        updateProps$1(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, newIdx);
        saveOldStyle(el);
      }
      setBoxCommon(el, data, newIdx, isSimpleBox);
      group.add(el);
      data.setItemGraphicEl(newIdx, el);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  };
  CandlestickView2.prototype._renderLarge = function(seriesModel) {
    this._clear();
    createLarge(seriesModel, this.group);
    var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
  };
  CandlestickView2.prototype._incrementalRenderNormal = function(params, seriesModel) {
    var data = seriesModel.getData();
    var isSimpleBox = data.getLayout("isSimpleBox");
    var dataIndex;
    while ((dataIndex = params.next()) != null) {
      var itemLayout = data.getItemLayout(dataIndex);
      var el = createNormalBox(itemLayout);
      setBoxCommon(el, data, dataIndex, isSimpleBox);
      el.incremental = true;
      this.group.add(el);
      this._progressiveEls.push(el);
    }
  };
  CandlestickView2.prototype._incrementalRenderLarge = function(params, seriesModel) {
    createLarge(seriesModel, this.group, this._progressiveEls, true);
  };
  CandlestickView2.prototype.remove = function(ecModel) {
    this._clear();
  };
  CandlestickView2.prototype._clear = function() {
    this.group.removeAll();
    this._data = null;
  };
  CandlestickView2.type = "candlestick";
  return CandlestickView2;
}(ChartView$1);
var NormalBoxPathShape = function() {
  function NormalBoxPathShape2() {
  }
  return NormalBoxPathShape2;
}();
var NormalBoxPath = function(_super) {
  __extends(NormalBoxPath2, _super);
  function NormalBoxPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "normalCandlestickBox";
    return _this;
  }
  NormalBoxPath2.prototype.getDefaultShape = function() {
    return new NormalBoxPathShape();
  };
  NormalBoxPath2.prototype.buildPath = function(ctx, shape) {
    var ends = shape.points;
    if (this.__simpleBox) {
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[6][0], ends[6][1]);
    } else {
      ctx.moveTo(ends[0][0], ends[0][1]);
      ctx.lineTo(ends[1][0], ends[1][1]);
      ctx.lineTo(ends[2][0], ends[2][1]);
      ctx.lineTo(ends[3][0], ends[3][1]);
      ctx.closePath();
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[5][0], ends[5][1]);
      ctx.moveTo(ends[6][0], ends[6][1]);
      ctx.lineTo(ends[7][0], ends[7][1]);
    }
  };
  return NormalBoxPath2;
}(Path$1);
function createNormalBox(itemLayout, dataIndex, isInit) {
  var ends = itemLayout.ends;
  return new NormalBoxPath({
    shape: {
      points: isInit ? transInit(ends, itemLayout) : ends
    },
    z2: 100
  });
}
function isNormalBoxClipped(clipArea, itemLayout) {
  var clipped = true;
  for (var i = 0; i < itemLayout.ends.length; i++) {
    if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
      clipped = false;
      break;
    }
  }
  return clipped;
}
function setBoxCommon(el, data, dataIndex, isSimpleBox) {
  var itemModel = data.getItemModel(dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.strokeNoScale = true;
  el.__simpleBox = isSimpleBox;
  setStatesStylesFromModel(el, itemModel);
}
function transInit(points2, itemLayout) {
  return map$1(points2, function(point) {
    point = point.slice();
    point[1] = itemLayout.initBaseline;
    return point;
  });
}
var LargeBoxPathShape = function() {
  function LargeBoxPathShape2() {
  }
  return LargeBoxPathShape2;
}();
var LargeBoxPath = function(_super) {
  __extends(LargeBoxPath2, _super);
  function LargeBoxPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this.type = "largeCandlestickBox";
    return _this;
  }
  LargeBoxPath2.prototype.getDefaultShape = function() {
    return new LargeBoxPathShape();
  };
  LargeBoxPath2.prototype.buildPath = function(ctx, shape) {
    var points2 = shape.points;
    for (var i = 0; i < points2.length; ) {
      if (this.__sign === points2[i++]) {
        var x = points2[i++];
        ctx.moveTo(x, points2[i++]);
        ctx.lineTo(x, points2[i++]);
      } else {
        i += 3;
      }
    }
  };
  return LargeBoxPath2;
}(Path$1);
function createLarge(seriesModel, group, progressiveEls, incremental) {
  var data = seriesModel.getData();
  var largePoints = data.getLayout("largePoints");
  var elP = new LargeBoxPath({
    shape: {
      points: largePoints
    },
    __sign: 1
  });
  group.add(elP);
  var elN = new LargeBoxPath({
    shape: {
      points: largePoints
    },
    __sign: -1
  });
  group.add(elN);
  setLargeStyle(1, elP, seriesModel);
  setLargeStyle(-1, elN, seriesModel);
  if (incremental) {
    elP.incremental = true;
    elN.incremental = true;
  }
  if (progressiveEls) {
    progressiveEls.push(elP, elN);
  }
}
function setLargeStyle(sign2, el, seriesModel, data) {
  var borderColor = seriesModel.get(["itemStyle", sign2 > 0 ? "borderColor" : "borderColor0"]) || seriesModel.get(["itemStyle", sign2 > 0 ? "color" : "color0"]);
  var itemStyle = seriesModel.getModel("itemStyle").getItemStyle(SKIP_PROPS);
  el.useStyle(itemStyle);
  el.style.fill = null;
  el.style.stroke = borderColor;
}
var CandlestickView$1 = CandlestickView;
var CandlestickSeriesModel = function(_super) {
  __extends(CandlestickSeriesModel2, _super);
  function CandlestickSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CandlestickSeriesModel2.type;
    _this.defaultValueDimensions = [{
      name: "open",
      defaultTooltip: true
    }, {
      name: "close",
      defaultTooltip: true
    }, {
      name: "lowest",
      defaultTooltip: true
    }, {
      name: "highest",
      defaultTooltip: true
    }];
    return _this;
  }
  CandlestickSeriesModel2.prototype.getShadowDim = function() {
    return "open";
  };
  CandlestickSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    var itemLayout = data.getItemLayout(dataIndex);
    return itemLayout && selectors.rect(itemLayout.brushRect);
  };
  CandlestickSeriesModel2.type = "series.candlestick";
  CandlestickSeriesModel2.dependencies = ["xAxis", "yAxis", "grid"];
  CandlestickSeriesModel2.defaultOption = {
    z: 2,
    coordinateSystem: "cartesian2d",
    legendHoverLink: true,
    layout: null,
    clip: true,
    itemStyle: {
      color: "#eb5454",
      color0: "#47b262",
      borderColor: "#eb5454",
      borderColor0: "#47b262",
      borderWidth: 1
    },
    emphasis: {
      scale: true,
      itemStyle: {
        borderWidth: 2
      }
    },
    barMaxWidth: null,
    barMinWidth: null,
    barWidth: null,
    large: true,
    largeThreshold: 600,
    progressive: 3e3,
    progressiveThreshold: 1e4,
    progressiveChunkMode: "mod",
    animationEasing: "linear",
    animationDuration: 300
  };
  return CandlestickSeriesModel2;
}(SeriesModel$1);
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, true);
var CandlestickSeriesModel$1 = CandlestickSeriesModel;
function candlestickPreprocessor(option) {
  if (!option || !isArray$1(option.series)) {
    return;
  }
  each$f(option.series, function(seriesItem) {
    if (isObject$3(seriesItem) && seriesItem.type === "k") {
      seriesItem.type = "candlestick";
    }
  });
}
var positiveBorderColorQuery = ["itemStyle", "borderColor"];
var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
var positiveColorQuery = ["itemStyle", "color"];
var negativeColorQuery = ["itemStyle", "color0"];
var candlestickVisual = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    function getColor(sign2, model) {
      return model.get(sign2 > 0 ? positiveColorQuery : negativeColorQuery);
    }
    function getBorderColor(sign2, model) {
      return model.get(sign2 > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    var isLargeRender = seriesModel.pipelineContext.large;
    return !isLargeRender && {
      progress: function(params, data) {
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var itemModel = data.getItemModel(dataIndex);
          var sign2 = data.getItemLayout(dataIndex).sign;
          var style = itemModel.getItemStyle();
          style.fill = getColor(sign2, itemModel);
          style.stroke = getBorderColor(sign2, itemModel) || style.fill;
          var existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
          extend$1(existsStyle, style);
        }
      }
    };
  }
};
var candlestickVisual$1 = candlestickVisual;
var candlestickLayout = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  reset: function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var data = seriesModel.getData();
    var candleWidth = calculateCandleWidth(seriesModel, data);
    var cDimIdx = 0;
    var vDimIdx = 1;
    var coordDims = ["x", "y"];
    var cDimI = data.getDimensionIndex(data.mapDimension(coordDims[cDimIdx]));
    var vDimsI = map$1(data.mapDimensionsAll(coordDims[vDimIdx]), data.getDimensionIndex, data);
    var openDimI = vDimsI[0];
    var closeDimI = vDimsI[1];
    var lowestDimI = vDimsI[2];
    var highestDimI = vDimsI[3];
    data.setLayout({
      candleWidth,
      isSimpleBox: candleWidth <= 1.3
    });
    if (cDimI < 0 || vDimsI.length < 4) {
      return;
    }
    return {
      progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
    };
    function normalProgress(params, data2) {
      var dataIndex;
      var store = data2.getStore();
      while ((dataIndex = params.next()) != null) {
        var axisDimVal = store.get(cDimI, dataIndex);
        var openVal = store.get(openDimI, dataIndex);
        var closeVal = store.get(closeDimI, dataIndex);
        var lowestVal = store.get(lowestDimI, dataIndex);
        var highestVal = store.get(highestDimI, dataIndex);
        var ocLow = Math.min(openVal, closeVal);
        var ocHigh = Math.max(openVal, closeVal);
        var ocLowPoint = getPoint(ocLow, axisDimVal);
        var ocHighPoint = getPoint(ocHigh, axisDimVal);
        var lowestPoint = getPoint(lowestVal, axisDimVal);
        var highestPoint = getPoint(highestVal, axisDimVal);
        var ends = [];
        addBodyEnd(ends, ocHighPoint, 0);
        addBodyEnd(ends, ocLowPoint, 1);
        ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
        data2.setItemLayout(dataIndex, {
          sign: getSign(store, dataIndex, openVal, closeVal, closeDimI),
          initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
          ends,
          brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
        });
      }
      function getPoint(val, axisDimVal2) {
        var p = [];
        p[cDimIdx] = axisDimVal2;
        p[vDimIdx] = val;
        return isNaN(axisDimVal2) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
      }
      function addBodyEnd(ends2, point, start2) {
        var point1 = point.slice();
        var point2 = point.slice();
        point1[cDimIdx] = subPixelOptimize(point1[cDimIdx] + candleWidth / 2, 1, false);
        point2[cDimIdx] = subPixelOptimize(point2[cDimIdx] - candleWidth / 2, 1, true);
        start2 ? ends2.push(point1, point2) : ends2.push(point2, point1);
      }
      function makeBrushRect(lowestVal2, highestVal2, axisDimVal2) {
        var pmin = getPoint(lowestVal2, axisDimVal2);
        var pmax = getPoint(highestVal2, axisDimVal2);
        pmin[cDimIdx] -= candleWidth / 2;
        pmax[cDimIdx] -= candleWidth / 2;
        return {
          x: pmin[0],
          y: pmin[1],
          width: candleWidth,
          height: pmax[1] - pmin[1]
        };
      }
      function subPixelOptimizePoint(point) {
        point[cDimIdx] = subPixelOptimize(point[cDimIdx], 1);
        return point;
      }
    }
    function largeProgress(params, data2) {
      var points2 = createFloat32Array(params.count * 4);
      var offset = 0;
      var point;
      var tmpIn = [];
      var tmpOut = [];
      var dataIndex;
      var store = data2.getStore();
      while ((dataIndex = params.next()) != null) {
        var axisDimVal = store.get(cDimI, dataIndex);
        var openVal = store.get(openDimI, dataIndex);
        var closeVal = store.get(closeDimI, dataIndex);
        var lowestVal = store.get(lowestDimI, dataIndex);
        var highestVal = store.get(highestDimI, dataIndex);
        if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
          points2[offset++] = NaN;
          offset += 3;
          continue;
        }
        points2[offset++] = getSign(store, dataIndex, openVal, closeVal, closeDimI);
        tmpIn[cDimIdx] = axisDimVal;
        tmpIn[vDimIdx] = lowestVal;
        point = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points2[offset++] = point ? point[0] : NaN;
        points2[offset++] = point ? point[1] : NaN;
        tmpIn[vDimIdx] = highestVal;
        point = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points2[offset++] = point ? point[1] : NaN;
      }
      data2.setLayout("largePoints", points2);
    }
  }
};
function getSign(store, dataIndex, openVal, closeVal, closeDimI) {
  var sign2;
  if (openVal > closeVal) {
    sign2 = -1;
  } else if (openVal < closeVal) {
    sign2 = 1;
  } else {
    sign2 = dataIndex > 0 ? store.get(closeDimI, dataIndex - 1) <= closeVal ? 1 : -1 : 1;
  }
  return sign2;
}
function calculateCandleWidth(seriesModel, data) {
  var baseAxis = seriesModel.getBaseAxis();
  var extent3;
  var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent3 = baseAxis.getExtent(), Math.abs(extent3[1] - extent3[0]) / data.count());
  var barMaxWidth = parsePercent$1(retrieve2(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
  var barMinWidth = parsePercent$1(retrieve2(seriesModel.get("barMinWidth"), 1), bandWidth);
  var barWidth = seriesModel.get("barWidth");
  return barWidth != null ? parsePercent$1(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
}
var candlestickLayout$1 = candlestickLayout;
function install$O(registers) {
  registers.registerChartView(CandlestickView$1);
  registers.registerSeriesModel(CandlestickSeriesModel$1);
  registers.registerPreprocessor(candlestickPreprocessor);
  registers.registerVisual(candlestickVisual$1);
  registers.registerLayout(candlestickLayout$1);
}
function updateRipplePath(rippleGroup, effectCfg) {
  var color = effectCfg.rippleEffectColor || effectCfg.color;
  rippleGroup.eachChild(function(ripplePath) {
    ripplePath.attr({
      z: effectCfg.z,
      zlevel: effectCfg.zlevel,
      style: {
        stroke: effectCfg.brushType === "stroke" ? color : null,
        fill: effectCfg.brushType === "fill" ? color : null
      }
    });
  });
}
var EffectSymbol = function(_super) {
  __extends(EffectSymbol2, _super);
  function EffectSymbol2(data, idx) {
    var _this = _super.call(this) || this;
    var symbol = new SymbolClz(data, idx);
    var rippleGroup = new Group$4();
    _this.add(symbol);
    _this.add(rippleGroup);
    _this.updateData(data, idx);
    return _this;
  }
  EffectSymbol2.prototype.stopEffectAnimation = function() {
    this.childAt(1).removeAll();
  };
  EffectSymbol2.prototype.startEffectAnimation = function(effectCfg) {
    var symbolType = effectCfg.symbolType;
    var color = effectCfg.color;
    var rippleNumber = effectCfg.rippleNumber;
    var rippleGroup = this.childAt(1);
    for (var i = 0; i < rippleNumber; i++) {
      var ripplePath = createSymbol$1(symbolType, -1, -1, 2, 2, color);
      ripplePath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 99,
        silent: true,
        scaleX: 0.5,
        scaleY: 0.5
      });
      var delay = -i / rippleNumber * effectCfg.period + effectCfg.effectOffset;
      ripplePath.animate("", true).when(effectCfg.period, {
        scaleX: effectCfg.rippleScale / 2,
        scaleY: effectCfg.rippleScale / 2
      }).delay(delay).start();
      ripplePath.animateStyle(true).when(effectCfg.period, {
        opacity: 0
      }).delay(delay).start();
      rippleGroup.add(ripplePath);
    }
    updateRipplePath(rippleGroup, effectCfg);
  };
  EffectSymbol2.prototype.updateEffectAnimation = function(effectCfg) {
    var oldEffectCfg = this._effectCfg;
    var rippleGroup = this.childAt(1);
    var DIFFICULT_PROPS = ["symbolType", "period", "rippleScale", "rippleNumber"];
    for (var i = 0; i < DIFFICULT_PROPS.length; i++) {
      var propName = DIFFICULT_PROPS[i];
      if (oldEffectCfg[propName] !== effectCfg[propName]) {
        this.stopEffectAnimation();
        this.startEffectAnimation(effectCfg);
        return;
      }
    }
    updateRipplePath(rippleGroup, effectCfg);
  };
  EffectSymbol2.prototype.highlight = function() {
    enterEmphasis(this);
  };
  EffectSymbol2.prototype.downplay = function() {
    leaveEmphasis(this);
  };
  EffectSymbol2.prototype.getSymbolType = function() {
    var symbol = this.childAt(0);
    return symbol && symbol.getSymbolType();
  };
  EffectSymbol2.prototype.updateData = function(data, idx) {
    var _this = this;
    var seriesModel = data.hostModel;
    this.childAt(0).updateData(data, idx);
    var rippleGroup = this.childAt(1);
    var itemModel = data.getItemModel(idx);
    var symbolType = data.getItemVisual(idx, "symbol");
    var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
    var symbolStyle = data.getItemVisual(idx, "style");
    var color = symbolStyle && symbolStyle.fill;
    var emphasisModel = itemModel.getModel("emphasis");
    rippleGroup.setScale(symbolSize);
    rippleGroup.traverse(function(ripplePath) {
      ripplePath.setStyle("fill", color);
    });
    var symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      rippleGroup.x = symbolOffset[0];
      rippleGroup.y = symbolOffset[1];
    }
    var symbolRotate = data.getItemVisual(idx, "symbolRotate");
    rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    var effectCfg = {};
    effectCfg.showEffectOn = seriesModel.get("showEffectOn");
    effectCfg.rippleScale = itemModel.get(["rippleEffect", "scale"]);
    effectCfg.brushType = itemModel.get(["rippleEffect", "brushType"]);
    effectCfg.period = itemModel.get(["rippleEffect", "period"]) * 1e3;
    effectCfg.effectOffset = idx / data.count();
    effectCfg.z = seriesModel.getShallow("z") || 0;
    effectCfg.zlevel = seriesModel.getShallow("zlevel") || 0;
    effectCfg.symbolType = symbolType;
    effectCfg.color = color;
    effectCfg.rippleEffectColor = itemModel.get(["rippleEffect", "color"]);
    effectCfg.rippleNumber = itemModel.get(["rippleEffect", "number"]);
    if (effectCfg.showEffectOn === "render") {
      this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
      this._effectCfg = effectCfg;
    } else {
      this._effectCfg = null;
      this.stopEffectAnimation();
      this.onHoverStateChange = function(toState) {
        if (toState === "emphasis") {
          if (effectCfg.showEffectOn !== "render") {
            _this.startEffectAnimation(effectCfg);
          }
        } else if (toState === "normal") {
          if (effectCfg.showEffectOn !== "render") {
            _this.stopEffectAnimation();
          }
        }
      };
    }
    this._effectCfg = effectCfg;
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  EffectSymbol2.prototype.fadeOut = function(cb) {
    cb && cb();
  };
  return EffectSymbol2;
}(Group$4);
var EffectSymbol$1 = EffectSymbol;
var EffectScatterView = function(_super) {
  __extends(EffectScatterView2, _super);
  function EffectScatterView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = EffectScatterView2.type;
    return _this;
  }
  EffectScatterView2.prototype.init = function() {
    this._symbolDraw = new SymbolDraw$1(EffectSymbol$1);
  };
  EffectScatterView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var effectSymbolDraw = this._symbolDraw;
    effectSymbolDraw.updateData(data, {
      clipShape: this._getClipShape(seriesModel)
    });
    this.group.add(effectSymbolDraw.group);
  };
  EffectScatterView2.prototype._getClipShape = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
    return seriesModel.get("clip", true) ? clipArea : null;
  };
  EffectScatterView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    this.group.dirty();
    var res = pointsLayout("").reset(seriesModel, ecModel, api);
    if (res.progress) {
      res.progress({
        start: 0,
        end: data.count(),
        count: data.count()
      }, data);
    }
    this._symbolDraw.updateLayout();
  };
  EffectScatterView2.prototype._updateGroupTransform = function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.getRoamTransform) {
      this.group.transform = clone$2(coordSys.getRoamTransform());
      this.group.decomposeTransform();
    }
  };
  EffectScatterView2.prototype.remove = function(ecModel, api) {
    this._symbolDraw && this._symbolDraw.remove(true);
  };
  EffectScatterView2.type = "effectScatter";
  return EffectScatterView2;
}(ChartView$1);
var EffectScatterView$1 = EffectScatterView;
var EffectScatterSeriesModel = function(_super) {
  __extends(EffectScatterSeriesModel2, _super);
  function EffectScatterSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = EffectScatterSeriesModel2.type;
    _this.hasSymbolVisual = true;
    return _this;
  }
  EffectScatterSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      useEncodeDefaulter: true
    });
  };
  EffectScatterSeriesModel2.prototype.brushSelector = function(dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  };
  EffectScatterSeriesModel2.type = "series.effectScatter";
  EffectScatterSeriesModel2.dependencies = ["grid", "polar"];
  EffectScatterSeriesModel2.defaultOption = {
    coordinateSystem: "cartesian2d",
    z: 2,
    legendHoverLink: true,
    effectType: "ripple",
    progressive: 0,
    showEffectOn: "render",
    clip: true,
    rippleEffect: {
      period: 4,
      scale: 2.5,
      brushType: "fill",
      number: 3
    },
    universalTransition: {
      divideShape: "clone"
    },
    symbolSize: 10
  };
  return EffectScatterSeriesModel2;
}(SeriesModel$1);
var EffectScatterSeriesModel$1 = EffectScatterSeriesModel;
function install$N(registers) {
  registers.registerChartView(EffectScatterView$1);
  registers.registerSeriesModel(EffectScatterSeriesModel$1);
  registers.registerLayout(pointsLayout("effectScatter"));
}
var EffectLine = function(_super) {
  __extends(EffectLine2, _super);
  function EffectLine2(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;
    _this.add(_this.createLine(lineData, idx, seriesScope));
    _this._updateEffectSymbol(lineData, idx);
    return _this;
  }
  EffectLine2.prototype.createLine = function(lineData, idx, seriesScope) {
    return new Line$1(lineData, idx, seriesScope);
  };
  EffectLine2.prototype._updateEffectSymbol = function(lineData, idx) {
    var itemModel = lineData.getItemModel(idx);
    var effectModel = itemModel.getModel("effect");
    var size = effectModel.get("symbolSize");
    var symbolType = effectModel.get("symbol");
    if (!isArray$1(size)) {
      size = [size, size];
    }
    var lineStyle = lineData.getItemVisual(idx, "style");
    var color = effectModel.get("color") || lineStyle && lineStyle.stroke;
    var symbol = this.childAt(1);
    if (this._symbolType !== symbolType) {
      this.remove(symbol);
      symbol = createSymbol$1(symbolType, -0.5, -0.5, 1, 1, color);
      symbol.z2 = 100;
      symbol.culling = true;
      this.add(symbol);
    }
    if (!symbol) {
      return;
    }
    symbol.setStyle("shadowColor", color);
    symbol.setStyle(effectModel.getItemStyle(["color"]));
    symbol.scaleX = size[0];
    symbol.scaleY = size[1];
    symbol.setColor(color);
    this._symbolType = symbolType;
    this._symbolScale = size;
    this._updateEffectAnimation(lineData, effectModel, idx);
  };
  EffectLine2.prototype._updateEffectAnimation = function(lineData, effectModel, idx) {
    var symbol = this.childAt(1);
    if (!symbol) {
      return;
    }
    var self2 = this;
    var points2 = lineData.getItemLayout(idx);
    var period = effectModel.get("period") * 1e3;
    var loop = effectModel.get("loop");
    var constantSpeed = effectModel.get("constantSpeed");
    var delayExpr = retrieve$2(effectModel.get("delay"), function(idx2) {
      return idx2 / lineData.count() * period / 3;
    });
    symbol.ignore = true;
    this._updateAnimationPoints(symbol, points2);
    if (constantSpeed > 0) {
      period = this._getLineLength(symbol) / constantSpeed * 1e3;
    }
    if (period !== this._period || loop !== this._loop) {
      symbol.stopAnimation();
      if (period > 0) {
        var delayNum = void 0;
        if (isFunction$1(delayExpr)) {
          delayNum = delayExpr(idx);
        } else {
          delayNum = delayExpr;
        }
        if (symbol.__t > 0) {
          delayNum = -period * symbol.__t;
        }
        symbol.__t = 0;
        var animator = symbol.animate("", loop).when(period, {
          __t: 1
        }).delay(delayNum).during(function() {
          self2._updateSymbolPosition(symbol);
        });
        if (!loop) {
          animator.done(function() {
            self2.remove(symbol);
          });
        }
        animator.start();
      }
    }
    this._period = period;
    this._loop = loop;
  };
  EffectLine2.prototype._getLineLength = function(symbol) {
    return dist$1(symbol.__p1, symbol.__cp1) + dist$1(symbol.__cp1, symbol.__p2);
  };
  EffectLine2.prototype._updateAnimationPoints = function(symbol, points2) {
    symbol.__p1 = points2[0];
    symbol.__p2 = points2[1];
    symbol.__cp1 = points2[2] || [(points2[0][0] + points2[1][0]) / 2, (points2[0][1] + points2[1][1]) / 2];
  };
  EffectLine2.prototype.updateData = function(lineData, idx, seriesScope) {
    this.childAt(0).updateData(lineData, idx, seriesScope);
    this._updateEffectSymbol(lineData, idx);
  };
  EffectLine2.prototype._updateSymbolPosition = function(symbol) {
    var p12 = symbol.__p1;
    var p22 = symbol.__p2;
    var cp1 = symbol.__cp1;
    var t = symbol.__t;
    var pos = [symbol.x, symbol.y];
    var lastPos = pos.slice();
    var quadraticAt2 = quadraticAt$1;
    var quadraticDerivativeAt$1 = quadraticDerivativeAt;
    pos[0] = quadraticAt2(p12[0], cp1[0], p22[0], t);
    pos[1] = quadraticAt2(p12[1], cp1[1], p22[1], t);
    var tx = quadraticDerivativeAt$1(p12[0], cp1[0], p22[0], t);
    var ty = quadraticDerivativeAt$1(p12[1], cp1[1], p22[1], t);
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") {
      if (symbol.__lastT !== void 0 && symbol.__lastT < symbol.__t) {
        symbol.scaleY = dist$1(lastPos, pos) * 1.05;
        if (t === 1) {
          pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
          pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
        }
      } else if (symbol.__lastT === 1) {
        symbol.scaleY = 2 * dist$1(p12, pos);
      } else {
        symbol.scaleY = this._symbolScale[1];
      }
    }
    symbol.__lastT = symbol.__t;
    symbol.ignore = false;
    symbol.x = pos[0];
    symbol.y = pos[1];
  };
  EffectLine2.prototype.updateLayout = function(lineData, idx) {
    this.childAt(0).updateLayout(lineData, idx);
    var effectModel = lineData.getItemModel(idx).getModel("effect");
    this._updateEffectAnimation(lineData, effectModel, idx);
  };
  return EffectLine2;
}(Group$4);
var EffectLine$1 = EffectLine;
var Polyline = function(_super) {
  __extends(Polyline2, _super);
  function Polyline2(lineData, idx, seriesScope) {
    var _this = _super.call(this) || this;
    _this._createPolyline(lineData, idx, seriesScope);
    return _this;
  }
  Polyline2.prototype._createPolyline = function(lineData, idx, seriesScope) {
    var points2 = lineData.getItemLayout(idx);
    var line = new Polyline$3({
      shape: {
        points: points2
      }
    });
    this.add(line);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  Polyline2.prototype.updateData = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line = this.childAt(0);
    var target = {
      shape: {
        points: lineData.getItemLayout(idx)
      }
    };
    updateProps$1(line, target, seriesModel, idx);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  Polyline2.prototype._updateCommonStl = function(lineData, idx, seriesScope) {
    var line = this.childAt(0);
    var itemModel = lineData.getItemModel(idx);
    var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    var focus = seriesScope && seriesScope.focus;
    var blurScope = seriesScope && seriesScope.blurScope;
    var emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
    if (!seriesScope || lineData.hasItemOption) {
      var emphasisModel = itemModel.getModel("emphasis");
      emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
      emphasisDisabled = emphasisModel.get("disabled");
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
    }
    line.useStyle(lineData.getItemVisual(idx, "style"));
    line.style.fill = null;
    line.style.strokeNoScale = true;
    var lineEmphasisState = line.ensureState("emphasis");
    lineEmphasisState.style = emphasisLineStyle;
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  };
  Polyline2.prototype.updateLayout = function(lineData, idx) {
    var polyline = this.childAt(0);
    polyline.setShape("points", lineData.getItemLayout(idx));
  };
  return Polyline2;
}(Group$4);
var Polyline$1 = Polyline;
var EffectPolyline = function(_super) {
  __extends(EffectPolyline2, _super);
  function EffectPolyline2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._lastFrame = 0;
    _this._lastFramePercent = 0;
    return _this;
  }
  EffectPolyline2.prototype.createLine = function(lineData, idx, seriesScope) {
    return new Polyline$1(lineData, idx, seriesScope);
  };
  EffectPolyline2.prototype._updateAnimationPoints = function(symbol, points2) {
    this._points = points2;
    var accLenArr = [0];
    var len2 = 0;
    for (var i = 1; i < points2.length; i++) {
      var p12 = points2[i - 1];
      var p22 = points2[i];
      len2 += dist$1(p12, p22);
      accLenArr.push(len2);
    }
    if (len2 === 0) {
      this._length = 0;
      return;
    }
    for (var i = 0; i < accLenArr.length; i++) {
      accLenArr[i] /= len2;
    }
    this._offsets = accLenArr;
    this._length = len2;
  };
  EffectPolyline2.prototype._getLineLength = function() {
    return this._length;
  };
  EffectPolyline2.prototype._updateSymbolPosition = function(symbol) {
    var t = symbol.__t;
    var points2 = this._points;
    var offsets = this._offsets;
    var len2 = points2.length;
    if (!offsets) {
      return;
    }
    var lastFrame = this._lastFrame;
    var frame;
    if (t < this._lastFramePercent) {
      var start2 = Math.min(lastFrame + 1, len2 - 1);
      for (frame = start2; frame >= 0; frame--) {
        if (offsets[frame] <= t) {
          break;
        }
      }
      frame = Math.min(frame, len2 - 2);
    } else {
      for (frame = lastFrame; frame < len2; frame++) {
        if (offsets[frame] > t) {
          break;
        }
      }
      frame = Math.min(frame - 1, len2 - 2);
    }
    var p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);
    var p02 = points2[frame];
    var p12 = points2[frame + 1];
    symbol.x = p02[0] * (1 - p) + p * p12[0];
    symbol.y = p02[1] * (1 - p) + p * p12[1];
    var tx = p12[0] - p02[0];
    var ty = p12[1] - p02[1];
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    this._lastFrame = frame;
    this._lastFramePercent = t;
    symbol.ignore = false;
  };
  return EffectPolyline2;
}(EffectLine$1);
var EffectPolyline$1 = EffectPolyline;
var LargeLinesPathShape = function() {
  function LargeLinesPathShape2() {
    this.polyline = false;
    this.curveness = 0;
    this.segs = [];
  }
  return LargeLinesPathShape2;
}();
var LargeLinesPath = function(_super) {
  __extends(LargeLinesPath2, _super);
  function LargeLinesPath2(opts) {
    var _this = _super.call(this, opts) || this;
    _this._off = 0;
    _this.hoverDataIdx = -1;
    return _this;
  }
  LargeLinesPath2.prototype.reset = function() {
    this.notClear = false;
    this._off = 0;
  };
  LargeLinesPath2.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  };
  LargeLinesPath2.prototype.getDefaultShape = function() {
    return new LargeLinesPathShape();
  };
  LargeLinesPath2.prototype.buildPath = function(ctx, shape) {
    var segs = shape.segs;
    var curveness = shape.curveness;
    var i;
    if (shape.polyline) {
      for (i = this._off; i < segs.length; ) {
        var count2 = segs[i++];
        if (count2 > 0) {
          ctx.moveTo(segs[i++], segs[i++]);
          for (var k = 1; k < count2; k++) {
            ctx.lineTo(segs[i++], segs[i++]);
          }
        }
      }
    } else {
      for (i = this._off; i < segs.length; ) {
        var x0 = segs[i++];
        var y0 = segs[i++];
        var x1 = segs[i++];
        var y1 = segs[i++];
        ctx.moveTo(x0, y0);
        if (curveness > 0) {
          var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
          var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
          ctx.quadraticCurveTo(x2, y2, x1, y1);
        } else {
          ctx.lineTo(x1, y1);
        }
      }
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  };
  LargeLinesPath2.prototype.findDataIndex = function(x, y) {
    var shape = this.shape;
    var segs = shape.segs;
    var curveness = shape.curveness;
    var lineWidth = this.style.lineWidth;
    if (shape.polyline) {
      var dataIndex = 0;
      for (var i = 0; i < segs.length; ) {
        var count2 = segs[i++];
        if (count2 > 0) {
          var x0 = segs[i++];
          var y0 = segs[i++];
          for (var k = 1; k < count2; k++) {
            var x1 = segs[i++];
            var y1 = segs[i++];
            if (containStroke$4(x0, y0, x1, y1, lineWidth, x, y)) {
              return dataIndex;
            }
          }
        }
        dataIndex++;
      }
    } else {
      var dataIndex = 0;
      for (var i = 0; i < segs.length; ) {
        var x0 = segs[i++];
        var y0 = segs[i++];
        var x1 = segs[i++];
        var y1 = segs[i++];
        if (curveness > 0) {
          var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
          var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
          if (containStroke$2(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) {
            return dataIndex;
          }
        } else {
          if (containStroke$4(x0, y0, x1, y1, lineWidth, x, y)) {
            return dataIndex;
          }
        }
        dataIndex++;
      }
    }
    return -1;
  };
  LargeLinesPath2.prototype.contain = function(x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      var dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
      return dataIdx >= 0;
    }
    this.hoverDataIdx = -1;
    return false;
  };
  LargeLinesPath2.prototype.getBoundingRect = function() {
    var rect = this._rect;
    if (!rect) {
      var shape = this.shape;
      var points2 = shape.segs;
      var minX = Infinity;
      var minY = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      for (var i = 0; i < points2.length; ) {
        var x = points2[i++];
        var y = points2[i++];
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      }
      rect = this._rect = new BoundingRect$1(minX, minY, maxX, maxY);
    }
    return rect;
  };
  return LargeLinesPath2;
}(Path$1);
var LargeLineDraw = function() {
  function LargeLineDraw2() {
    this.group = new Group$4();
  }
  LargeLineDraw2.prototype.updateData = function(data) {
    this._clear();
    var lineEl = this._create();
    lineEl.setShape({
      segs: data.getLayout("linesPoints")
    });
    this._setCommon(lineEl, data);
  };
  LargeLineDraw2.prototype.incrementalPrepareUpdate = function(data) {
    this.group.removeAll();
    this._clear();
  };
  LargeLineDraw2.prototype.incrementalUpdate = function(taskParams, data) {
    var lastAdded = this._newAdded[0];
    var linePoints = data.getLayout("linesPoints");
    var oldSegs = lastAdded && lastAdded.shape.segs;
    if (oldSegs && oldSegs.length < 2e4) {
      var oldLen = oldSegs.length;
      var newSegs = new Float32Array(oldLen + linePoints.length);
      newSegs.set(oldSegs);
      newSegs.set(linePoints, oldLen);
      lastAdded.setShape({
        segs: newSegs
      });
    } else {
      this._newAdded = [];
      var lineEl = this._create();
      lineEl.incremental = true;
      lineEl.setShape({
        segs: linePoints
      });
      this._setCommon(lineEl, data);
      lineEl.__startIndex = taskParams.start;
    }
  };
  LargeLineDraw2.prototype.remove = function() {
    this._clear();
  };
  LargeLineDraw2.prototype.eachRendered = function(cb) {
    this._newAdded[0] && cb(this._newAdded[0]);
  };
  LargeLineDraw2.prototype._create = function() {
    var lineEl = new LargeLinesPath({
      cursor: "default"
    });
    this._newAdded.push(lineEl);
    this.group.add(lineEl);
    return lineEl;
  };
  LargeLineDraw2.prototype._setCommon = function(lineEl, data, isIncremental) {
    var hostModel = data.hostModel;
    lineEl.setShape({
      polyline: hostModel.get("polyline"),
      curveness: hostModel.get(["lineStyle", "curveness"])
    });
    lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
    lineEl.style.strokeNoScale = true;
    var style = data.getVisual("style");
    if (style && style.stroke) {
      lineEl.setStyle("stroke", style.stroke);
    }
    lineEl.setStyle("fill", null);
    var ecData = getECData(lineEl);
    ecData.seriesIndex = hostModel.seriesIndex;
    lineEl.on("mousemove", function(e2) {
      ecData.dataIndex = null;
      var dataIndex = lineEl.hoverDataIdx;
      if (dataIndex > 0) {
        ecData.dataIndex = dataIndex + lineEl.__startIndex;
      }
    });
  };
  LargeLineDraw2.prototype._clear = function() {
    this._newAdded = [];
    this.group.removeAll();
  };
  return LargeLineDraw2;
}();
var LargeLineDraw$1 = LargeLineDraw;
var linesLayout = {
  seriesType: "lines",
  plan: createRenderPlanner(),
  reset: function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      return;
    }
    var isPolyline = seriesModel.get("polyline");
    var isLarge = seriesModel.pipelineContext.large;
    return {
      progress: function(params, lineData) {
        var lineCoords = [];
        if (isLarge) {
          var points2 = void 0;
          var segCount = params.end - params.start;
          if (isPolyline) {
            var totalCoordsCount = 0;
            for (var i = params.start; i < params.end; i++) {
              totalCoordsCount += seriesModel.getLineCoordsCount(i);
            }
            points2 = new Float32Array(segCount + totalCoordsCount * 2);
          } else {
            points2 = new Float32Array(segCount * 4);
          }
          var offset = 0;
          var pt = [];
          for (var i = params.start; i < params.end; i++) {
            var len2 = seriesModel.getLineCoords(i, lineCoords);
            if (isPolyline) {
              points2[offset++] = len2;
            }
            for (var k = 0; k < len2; k++) {
              pt = coordSys.dataToPoint(lineCoords[k], false, pt);
              points2[offset++] = pt[0];
              points2[offset++] = pt[1];
            }
          }
          lineData.setLayout("linesPoints", points2);
        } else {
          for (var i = params.start; i < params.end; i++) {
            var itemModel = lineData.getItemModel(i);
            var len2 = seriesModel.getLineCoords(i, lineCoords);
            var pts = [];
            if (isPolyline) {
              for (var j = 0; j < len2; j++) {
                pts.push(coordSys.dataToPoint(lineCoords[j]));
              }
            } else {
              pts[0] = coordSys.dataToPoint(lineCoords[0]);
              pts[1] = coordSys.dataToPoint(lineCoords[1]);
              var curveness = itemModel.get(["lineStyle", "curveness"]);
              if (+curveness) {
                pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
              }
            }
            lineData.setItemLayout(i, pts);
          }
        }
      }
    };
  }
};
var linesLayout$1 = linesLayout;
var LinesView = function(_super) {
  __extends(LinesView2, _super);
  function LinesView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LinesView2.type;
    return _this;
  }
  LinesView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var lineDraw = this._updateLineDraw(data, seriesModel);
    var zlevel = seriesModel.get("zlevel");
    var trailLength = seriesModel.get(["effect", "trailLength"]);
    var zr = api.getZr();
    var isSvg = zr.painter.getType() === "svg";
    if (!isSvg) {
      zr.painter.getLayer(zlevel).clear(true);
    }
    if (this._lastZlevel != null && !isSvg) {
      zr.configLayer(this._lastZlevel, {
        motionBlur: false
      });
    }
    if (this._showEffect(seriesModel) && trailLength > 0) {
      if (!isSvg) {
        zr.configLayer(zlevel, {
          motionBlur: true,
          lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
        });
      }
    }
    lineDraw.updateData(data);
    var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
    this._lastZlevel = zlevel;
    this._finished = true;
  };
  LinesView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var lineDraw = this._updateLineDraw(data, seriesModel);
    lineDraw.incrementalPrepareUpdate(data);
    this._clearLayer(api);
    this._finished = false;
  };
  LinesView2.prototype.incrementalRender = function(taskParams, seriesModel, ecModel) {
    this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
    this._finished = taskParams.end === seriesModel.getData().count();
  };
  LinesView2.prototype.eachRendered = function(cb) {
    this._lineDraw && this._lineDraw.eachRendered(cb);
  };
  LinesView2.prototype.updateTransform = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var pipelineContext = seriesModel.pipelineContext;
    if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
      return {
        update: true
      };
    } else {
      var res = linesLayout$1.reset(seriesModel, ecModel, api);
      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      }
      this._lineDraw.updateLayout();
      this._clearLayer(api);
    }
  };
  LinesView2.prototype._updateLineDraw = function(data, seriesModel) {
    var lineDraw = this._lineDraw;
    var hasEffect = this._showEffect(seriesModel);
    var isPolyline = !!seriesModel.get("polyline");
    var pipelineContext = seriesModel.pipelineContext;
    var isLargeDraw = pipelineContext.large;
    if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
      if (lineDraw) {
        lineDraw.remove();
      }
      lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw$1() : new LineDraw$1(isPolyline ? hasEffect ? EffectPolyline$1 : Polyline$1 : hasEffect ? EffectLine$1 : Line$1);
      this._hasEffet = hasEffect;
      this._isPolyline = isPolyline;
      this._isLargeDraw = isLargeDraw;
    }
    this.group.add(lineDraw.group);
    return lineDraw;
  };
  LinesView2.prototype._showEffect = function(seriesModel) {
    return !!seriesModel.get(["effect", "show"]);
  };
  LinesView2.prototype._clearLayer = function(api) {
    var zr = api.getZr();
    var isSvg = zr.painter.getType() === "svg";
    if (!isSvg && this._lastZlevel != null) {
      zr.painter.getLayer(this._lastZlevel).clear(true);
    }
  };
  LinesView2.prototype.remove = function(ecModel, api) {
    this._lineDraw && this._lineDraw.remove();
    this._lineDraw = null;
    this._clearLayer(api);
  };
  LinesView2.prototype.dispose = function(ecModel, api) {
    this.remove(ecModel, api);
  };
  LinesView2.type = "lines";
  return LinesView2;
}(ChartView$1);
var LinesView$1 = LinesView;
var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
function compatEc2(seriesOpt) {
  var data = seriesOpt.data;
  if (data && data[0] && data[0][0] && data[0][0].coord) {
    seriesOpt.data = map$1(data, function(itemOpt) {
      var coords = [itemOpt[0].coord, itemOpt[1].coord];
      var target = {
        coords
      };
      if (itemOpt[0].name) {
        target.fromName = itemOpt[0].name;
      }
      if (itemOpt[1].name) {
        target.toName = itemOpt[1].name;
      }
      return mergeAll([target, itemOpt[0], itemOpt[1]]);
    });
  }
}
var LinesSeriesModel = function(_super) {
  __extends(LinesSeriesModel2, _super);
  function LinesSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LinesSeriesModel2.type;
    _this.visualStyleAccessPath = "lineStyle";
    _this.visualDrawType = "stroke";
    return _this;
  }
  LinesSeriesModel2.prototype.init = function(option) {
    option.data = option.data || [];
    compatEc2(option);
    var result = this._processFlatCoordsArray(option.data);
    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;
    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }
    _super.prototype.init.apply(this, arguments);
  };
  LinesSeriesModel2.prototype.mergeOption = function(option) {
    compatEc2(option);
    if (option.data) {
      var result = this._processFlatCoordsArray(option.data);
      this._flatCoords = result.flatCoords;
      this._flatCoordsOffset = result.flatCoordsOffset;
      if (result.flatCoords) {
        option.data = new Float32Array(result.count);
      }
    }
    _super.prototype.mergeOption.apply(this, arguments);
  };
  LinesSeriesModel2.prototype.appendData = function(params) {
    var result = this._processFlatCoordsArray(params.data);
    if (result.flatCoords) {
      if (!this._flatCoords) {
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
      } else {
        this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
        this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
      }
      params.data = new Float32Array(result.count);
    }
    this.getRawData().appendData(params.data);
  };
  LinesSeriesModel2.prototype._getCoordsFromItemModel = function(idx) {
    var itemModel = this.getData().getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
    return coords;
  };
  LinesSeriesModel2.prototype.getLineCoordsCount = function(idx) {
    if (this._flatCoordsOffset) {
      return this._flatCoordsOffset[idx * 2 + 1];
    } else {
      return this._getCoordsFromItemModel(idx).length;
    }
  };
  LinesSeriesModel2.prototype.getLineCoords = function(idx, out2) {
    if (this._flatCoordsOffset) {
      var offset = this._flatCoordsOffset[idx * 2];
      var len2 = this._flatCoordsOffset[idx * 2 + 1];
      for (var i = 0; i < len2; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = this._flatCoords[offset + i * 2];
        out2[i][1] = this._flatCoords[offset + i * 2 + 1];
      }
      return len2;
    } else {
      var coords = this._getCoordsFromItemModel(idx);
      for (var i = 0; i < coords.length; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = coords[i][0];
        out2[i][1] = coords[i][1];
      }
      return coords.length;
    }
  };
  LinesSeriesModel2.prototype._processFlatCoordsArray = function(data) {
    var startOffset = 0;
    if (this._flatCoords) {
      startOffset = this._flatCoords.length;
    }
    if (isNumber(data[0])) {
      var len2 = data.length;
      var coordsOffsetAndLenStorage = new Uint32Arr(len2);
      var coordsStorage = new Float64Arr(len2);
      var coordsCursor = 0;
      var offsetCursor = 0;
      var dataCount = 0;
      for (var i = 0; i < len2; ) {
        dataCount++;
        var count2 = data[i++];
        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
        coordsOffsetAndLenStorage[offsetCursor++] = count2;
        for (var k = 0; k < count2; k++) {
          var x = data[i++];
          var y = data[i++];
          coordsStorage[coordsCursor++] = x;
          coordsStorage[coordsCursor++] = y;
        }
      }
      return {
        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
        flatCoords: coordsStorage,
        count: dataCount
      };
    }
    return {
      flatCoordsOffset: null,
      flatCoords: null,
      count: data.length
    };
  };
  LinesSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var lineData = new SeriesData$1(["value"], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        var value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  };
  LinesSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var itemModel = data.getItemModel(dataIndex);
    var name = itemModel.get("name");
    if (name) {
      return name;
    }
    var fromName = itemModel.get("fromName");
    var toName = itemModel.get("toName");
    var nameArr = [];
    fromName != null && nameArr.push(fromName);
    toName != null && nameArr.push(toName);
    return createTooltipMarkup("nameValue", {
      name: nameArr.join(" > ")
    });
  };
  LinesSeriesModel2.prototype.preventIncremental = function() {
    return !!this.get(["effect", "show"]);
  };
  LinesSeriesModel2.prototype.getProgressive = function() {
    var progressive = this.option.progressive;
    if (progressive == null) {
      return this.option.large ? 1e4 : this.get("progressive");
    }
    return progressive;
  };
  LinesSeriesModel2.prototype.getProgressiveThreshold = function() {
    var progressiveThreshold = this.option.progressiveThreshold;
    if (progressiveThreshold == null) {
      return this.option.large ? 2e4 : this.get("progressiveThreshold");
    }
    return progressiveThreshold;
  };
  LinesSeriesModel2.prototype.getZLevelKey = function() {
    var effectModel = this.getModel("effect");
    var trailLength = effectModel.get("trailLength");
    return this.getData().count() > this.getProgressiveThreshold() ? this.id : effectModel.get("show") && trailLength > 0 ? trailLength + "" : "";
  };
  LinesSeriesModel2.type = "series.lines";
  LinesSeriesModel2.dependencies = ["grid", "polar", "geo", "calendar"];
  LinesSeriesModel2.defaultOption = {
    coordinateSystem: "geo",
    z: 2,
    legendHoverLink: true,
    xAxisIndex: 0,
    yAxisIndex: 0,
    symbol: ["none", "none"],
    symbolSize: [10, 10],
    geoIndex: 0,
    effect: {
      show: false,
      period: 4,
      constantSpeed: 0,
      symbol: "circle",
      symbolSize: 3,
      loop: true,
      trailLength: 0.2
    },
    large: false,
    largeThreshold: 2e3,
    polyline: false,
    clip: true,
    label: {
      show: false,
      position: "end"
    },
    lineStyle: {
      opacity: 0.5
    }
  };
  return LinesSeriesModel2;
}(SeriesModel$1);
var LinesSeriesModel$1 = LinesSeriesModel;
function normalize$2(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
var linesVisual = {
  seriesType: "lines",
  reset: function(seriesModel) {
    var symbolType = normalize$2(seriesModel.get("symbol"));
    var symbolSize = normalize$2(seriesModel.get("symbolSize"));
    var data = seriesModel.getData();
    data.setVisual("fromSymbol", symbolType && symbolType[0]);
    data.setVisual("toSymbol", symbolType && symbolType[1]);
    data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
    data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
    function dataEach(data2, idx) {
      var itemModel = data2.getItemModel(idx);
      var symbolType2 = normalize$2(itemModel.getShallow("symbol", true));
      var symbolSize2 = normalize$2(itemModel.getShallow("symbolSize", true));
      symbolType2[0] && data2.setItemVisual(idx, "fromSymbol", symbolType2[0]);
      symbolType2[1] && data2.setItemVisual(idx, "toSymbol", symbolType2[1]);
      symbolSize2[0] && data2.setItemVisual(idx, "fromSymbolSize", symbolSize2[0]);
      symbolSize2[1] && data2.setItemVisual(idx, "toSymbolSize", symbolSize2[1]);
    }
    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};
var linesVisual$1 = linesVisual;
function install$M(registers) {
  registers.registerChartView(LinesView$1);
  registers.registerSeriesModel(LinesSeriesModel$1);
  registers.registerLayout(linesLayout$1);
  registers.registerVisual(linesVisual$1);
}
var GRADIENT_LEVELS = 256;
var HeatmapLayer = function() {
  function HeatmapLayer2() {
    this.blurSize = 30;
    this.pointSize = 20;
    this.maxOpacity = 1;
    this.minOpacity = 0;
    this._gradientPixels = {
      inRange: null,
      outOfRange: null
    };
    var canvas = platformApi.createCanvas();
    this.canvas = canvas;
  }
  HeatmapLayer2.prototype.update = function(data, width, height, normalize2, colorFunc, isInRange) {
    var brush2 = this._getBrush();
    var gradientInRange = this._getGradient(colorFunc, "inRange");
    var gradientOutOfRange = this._getGradient(colorFunc, "outOfRange");
    var r = this.pointSize + this.blurSize;
    var canvas = this.canvas;
    var ctx = canvas.getContext("2d");
    var len2 = data.length;
    canvas.width = width;
    canvas.height = height;
    for (var i = 0; i < len2; ++i) {
      var p = data[i];
      var x = p[0];
      var y = p[1];
      var value = p[2];
      var alpha = normalize2(value);
      ctx.globalAlpha = alpha;
      ctx.drawImage(brush2, x - r, y - r);
    }
    if (!canvas.width || !canvas.height) {
      return canvas;
    }
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    var pixels = imageData.data;
    var offset = 0;
    var pixelLen = pixels.length;
    var minOpacity = this.minOpacity;
    var maxOpacity = this.maxOpacity;
    var diffOpacity = maxOpacity - minOpacity;
    while (offset < pixelLen) {
      var alpha = pixels[offset + 3] / 256;
      var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
      if (alpha > 0) {
        var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
        alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
        pixels[offset++] = gradient[gradientOffset];
        pixels[offset++] = gradient[gradientOffset + 1];
        pixels[offset++] = gradient[gradientOffset + 2];
        pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
      } else {
        offset += 4;
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  };
  HeatmapLayer2.prototype._getBrush = function() {
    var brushCanvas = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas());
    var r = this.pointSize + this.blurSize;
    var d = r * 2;
    brushCanvas.width = d;
    brushCanvas.height = d;
    var ctx = brushCanvas.getContext("2d");
    ctx.clearRect(0, 0, d, d);
    ctx.shadowOffsetX = d;
    ctx.shadowBlur = this.blurSize;
    ctx.shadowColor = "#000";
    ctx.beginPath();
    ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    return brushCanvas;
  };
  HeatmapLayer2.prototype._getGradient = function(colorFunc, state) {
    var gradientPixels = this._gradientPixels;
    var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
    var color = [0, 0, 0, 0];
    var off = 0;
    for (var i = 0; i < 256; i++) {
      colorFunc[state](i / 255, true, color);
      pixelsSingleState[off++] = color[0];
      pixelsSingleState[off++] = color[1];
      pixelsSingleState[off++] = color[2];
      pixelsSingleState[off++] = color[3];
    }
    return pixelsSingleState;
  };
  return HeatmapLayer2;
}();
var HeatmapLayer$1 = HeatmapLayer;
function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
  var dataSpan = dataExtent[1] - dataExtent[0];
  pieceList = map$1(pieceList, function(piece) {
    return {
      interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
    };
  });
  var len2 = pieceList.length;
  var lastIndex = 0;
  return function(val) {
    var i;
    for (i = lastIndex; i < len2; i++) {
      var interval = pieceList[i].interval;
      if (interval[0] <= val && val <= interval[1]) {
        lastIndex = i;
        break;
      }
    }
    if (i === len2) {
      for (i = lastIndex - 1; i >= 0; i--) {
        var interval = pieceList[i].interval;
        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
    }
    return i >= 0 && i < len2 && selected[i];
  };
}
function getIsInContinuousRange(dataExtent, range) {
  var dataSpan = dataExtent[1] - dataExtent[0];
  range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
  return function(val) {
    return val >= range[0] && val <= range[1];
  };
}
function isGeoCoordSys(coordSys) {
  var dimensions = coordSys.dimensions;
  return dimensions[0] === "lng" && dimensions[1] === "lat";
}
var HeatmapView = function(_super) {
  __extends(HeatmapView2, _super);
  function HeatmapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = HeatmapView2.type;
    return _this;
  }
  HeatmapView2.prototype.render = function(seriesModel, ecModel, api) {
    var visualMapOfThisSeries;
    ecModel.eachComponent("visualMap", function(visualMap) {
      visualMap.eachTargetSeries(function(targetSeries) {
        if (targetSeries === seriesModel) {
          visualMapOfThisSeries = visualMap;
        }
      });
    });
    this._progressiveEls = null;
    this.group.removeAll();
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys.type === "cartesian2d" || coordSys.type === "calendar") {
      this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
    } else if (isGeoCoordSys(coordSys)) {
      this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
    }
  };
  HeatmapView2.prototype.incrementalPrepareRender = function(seriesModel, ecModel, api) {
    this.group.removeAll();
  };
  HeatmapView2.prototype.incrementalRender = function(params, seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys) {
      if (isGeoCoordSys(coordSys)) {
        this.render(seriesModel, ecModel, api);
      } else {
        this._progressiveEls = [];
        this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
      }
    }
  };
  HeatmapView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  HeatmapView2.prototype._renderOnCartesianAndCalendar = function(seriesModel, api, start2, end2, incremental) {
    var coordSys = seriesModel.coordinateSystem;
    var width;
    var height;
    var xAxisExtent;
    var yAxisExtent;
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      var xAxis = coordSys.getAxis("x");
      var yAxis = coordSys.getAxis("y");
      width = xAxis.getBandWidth();
      height = yAxis.getBandWidth();
      xAxisExtent = xAxis.scale.getExtent();
      yAxisExtent = yAxis.scale.getExtent();
    }
    var group = this.group;
    var data = seriesModel.getData();
    var emphasisStyle = seriesModel.getModel(["emphasis", "itemStyle"]).getItemStyle();
    var blurStyle = seriesModel.getModel(["blur", "itemStyle"]).getItemStyle();
    var selectStyle = seriesModel.getModel(["select", "itemStyle"]).getItemStyle();
    var labelStatesModels = getLabelStatesModels(seriesModel);
    var emphasisModel = seriesModel.getModel("emphasis");
    var focus = emphasisModel.get("focus");
    var blurScope = emphasisModel.get("blurScope");
    var emphasisDisabled = emphasisModel.get("disabled");
    var dataDims = isCoordinateSystemType(coordSys, "cartesian2d") ? [data.mapDimension("x"), data.mapDimension("y"), data.mapDimension("value")] : [data.mapDimension("time"), data.mapDimension("value")];
    for (var idx = start2; idx < end2; idx++) {
      var rect = void 0;
      var style = data.getItemVisual(idx, "style");
      if (isCoordinateSystemType(coordSys, "cartesian2d")) {
        var dataDimX = data.get(dataDims[0], idx);
        var dataDimY = data.get(dataDims[1], idx);
        if (isNaN(data.get(dataDims[2], idx)) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {
          continue;
        }
        var point = coordSys.dataToPoint([dataDimX, dataDimY]);
        rect = new Rect$3({
          shape: {
            x: Math.floor(Math.round(point[0]) - width / 2),
            y: Math.floor(Math.round(point[1]) - height / 2),
            width: Math.ceil(width),
            height: Math.ceil(height)
          },
          style
        });
      } else {
        if (isNaN(data.get(dataDims[1], idx))) {
          continue;
        }
        rect = new Rect$3({
          z2: 1,
          shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
          style
        });
      }
      var itemModel = data.getItemModel(idx);
      if (data.hasItemOption) {
        var emphasisModel_1 = itemModel.getModel("emphasis");
        emphasisStyle = emphasisModel_1.getModel("itemStyle").getItemStyle();
        blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
        selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
        focus = emphasisModel_1.get("focus");
        blurScope = emphasisModel_1.get("blurScope");
        emphasisDisabled = emphasisModel_1.get("disabled");
        labelStatesModels = getLabelStatesModels(itemModel);
      }
      var rawValue = seriesModel.getRawValue(idx);
      var defaultText = "-";
      if (rawValue && rawValue[2] != null) {
        defaultText = rawValue[2] + "";
      }
      setLabelStyle(rect, labelStatesModels, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultOpacity: style.opacity,
        defaultText
      });
      rect.ensureState("emphasis").style = emphasisStyle;
      rect.ensureState("blur").style = blurStyle;
      rect.ensureState("select").style = selectStyle;
      toggleHoverEmphasis(rect, focus, blurScope, emphasisDisabled);
      rect.incremental = incremental;
      if (incremental) {
        rect.states.emphasis.hoverLayer = true;
      }
      group.add(rect);
      data.setItemGraphicEl(idx, rect);
      if (this._progressiveEls) {
        this._progressiveEls.push(rect);
      }
    }
  };
  HeatmapView2.prototype._renderOnGeo = function(geo, seriesModel, visualMapModel, api) {
    var inRangeVisuals = visualMapModel.targetVisuals.inRange;
    var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
    var data = seriesModel.getData();
    var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer$1();
    hmLayer.blurSize = seriesModel.get("blurSize");
    hmLayer.pointSize = seriesModel.get("pointSize");
    hmLayer.minOpacity = seriesModel.get("minOpacity");
    hmLayer.maxOpacity = seriesModel.get("maxOpacity");
    var rect = geo.getViewRect().clone();
    var roamTransform = geo.getRoamTransform();
    rect.applyTransform(roamTransform);
    var x = Math.max(rect.x, 0);
    var y = Math.max(rect.y, 0);
    var x2 = Math.min(rect.width + rect.x, api.getWidth());
    var y2 = Math.min(rect.height + rect.y, api.getHeight());
    var width = x2 - x;
    var height = y2 - y;
    var dims = [data.mapDimension("lng"), data.mapDimension("lat"), data.mapDimension("value")];
    var points2 = data.mapArray(dims, function(lng, lat, value) {
      var pt = geo.dataToPoint([lng, lat]);
      pt[0] -= x;
      pt[1] -= y;
      pt.push(value);
      return pt;
    });
    var dataExtent = visualMapModel.getExtent();
    var isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
    hmLayer.update(points2, width, height, inRangeVisuals.color.getNormalizer(), {
      inRange: inRangeVisuals.color.getColorMapper(),
      outOfRange: outOfRangeVisuals.color.getColorMapper()
    }, isInRange);
    var img = new ZRImage$1({
      style: {
        width,
        height,
        x,
        y,
        image: hmLayer.canvas
      },
      silent: true
    });
    this.group.add(img);
  };
  HeatmapView2.type = "heatmap";
  return HeatmapView2;
}(ChartView$1);
var HeatmapView$1 = HeatmapView;
var HeatmapSeriesModel = function(_super) {
  __extends(HeatmapSeriesModel2, _super);
  function HeatmapSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = HeatmapSeriesModel2.type;
    return _this;
  }
  HeatmapSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this, {
      generateCoord: "value"
    });
  };
  HeatmapSeriesModel2.prototype.preventIncremental = function() {
    var coordSysCreator = CoordinateSystem.get(this.get("coordinateSystem"));
    if (coordSysCreator && coordSysCreator.dimensions) {
      return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
    }
  };
  HeatmapSeriesModel2.type = "series.heatmap";
  HeatmapSeriesModel2.dependencies = ["grid", "geo", "calendar"];
  HeatmapSeriesModel2.defaultOption = {
    coordinateSystem: "cartesian2d",
    z: 2,
    geoIndex: 0,
    blurSize: 30,
    pointSize: 20,
    maxOpacity: 1,
    minOpacity: 0,
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  };
  return HeatmapSeriesModel2;
}(SeriesModel$1);
var HeatmapSeriesModel$1 = HeatmapSeriesModel;
function install$L(registers) {
  registers.registerChartView(HeatmapView$1);
  registers.registerSeriesModel(HeatmapSeriesModel$1);
}
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
var LAYOUT_ATTRS = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}];
var pathForLineWidth = new Circle$1();
var PictorialBarView = function(_super) {
  __extends(PictorialBarView2, _super);
  function PictorialBarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PictorialBarView2.type;
    return _this;
  }
  PictorialBarView2.prototype.render = function(seriesModel, ecModel, api) {
    var group = this.group;
    var data = seriesModel.getData();
    var oldData = this._data;
    var cartesian = seriesModel.coordinateSystem;
    var baseAxis = cartesian.getBaseAxis();
    var isHorizontal = baseAxis.isHorizontal();
    var coordSysRect = cartesian.master.getRect();
    var opt = {
      ecSize: {
        width: api.getWidth(),
        height: api.getHeight()
      },
      seriesModel,
      coordSys: cartesian,
      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
      isHorizontal,
      valueDim: LAYOUT_ATTRS[+isHorizontal],
      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]
    };
    data.diff(oldData).add(function(dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }
      var itemModel = getItemModel(data, dataIndex);
      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
      var bar = createBar(data, opt, symbolMeta);
      data.setItemGraphicEl(dataIndex, bar);
      group.add(bar);
      updateCommon(bar, opt, symbolMeta);
    }).update(function(newIndex, oldIndex) {
      var bar = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex)) {
        group.remove(bar);
        return;
      }
      var itemModel = getItemModel(data, newIndex);
      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
      var pictorialShapeStr = getShapeStr(data, symbolMeta);
      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
        group.remove(bar);
        data.setItemGraphicEl(newIndex, null);
        bar = null;
      }
      if (bar) {
        updateBar(bar, opt, symbolMeta);
      } else {
        bar = createBar(data, opt, symbolMeta, true);
      }
      data.setItemGraphicEl(newIndex, bar);
      bar.__pictorialSymbolMeta = symbolMeta;
      group.add(bar);
      updateCommon(bar, opt, symbolMeta);
    }).remove(function(dataIndex) {
      var bar = oldData.getItemGraphicEl(dataIndex);
      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
    }).execute();
    this._data = data;
    return this.group;
  };
  PictorialBarView2.prototype.remove = function(ecModel, api) {
    var group = this.group;
    var data = this._data;
    if (ecModel.get("animation")) {
      if (data) {
        data.eachItemGraphicEl(function(bar) {
          removeBar(data, getECData(bar).dataIndex, ecModel, bar);
        });
      }
    } else {
      group.removeAll();
    }
  };
  PictorialBarView2.type = "pictorialBar";
  return PictorialBarView2;
}(ChartView$1);
function getSymbolMeta(data, dataIndex, itemModel, opt) {
  var layout2 = data.getItemLayout(dataIndex);
  var symbolRepeat = itemModel.get("symbolRepeat");
  var symbolClip = itemModel.get("symbolClip");
  var symbolPosition = itemModel.get("symbolPosition") || "start";
  var symbolRotate = itemModel.get("symbolRotate");
  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  var symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
  var isAnimationEnabled2 = itemModel.isAnimationEnabled();
  var symbolMeta = {
    dataIndex,
    layout: layout2,
    itemModel,
    symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
    style: data.getItemVisual(dataIndex, "style"),
    symbolClip,
    symbolRepeat,
    symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
    symbolPatternSize,
    rotation,
    animationModel: isAnimationEnabled2 ? itemModel : null,
    hoverScale: isAnimationEnabled2 && itemModel.get(["emphasis", "scale"]),
    z2: itemModel.getShallow("z", true) || 0
  };
  prepareBarLength(itemModel, symbolRepeat, layout2, opt, symbolMeta);
  prepareSymbolSize(data, dataIndex, layout2, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
  var symbolSize = symbolMeta.symbolSize;
  var symbolOffset = normalizeSymbolOffset(itemModel.get("symbolOffset"), symbolSize);
  prepareLayoutInfo(itemModel, symbolSize, layout2, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
  return symbolMeta;
}
function prepareBarLength(itemModel, symbolRepeat, layout2, opt, outputSymbolMeta) {
  var valueDim = opt.valueDim;
  var symbolBoundingData = itemModel.get("symbolBoundingData");
  var valueAxis2 = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
  var zeroPx = valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(0));
  var pxSignIdx = 1 - +(layout2[valueDim.wh] <= 0);
  var boundingLength;
  if (isArray$1(symbolBoundingData)) {
    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis2, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis2, symbolBoundingData[1]) - zeroPx];
    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
    boundingLength = symbolBoundingExtent[pxSignIdx];
  } else if (symbolBoundingData != null) {
    boundingLength = convertToCoordOnAxis(valueAxis2, symbolBoundingData) - zeroPx;
  } else if (symbolRepeat) {
    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
  } else {
    boundingLength = layout2[valueDim.wh];
  }
  outputSymbolMeta.boundingLength = boundingLength;
  if (symbolRepeat) {
    outputSymbolMeta.repeatCutLength = layout2[valueDim.wh];
  }
  outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : -1;
}
function convertToCoordOnAxis(axis, value) {
  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
}
function prepareSymbolSize(data, dataIndex, layout2, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
  var valueDim = opt.valueDim;
  var categoryDim = opt.categoryDim;
  var categorySize = Math.abs(layout2[categoryDim.wh]);
  var symbolSize = data.getItemVisual(dataIndex, "symbolSize");
  var parsedSymbolSize;
  if (isArray$1(symbolSize)) {
    parsedSymbolSize = symbolSize.slice();
  } else {
    if (symbolSize == null) {
      parsedSymbolSize = ["100%", "100%"];
    } else {
      parsedSymbolSize = [symbolSize, symbolSize];
    }
  }
  parsedSymbolSize[categoryDim.index] = parsePercent$1(parsedSymbolSize[categoryDim.index], categorySize);
  parsedSymbolSize[valueDim.index] = parsePercent$1(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
  outputSymbolMeta.symbolSize = parsedSymbolSize;
  var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize];
  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
}
function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
  if (valueLineWidth) {
    pathForLineWidth.attr({
      scaleX: symbolScale[0],
      scaleY: symbolScale[1],
      rotation
    });
    pathForLineWidth.updateTransform();
    valueLineWidth /= pathForLineWidth.getLineScale();
    valueLineWidth *= symbolScale[opt.valueDim.index];
  }
  outputSymbolMeta.valueLineWidth = valueLineWidth;
}
function prepareLayoutInfo(itemModel, symbolSize, layout2, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
  var categoryDim = opt.categoryDim;
  var valueDim = opt.valueDim;
  var pxSign = outputSymbolMeta.pxSign;
  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
  var pathLen = unitLength;
  if (symbolRepeat) {
    var absBoundingLength = Math.abs(boundingLength);
    var symbolMargin = retrieve$2(itemModel.get("symbolMargin"), "15%") + "";
    var hasEndGap = false;
    if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
      hasEndGap = true;
      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
    }
    var symbolMarginNumeric = parsePercent$1(symbolMargin, symbolSize[valueDim.index]);
    var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);
    var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    var repeatSpecified = isNumeric(symbolRepeat);
    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
    var mDiff = absBoundingLength - repeatTimes * unitLength;
    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));
    uLenWithMargin = unitLength + symbolMarginNumeric * 2;
    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    if (!repeatSpecified && symbolRepeat !== "fixed") {
      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
    }
    pathLen = repeatTimes * uLenWithMargin - endFix;
    outputSymbolMeta.repeatTimes = repeatTimes;
    outputSymbolMeta.symbolMargin = symbolMarginNumeric;
  }
  var sizeFix = pxSign * (pathLen / 2);
  var pathPosition = outputSymbolMeta.pathPosition = [];
  pathPosition[categoryDim.index] = layout2[categoryDim.wh] / 2;
  pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
  if (symbolOffset) {
    pathPosition[0] += symbolOffset[0];
    pathPosition[1] += symbolOffset[1];
  }
  var bundlePosition = outputSymbolMeta.bundlePosition = [];
  bundlePosition[categoryDim.index] = layout2[categoryDim.xy];
  bundlePosition[valueDim.index] = layout2[valueDim.xy];
  var barRectShape = outputSymbolMeta.barRectShape = extend$1({}, layout2);
  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout2[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
  barRectShape[categoryDim.wh] = layout2[categoryDim.wh];
  var clipShape = outputSymbolMeta.clipShape = {};
  clipShape[categoryDim.xy] = -layout2[categoryDim.xy];
  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
  clipShape[valueDim.xy] = 0;
  clipShape[valueDim.wh] = layout2[valueDim.wh];
}
function createPath(symbolMeta) {
  var symbolPatternSize = symbolMeta.symbolPatternSize;
  var path = createSymbol$1(symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);
  path.attr({
    culling: true
  });
  path.type !== "image" && path.setStyle({
    strokeNoScale: true
  });
  return path;
}
function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
  var bundle = bar.__pictorialBundle;
  var symbolSize = symbolMeta.symbolSize;
  var valueLineWidth = symbolMeta.valueLineWidth;
  var pathPosition = symbolMeta.pathPosition;
  var valueDim = opt.valueDim;
  var repeatTimes = symbolMeta.repeatTimes || 0;
  var index = 0;
  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
  eachPath(bar, function(path2) {
    path2.__pictorialAnimationIndex = index;
    path2.__pictorialRepeatTimes = repeatTimes;
    if (index < repeatTimes) {
      updateAttr(path2, null, makeTarget(index), symbolMeta, isUpdate);
    } else {
      updateAttr(path2, null, {
        scaleX: 0,
        scaleY: 0
      }, symbolMeta, isUpdate, function() {
        bundle.remove(path2);
      });
    }
    index++;
  });
  for (; index < repeatTimes; index++) {
    var path = createPath(symbolMeta);
    path.__pictorialAnimationIndex = index;
    path.__pictorialRepeatTimes = repeatTimes;
    bundle.add(path);
    var target = makeTarget(index);
    updateAttr(path, {
      x: target.x,
      y: target.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: target.scaleX,
      scaleY: target.scaleY,
      rotation: target.rotation
    }, symbolMeta, isUpdate);
  }
  function makeTarget(index2) {
    var position2 = pathPosition.slice();
    var pxSign = symbolMeta.pxSign;
    var i = index2;
    if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
      i = repeatTimes - 1 - index2;
    }
    position2[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
    return {
      x: position2[0],
      y: position2[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    };
  }
}
function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
  var bundle = bar.__pictorialBundle;
  var mainPath = bar.__pictorialMainPath;
  if (!mainPath) {
    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
    bundle.add(mainPath);
    updateAttr(mainPath, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: symbolMeta.rotation
    }, {
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1]
    }, symbolMeta, isUpdate);
  } else {
    updateAttr(mainPath, null, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    }, symbolMeta, isUpdate);
  }
}
function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
  var rectShape = extend$1({}, symbolMeta.barRectShape);
  var barRect = bar.__pictorialBarRect;
  if (!barRect) {
    barRect = bar.__pictorialBarRect = new Rect$3({
      z2: 2,
      shape: rectShape,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    });
    barRect.disableMorphing = true;
    bar.add(barRect);
  } else {
    updateAttr(barRect, null, {
      shape: rectShape
    }, symbolMeta, isUpdate);
  }
}
function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
  if (symbolMeta.symbolClip) {
    var clipPath = bar.__pictorialClipPath;
    var clipShape = extend$1({}, symbolMeta.clipShape);
    var valueDim = opt.valueDim;
    var animationModel = symbolMeta.animationModel;
    var dataIndex = symbolMeta.dataIndex;
    if (clipPath) {
      updateProps$1(clipPath, {
        shape: clipShape
      }, animationModel, dataIndex);
    } else {
      clipShape[valueDim.wh] = 0;
      clipPath = new Rect$3({
        shape: clipShape
      });
      bar.__pictorialBundle.setClipPath(clipPath);
      bar.__pictorialClipPath = clipPath;
      var target = {};
      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
      graphic[isUpdate ? "updateProps" : "initProps"](clipPath, {
        shape: target
      }, animationModel, dataIndex);
    }
  }
}
function getItemModel(data, dataIndex) {
  var itemModel = data.getItemModel(dataIndex);
  itemModel.getAnimationDelayParams = getAnimationDelayParams;
  itemModel.isAnimationEnabled = isAnimationEnabled;
  return itemModel;
}
function getAnimationDelayParams(path) {
  return {
    index: path.__pictorialAnimationIndex,
    count: path.__pictorialRepeatTimes
  };
}
function isAnimationEnabled() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(data, opt, symbolMeta, isUpdate) {
  var bar = new Group$4();
  var bundle = new Group$4();
  bar.add(bundle);
  bar.__pictorialBundle = bundle;
  bundle.x = symbolMeta.bundlePosition[0];
  bundle.y = symbolMeta.bundlePosition[1];
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta);
  }
  createOrUpdateBarRect(bar, symbolMeta, isUpdate);
  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
  bar.__pictorialSymbolMeta = symbolMeta;
  return bar;
}
function updateBar(bar, opt, symbolMeta) {
  var animationModel = symbolMeta.animationModel;
  var dataIndex = symbolMeta.dataIndex;
  var bundle = bar.__pictorialBundle;
  updateProps$1(bundle, {
    x: symbolMeta.bundlePosition[0],
    y: symbolMeta.bundlePosition[1]
  }, animationModel, dataIndex);
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
  }
  createOrUpdateBarRect(bar, symbolMeta, true);
  createOrUpdateClip(bar, opt, symbolMeta, true);
}
function removeBar(data, dataIndex, animationModel, bar) {
  var labelRect = bar.__pictorialBarRect;
  labelRect && labelRect.removeTextContent();
  var pathes = [];
  eachPath(bar, function(path) {
    pathes.push(path);
  });
  bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath);
  bar.__pictorialClipPath && (animationModel = null);
  each$f(pathes, function(path) {
    removeElement(path, {
      scaleX: 0,
      scaleY: 0
    }, animationModel, dataIndex, function() {
      bar.parent && bar.parent.remove(bar);
    });
  });
  data.setItemGraphicEl(dataIndex, null);
}
function getShapeStr(data, symbolMeta) {
  return [data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none", !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(":");
}
function eachPath(bar, cb, context) {
  each$f(bar.__pictorialBundle.children(), function(el) {
    el !== bar.__pictorialBarRect && cb.call(context, el);
  });
}
function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
  immediateAttrs && el.attr(immediateAttrs);
  if (symbolMeta.symbolClip && !isUpdate) {
    animationAttrs && el.attr(animationAttrs);
  } else {
    animationAttrs && graphic[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
  }
}
function updateCommon(bar, opt, symbolMeta) {
  var dataIndex = symbolMeta.dataIndex;
  var itemModel = symbolMeta.itemModel;
  var emphasisModel = itemModel.getModel("emphasis");
  var emphasisStyle = emphasisModel.getModel("itemStyle").getItemStyle();
  var blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
  var selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
  var cursorStyle = itemModel.getShallow("cursor");
  var focus = emphasisModel.get("focus");
  var blurScope = emphasisModel.get("blurScope");
  var hoverScale = emphasisModel.get("scale");
  eachPath(bar, function(path) {
    if (path instanceof ZRImage$1) {
      var pathStyle = path.style;
      path.useStyle(extend$1({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolMeta.style));
    } else {
      path.useStyle(symbolMeta.style);
    }
    var emphasisState = path.ensureState("emphasis");
    emphasisState.style = emphasisStyle;
    if (hoverScale) {
      emphasisState.scaleX = path.scaleX * 1.1;
      emphasisState.scaleY = path.scaleY * 1.1;
    }
    path.ensureState("blur").style = blurStyle;
    path.ensureState("select").style = selectStyle;
    cursorStyle && (path.cursor = cursorStyle);
    path.z2 = symbolMeta.z2;
  });
  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
  var barRect = bar.__pictorialBarRect;
  setLabelStyle(barRect, getLabelStatesModels(itemModel), {
    labelFetcher: opt.seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),
    inheritColor: symbolMeta.style.fill,
    defaultOpacity: symbolMeta.style.opacity,
    defaultOutsidePosition: barPositionOutside
  });
  toggleHoverEmphasis(bar, focus, blurScope, emphasisModel.get("disabled"));
}
function toIntTimes(times) {
  var roundedTimes = Math.round(times);
  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
}
var PictorialBarView$1 = PictorialBarView;
var PictorialBarSeriesModel = function(_super) {
  __extends(PictorialBarSeriesModel2, _super);
  function PictorialBarSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PictorialBarSeriesModel2.type;
    _this.hasSymbolVisual = true;
    _this.defaultSymbol = "roundRect";
    return _this;
  }
  PictorialBarSeriesModel2.prototype.getInitialData = function(option) {
    option.stack = null;
    return _super.prototype.getInitialData.apply(this, arguments);
  };
  PictorialBarSeriesModel2.type = "series.pictorialBar";
  PictorialBarSeriesModel2.dependencies = ["grid"];
  PictorialBarSeriesModel2.defaultOption = inheritDefaultOption(BaseBarSeriesModel$1.defaultOption, {
    symbol: "circle",
    symbolSize: null,
    symbolRotate: null,
    symbolPosition: null,
    symbolOffset: null,
    symbolMargin: null,
    symbolRepeat: false,
    symbolRepeatDirection: "end",
    symbolClip: false,
    symbolBoundingData: null,
    symbolPatternSize: 400,
    barGap: "-100%",
    progressive: 0,
    emphasis: {
      scale: false
    },
    select: {
      itemStyle: {
        borderColor: "#212121"
      }
    }
  });
  return PictorialBarSeriesModel2;
}(BaseBarSeriesModel$1);
var PictorialBarSeriesModel$1 = PictorialBarSeriesModel;
function install$K(registers) {
  registers.registerChartView(PictorialBarView$1);
  registers.registerSeriesModel(PictorialBarSeriesModel$1);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, "pictorialBar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}
var ThemeRiverView = function(_super) {
  __extends(ThemeRiverView2, _super);
  function ThemeRiverView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ThemeRiverView2.type;
    _this._layers = [];
    return _this;
  }
  ThemeRiverView2.prototype.render = function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var self2 = this;
    var group = this.group;
    var layersSeries = seriesModel.getLayerSeries();
    var layoutInfo = data.getLayout("layoutInfo");
    var rect = layoutInfo.rect;
    var boundaryGap = layoutInfo.boundaryGap;
    group.x = 0;
    group.y = rect.y + boundaryGap[0];
    function keyGetter(item) {
      return item.name;
    }
    var dataDiffer = new DataDiffer$1(this._layersSeries || [], layersSeries, keyGetter, keyGetter);
    var newLayersGroups = [];
    dataDiffer.add(bind$1(process, this, "add")).update(bind$1(process, this, "update")).remove(bind$1(process, this, "remove")).execute();
    function process(status, idx, oldIdx) {
      var oldLayersGroups = self2._layers;
      if (status === "remove") {
        group.remove(oldLayersGroups[idx]);
        return;
      }
      var points0 = [];
      var points1 = [];
      var style;
      var indices = layersSeries[idx].indices;
      var j = 0;
      for (; j < indices.length; j++) {
        var layout2 = data.getItemLayout(indices[j]);
        var x = layout2.x;
        var y0 = layout2.y0;
        var y = layout2.y;
        points0.push(x, y0);
        points1.push(x, y0 + y);
        style = data.getItemVisual(indices[j], "style");
      }
      var polygon;
      var textLayout = data.getItemLayout(indices[0]);
      var labelModel = seriesModel.getModel("label");
      var margin = labelModel.get("margin");
      var emphasisModel = seriesModel.getModel("emphasis");
      if (status === "add") {
        var layerGroup = newLayersGroups[idx] = new Group$4();
        polygon = new ECPolygon({
          shape: {
            points: points0,
            stackedOnPoints: points1,
            smooth: 0.4,
            stackedOnSmooth: 0.4,
            smoothConstraint: false
          },
          z2: 0
        });
        layerGroup.add(polygon);
        group.add(layerGroup);
        if (seriesModel.isAnimationEnabled()) {
          polygon.setClipPath(createGridClipShape(polygon.getBoundingRect(), seriesModel, function() {
            polygon.removeClipPath();
          }));
        }
      } else {
        var layerGroup = oldLayersGroups[oldIdx];
        polygon = layerGroup.childAt(0);
        group.add(layerGroup);
        newLayersGroups[idx] = layerGroup;
        updateProps$1(polygon, {
          shape: {
            points: points0,
            stackedOnPoints: points1
          }
        }, seriesModel);
        saveOldStyle(polygon);
      }
      setLabelStyle(polygon, getLabelStatesModels(seriesModel), {
        labelDataIndex: indices[j - 1],
        defaultText: data.getName(indices[j - 1]),
        inheritColor: style.fill
      }, {
        normal: {
          verticalAlign: "middle"
        }
      });
      polygon.setTextConfig({
        position: null,
        local: true
      });
      var labelEl = polygon.getTextContent();
      if (labelEl) {
        labelEl.x = textLayout.x - margin;
        labelEl.y = textLayout.y0 + textLayout.y / 2;
      }
      polygon.useStyle(style);
      data.setItemGraphicEl(idx, polygon);
      setStatesStylesFromModel(polygon, seriesModel);
      toggleHoverEmphasis(polygon, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    }
    this._layersSeries = layersSeries;
    this._layers = newLayersGroups;
  };
  ThemeRiverView2.type = "themeRiver";
  return ThemeRiverView2;
}(ChartView$1);
function createGridClipShape(rect, seriesModel, cb) {
  var rectEl = new Rect$3({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  initProps(rectEl, {
    shape: {
      x: rect.x - 50,
      width: rect.width + 100,
      height: rect.height + 20
    }
  }, seriesModel, cb);
  return rectEl;
}
var ThemeRiverView$1 = ThemeRiverView;
var DATA_NAME_INDEX = 2;
var ThemeRiverSeriesModel = function(_super) {
  __extends(ThemeRiverSeriesModel2, _super);
  function ThemeRiverSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ThemeRiverSeriesModel2.type;
    return _this;
  }
  ThemeRiverSeriesModel2.prototype.init = function(option) {
    _super.prototype.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider$1(bind$1(this.getData, this), bind$1(this.getRawData, this));
  };
  ThemeRiverSeriesModel2.prototype.fixData = function(data) {
    var rawDataLength = data.length;
    var timeValueKeys = {};
    var groupResult = groupData(data, function(item) {
      if (!timeValueKeys.hasOwnProperty(item[0] + "")) {
        timeValueKeys[item[0] + ""] = -1;
      }
      return item[2];
    });
    var layerData = [];
    groupResult.buckets.each(function(items, key) {
      layerData.push({
        name: key,
        dataList: items
      });
    });
    var layerNum = layerData.length;
    for (var k = 0; k < layerNum; ++k) {
      var name_1 = layerData[k].name;
      for (var j = 0; j < layerData[k].dataList.length; ++j) {
        var timeValue = layerData[k].dataList[j][0] + "";
        timeValueKeys[timeValue] = k;
      }
      for (var timeValue in timeValueKeys) {
        if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
          timeValueKeys[timeValue] = k;
          data[rawDataLength] = [timeValue, 0, name_1];
          rawDataLength++;
        }
      }
    }
    return data;
  };
  ThemeRiverSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var singleAxisModel = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    var axisType = singleAxisModel.get("type");
    var filterData = filter(option.data, function(dataItem) {
      return dataItem[2] !== void 0;
    });
    var data = this.fixData(filterData || []);
    var nameList = [];
    var nameMap = this.nameMap = createHashMap();
    var count2 = 0;
    for (var i = 0; i < data.length; ++i) {
      nameList.push(data[i][DATA_NAME_INDEX]);
      if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
        nameMap.set(data[i][DATA_NAME_INDEX], count2);
        count2++;
      }
    }
    var dimensions = prepareSeriesDataSchema(data, {
      coordDimensions: ["single"],
      dimensionsDefine: [{
        name: "time",
        type: getDimensionTypeByAxis(axisType)
      }, {
        name: "value",
        type: "float"
      }, {
        name: "name",
        type: "ordinal"
      }],
      encodeDefine: {
        single: 0,
        value: 1,
        itemName: 2
      }
    }).dimensions;
    var list = new SeriesData$1(dimensions, this);
    list.initData(data);
    return list;
  };
  ThemeRiverSeriesModel2.prototype.getLayerSeries = function() {
    var data = this.getData();
    var lenCount = data.count();
    var indexArr = [];
    for (var i = 0; i < lenCount; ++i) {
      indexArr[i] = i;
    }
    var timeDim = data.mapDimension("single");
    var groupResult = groupData(indexArr, function(index) {
      return data.get("name", index);
    });
    var layerSeries = [];
    groupResult.buckets.each(function(items, key) {
      items.sort(function(index1, index2) {
        return data.get(timeDim, index1) - data.get(timeDim, index2);
      });
      layerSeries.push({
        name: key,
        indices: items
      });
    });
    return layerSeries;
  };
  ThemeRiverSeriesModel2.prototype.getAxisTooltipData = function(dim, value, baseAxis) {
    if (!isArray$1(dim)) {
      dim = dim ? [dim] : [];
    }
    var data = this.getData();
    var layerSeries = this.getLayerSeries();
    var indices = [];
    var layerNum = layerSeries.length;
    var nestestValue;
    for (var i = 0; i < layerNum; ++i) {
      var minDist = Number.MAX_VALUE;
      var nearestIdx = -1;
      var pointNum = layerSeries[i].indices.length;
      for (var j = 0; j < pointNum; ++j) {
        var theValue = data.get(dim[0], layerSeries[i].indices[j]);
        var dist2 = Math.abs(theValue - value);
        if (dist2 <= minDist) {
          nestestValue = theValue;
          minDist = dist2;
          nearestIdx = layerSeries[i].indices[j];
        }
      }
      indices.push(nearestIdx);
    }
    return {
      dataIndices: indices,
      nestestValue
    };
  };
  ThemeRiverSeriesModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var name = data.getName(dataIndex);
    var value = data.get(data.mapDimension("value"), dataIndex);
    return createTooltipMarkup("nameValue", {
      name,
      value
    });
  };
  ThemeRiverSeriesModel2.type = "series.themeRiver";
  ThemeRiverSeriesModel2.dependencies = ["singleAxis"];
  ThemeRiverSeriesModel2.defaultOption = {
    z: 2,
    colorBy: "data",
    coordinateSystem: "singleAxis",
    boundaryGap: ["10%", "10%"],
    singleAxisIndex: 0,
    animationEasing: "linear",
    label: {
      margin: 4,
      show: true,
      position: "left",
      fontSize: 11
    },
    emphasis: {
      label: {
        show: true
      }
    }
  };
  return ThemeRiverSeriesModel2;
}(SeriesModel$1);
var ThemeRiverSeriesModel$1 = ThemeRiverSeriesModel;
function themeRiverLayout(ecModel, api) {
  ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
    var data = seriesModel.getData();
    var single = seriesModel.coordinateSystem;
    var layoutInfo = {};
    var rect = single.getRect();
    layoutInfo.rect = rect;
    var boundaryGap = seriesModel.get("boundaryGap");
    var axis = single.getAxis();
    layoutInfo.boundaryGap = boundaryGap;
    if (axis.orient === "horizontal") {
      boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.height);
      boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.height);
      var height = rect.height - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, height);
    } else {
      boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.width);
      boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.width);
      var width = rect.width - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, width);
    }
    data.setLayout("layoutInfo", layoutInfo);
  });
}
function doThemeRiverLayout(data, seriesModel, height) {
  if (!data.count()) {
    return;
  }
  var coordSys = seriesModel.coordinateSystem;
  var layerSeries = seriesModel.getLayerSeries();
  var timeDim = data.mapDimension("single");
  var valueDim = data.mapDimension("value");
  var layerPoints = map$1(layerSeries, function(singleLayer) {
    return map$1(singleLayer.indices, function(idx) {
      var pt = coordSys.dataToPoint(data.get(timeDim, idx));
      pt[1] = data.get(valueDim, idx);
      return pt;
    });
  });
  var base2 = computeBaseline(layerPoints);
  var baseLine = base2.y0;
  var ky = height / base2.max;
  var n = layerSeries.length;
  var m2 = layerSeries[0].indices.length;
  var baseY0;
  for (var j = 0; j < m2; ++j) {
    baseY0 = baseLine[j] * ky;
    data.setItemLayout(layerSeries[0].indices[j], {
      layerIndex: 0,
      x: layerPoints[0][j][0],
      y0: baseY0,
      y: layerPoints[0][j][1] * ky
    });
    for (var i = 1; i < n; ++i) {
      baseY0 += layerPoints[i - 1][j][1] * ky;
      data.setItemLayout(layerSeries[i].indices[j], {
        layerIndex: i,
        x: layerPoints[i][j][0],
        y0: baseY0,
        y: layerPoints[i][j][1] * ky
      });
    }
  }
}
function computeBaseline(data) {
  var layerNum = data.length;
  var pointNum = data[0].length;
  var sums = [];
  var y0 = [];
  var max3 = 0;
  for (var i = 0; i < pointNum; ++i) {
    var temp = 0;
    for (var j = 0; j < layerNum; ++j) {
      temp += data[j][i][1];
    }
    if (temp > max3) {
      max3 = temp;
    }
    sums.push(temp);
  }
  for (var k = 0; k < pointNum; ++k) {
    y0[k] = (max3 - sums[k]) / 2;
  }
  max3 = 0;
  for (var l = 0; l < pointNum; ++l) {
    var sum2 = sums[l] + y0[l];
    if (sum2 > max3) {
      max3 = sum2;
    }
  }
  return {
    y0,
    max: max3
  };
}
function install$J(registers) {
  registers.registerChartView(ThemeRiverView$1);
  registers.registerSeriesModel(ThemeRiverSeriesModel$1);
  registers.registerLayout(themeRiverLayout);
  registers.registerProcessor(dataFilter$1("themeRiver"));
}
var DEFAULT_SECTOR_Z = 2;
var DEFAULT_TEXT_Z = 4;
var SunburstPiece = function(_super) {
  __extends(SunburstPiece2, _super);
  function SunburstPiece2(node, seriesModel, ecModel, api) {
    var _this = _super.call(this) || this;
    _this.z2 = DEFAULT_SECTOR_Z;
    _this.textConfig = {
      inside: true
    };
    getECData(_this).seriesIndex = seriesModel.seriesIndex;
    var text = new ZRText$1({
      z2: DEFAULT_TEXT_Z,
      silent: node.getModel().get(["label", "silent"])
    });
    _this.setTextContent(text);
    _this.updateData(true, node, seriesModel, ecModel, api);
    return _this;
  }
  SunburstPiece2.prototype.updateData = function(firstCreate, node, seriesModel, ecModel, api) {
    this.node = node;
    node.piece = this;
    seriesModel = seriesModel || this._seriesModel;
    ecModel = ecModel || this._ecModel;
    var sector = this;
    getECData(sector).dataIndex = node.dataIndex;
    var itemModel = node.getModel();
    var emphasisModel = itemModel.getModel("emphasis");
    var layout2 = node.getLayout();
    var sectorShape = extend$1({}, layout2);
    sectorShape.label = null;
    var normalStyle = node.getVisual("style");
    normalStyle.lineJoin = "bevel";
    var decal = node.getVisual("decal");
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, api);
    }
    var cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
    extend$1(sectorShape, cornerRadius);
    each$f(SPECIAL_STATES, function(stateName) {
      var state = sector.ensureState(stateName);
      var itemStyleModel = itemModel.getModel([stateName, "itemStyle"]);
      state.style = itemStyleModel.getItemStyle();
      var cornerRadius2 = getSectorCornerRadius(itemStyleModel, sectorShape);
      if (cornerRadius2) {
        state.shape = cornerRadius2;
      }
    });
    if (firstCreate) {
      sector.setShape(sectorShape);
      sector.shape.r = layout2.r0;
      updateProps$1(sector, {
        shape: {
          r: layout2.r
        }
      }, seriesModel, node.dataIndex);
    } else {
      updateProps$1(sector, {
        shape: sectorShape
      }, seriesModel);
      saveOldStyle(sector);
    }
    sector.useStyle(normalStyle);
    this._updateLabel(seriesModel);
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._seriesModel = seriesModel || this._seriesModel;
    this._ecModel = ecModel || this._ecModel;
    var focus = emphasisModel.get("focus");
    var focusOrIndices = focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : focus;
    toggleHoverEmphasis(this, focusOrIndices, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  };
  SunburstPiece2.prototype._updateLabel = function(seriesModel) {
    var _this = this;
    var itemModel = this.node.getModel();
    var normalLabelModel = itemModel.getModel("label");
    var layout2 = this.node.getLayout();
    var angle = layout2.endAngle - layout2.startAngle;
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var dx = Math.cos(midAngle);
    var dy = Math.sin(midAngle);
    var sector = this;
    var label = sector.getTextContent();
    var dataIndex = this.node.dataIndex;
    var labelMinAngle = normalLabelModel.get("minAngle") / 180 * Math.PI;
    var isNormalShown = normalLabelModel.get("show") && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle);
    label.ignore = !isNormalShown;
    each$f(DISPLAY_STATES, function(stateName) {
      var labelStateModel = stateName === "normal" ? itemModel.getModel("label") : itemModel.getModel([stateName, "label"]);
      var isNormal = stateName === "normal";
      var state = isNormal ? label : label.ensureState(stateName);
      var text = seriesModel.getFormattedLabel(dataIndex, stateName);
      if (isNormal) {
        text = text || _this.node.name;
      }
      state.style = createTextStyle$1(labelStateModel, {}, null, stateName !== "normal", true);
      if (text) {
        state.style.text = text;
      }
      var isShown = labelStateModel.get("show");
      if (isShown != null && !isNormal) {
        state.ignore = !isShown;
      }
      var labelPosition = getLabelAttr(labelStateModel, "position");
      var sectorState = isNormal ? sector : sector.states[stateName];
      var labelColor = sectorState.style.fill;
      sectorState.textConfig = {
        outsideFill: labelStateModel.get("color") === "inherit" ? labelColor : null,
        inside: labelPosition !== "outside"
      };
      var r;
      var labelPadding = getLabelAttr(labelStateModel, "distance") || 0;
      var textAlign = getLabelAttr(labelStateModel, "align");
      if (labelPosition === "outside") {
        r = layout2.r + labelPadding;
        textAlign = midAngle > Math.PI / 2 ? "right" : "left";
      } else {
        if (!textAlign || textAlign === "center") {
          r = (layout2.r + layout2.r0) / 2;
          textAlign = "center";
        } else if (textAlign === "left") {
          r = layout2.r0 + labelPadding;
          if (midAngle > Math.PI / 2) {
            textAlign = "right";
          }
        } else if (textAlign === "right") {
          r = layout2.r - labelPadding;
          if (midAngle > Math.PI / 2) {
            textAlign = "left";
          }
        }
      }
      state.style.align = textAlign;
      state.style.verticalAlign = getLabelAttr(labelStateModel, "verticalAlign") || "middle";
      state.x = r * dx + layout2.cx;
      state.y = r * dy + layout2.cy;
      var rotateType = getLabelAttr(labelStateModel, "rotate");
      var rotate2 = 0;
      if (rotateType === "radial") {
        rotate2 = -midAngle;
        if (rotate2 < -Math.PI / 2) {
          rotate2 += Math.PI;
        }
      } else if (rotateType === "tangential") {
        rotate2 = Math.PI / 2 - midAngle;
        if (rotate2 > Math.PI / 2) {
          rotate2 -= Math.PI;
        } else if (rotate2 < -Math.PI / 2) {
          rotate2 += Math.PI;
        }
      } else if (isNumber(rotateType)) {
        rotate2 = rotateType * Math.PI / 180;
      }
      state.rotation = rotate2;
    });
    function getLabelAttr(model, name) {
      var stateAttr = model.get(name);
      if (stateAttr == null) {
        return normalLabelModel.get(name);
      }
      return stateAttr;
    }
    label.dirtyStyle();
  };
  return SunburstPiece2;
}(Sector$1);
var SunburstPiece$1 = SunburstPiece;
var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
var HIGHLIGHT_ACTION = "sunburstHighlight";
var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
function installSunburstAction(registers) {
  registers.registerAction({
    type: ROOT_TO_NODE_ACTION,
    update: "updateView"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: payload
    }, handleRootToNode);
    function handleRootToNode(model, index) {
      var targetInfo = retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);
      if (targetInfo) {
        var originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
  registers.registerAction({
    type: HIGHLIGHT_ACTION,
    update: "none"
  }, function(payload, ecModel, api) {
    payload = extend$1({}, payload);
    ecModel.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: payload
    }, handleHighlight);
    function handleHighlight(model) {
      var targetInfo = retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);
      if (targetInfo) {
        payload.dataIndex = targetInfo.node.dataIndex;
      }
    }
    api.dispatchAction(extend$1(payload, {
      type: "highlight"
    }));
  });
  registers.registerAction({
    type: UNHIGHLIGHT_ACTION,
    update: "updateView"
  }, function(payload, ecModel, api) {
    payload = extend$1({}, payload);
    api.dispatchAction(extend$1(payload, {
      type: "downplay"
    }));
  });
}
var SunburstView = function(_super) {
  __extends(SunburstView2, _super);
  function SunburstView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SunburstView2.type;
    return _this;
  }
  SunburstView2.prototype.render = function(seriesModel, ecModel, api, payload) {
    var self2 = this;
    this.seriesModel = seriesModel;
    this.api = api;
    this.ecModel = ecModel;
    var data = seriesModel.getData();
    var virtualRoot = data.tree.root;
    var newRoot = seriesModel.getViewRoot();
    var group = this.group;
    var renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
    var newChildren = [];
    newRoot.eachNode(function(node) {
      newChildren.push(node);
    });
    var oldChildren = this._oldChildren || [];
    dualTravel(newChildren, oldChildren);
    renderRollUp(virtualRoot, newRoot);
    this._initEvents();
    this._oldChildren = newChildren;
    function dualTravel(newChildren2, oldChildren2) {
      if (newChildren2.length === 0 && oldChildren2.length === 0) {
        return;
      }
      new DataDiffer$1(oldChildren2, newChildren2, getKey2, getKey2).add(processNode).update(processNode).remove(curry$1(processNode, null)).execute();
      function getKey2(node) {
        return node.getId();
      }
      function processNode(newIdx, oldIdx) {
        var newNode = newIdx == null ? null : newChildren2[newIdx];
        var oldNode = oldIdx == null ? null : oldChildren2[oldIdx];
        doRenderNode(newNode, oldNode);
      }
    }
    function doRenderNode(newNode, oldNode) {
      if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
        newNode = null;
      }
      if (newNode !== virtualRoot && oldNode !== virtualRoot) {
        if (oldNode && oldNode.piece) {
          if (newNode) {
            oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api);
            data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
          } else {
            removeNode2(oldNode);
          }
        } else if (newNode) {
          var piece = new SunburstPiece$1(newNode, seriesModel, ecModel, api);
          group.add(piece);
          data.setItemGraphicEl(newNode.dataIndex, piece);
        }
      }
    }
    function removeNode2(node) {
      if (!node) {
        return;
      }
      if (node.piece) {
        group.remove(node.piece);
        node.piece = null;
      }
    }
    function renderRollUp(virtualRoot2, viewRoot) {
      if (viewRoot.depth > 0) {
        if (self2.virtualPiece) {
          self2.virtualPiece.updateData(false, virtualRoot2, seriesModel, ecModel, api);
        } else {
          self2.virtualPiece = new SunburstPiece$1(virtualRoot2, seriesModel, ecModel, api);
          group.add(self2.virtualPiece);
        }
        viewRoot.piece.off("click");
        self2.virtualPiece.on("click", function(e2) {
          self2._rootToNode(viewRoot.parentNode);
        });
      } else if (self2.virtualPiece) {
        group.remove(self2.virtualPiece);
        self2.virtualPiece = null;
      }
    }
  };
  SunburstView2.prototype._initEvents = function() {
    var _this = this;
    this.group.off("click");
    this.group.on("click", function(e2) {
      var targetFound = false;
      var viewRoot = _this.seriesModel.getViewRoot();
      viewRoot.eachNode(function(node) {
        if (!targetFound && node.piece && node.piece === e2.target) {
          var nodeClick = node.getModel().get("nodeClick");
          if (nodeClick === "rootToNode") {
            _this._rootToNode(node);
          } else if (nodeClick === "link") {
            var itemModel = node.getModel();
            var link = itemModel.get("link");
            if (link) {
              var linkTarget = itemModel.get("target", true) || "_blank";
              windowOpen(link, linkTarget);
            }
          }
          targetFound = true;
        }
      });
    });
  };
  SunburstView2.prototype._rootToNode = function(node) {
    if (node !== this.seriesModel.getViewRoot()) {
      this.api.dispatchAction({
        type: ROOT_TO_NODE_ACTION,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: node
      });
    }
  };
  SunburstView2.prototype.containPoint = function(point, seriesModel) {
    var treeRoot = seriesModel.getData();
    var itemLayout = treeRoot.getItemLayout(0);
    if (itemLayout) {
      var dx = point[0] - itemLayout.cx;
      var dy = point[1] - itemLayout.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  };
  SunburstView2.type = "sunburst";
  return SunburstView2;
}(ChartView$1);
var SunburstView$1 = SunburstView;
var SunburstSeriesModel = function(_super) {
  __extends(SunburstSeriesModel2, _super);
  function SunburstSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SunburstSeriesModel2.type;
    _this.ignoreStyleOnData = true;
    return _this;
  }
  SunburstSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    var root2 = {
      name: option.name,
      children: option.data
    };
    completeTreeValue(root2);
    var levelModels = this._levelModels = map$1(option.levels || [], function(levelDefine) {
      return new Model$1(levelDefine, this, ecModel);
    }, this);
    var tree = Tree$1.createTree(root2, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        var node = tree.getNodeByDataIndex(idx);
        var levelModel = levelModels[node.depth];
        levelModel && (model.parentModel = levelModel);
        return model;
      });
    }
    return tree.data;
  };
  SunburstSeriesModel2.prototype.optionUpdated = function() {
    this.resetViewRoot();
  };
  SunburstSeriesModel2.prototype.getDataParams = function(dataIndex) {
    var params = _super.prototype.getDataParams.apply(this, arguments);
    var node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treePathInfo = wrapTreePathInfo(node, this);
    return params;
  };
  SunburstSeriesModel2.prototype.getLevelModel = function(node) {
    return this._levelModels && this._levelModels[node.depth];
  };
  SunburstSeriesModel2.prototype.getViewRoot = function() {
    return this._viewRoot;
  };
  SunburstSeriesModel2.prototype.resetViewRoot = function(viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    var root2 = this.getRawData().tree.root;
    if (!viewRoot || viewRoot !== root2 && !root2.contains(viewRoot)) {
      this._viewRoot = root2;
    }
  };
  SunburstSeriesModel2.prototype.enableAriaDecal = function() {
    enableAriaDecalForTree(this);
  };
  SunburstSeriesModel2.type = "series.sunburst";
  SunburstSeriesModel2.defaultOption = {
    z: 2,
    center: ["50%", "50%"],
    radius: [0, "75%"],
    clockwise: true,
    startAngle: 90,
    minAngle: 0,
    stillShowZeroSum: true,
    nodeClick: "rootToNode",
    renderLabelForZeroData: false,
    label: {
      rotate: "radial",
      show: true,
      opacity: 1,
      align: "center",
      position: "inside",
      distance: 5,
      silent: true
    },
    itemStyle: {
      borderWidth: 1,
      borderColor: "white",
      borderType: "solid",
      shadowBlur: 0,
      shadowColor: "rgba(0, 0, 0, 0.2)",
      shadowOffsetX: 0,
      shadowOffsetY: 0,
      opacity: 1
    },
    emphasis: {
      focus: "descendant"
    },
    blur: {
      itemStyle: {
        opacity: 0.2
      },
      label: {
        opacity: 0.1
      }
    },
    animationType: "expansion",
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    data: [],
    sort: "desc"
  };
  return SunburstSeriesModel2;
}(SeriesModel$1);
function completeTreeValue(dataNode) {
  var sum2 = 0;
  each$f(dataNode.children, function(child) {
    completeTreeValue(child);
    var childValue = child.value;
    isArray$1(childValue) && (childValue = childValue[0]);
    sum2 += childValue;
  });
  var thisValue = dataNode.value;
  if (isArray$1(thisValue)) {
    thisValue = thisValue[0];
  }
  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum2;
  }
  if (thisValue < 0) {
    thisValue = 0;
  }
  isArray$1(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
var SunburstSeriesModel$1 = SunburstSeriesModel;
var RADIAN = Math.PI / 180;
function sunburstLayout(seriesType2, ecModel, api) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    var center2 = seriesModel.get("center");
    var radius = seriesModel.get("radius");
    if (!isArray$1(radius)) {
      radius = [0, radius];
    }
    if (!isArray$1(center2)) {
      center2 = [center2, center2];
    }
    var width = api.getWidth();
    var height = api.getHeight();
    var size = Math.min(width, height);
    var cx = parsePercent$1(center2[0], width);
    var cy = parsePercent$1(center2[1], height);
    var r0 = parsePercent$1(radius[0], size / 2);
    var r = parsePercent$1(radius[1], size / 2);
    var startAngle = -seriesModel.get("startAngle") * RADIAN;
    var minAngle = seriesModel.get("minAngle") * RADIAN;
    var virtualRoot = seriesModel.getData().tree.root;
    var treeRoot = seriesModel.getViewRoot();
    var rootDepth = treeRoot.depth;
    var sort2 = seriesModel.get("sort");
    if (sort2 != null) {
      initChildren(treeRoot, sort2);
    }
    var validDataCount = 0;
    each$f(treeRoot.children, function(child) {
      !isNaN(child.getValue()) && validDataCount++;
    });
    var sum2 = treeRoot.getValue();
    var unitRadian = Math.PI / (sum2 || validDataCount) * 2;
    var renderRollupNode = treeRoot.depth > 0;
    var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
    var rPerLevel = (r - r0) / (levels || 1);
    var clockwise = seriesModel.get("clockwise");
    var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    var dir3 = clockwise ? 1 : -1;
    var renderNode2 = function(node, startAngle2) {
      if (!node) {
        return;
      }
      var endAngle = startAngle2;
      if (node !== virtualRoot) {
        var value = node.getValue();
        var angle2 = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
        if (angle2 < minAngle) {
          angle2 = minAngle;
        }
        endAngle = startAngle2 + dir3 * angle2;
        var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
        var rStart2 = r0 + rPerLevel * depth;
        var rEnd2 = r0 + rPerLevel * (depth + 1);
        var levelModel = seriesModel.getLevelModel(node);
        if (levelModel) {
          var r0_1 = levelModel.get("r0", true);
          var r_1 = levelModel.get("r", true);
          var radius_1 = levelModel.get("radius", true);
          if (radius_1 != null) {
            r0_1 = radius_1[0];
            r_1 = radius_1[1];
          }
          r0_1 != null && (rStart2 = parsePercent$1(r0_1, size / 2));
          r_1 != null && (rEnd2 = parsePercent$1(r_1, size / 2));
        }
        node.setLayout({
          angle: angle2,
          startAngle: startAngle2,
          endAngle,
          clockwise,
          cx,
          cy,
          r0: rStart2,
          r: rEnd2
        });
      }
      if (node.children && node.children.length) {
        var siblingAngle_1 = 0;
        each$f(node.children, function(node2) {
          siblingAngle_1 += renderNode2(node2, startAngle2 + siblingAngle_1);
        });
      }
      return endAngle - startAngle2;
    };
    if (renderRollupNode) {
      var rStart = r0;
      var rEnd = r0 + rPerLevel;
      var angle = Math.PI * 2;
      virtualRoot.setLayout({
        angle,
        startAngle,
        endAngle: startAngle + angle,
        clockwise,
        cx,
        cy,
        r0: rStart,
        r: rEnd
      });
    }
    renderNode2(treeRoot, startAngle);
  });
}
function initChildren(node, sortOrder) {
  var children = node.children || [];
  node.children = sort(children, sortOrder);
  if (children.length) {
    each$f(node.children, function(child) {
      initChildren(child, sortOrder);
    });
  }
}
function sort(children, sortOrder) {
  if (isFunction$1(sortOrder)) {
    var sortTargets = map$1(children, function(child, idx) {
      var value = child.getValue();
      return {
        params: {
          depth: child.depth,
          height: child.height,
          dataIndex: child.dataIndex,
          getValue: function() {
            return value;
          }
        },
        index: idx
      };
    });
    sortTargets.sort(function(a, b) {
      return sortOrder(a.params, b.params);
    });
    return map$1(sortTargets, function(target) {
      return children[target.index];
    });
  } else {
    var isAsc_1 = sortOrder === "asc";
    return children.sort(function(a, b) {
      var diff = (a.getValue() - b.getValue()) * (isAsc_1 ? 1 : -1);
      return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc_1 ? -1 : 1) : diff;
    });
  }
}
function sunburstVisual(ecModel) {
  var paletteScope = {};
  function pickColor(node, seriesModel, treeHeight) {
    var current = node;
    while (current && current.depth > 1) {
      current = current.parentNode;
    }
    var color = seriesModel.getColorFromPalette(current.name || current.dataIndex + "", paletteScope);
    if (node.depth > 1 && isString(color)) {
      color = lift(color, (node.depth - 1) / (treeHeight - 1) * 0.5);
    }
    return color;
  }
  ecModel.eachSeriesByType("sunburst", function(seriesModel) {
    var data = seriesModel.getData();
    var tree = data.tree;
    tree.eachNode(function(node) {
      var model = node.getModel();
      var style = model.getModel("itemStyle").getItemStyle();
      if (!style.fill) {
        style.fill = pickColor(node, seriesModel, tree.root.height);
      }
      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
      extend$1(existsStyle, style);
    });
  });
}
function install$I(registers) {
  registers.registerChartView(SunburstView$1);
  registers.registerSeriesModel(SunburstSeriesModel$1);
  registers.registerLayout(curry$1(sunburstLayout, "sunburst"));
  registers.registerProcessor(curry$1(dataFilter$1, "sunburst"));
  registers.registerVisual(sunburstVisual);
  installSunburstAction(registers);
}
var STYLE_VISUAL_TYPE = {
  color: "fill",
  borderColor: "stroke"
};
var NON_STYLE_VISUAL_PROPS = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
};
var customInnerStore = makeInner();
var CustomSeriesModel = function(_super) {
  __extends(CustomSeriesModel2, _super);
  function CustomSeriesModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CustomSeriesModel2.type;
    return _this;
  }
  CustomSeriesModel2.prototype.optionUpdated = function() {
    this.currentZLevel = this.get("zlevel", true);
    this.currentZ = this.get("z", true);
  };
  CustomSeriesModel2.prototype.getInitialData = function(option, ecModel) {
    return createSeriesData(null, this);
  };
  CustomSeriesModel2.prototype.getDataParams = function(dataIndex, dataType, el) {
    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);
    el && (params.info = customInnerStore(el).info);
    return params;
  };
  CustomSeriesModel2.type = "series.custom";
  CustomSeriesModel2.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
  CustomSeriesModel2.defaultOption = {
    coordinateSystem: "cartesian2d",
    z: 2,
    legendHoverLink: true,
    clip: false
  };
  return CustomSeriesModel2;
}(SeriesModel$1);
var CustomSeriesModel$1 = CustomSeriesModel;
function dataToCoordSize$3(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map$1(["x", "y"], function(dim, dimIdx) {
    var axis = this.getAxis(dim);
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
  }, this);
}
function cartesianPrepareCustom(coordSys) {
  var rect = coordSys.master.getRect();
  return {
    coordSys: {
      type: "cartesian2d",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(data) {
        return coordSys.dataToPoint(data);
      },
      size: bind$1(dataToCoordSize$3, coordSys)
    }
  };
}
function dataToCoordSize$2(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map$1([0, 1], function(dimIdx) {
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    var p12 = [];
    var p22 = [];
    p12[dimIdx] = val - halfSize;
    p22[dimIdx] = val + halfSize;
    p12[1 - dimIdx] = p22[1 - dimIdx] = dataItem[1 - dimIdx];
    return Math.abs(this.dataToPoint(p12)[dimIdx] - this.dataToPoint(p22)[dimIdx]);
  }, this);
}
function geoPrepareCustom(coordSys) {
  var rect = coordSys.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      zoom: coordSys.getZoom()
    },
    api: {
      coord: function(data) {
        return coordSys.dataToPoint(data);
      },
      size: bind$1(dataToCoordSize$2, coordSys)
    }
  };
}
function dataToCoordSize$1(dataSize, dataItem) {
  var axis = this.getAxis();
  var val = dataItem instanceof Array ? dataItem[0] : dataItem;
  var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
  return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
}
function singlePrepareCustom(coordSys) {
  var rect = coordSys.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(val) {
        return coordSys.dataToPoint(val);
      },
      size: bind$1(dataToCoordSize$1, coordSys)
    }
  };
}
function dataToCoordSize(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map$1(["Radius", "Angle"], function(dim, dimIdx) {
    var getterName = "get" + dim + "Axis";
    var axis = this[getterName]();
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    var result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
    if (dim === "Angle") {
      result = result * Math.PI / 180;
    }
    return result;
  }, this);
}
function polarPrepareCustom(coordSys) {
  var radiusAxis = coordSys.getRadiusAxis();
  var angleAxis = coordSys.getAngleAxis();
  var radius = radiusAxis.getExtent();
  radius[0] > radius[1] && radius.reverse();
  return {
    coordSys: {
      type: "polar",
      cx: coordSys.cx,
      cy: coordSys.cy,
      r: radius[1],
      r0: radius[0]
    },
    api: {
      coord: function(data) {
        var radius2 = radiusAxis.dataToRadius(data[0]);
        var angle = angleAxis.dataToAngle(data[1]);
        var coord = coordSys.coordToPoint([radius2, angle]);
        coord.push(radius2, angle * Math.PI / 180);
        return coord;
      },
      size: bind$1(dataToCoordSize, coordSys)
    }
  };
}
function calendarPrepareCustom(coordSys) {
  var rect = coordSys.getRect();
  var rangeInfo = coordSys.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      cellWidth: coordSys.getCellWidth(),
      cellHeight: coordSys.getCellHeight(),
      rangeInfo: {
        start: rangeInfo.start,
        end: rangeInfo.end,
        weeks: rangeInfo.weeks,
        dayCount: rangeInfo.allDay
      }
    },
    api: {
      coord: function(data, clamp2) {
        return coordSys.dataToPoint(data, clamp2);
      }
    }
  };
}
function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
  return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== "tspan" && (elType === "text" || hasOwn(style, "text")));
}
function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
  var srcStyle = hostStyle;
  var textConfig;
  var textContent;
  var textContentStyle;
  if (elType === "text") {
    textContentStyle = srcStyle;
  } else {
    textContentStyle = {};
    hasOwn(srcStyle, "text") && (textContentStyle.text = srcStyle.text);
    hasOwn(srcStyle, "rich") && (textContentStyle.rich = srcStyle.rich);
    hasOwn(srcStyle, "textFill") && (textContentStyle.fill = srcStyle.textFill);
    hasOwn(srcStyle, "textStroke") && (textContentStyle.stroke = srcStyle.textStroke);
    hasOwn(srcStyle, "fontFamily") && (textContentStyle.fontFamily = srcStyle.fontFamily);
    hasOwn(srcStyle, "fontSize") && (textContentStyle.fontSize = srcStyle.fontSize);
    hasOwn(srcStyle, "fontStyle") && (textContentStyle.fontStyle = srcStyle.fontStyle);
    hasOwn(srcStyle, "fontWeight") && (textContentStyle.fontWeight = srcStyle.fontWeight);
    textContent = {
      type: "text",
      style: textContentStyle,
      silent: true
    };
    textConfig = {};
    var hasOwnPos = hasOwn(srcStyle, "textPosition");
    if (isNormal) {
      textConfig.position = hasOwnPos ? srcStyle.textPosition : "inside";
    } else {
      hasOwnPos && (textConfig.position = srcStyle.textPosition);
    }
    hasOwn(srcStyle, "textPosition") && (textConfig.position = srcStyle.textPosition);
    hasOwn(srcStyle, "textOffset") && (textConfig.offset = srcStyle.textOffset);
    hasOwn(srcStyle, "textRotation") && (textConfig.rotation = srcStyle.textRotation);
    hasOwn(srcStyle, "textDistance") && (textConfig.distance = srcStyle.textDistance);
  }
  convertEC4CompatibleRichItem(textContentStyle, hostStyle);
  each$f(textContentStyle.rich, function(richItem) {
    convertEC4CompatibleRichItem(richItem, richItem);
  });
  return {
    textConfig,
    textContent
  };
}
function convertEC4CompatibleRichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  richItem.font = richItem.textFont || richItem.font;
  hasOwn(richItem, "textStrokeWidth") && (out2.lineWidth = richItem.textStrokeWidth);
  hasOwn(richItem, "textAlign") && (out2.align = richItem.textAlign);
  hasOwn(richItem, "textVerticalAlign") && (out2.verticalAlign = richItem.textVerticalAlign);
  hasOwn(richItem, "textLineHeight") && (out2.lineHeight = richItem.textLineHeight);
  hasOwn(richItem, "textWidth") && (out2.width = richItem.textWidth);
  hasOwn(richItem, "textHeight") && (out2.height = richItem.textHeight);
  hasOwn(richItem, "textBackgroundColor") && (out2.backgroundColor = richItem.textBackgroundColor);
  hasOwn(richItem, "textPadding") && (out2.padding = richItem.textPadding);
  hasOwn(richItem, "textBorderColor") && (out2.borderColor = richItem.textBorderColor);
  hasOwn(richItem, "textBorderWidth") && (out2.borderWidth = richItem.textBorderWidth);
  hasOwn(richItem, "textBorderRadius") && (out2.borderRadius = richItem.textBorderRadius);
  hasOwn(richItem, "textBoxShadowColor") && (out2.shadowColor = richItem.textBoxShadowColor);
  hasOwn(richItem, "textBoxShadowBlur") && (out2.shadowBlur = richItem.textBoxShadowBlur);
  hasOwn(richItem, "textBoxShadowOffsetX") && (out2.shadowOffsetX = richItem.textBoxShadowOffsetX);
  hasOwn(richItem, "textBoxShadowOffsetY") && (out2.shadowOffsetY = richItem.textBoxShadowOffsetY);
}
function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {
  var out2 = itemStl;
  out2.textPosition = out2.textPosition || txCfg.position || "inside";
  txCfg.offset != null && (out2.textOffset = txCfg.offset);
  txCfg.rotation != null && (out2.textRotation = txCfg.rotation);
  txCfg.distance != null && (out2.textDistance = txCfg.distance);
  var isInside = out2.textPosition.indexOf("inside") >= 0;
  var hostFill = itemStl.fill || "#000";
  convertToEC4RichItem(out2, txStl);
  var textFillNotSet = out2.textFill == null;
  if (isInside) {
    if (textFillNotSet) {
      out2.textFill = txCfg.insideFill || "#fff";
      !out2.textStroke && txCfg.insideStroke && (out2.textStroke = txCfg.insideStroke);
      !out2.textStroke && (out2.textStroke = hostFill);
      out2.textStrokeWidth == null && (out2.textStrokeWidth = 2);
    }
  } else {
    if (textFillNotSet) {
      out2.textFill = itemStl.fill || txCfg.outsideFill || "#000";
    }
    !out2.textStroke && txCfg.outsideStroke && (out2.textStroke = txCfg.outsideStroke);
  }
  out2.text = txStl.text;
  out2.rich = txStl.rich;
  each$f(txStl.rich, function(richItem) {
    convertToEC4RichItem(richItem, richItem);
  });
  return out2;
}
function convertToEC4RichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  hasOwn(richItem, "fill") && (out2.textFill = richItem.fill);
  hasOwn(richItem, "stroke") && (out2.textStroke = richItem.fill);
  hasOwn(richItem, "lineWidth") && (out2.textStrokeWidth = richItem.lineWidth);
  hasOwn(richItem, "font") && (out2.font = richItem.font);
  hasOwn(richItem, "fontStyle") && (out2.fontStyle = richItem.fontStyle);
  hasOwn(richItem, "fontWeight") && (out2.fontWeight = richItem.fontWeight);
  hasOwn(richItem, "fontSize") && (out2.fontSize = richItem.fontSize);
  hasOwn(richItem, "fontFamily") && (out2.fontFamily = richItem.fontFamily);
  hasOwn(richItem, "align") && (out2.textAlign = richItem.align);
  hasOwn(richItem, "verticalAlign") && (out2.textVerticalAlign = richItem.verticalAlign);
  hasOwn(richItem, "lineHeight") && (out2.textLineHeight = richItem.lineHeight);
  hasOwn(richItem, "width") && (out2.textWidth = richItem.width);
  hasOwn(richItem, "height") && (out2.textHeight = richItem.height);
  hasOwn(richItem, "backgroundColor") && (out2.textBackgroundColor = richItem.backgroundColor);
  hasOwn(richItem, "padding") && (out2.textPadding = richItem.padding);
  hasOwn(richItem, "borderColor") && (out2.textBorderColor = richItem.borderColor);
  hasOwn(richItem, "borderWidth") && (out2.textBorderWidth = richItem.borderWidth);
  hasOwn(richItem, "borderRadius") && (out2.textBorderRadius = richItem.borderRadius);
  hasOwn(richItem, "shadowColor") && (out2.textBoxShadowColor = richItem.shadowColor);
  hasOwn(richItem, "shadowBlur") && (out2.textBoxShadowBlur = richItem.shadowBlur);
  hasOwn(richItem, "shadowOffsetX") && (out2.textBoxShadowOffsetX = richItem.shadowOffsetX);
  hasOwn(richItem, "shadowOffsetY") && (out2.textBoxShadowOffsetY = richItem.shadowOffsetY);
  hasOwn(richItem, "textShadowColor") && (out2.textShadowColor = richItem.textShadowColor);
  hasOwn(richItem, "textShadowBlur") && (out2.textShadowBlur = richItem.textShadowBlur);
  hasOwn(richItem, "textShadowOffsetX") && (out2.textShadowOffsetX = richItem.textShadowOffsetX);
  hasOwn(richItem, "textShadowOffsetY") && (out2.textShadowOffsetY = richItem.textShadowOffsetY);
}
var LEGACY_TRANSFORM_PROPS_MAP = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
};
var LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);
reduce(TRANSFORMABLE_PROPS, function(obj, key) {
  obj[key] = 1;
  return obj;
}, {});
TRANSFORMABLE_PROPS.join(", ");
var ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"];
var transitionInnerStore = makeInner();
function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
  var animationProp = animationType + "Animation";
  var config = getAnimationConfig(animationType, parentModel, dataIndex) || {};
  var userDuring = transitionInnerStore(el).userDuring;
  if (config.duration > 0) {
    config.during = userDuring ? bind$1(duringCall, {
      el,
      userDuring
    }) : null;
    config.setToFinal = true;
    config.scope = animationType;
  }
  extend$1(config, elOption[animationProp]);
  return config;
}
function applyUpdateTransition(el, elOption, animatableModel, opts) {
  opts = opts || {};
  var dataIndex = opts.dataIndex, isInit = opts.isInit, clearStyle = opts.clearStyle;
  var hasAnimation = animatableModel.isAnimationEnabled();
  var store = transitionInnerStore(el);
  var styleOpt = elOption.style;
  store.userDuring = elOption.during;
  var transFromProps = {};
  var propsToSet = {};
  prepareTransformAllPropsFinal(el, elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal("shape", elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal("extra", elOption, propsToSet);
  if (!isInit && hasAnimation) {
    prepareTransformTransitionFrom(el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("shape", el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("extra", el, elOption, transFromProps);
    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
  }
  propsToSet.style = styleOpt;
  applyPropsDirectly(el, propsToSet, clearStyle);
  applyMiscProps(el, elOption);
  if (hasAnimation) {
    if (isInit) {
      var enterFromProps_1 = {};
      each$f(ELEMENT_ANIMATABLE_PROPS, function(propName) {
        var prop = propName ? elOption[propName] : elOption;
        if (prop && prop.enterFrom) {
          if (propName) {
            enterFromProps_1[propName] = enterFromProps_1[propName] || {};
          }
          extend$1(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom);
        }
      });
      var config = getElementAnimationConfig("enter", el, elOption, animatableModel, dataIndex);
      if (config.duration > 0) {
        el.animateFrom(enterFromProps_1, config);
      }
    } else {
      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
    }
  }
  updateLeaveTo(el, elOption);
  styleOpt ? el.dirty() : el.markRedraw();
}
function updateLeaveTo(el, elOption) {
  var leaveToProps = transitionInnerStore(el).leaveToProps;
  for (var i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {
    var propName = ELEMENT_ANIMATABLE_PROPS[i];
    var prop = propName ? elOption[propName] : elOption;
    if (prop && prop.leaveTo) {
      if (!leaveToProps) {
        leaveToProps = transitionInnerStore(el).leaveToProps = {};
      }
      if (propName) {
        leaveToProps[propName] = leaveToProps[propName] || {};
      }
      extend$1(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
    }
  }
}
function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
  if (el) {
    var parent_1 = el.parent;
    var leaveToProps = transitionInnerStore(el).leaveToProps;
    if (leaveToProps) {
      var config = getElementAnimationConfig("update", el, elOption, animatableModel, 0);
      config.done = function() {
        parent_1.remove(el);
        onRemove && onRemove();
      };
      el.animateTo(leaveToProps, config);
    } else {
      parent_1.remove(el);
      onRemove && onRemove();
    }
  }
}
function isTransitionAll(transition) {
  return transition === "all";
}
function applyPropsDirectly(el, allPropsFinal, clearStyle) {
  var styleOpt = allPropsFinal.style;
  if (!el.isGroup && styleOpt) {
    if (clearStyle) {
      el.useStyle({});
      var animators = el.animators;
      for (var i = 0; i < animators.length; i++) {
        var animator = animators[i];
        if (animator.targetName === "style") {
          animator.changeTarget(el.style);
        }
      }
    }
    el.setStyle(styleOpt);
  }
  if (allPropsFinal) {
    allPropsFinal.style = null;
    allPropsFinal && el.attr(allPropsFinal);
    allPropsFinal.style = styleOpt;
  }
}
function applyPropsTransition(el, elOption, dataIndex, model, transFromProps) {
  if (transFromProps) {
    var config = getElementAnimationConfig("update", el, elOption, model, dataIndex);
    if (config.duration > 0) {
      el.animateFrom(transFromProps, config);
    }
  }
}
function applyMiscProps(el, elOption) {
  hasOwn(elOption, "silent") && (el.silent = elOption.silent);
  hasOwn(elOption, "ignore") && (el.ignore = elOption.ignore);
  if (el instanceof Displayable$1) {
    hasOwn(elOption, "invisible") && (el.invisible = elOption.invisible);
  }
  if (el instanceof Path$1) {
    hasOwn(elOption, "autoBatch") && (el.autoBatch = elOption.autoBatch);
  }
}
var tmpDuringScope = {};
var transitionDuringAPI = {
  setTransform: function(key, val) {
    tmpDuringScope.el[key] = val;
    return this;
  },
  getTransform: function(key) {
    return tmpDuringScope.el[key];
  },
  setShape: function(key, val) {
    var el = tmpDuringScope.el;
    var shape = el.shape || (el.shape = {});
    shape[key] = val;
    el.dirtyShape && el.dirtyShape();
    return this;
  },
  getShape: function(key) {
    var shape = tmpDuringScope.el.shape;
    if (shape) {
      return shape[key];
    }
  },
  setStyle: function(key, val) {
    var el = tmpDuringScope.el;
    var style = el.style;
    if (style) {
      style[key] = val;
      el.dirtyStyle && el.dirtyStyle();
    }
    return this;
  },
  getStyle: function(key) {
    var style = tmpDuringScope.el.style;
    if (style) {
      return style[key];
    }
  },
  setExtra: function(key, val) {
    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    extra[key] = val;
    return this;
  },
  getExtra: function(key) {
    var extra = tmpDuringScope.el.extra;
    if (extra) {
      return extra[key];
    }
  }
};
function duringCall() {
  var scope = this;
  var el = scope.el;
  if (!el) {
    return;
  }
  var latestUserDuring = transitionInnerStore(el).userDuring;
  var scopeUserDuring = scope.userDuring;
  if (latestUserDuring !== scopeUserDuring) {
    scope.el = scope.userDuring = null;
    return;
  }
  tmpDuringScope.el = el;
  scopeUserDuring(transitionDuringAPI);
}
function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
  var attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  var elPropsInAttr = fromEl[mainAttr];
  var transFromPropsInAttr;
  if (elPropsInAttr) {
    var transition = elOption.transition;
    var attrTransition = attrOpt.transition;
    if (attrTransition) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      if (isTransitionAll(attrTransition)) {
        extend$1(transFromPropsInAttr, elPropsInAttr);
      } else {
        var transitionKeys = normalizeToArray(attrTransition);
        for (var i = 0; i < transitionKeys.length; i++) {
          var key = transitionKeys[i];
          var elVal = elPropsInAttr[key];
          transFromPropsInAttr[key] = elVal;
        }
      }
    } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      var elPropsInAttrKeys = keys(elPropsInAttr);
      for (var i = 0; i < elPropsInAttrKeys.length; i++) {
        var key = elPropsInAttrKeys[i];
        var elVal = elPropsInAttr[key];
        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {
          transFromPropsInAttr[key] = elVal;
        }
      }
    }
  }
}
function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
  var attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  var allPropsInAttr = allProps[mainAttr] = {};
  var keysInAttr = keys(attrOpt);
  for (var i = 0; i < keysInAttr.length; i++) {
    var key = keysInAttr[i];
    allPropsInAttr[key] = cloneValue(attrOpt[key]);
  }
}
function prepareTransformTransitionFrom(el, elOption, transFromProps) {
  var transition = elOption.transition;
  var transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);
  for (var i = 0; i < transitionKeys.length; i++) {
    var key = transitionKeys[i];
    if (key === "style" || key === "shape" || key === "extra") {
      continue;
    }
    var elVal = el[key];
    transFromProps[key] = elVal;
  }
}
function prepareTransformAllPropsFinal(el, elOption, allProps) {
  for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {
    var legacyName = LEGACY_TRANSFORM_PROPS[i];
    var xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
    var legacyArr = elOption[legacyName];
    if (legacyArr) {
      allProps[xyName[0]] = legacyArr[0];
      allProps[xyName[1]] = legacyArr[1];
    }
  }
  for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    var key = TRANSFORMABLE_PROPS[i];
    if (elOption[key] != null) {
      allProps[key] = elOption[key];
    }
  }
}
function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
  if (!styleOpt) {
    return;
  }
  var fromElStyle = fromEl.style;
  var transFromStyleProps;
  if (fromElStyle) {
    var styleTransition = styleOpt.transition;
    var elTransition = elOption.transition;
    if (styleTransition && !isTransitionAll(styleTransition)) {
      var transitionKeys = normalizeToArray(styleTransition);
      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
      for (var i = 0; i < transitionKeys.length; i++) {
        var key = transitionKeys[i];
        var elVal = fromElStyle[key];
        transFromStyleProps[key] = elVal;
      }
    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, "style") >= 0)) {
      var animationProps = fromEl.getAnimationStyleProps();
      var animationStyleProps = animationProps ? animationProps.style : null;
      if (animationStyleProps) {
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        var styleKeys = keys(styleOpt);
        for (var i = 0; i < styleKeys.length; i++) {
          var key = styleKeys[i];
          if (animationStyleProps[key]) {
            var elVal = fromElStyle[key];
            transFromStyleProps[key] = elVal;
          }
        }
      }
    }
  }
}
function isNonStyleTransitionEnabled(optVal, elVal) {
  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
}
var getStateToRestore = makeInner();
var KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
function stopPreviousKeyframeAnimationAndRestore(el) {
  el.stopAnimation("keyframe");
  el.attr(getStateToRestore(el));
}
function applyKeyframeAnimation(el, animationOpts, animatableModel) {
  if (!animatableModel.isAnimationEnabled() || !animationOpts) {
    return;
  }
  if (isArray$1(animationOpts)) {
    each$f(animationOpts, function(singleAnimationOpts) {
      applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
    });
    return;
  }
  var keyframes = animationOpts.keyframes;
  var duration = animationOpts.duration;
  if (animatableModel && duration == null) {
    var config = getAnimationConfig("enter", animatableModel, 0);
    duration = config && config.duration;
  }
  if (!keyframes || !duration) {
    return;
  }
  var stateToRestore = getStateToRestore(el);
  each$f(ELEMENT_ANIMATABLE_PROPS, function(targetPropName) {
    if (targetPropName && !el[targetPropName]) {
      return;
    }
    var animator;
    keyframes.sort(function(a, b) {
      return a.percent - b.percent;
    });
    each$f(keyframes, function(kf) {
      var animators = el.animators;
      var kfValues = targetPropName ? kf[targetPropName] : kf;
      if (!kfValues) {
        return;
      }
      var propKeys = keys(kfValues);
      if (!targetPropName) {
        propKeys = filter(propKeys, function(key) {
          return indexOf(KEYFRAME_EXCLUDE_KEYS, key) < 0;
        });
      }
      if (!propKeys.length) {
        return;
      }
      if (!animator) {
        animator = el.animate(targetPropName, animationOpts.loop, true);
        animator.scope = "keyframe";
      }
      for (var i = 0; i < animators.length; i++) {
        if (animators[i] !== animator && animators[i].targetName === animator.targetName) {
          animators[i].stopTracks(propKeys);
        }
      }
      targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
      var savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
      each$f(propKeys, function(key) {
        savedTarget[key] = ((targetPropName ? el[targetPropName] : el) || {})[key];
      });
      animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
    });
    if (!animator) {
      return;
    }
    animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
  });
}
var EMPHASIS = "emphasis";
var NORMAL = "normal";
var BLUR = "blur";
var SELECT = "select";
var STATES = [NORMAL, EMPHASIS, BLUR, SELECT];
var PATH_ITEM_STYLE = {
  normal: ["itemStyle"],
  emphasis: [EMPHASIS, "itemStyle"],
  blur: [BLUR, "itemStyle"],
  select: [SELECT, "itemStyle"]
};
var PATH_LABEL = {
  normal: ["label"],
  emphasis: [EMPHASIS, "label"],
  blur: [BLUR, "label"],
  select: [SELECT, "label"]
};
var DEFAULT_TRANSITION = ["x", "y"];
var GROUP_DIFF_PREFIX = "e\0\0";
var attachedTxInfoTmp = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
};
var prepareCustoms = {
  cartesian2d: cartesianPrepareCustom,
  geo: geoPrepareCustom,
  singleAxis: singlePrepareCustom,
  polar: polarPrepareCustom,
  calendar: calendarPrepareCustom
};
function isPath(el) {
  return el instanceof Path$1;
}
function isDisplayable(el) {
  return el instanceof Displayable$1;
}
function copyElement(sourceEl, targetEl) {
  targetEl.copyTransform(sourceEl);
  if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {
    targetEl.setStyle(sourceEl.style);
    targetEl.z = sourceEl.z;
    targetEl.z2 = sourceEl.z2;
    targetEl.zlevel = sourceEl.zlevel;
    targetEl.invisible = sourceEl.invisible;
    targetEl.ignore = sourceEl.ignore;
    if (isPath(targetEl) && isPath(sourceEl)) {
      targetEl.setShape(sourceEl.shape);
    }
  }
}
var CustomChartView = function(_super) {
  __extends(CustomChartView2, _super);
  function CustomChartView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CustomChartView2.type;
    return _this;
  }
  CustomChartView2.prototype.render = function(customSeries, ecModel, api, payload) {
    this._progressiveEls = null;
    var oldData = this._data;
    var data = customSeries.getData();
    var group = this.group;
    var renderItem = makeRenderItem(customSeries, data, ecModel, api);
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      applyLeaveTransition(el, customInnerStore(el).option, customSeries);
    }).update(function(newIdx, oldIdx) {
      var oldEl = oldData.getItemGraphicEl(oldIdx);
      createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data);
    }).execute();
    var clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
    this._data = data;
  };
  CustomChartView2.prototype.incrementalPrepareRender = function(customSeries, ecModel, api) {
    this.group.removeAll();
    this._data = null;
  };
  CustomChartView2.prototype.incrementalRender = function(params, customSeries, ecModel, api, payload) {
    var data = customSeries.getData();
    var renderItem = makeRenderItem(customSeries, data, ecModel, api);
    var progressiveEls = this._progressiveEls = [];
    function setIncrementalAndHoverLayer(el2) {
      if (!el2.isGroup) {
        el2.incremental = true;
        el2.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (var idx = params.start; idx < params.end; idx++) {
      var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data);
      if (el) {
        el.traverse(setIncrementalAndHoverLayer);
        progressiveEls.push(el);
      }
    }
  };
  CustomChartView2.prototype.eachRendered = function(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  };
  CustomChartView2.prototype.filterForExposedEvent = function(eventType, query, targetEl, packedEvent) {
    var elementName = query.element;
    if (elementName == null || targetEl.name === elementName) {
      return true;
    }
    while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {
      if (targetEl.name === elementName) {
        return true;
      }
    }
    return false;
  };
  CustomChartView2.type = "custom";
  return CustomChartView2;
}(ChartView$1);
var CustomChartView$1 = CustomChartView;
function createEl$1(elOption) {
  var graphicType = elOption.type;
  var el;
  if (graphicType === "path") {
    var shape = elOption.shape;
    var pathRect = shape.width != null && shape.height != null ? {
      x: shape.x || 0,
      y: shape.y || 0,
      width: shape.width,
      height: shape.height
    } : null;
    var pathData = getPathData(shape);
    el = makePath$1(pathData, null, pathRect, shape.layout || "center");
    customInnerStore(el).customPathData = pathData;
  } else if (graphicType === "image") {
    el = new ZRImage$1({});
    customInnerStore(el).customImagePath = elOption.style.image;
  } else if (graphicType === "text") {
    el = new ZRText$1({});
  } else if (graphicType === "group") {
    el = new Group$4();
  } else if (graphicType === "compoundPath") {
    throw new Error('"compoundPath" is not supported yet.');
  } else {
    var Clz = getShapeClass(graphicType);
    if (!Clz) {
      var errMsg = "";
      throwError(errMsg);
    }
    el = new Clz();
  }
  customInnerStore(el).customGraphicType = graphicType;
  el.name = elOption.name;
  el.z2EmphasisLift = 1;
  el.z2SelectLift = 1;
  return el;
}
function updateElNormal(api, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {
  stopPreviousKeyframeAnimationAndRestore(el);
  var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;
  if (txCfgOpt) {
    el.setTextConfig(txCfgOpt);
  }
  if (elOption && elOption.transition == null) {
    elOption.transition = DEFAULT_TRANSITION;
  }
  var styleOpt = elOption && elOption.style;
  if (styleOpt) {
    if (el.type === "text") {
      var textOptionStyle = styleOpt;
      hasOwn(textOptionStyle, "textFill") && (textOptionStyle.fill = textOptionStyle.textFill);
      hasOwn(textOptionStyle, "textStroke") && (textOptionStyle.stroke = textOptionStyle.textStroke);
    }
    var decalPattern = void 0;
    var decalObj = isPath(el) ? styleOpt.decal : null;
    if (api && decalObj) {
      decalObj.dirty = true;
      decalPattern = createOrUpdatePatternFromDecal(decalObj, api);
    }
    styleOpt.__decalPattern = decalPattern;
  }
  if (isDisplayable(el)) {
    if (styleOpt) {
      var decalPattern = styleOpt.__decalPattern;
      if (decalPattern) {
        styleOpt.decal = decalPattern;
      }
    }
  }
  applyUpdateTransition(el, elOption, seriesModel, {
    dataIndex,
    isInit,
    clearStyle: true
  });
  applyKeyframeAnimation(el, elOption.keyframeAnimation, seriesModel);
}
function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo) {
  var elDisplayable = el.isGroup ? null : el;
  var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;
  if (elDisplayable) {
    var stateObj = elDisplayable.ensureState(state);
    if (styleOpt === false) {
      var existingEmphasisState = elDisplayable.getState(state);
      if (existingEmphasisState) {
        existingEmphasisState.style = null;
      }
    } else {
      stateObj.style = styleOpt || null;
    }
    if (txCfgOpt) {
      stateObj.textConfig = txCfgOpt;
    }
    setDefaultStateProxy(elDisplayable);
  }
}
function updateZ(el, elOption, seriesModel) {
  if (el.isGroup) {
    return;
  }
  var elDisplayable = el;
  var currentZ = seriesModel.currentZ;
  var currentZLevel = seriesModel.currentZLevel;
  elDisplayable.z = currentZ;
  elDisplayable.zlevel = currentZLevel;
  var optZ2 = elOption.z2;
  optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
  for (var i = 0; i < STATES.length; i++) {
    updateZForEachState(elDisplayable, elOption, STATES[i]);
  }
}
function updateZForEachState(elDisplayable, elOption, state) {
  var isNormal = state === NORMAL;
  var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);
  var optZ2 = elStateOpt ? elStateOpt.z2 : null;
  var stateObj;
  if (optZ2 != null) {
    stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);
    stateObj.z2 = optZ2 || 0;
  }
}
function makeRenderItem(customSeries, data, ecModel, api) {
  var renderItem = customSeries.get("renderItem");
  var coordSys = customSeries.coordinateSystem;
  var prepareResult2 = {};
  if (coordSys) {
    prepareResult2 = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);
  }
  var userAPI = defaults({
    getWidth: api.getWidth,
    getHeight: api.getHeight,
    getZr: api.getZr,
    getDevicePixelRatio: api.getDevicePixelRatio,
    value,
    style,
    ordinalRawValue,
    styleEmphasis,
    visual,
    barLayout,
    currentSeriesIndices,
    font
  }, prepareResult2.api || {});
  var userParams = {
    context: {},
    seriesId: customSeries.id,
    seriesName: customSeries.name,
    seriesIndex: customSeries.seriesIndex,
    coordSys: prepareResult2.coordSys,
    dataInsideLength: data.count(),
    encode: wrapEncodeDef(customSeries.getData())
  };
  var currDataIndexInside;
  var currItemModel;
  var currItemStyleModels = {};
  var currLabelModels = {};
  var seriesItemStyleModels = {};
  var seriesLabelModels = {};
  for (var i = 0; i < STATES.length; i++) {
    var stateName = STATES[i];
    seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);
    seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);
  }
  function getItemModel2(dataIndexInside) {
    return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);
  }
  function getItemStyleModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);
  }
  function getLabelModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel2(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel2(dataIndexInside).getModel(PATH_LABEL[state]);
  }
  return function(dataIndexInside, payload) {
    currDataIndexInside = dataIndexInside;
    currItemModel = null;
    currItemStyleModels = {};
    currLabelModels = {};
    return renderItem && renderItem(defaults({
      dataIndexInside,
      dataIndex: data.getRawIndex(dataIndexInside),
      actionType: payload ? payload.type : null
    }, userParams), userAPI);
  };
  function value(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside);
  }
  function ordinalRawValue(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    dim = dim || 0;
    var dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo) {
      var dimIndex = data.getDimensionIndex(dim);
      return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : void 0;
    }
    var val = data.get(dimInfo.name, dataIndexInside);
    var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
    return ordinalMeta ? ordinalMeta.categories[val] : val;
  }
  function style(userProps, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    var style2 = data.getItemVisual(dataIndexInside, "style");
    var visualColor = style2 && style2.fill;
    var opacity = style2 && style2.opacity;
    var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();
    visualColor != null && (itemStyle.fill = visualColor);
    opacity != null && (itemStyle.opacity = opacity);
    var opt = {
      inheritColor: isString(visualColor) ? visualColor : "#000"
    };
    var labelModel = getLabelModel(dataIndexInside, NORMAL);
    var textStyle = createTextStyle$1(labelModel, null, opt, false, true);
    textStyle.text = labelModel.getShallow("show") ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
    var textConfig = createTextConfig(labelModel, opt, false);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  function styleEmphasis(userProps, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();
    var labelModel = getLabelModel(dataIndexInside, EMPHASIS);
    var textStyle = createTextStyle$1(labelModel, null, null, true, true);
    textStyle.text = labelModel.getShallow("show") ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
    var textConfig = createTextConfig(labelModel, null, true);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  function applyUserPropsAfter(itemStyle, extra) {
    for (var key in extra) {
      if (hasOwn(extra, key)) {
        itemStyle[key] = extra[key];
      }
    }
  }
  function preFetchFromExtra(extra, itemStyle) {
    if (extra) {
      extra.textFill && (itemStyle.textFill = extra.textFill);
      extra.textPosition && (itemStyle.textPosition = extra.textPosition);
    }
  }
  function visual(visualType, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {
      var style_1 = data.getItemVisual(dataIndexInside, "style");
      return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;
    }
    if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {
      return data.getItemVisual(dataIndexInside, visualType);
    }
  }
  function barLayout(opt) {
    if (coordSys.type === "cartesian2d") {
      var baseAxis = coordSys.getBaseAxis();
      return getLayoutOnAxis(defaults({
        axis: baseAxis
      }, opt));
    }
  }
  function currentSeriesIndices() {
    return ecModel.getCurrentSeriesIndices();
  }
  function font(opt) {
    return getFont(opt, ecModel);
  }
}
function wrapEncodeDef(data) {
  var encodeDef = {};
  each$f(data.dimensions, function(dimName) {
    var dimInfo = data.getDimensionInfo(dimName);
    if (!dimInfo.isExtraCoord) {
      var coordDim = dimInfo.coordDim;
      var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
      dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName);
    }
  });
  return encodeDef;
}
function createOrUpdateItem(api, existsEl, dataIndex, elOption, seriesModel, group, data) {
  if (!elOption) {
    group.remove(existsEl);
    return;
  }
  var el = doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group);
  el && data.setItemGraphicEl(dataIndex, el);
  el && toggleHoverEmphasis(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled);
  return el;
}
function doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group) {
  var toBeReplacedIdx = -1;
  var oldEl = existsEl;
  if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel)) {
    toBeReplacedIdx = indexOf(group.childrenRef(), existsEl);
    existsEl = null;
  }
  var isInit = !existsEl;
  var el = existsEl;
  if (!el) {
    el = createEl$1(elOption);
    if (oldEl) {
      copyElement(oldEl, el);
    }
  } else {
    el.clearStates();
  }
  if (elOption.morph === false) {
    el.disableMorphing = true;
  } else if (el.disableMorphing) {
    el.disableMorphing = false;
  }
  attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;
  attachedTxInfoTmp.isLegacy = false;
  doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);
  doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);
  updateElNormal(api, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit);
  hasOwn(elOption, "info") && (customInnerStore(el).info = elOption.info);
  for (var i = 0; i < STATES.length; i++) {
    var stateName = STATES[i];
    if (stateName !== NORMAL) {
      var otherStateOpt = retrieveStateOption(elOption, stateName);
      var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);
      updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);
    }
  }
  updateZ(el, elOption, seriesModel);
  if (elOption.type === "group") {
    mergeChildren(api, el, dataIndex, elOption, seriesModel);
  }
  if (toBeReplacedIdx >= 0) {
    group.replaceAt(el, toBeReplacedIdx);
  } else {
    group.add(el);
  }
  return el;
}
function doesElNeedRecreate(el, elOption, seriesModel) {
  var elInner = customInnerStore(el);
  var elOptionType = elOption.type;
  var elOptionShape = elOption.shape;
  var elOptionStyle = elOption.style;
  return seriesModel.isUniversalTransitionEnabled() || elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== elInner.customImagePath;
}
function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {
  var clipPathOpt = elOption.clipPath;
  if (clipPathOpt === false) {
    if (el && el.getClipPath()) {
      el.removeClipPath();
    }
  } else if (clipPathOpt) {
    var clipPath = el.getClipPath();
    if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) {
      clipPath = null;
    }
    if (!clipPath) {
      clipPath = createEl$1(clipPathOpt);
      el.setClipPath(clipPath);
    }
    updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit);
  }
}
function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
  if (el.isGroup) {
    return;
  }
  processTxInfo(elOption, null, attachedTxInfo);
  processTxInfo(elOption, EMPHASIS, attachedTxInfo);
  var txConOptNormal = attachedTxInfo.normal.conOpt;
  var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;
  var txConOptBlur = attachedTxInfo.blur.conOpt;
  var txConOptSelect = attachedTxInfo.select.conOpt;
  if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
    var textContent = el.getTextContent();
    if (txConOptNormal === false) {
      textContent && el.removeTextContent();
    } else {
      txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {
        type: "text"
      };
      if (!textContent) {
        textContent = createEl$1(txConOptNormal);
        el.setTextContent(textContent);
      } else {
        textContent.clearStates();
      }
      updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit);
      var txConStlOptNormal = txConOptNormal && txConOptNormal.style;
      for (var i = 0; i < STATES.length; i++) {
        var stateName = STATES[i];
        if (stateName !== NORMAL) {
          var txConOptOtherState = attachedTxInfo[stateName].conOpt;
          updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);
        }
      }
      txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();
    }
  }
}
function processTxInfo(elOption, state, attachedTxInfo) {
  var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);
  var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);
  var elType = elOption.type;
  var txCfg = stateOpt ? stateOpt.textConfig : null;
  var txConOptNormal = elOption.textContent;
  var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);
  if (styleOpt && (attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {
    attachedTxInfo.isLegacy = true;
    var convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state);
    if (!txCfg && convertResult.textConfig) {
      txCfg = convertResult.textConfig;
    }
    if (!txConOpt && convertResult.textContent) {
      txConOpt = convertResult.textContent;
    }
  }
  if (!state && txConOpt) {
    var txConOptNormal_1 = txConOpt;
    !txConOptNormal_1.type && (txConOptNormal_1.type = "text");
  }
  var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];
  info.cfg = txCfg;
  info.conOpt = txConOpt;
}
function retrieveStateOption(elOption, state) {
  return !state ? elOption : elOption ? elOption[state] : null;
}
function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {
  var style = stateOption && stateOption.style;
  if (style == null && state === EMPHASIS && stateOptionNormal) {
    style = stateOptionNormal.styleEmphasis;
  }
  return style;
}
function mergeChildren(api, el, dataIndex, elOption, seriesModel) {
  var newChildren = elOption.children;
  var newLen = newChildren ? newChildren.length : 0;
  var mergeChildren2 = elOption.$mergeChildren;
  var byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
  var notMerge = mergeChildren2 === false;
  if (!newLen && !byName && !notMerge) {
    return;
  }
  if (byName) {
    diffGroupChildren({
      api,
      oldChildren: el.children() || [],
      newChildren: newChildren || [],
      dataIndex,
      seriesModel,
      group: el
    });
    return;
  }
  notMerge && el.removeAll();
  var index = 0;
  for (; index < newLen; index++) {
    newChildren[index] && doCreateOrUpdateEl(api, el.childAt(index), dataIndex, newChildren[index], seriesModel, el);
  }
  for (var i = el.childCount() - 1; i >= index; i--) {
    var child = el.childAt(i);
    applyLeaveTransition(child, customInnerStore(el).option, seriesModel);
  }
}
function diffGroupChildren(context) {
  new DataDiffer$1(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}
function getKey(item, idx) {
  var name = item && item.name;
  return name != null ? name : GROUP_DIFF_PREFIX + idx;
}
function processAddUpdate(newIndex, oldIndex) {
  var context = this.context;
  var childOption = newIndex != null ? context.newChildren[newIndex] : null;
  var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
  doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group);
}
function processRemove(oldIndex) {
  var context = this.context;
  var child = context.oldChildren[oldIndex];
  applyLeaveTransition(child, customInnerStore(child).option, context.seriesModel);
}
function getPathData(shape) {
  return shape && (shape.pathData || shape.d);
}
function hasOwnPathData(shape) {
  return shape && (hasOwn(shape, "pathData") || hasOwn(shape, "d"));
}
function install$H(registers) {
  registers.registerChartView(CustomChartView$1);
  registers.registerSeriesModel(CustomSeriesModel$1);
}
var inner$b = makeInner();
var clone$1 = clone$4;
var bind = bind$1;
var BaseAxisPointer = function() {
  function BaseAxisPointer2() {
    this._dragging = false;
    this.animationThreshold = 15;
  }
  BaseAxisPointer2.prototype.render = function(axisModel, axisPointerModel, api, forceRender) {
    var value = axisPointerModel.get("value");
    var status = axisPointerModel.get("status");
    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api;
    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }
    this._lastValue = value;
    this._lastStatus = status;
    var group = this._group;
    var handle = this._handle;
    if (!status || status === "hide") {
      group && group.hide();
      handle && handle.hide();
      return;
    }
    group && group.show();
    handle && handle.show();
    var elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
    var graphicKey = elOption.graphicKey;
    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api);
    }
    this._lastGraphicKey = graphicKey;
    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
    if (!group) {
      group = this._group = new Group$4();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api.getZr().add(group);
    } else {
      var doUpdateProps = curry$1(updateProps, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }
    updateMandatoryProps(group, axisPointerModel, true);
    this._renderHandle(value);
  };
  BaseAxisPointer2.prototype.remove = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.dispose = function(api) {
    this.clear(api);
  };
  BaseAxisPointer2.prototype.determineAnimation = function(axisModel, axisPointerModel) {
    var animation = axisPointerModel.get("animation");
    var axis = axisModel.axis;
    var isCategoryAxis = axis.type === "category";
    var useSnap = axisPointerModel.get("snap");
    if (!useSnap && !isCategoryAxis) {
      return false;
    }
    if (animation === "auto" || animation == null) {
      var animationThreshold = this.animationThreshold;
      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      }
      if (useSnap) {
        var seriesDataCount = getAxisInfo$1(axisModel).seriesDataCount;
        var axisExtent = axis.getExtent();
        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }
      return false;
    }
    return animation === true;
  };
  BaseAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
  };
  BaseAxisPointer2.prototype.createPointerEl = function(group, elOption, axisModel, axisPointerModel) {
    var pointerOption = elOption.pointer;
    if (pointerOption) {
      var pointerEl = inner$b(group).pointerEl = new graphic[pointerOption.type](clone$1(elOption.pointer));
      group.add(pointerEl);
    }
  };
  BaseAxisPointer2.prototype.createLabelEl = function(group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      var labelEl = inner$b(group).labelEl = new ZRText$1(clone$1(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype.updatePointerEl = function(group, elOption, updateProps2) {
    var pointerEl = inner$b(group).pointerEl;
    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps2(pointerEl, {
        shape: elOption.pointer.shape
      });
    }
  };
  BaseAxisPointer2.prototype.updateLabelEl = function(group, elOption, updateProps2, axisPointerModel) {
    var labelEl = inner$b(group).labelEl;
    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps2(labelEl, {
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  };
  BaseAxisPointer2.prototype._renderHandle = function(value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }
    var axisPointerModel = this._axisPointerModel;
    var zr = this._api.getZr();
    var handle = this._handle;
    var handleModel = axisPointerModel.getModel("handle");
    var status = axisPointerModel.get("status");
    if (!handleModel.get("show") || !status || status === "hide") {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }
    var isInit;
    if (!this._handle) {
      isInit = true;
      handle = this._handle = createIcon(handleModel.get("icon"), {
        cursor: "move",
        draggable: true,
        onmousemove: function(e2) {
          stop(e2.event);
        },
        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
        drift: bind(this._onHandleDragMove, this),
        ondragend: bind(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }
    updateMandatoryProps(handle, axisPointerModel, false);
    handle.setStyle(handleModel.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
    var handleSize = handleModel.get("size");
    if (!isArray$1(handleSize)) {
      handleSize = [handleSize, handleSize];
    }
    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
    this._moveHandleToValue(value, isInit);
  };
  BaseAxisPointer2.prototype._moveHandleToValue = function(value, isInit) {
    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  };
  BaseAxisPointer2.prototype._onHandleDragMove = function(dx, dy) {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    this._dragging = true;
    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner$b(handle).lastProp = null;
    this._doDispatchAxisPointer();
  };
  BaseAxisPointer2.prototype._doDispatchAxisPointer = function() {
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var payloadInfo = this._payloadInfo;
    var axisModel = this._axisModel;
    this._api.dispatchAction({
      type: "updateAxisPointer",
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  };
  BaseAxisPointer2.prototype._onHandleDragEnd = function() {
    this._dragging = false;
    var handle = this._handle;
    if (!handle) {
      return;
    }
    var value = this._axisPointerModel.get("value");
    this._moveHandleToValue(value);
    this._api.dispatchAction({
      type: "hideTip"
    });
  };
  BaseAxisPointer2.prototype.clear = function(api) {
    this._lastValue = null;
    this._lastStatus = null;
    var zr = api.getZr();
    var group = this._group;
    var handle = this._handle;
    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
    clear$1(this, "_doDispatchAxisPointer");
  };
  BaseAxisPointer2.prototype.doClear = function() {
  };
  BaseAxisPointer2.prototype.buildLabel = function(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  };
  return BaseAxisPointer2;
}();
function updateProps(animationModel, moveAnimation, el, props) {
  if (!propsEqual(inner$b(el).lastProp, props)) {
    inner$b(el).lastProp = props;
    moveAnimation ? updateProps$1(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}
function propsEqual(lastProps, newProps) {
  if (isObject$3(lastProps) && isObject$3(newProps)) {
    var equals_1 = true;
    each$f(newProps, function(item, key) {
      equals_1 = equals_1 && propsEqual(lastProps[key], item);
    });
    return !!equals_1;
  } else {
    return lastProps === newProps;
  }
}
function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}
function updateMandatoryProps(group, axisPointerModel, silent) {
  var z = axisPointerModel.get("z");
  var zlevel = axisPointerModel.get("zlevel");
  group && group.traverse(function(el) {
    if (el.type !== "group") {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}
var BaseAxisPointer$1 = BaseAxisPointer;
function buildElStyle(axisPointerModel) {
  var axisPointerType = axisPointerModel.get("type");
  var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
  var style;
  if (axisPointerType === "line") {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === "shadow") {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }
  return style;
}
function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
  var value = axisPointerModel.get("value");
  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
    precision: axisPointerModel.get(["label", "precision"]),
    formatter: axisPointerModel.get(["label", "formatter"])
  });
  var labelModel = axisPointerModel.getModel("label");
  var paddings = normalizeCssArray(labelModel.get("padding") || 0);
  var font = labelModel.getFont();
  var textRect = getBoundingRect(text, font);
  var position2 = labelPos.position;
  var width = textRect.width + paddings[1] + paddings[3];
  var height = textRect.height + paddings[0] + paddings[2];
  var align = labelPos.align;
  align === "right" && (position2[0] -= width);
  align === "center" && (position2[0] -= width / 2);
  var verticalAlign = labelPos.verticalAlign;
  verticalAlign === "bottom" && (position2[1] -= height);
  verticalAlign === "middle" && (position2[1] -= height / 2);
  confineInContainer(position2, width, height, api);
  var bgColor = labelModel.get("backgroundColor");
  if (!bgColor || bgColor === "auto") {
    bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
  }
  elOption.label = {
    x: position2[0],
    y: position2[1],
    style: createTextStyle$1(labelModel, {
      text,
      font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    z2: 10
  };
}
function confineInContainer(position2, width, height, api) {
  var viewWidth = api.getWidth();
  var viewHeight = api.getHeight();
  position2[0] = Math.min(position2[0] + width, viewWidth) - width;
  position2[1] = Math.min(position2[1] + height, viewHeight) - height;
  position2[0] = Math.max(position2[0], 0);
  position2[1] = Math.max(position2[1], 0);
}
function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  var text = axis.scale.getLabel({
    value
  }, {
    precision: opt.precision
  });
  var formatter = opt.formatter;
  if (formatter) {
    var params_1 = {
      value: getAxisRawValue(axis, {
        value
      }),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    each$f(seriesDataIndices, function(idxItem) {
      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      var dataIndex = idxItem.dataIndexInside;
      var dataParams = series && series.getDataParams(dataIndex);
      dataParams && params_1.seriesData.push(dataParams);
    });
    if (isString(formatter)) {
      text = formatter.replace("{value}", text);
    } else if (isFunction$1(formatter)) {
      text = formatter(params_1);
    }
  }
  return text;
}
function getTransformedPosition(axis, value, layoutInfo) {
  var transform2 = create$2();
  rotate(transform2, transform2, layoutInfo.rotation);
  translate(transform2, transform2, layoutInfo.position);
  return applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform2);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
  var textLayout = AxisBuilder$1.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p12, p22, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p12[xDimIndex],
    y1: p12[1 - xDimIndex],
    x2: p22[xDimIndex],
    y2: p22[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}
function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx,
    cy,
    r0,
    r,
    startAngle,
    endAngle,
    clockwise: true
  };
}
var CartesianAxisPointer = function(_super) {
  __extends(CartesianAxisPointer2, _super);
  function CartesianAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CartesianAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisPointerType = axisPointerModel.get("type");
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder$2[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var layoutInfo = layout$2(grid.model, axisModel);
    buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  };
  CartesianAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
    var layoutInfo = layout$2(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  CartesianAxisPointer2.prototype.updateHandleTransform = function(transform2, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var grid = axis.grid;
    var axisExtent = axis.getGlobalExtent(true);
    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    var dimIndex = axis.dim === "x" ? 0 : 1;
    var currPosition = [transform2.x, transform2.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    var tooltipOptions = [{
      verticalAlign: "middle"
    }, {
      align: "center"
    }];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform2.rotation,
      cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  };
  return CartesianAxisPointer2;
}(BaseAxisPointer$1);
function getCartesian(grid, axis) {
  var opt = {};
  opt[axis.dim + "AxisIndex"] = axis.index;
  return grid.getCartesian(opt);
}
var pointerShapeBuilder$2 = {
  line: function(axis, pixelValue, otherExtent) {
    var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};
function getAxisDimIndex(axis) {
  return axis.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer$1 = CartesianAxisPointer;
var AxisPointerModel = function(_super) {
  __extends(AxisPointerModel2, _super);
  function AxisPointerModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerModel2.type;
    return _this;
  }
  AxisPointerModel2.type = "axisPointer";
  AxisPointerModel2.defaultOption = {
    show: "auto",
    z: 50,
    type: "line",
    snap: false,
    triggerTooltip: true,
    value: null,
    status: null,
    link: [],
    animation: null,
    animationDurationUpdate: 200,
    lineStyle: {
      color: "#B9BEC9",
      width: 1,
      type: "dashed"
    },
    shadowStyle: {
      color: "rgba(210,219,238,0.2)"
    },
    label: {
      show: true,
      formatter: null,
      precision: "auto",
      margin: 3,
      color: "#fff",
      padding: [5, 7, 5, 7],
      backgroundColor: "auto",
      borderColor: null,
      borderWidth: 0,
      borderRadius: 3
    },
    handle: {
      show: false,
      icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
      size: 45,
      margin: 50,
      color: "#333",
      shadowBlur: 3,
      shadowColor: "#aaa",
      shadowOffsetX: 0,
      shadowOffsetY: 2,
      throttle: 40
    }
  };
  return AxisPointerModel2;
}(ComponentModel$1);
var AxisPointerModel$1 = AxisPointerModel;
var inner$a = makeInner();
var each$8 = each$f;
function register$1(key, api, handler) {
  if (env$1.node) {
    return;
  }
  var zr = api.getZr();
  inner$a(zr).records || (inner$a(zr).records = {});
  initGlobalListeners(zr, api);
  var record = inner$a(zr).records[key] || (inner$a(zr).records[key] = {});
  record.handler = handler;
}
function initGlobalListeners(zr, api) {
  if (inner$a(zr).initialized) {
    return;
  }
  inner$a(zr).initialized = true;
  useHandler("click", curry$1(doEnter, "click"));
  useHandler("mousemove", curry$1(doEnter, "mousemove"));
  useHandler("globalout", onLeave);
  function useHandler(eventType, cb) {
    zr.on(eventType, function(e2) {
      var dis = makeDispatchAction$1(api);
      each$8(inner$a(zr).records, function(record) {
        record && cb(record, e2, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api);
    });
  }
}
function dispatchTooltipFinally(pendings, api) {
  var showLen = pendings.showTip.length;
  var hideLen = pendings.hideTip.length;
  var actuallyPayload;
  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }
  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api.dispatchAction(actuallyPayload);
  }
}
function onLeave(record, e2, dispatchAction2) {
  record.handler("leave", null, dispatchAction2);
}
function doEnter(currTrigger, record, e2, dispatchAction2) {
  record.handler(currTrigger, e2, dispatchAction2);
}
function makeDispatchAction$1(api) {
  var pendings = {
    showTip: [],
    hideTip: []
  };
  var dispatchAction2 = function(payload) {
    var pendingList = pendings[payload.type];
    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction2;
      api.dispatchAction(payload);
    }
  };
  return {
    dispatchAction: dispatchAction2,
    pendings
  };
}
function unregister(key, api) {
  if (env$1.node) {
    return;
  }
  var zr = api.getZr();
  var record = (inner$a(zr).records || {})[key];
  if (record) {
    inner$a(zr).records[key] = null;
  }
}
var AxisPointerView = function(_super) {
  __extends(AxisPointerView2, _super);
  function AxisPointerView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AxisPointerView2.type;
    return _this;
  }
  AxisPointerView2.prototype.render = function(globalAxisPointerModel, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
    register$1("axisPointer", api, function(currTrigger, e2, dispatchAction2) {
      if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction2({
          type: "updateAxisPointer",
          currTrigger,
          x: e2 && e2.offsetX,
          y: e2 && e2.offsetY
        });
      }
    });
  };
  AxisPointerView2.prototype.remove = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.prototype.dispose = function(ecModel, api) {
    unregister("axisPointer", api);
  };
  AxisPointerView2.type = "axisPointer";
  return AxisPointerView2;
}(ComponentView$1);
var AxisPointerView$1 = AxisPointerView;
function findPointFromSeries(finder, ecModel) {
  var point = [];
  var seriesIndex = finder.seriesIndex;
  var seriesModel;
  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }
  var data = seriesModel.getData();
  var dataIndex = queryDataIndex(data, finder);
  if (dataIndex == null || dataIndex < 0 || isArray$1(dataIndex)) {
    return {
      point: []
    };
  }
  var el = data.getItemGraphicEl(dataIndex);
  var coordSys = seriesModel.coordinateSystem;
  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis2 = coordSys.getOtherAxis(baseAxis);
      var valueAxisDim = valueAxis2.dim;
      var baseAxisDim = baseAxis.dim;
      var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      var baseDim = data.mapDimension(baseAxisDim);
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
      point = coordSys.dataToPoint(stackedData) || [];
    } else {
      point = coordSys.dataToPoint(data.getValues(map$1(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el) {
    var rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
  }
  return {
    point,
    el
  };
}
var inner$9 = makeInner();
function axisTrigger(payload, ecModel, api) {
  var currTrigger = payload.currTrigger;
  var point = [payload.x, payload.y];
  var finder = payload;
  var dispatchAction2 = payload.dispatchAction || bind$1(api.dispatchAction, api);
  var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
  if (!coordSysAxesInfo) {
    return;
  }
  if (illegalPoint(point)) {
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }
  var isIllegalPoint = illegalPoint(point);
  var inputAxesInfo = finder.axesInfo;
  var axesInfo = coordSysAxesInfo.axesInfo;
  var shouldHide = currTrigger === "leave" || illegalPoint(point);
  var outputPayload = {};
  var showValueMap = {};
  var dataByCoordSys = {
    list: [],
    map: {}
  };
  var updaters = {
    showPointer: curry$1(showPointer, showValueMap),
    showTooltip: curry$1(showTooltip, dataByCoordSys)
  };
  each$f(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each$f(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
      var axis = axisInfo.axis;
      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        var val = inputAxisInfo && inputAxisInfo.value;
        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }
        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
      }
    });
  });
  var linkTriggers = {};
  each$f(axesInfo, function(tarAxisInfo, tarKey) {
    var linkGroup = tarAxisInfo.linkGroup;
    if (linkGroup && !showValueMap[tarKey]) {
      each$f(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
        var srcValItem = showValueMap[srcKey];
        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          var val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each$f(linkTriggers, function(val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction2);
  dispatchHighDownActually(axesInfo, dispatchAction2, api);
  return outputPayload;
}
function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  var axis = axisInfo.axis;
  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }
  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  }
  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  var payloadBatch = payloadInfo.payloadBatch;
  var snapToValue = payloadInfo.snapToValue;
  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    extend$1(outputFinder, payloadBatch[0]);
  }
  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }
  updaters.showPointer(axisInfo, newValue, payloadBatch);
  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}
function buildPayloadsBySeries(value, axisInfo) {
  var axis = axisInfo.axis;
  var dim = axis.dim;
  var snapToValue = value;
  var payloadBatch = [];
  var minDist = Number.MAX_VALUE;
  var minDiff = -1;
  each$f(axisInfo.seriesModels, function(series, idx) {
    var dataDim = series.getData().mapDimensionsAll(dim);
    var seriesNestestValue;
    var dataIndices;
    if (series.getAxisTooltipData) {
      var result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, axis.type === "category" ? 0.5 : null);
      if (!dataIndices.length) {
        return;
      }
      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }
    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }
    var diff = value - seriesNestestValue;
    var dist2 = Math.abs(diff);
    if (dist2 <= minDist) {
      if (dist2 < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist2;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }
      each$f(dataIndices, function(dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch,
    snapToValue
  };
}
function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value,
    payloadBatch
  };
}
function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  var payloadBatch = payloadInfo.payloadBatch;
  var axis = axisInfo.axis;
  var axisModel = axis.model;
  var axisPointerModel = axisInfo.axisPointerModel;
  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }
  var coordSysModel = axisInfo.coordSys.model;
  var coordSysKey = makeKey(coordSysModel);
  var coordSysItem = dataByCoordSys.map[coordSysKey];
  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }
  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value,
    valueLabelOpt: {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}
function updateModelActually(showValueMap, axesInfo, outputPayload) {
  var outputAxesInfo = outputPayload.axesInfo = [];
  each$f(axesInfo, function(axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    var valItem = showValueMap[key];
    if (valItem) {
      !axisInfo.useHandle && (option.status = "show");
      option.value = valItem.value;
      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } else {
      !axisInfo.useHandle && (option.status = "hide");
    }
    option.status === "show" && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}
function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction2) {
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction2({
      type: "hideTip"
    });
    return;
  }
  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction2({
    type: "showTip",
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}
function dispatchHighDownActually(axesInfo, dispatchAction2, api) {
  var zr = api.getZr();
  var highDownKey = "axisPointerLastHighlights";
  var lastHighlights = inner$9(zr)[highDownKey] || {};
  var newHighlights = inner$9(zr)[highDownKey] = {};
  each$f(axesInfo, function(axisInfo, key) {
    var option = axisInfo.axisPointerModel.option;
    option.status === "show" && each$f(option.seriesDataIndices, function(batchItem) {
      var key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
      newHighlights[key2] = batchItem;
    });
  });
  var toHighlight = [];
  var toDownplay = [];
  each$f(lastHighlights, function(batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  each$f(newHighlights, function(batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api.dispatchAction({
    type: "downplay",
    escapeConnect: true,
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api.dispatchAction({
    type: "highlight",
    escapeConnect: true,
    notBlur: true,
    batch: toHighlight
  });
}
function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
    var inputAxisInfo = inputAxesInfo[i];
    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}
function makeMapperParam(axisInfo) {
  var axisModel = axisInfo.axis.model;
  var item = {};
  var dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
  item.axisName = item[dim + "AxisName"] = axisModel.name;
  item.axisId = item[dim + "AxisId"] = axisModel.id;
  return item;
}
function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}
function install$G(registers) {
  AxisView$1.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer$1);
  registers.registerComponentModel(AxisPointerModel$1);
  registers.registerComponentView(AxisPointerView$1);
  registers.registerPreprocessor(function(option) {
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link = option.axisPointer.link;
      if (link && !isArray$1(link)) {
        option.axisPointer.link = [link];
      }
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
    ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api);
  });
  registers.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}
function install$F(registers) {
  use(install$11);
  use(install$G);
}
var PolarAxisPointer = function(_super) {
  __extends(PolarAxisPointer2, _super);
  function PolarAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    if (axis.dim === "angle") {
      this.animationThreshold = Math.PI / 18;
    }
    var polar = axis.polar;
    var otherAxis = polar.getOtherAxis(axis);
    var otherExtent = otherAxis.getExtent();
    var coordValue = axis.dataToCoord(value);
    var axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder$1[axisPointerType](axis, polar, coordValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var labelMargin = axisPointerModel.get(["label", "margin"]);
    var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
  };
  return PolarAxisPointer2;
}(BaseAxisPointer$1);
function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
  var axis = axisModel.axis;
  var coord = axis.dataToCoord(value);
  var axisAngle = polar.getAngleAxis().getExtent()[0];
  axisAngle = axisAngle / 180 * Math.PI;
  var radiusExtent = polar.getRadiusAxis().getExtent();
  var position2;
  var align;
  var verticalAlign;
  if (axis.dim === "radius") {
    var transform2 = create$2();
    rotate(transform2, transform2, axisAngle);
    translate(transform2, transform2, [polar.cx, polar.cy]);
    position2 = applyTransform([coord, -labelMargin], transform2);
    var labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
    var labelLayout2 = AxisBuilder$1.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
    align = labelLayout2.textAlign;
    verticalAlign = labelLayout2.textVerticalAlign;
  } else {
    var r = radiusExtent[1];
    position2 = polar.coordToPoint([r + labelMargin, coord]);
    var cx = polar.cx;
    var cy = polar.cy;
    align = Math.abs(position2[0] - cx) / r < 0.3 ? "center" : position2[0] > cx ? "left" : "right";
    verticalAlign = Math.abs(position2[1] - cy) / r < 0.3 ? "middle" : position2[1] > cy ? "top" : "bottom";
  }
  return {
    position: position2,
    align,
    verticalAlign
  };
}
var pointerShapeBuilder$1 = {
  line: function(axis, polar, coordValue, otherExtent) {
    return axis.dim === "angle" ? {
      type: "Line",
      shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
    } : {
      type: "Circle",
      shape: {
        cx: polar.cx,
        cy: polar.cy,
        r: coordValue
      }
    };
  },
  shadow: function(axis, polar, coordValue, otherExtent) {
    var bandWidth = Math.max(1, axis.getBandWidth());
    var radian = Math.PI / 180;
    return axis.dim === "angle" ? {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
    } : {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
    };
  }
};
var PolarAxisPointer$1 = PolarAxisPointer;
var PolarModel = function(_super) {
  __extends(PolarModel2, _super);
  function PolarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PolarModel2.type;
    return _this;
  }
  PolarModel2.prototype.findAxisModel = function(axisType) {
    var foundAxisModel;
    var ecModel = this.ecModel;
    ecModel.eachComponent(axisType, function(axisModel) {
      if (axisModel.getCoordSysModel() === this) {
        foundAxisModel = axisModel;
      }
    }, this);
    return foundAxisModel;
  };
  PolarModel2.type = "polar";
  PolarModel2.dependencies = ["radiusAxis", "angleAxis"];
  PolarModel2.defaultOption = {
    z: 0,
    center: ["50%", "50%"],
    radius: "80%"
  };
  return PolarModel2;
}(ComponentModel$1);
var PolarModel$1 = PolarModel;
var PolarAxisModel = function(_super) {
  __extends(PolarAxisModel2, _super);
  function PolarAxisModel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolarAxisModel2.prototype.getCoordSysModel = function() {
    return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
  };
  PolarAxisModel2.type = "polarAxis";
  return PolarAxisModel2;
}(ComponentModel$1);
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel = function(_super) {
  __extends(AngleAxisModel2, _super);
  function AngleAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AngleAxisModel2.type;
    return _this;
  }
  AngleAxisModel2.type = "angleAxis";
  return AngleAxisModel2;
}(PolarAxisModel);
var RadiusAxisModel = function(_super) {
  __extends(RadiusAxisModel2, _super);
  function RadiusAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadiusAxisModel2.type;
    return _this;
  }
  RadiusAxisModel2.type = "radiusAxis";
  return RadiusAxisModel2;
}(PolarAxisModel);
var RadiusAxis = function(_super) {
  __extends(RadiusAxis2, _super);
  function RadiusAxis2(scale2, radiusExtent) {
    return _super.call(this, "radius", scale2, radiusExtent) || this;
  }
  RadiusAxis2.prototype.pointToData = function(point, clamp2) {
    return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
  };
  return RadiusAxis2;
}(Axis$1);
RadiusAxis.prototype.dataToRadius = Axis$1.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = Axis$1.prototype.coordToData;
var RadiusAxis$1 = RadiusAxis;
var inner$8 = makeInner();
var AngleAxis = function(_super) {
  __extends(AngleAxis2, _super);
  function AngleAxis2(scale2, angleExtent) {
    return _super.call(this, "angle", scale2, angleExtent || [0, 360]) || this;
  }
  AngleAxis2.prototype.pointToData = function(point, clamp2) {
    return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
  };
  AngleAxis2.prototype.calculateCategoryInterval = function() {
    var axis = this;
    var labelModel = axis.getLabelModel();
    var ordinalScale = axis.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    var tickValue = ordinalExtent[0];
    var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    var unitH = Math.abs(unitSpan);
    var rect = getBoundingRect(tickValue == null ? "" : tickValue + "", labelModel.getFont(), "center", "top");
    var maxH = Math.max(rect.height, 7);
    var dh = maxH / unitH;
    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(dh));
    var cache2 = inner$8(axis.model);
    var lastAutoInterval = cache2.lastAutoInterval;
    var lastTickCount = cache2.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
      interval = lastAutoInterval;
    } else {
      cache2.lastTickCount = tickCount;
      cache2.lastAutoInterval = interval;
    }
    return interval;
  };
  return AngleAxis2;
}(Axis$1);
AngleAxis.prototype.dataToAngle = Axis$1.prototype.dataToCoord;
AngleAxis.prototype.angleToData = Axis$1.prototype.coordToData;
var AngleAxis$1 = AngleAxis;
var polarDimensions = ["radius", "angle"];
var Polar = function() {
  function Polar2(name) {
    this.dimensions = polarDimensions;
    this.type = "polar";
    this.cx = 0;
    this.cy = 0;
    this._radiusAxis = new RadiusAxis$1();
    this._angleAxis = new AngleAxis$1();
    this.axisPointerEnabled = true;
    this.name = name || "";
    this._radiusAxis.polar = this._angleAxis.polar = this;
  }
  Polar2.prototype.containPoint = function(point) {
    var coord = this.pointToCoord(point);
    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
  };
  Polar2.prototype.containData = function(data) {
    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
  };
  Polar2.prototype.getAxis = function(dim) {
    var key = "_" + dim + "Axis";
    return this[key];
  };
  Polar2.prototype.getAxes = function() {
    return [this._radiusAxis, this._angleAxis];
  };
  Polar2.prototype.getAxesByScale = function(scaleType) {
    var axes = [];
    var angleAxis = this._angleAxis;
    var radiusAxis = this._radiusAxis;
    angleAxis.scale.type === scaleType && axes.push(angleAxis);
    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
    return axes;
  };
  Polar2.prototype.getAngleAxis = function() {
    return this._angleAxis;
  };
  Polar2.prototype.getRadiusAxis = function() {
    return this._radiusAxis;
  };
  Polar2.prototype.getOtherAxis = function(axis) {
    var angleAxis = this._angleAxis;
    return axis === angleAxis ? this._radiusAxis : angleAxis;
  };
  Polar2.prototype.getBaseAxis = function() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
  };
  Polar2.prototype.getTooltipAxes = function(dim) {
    var baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
    return {
      baseAxes: [baseAxis],
      otherAxes: [this.getOtherAxis(baseAxis)]
    };
  };
  Polar2.prototype.dataToPoint = function(data, clamp2) {
    return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp2), this._angleAxis.dataToAngle(data[1], clamp2)]);
  };
  Polar2.prototype.pointToData = function(point, clamp2) {
    var coord = this.pointToCoord(point);
    return [this._radiusAxis.radiusToData(coord[0], clamp2), this._angleAxis.angleToData(coord[1], clamp2)];
  };
  Polar2.prototype.pointToCoord = function(point) {
    var dx = point[0] - this.cx;
    var dy = point[1] - this.cy;
    var angleAxis = this.getAngleAxis();
    var extent3 = angleAxis.getExtent();
    var minAngle = Math.min(extent3[0], extent3[1]);
    var maxAngle = Math.max(extent3[0], extent3[1]);
    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx) / Math.PI * 180;
    var dir3 = radian < minAngle ? 1 : -1;
    while (radian < minAngle || radian > maxAngle) {
      radian += dir3 * 360;
    }
    return [radius, radian];
  };
  Polar2.prototype.coordToPoint = function(coord) {
    var radius = coord[0];
    var radian = coord[1] / 180 * Math.PI;
    var x = Math.cos(radian) * radius + this.cx;
    var y = -Math.sin(radian) * radius + this.cy;
    return [x, y];
  };
  Polar2.prototype.getArea = function() {
    var angleAxis = this.getAngleAxis();
    var radiusAxis = this.getRadiusAxis();
    var radiusExtent = radiusAxis.getExtent().slice();
    radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
    var angleExtent = angleAxis.getExtent();
    var RADIAN2 = Math.PI / 180;
    return {
      cx: this.cx,
      cy: this.cy,
      r0: radiusExtent[0],
      r: radiusExtent[1],
      startAngle: -angleExtent[0] * RADIAN2,
      endAngle: -angleExtent[1] * RADIAN2,
      clockwise: angleAxis.inverse,
      contain: function(x, y) {
        var dx = x - this.cx;
        var dy = y - this.cy;
        var d2 = dx * dx + dy * dy - 1e-4;
        var r = this.r;
        var r0 = this.r0;
        return d2 <= r * r && d2 >= r0 * r0;
      }
    };
  };
  Polar2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$2(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  };
  Polar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$2(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  };
  return Polar2;
}();
function getCoordSys$2(finder) {
  var seriesModel = finder.seriesModel;
  var polarModel = finder.polarModel;
  return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Polar$1 = Polar;
function resizePolar(polar, polarModel, api) {
  var center2 = polarModel.get("center");
  var width = api.getWidth();
  var height = api.getHeight();
  polar.cx = parsePercent$1(center2[0], width);
  polar.cy = parsePercent$1(center2[1], height);
  var radiusAxis = polar.getRadiusAxis();
  var size = Math.min(width, height) / 2;
  var radius = polarModel.get("radius");
  if (radius == null) {
    radius = [0, "100%"];
  } else if (!isArray$1(radius)) {
    radius = [0, radius];
  }
  var parsedRadius = [parsePercent$1(radius[0], size), parsePercent$1(radius[1], size)];
  radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);
}
function updatePolarScale(ecModel, api) {
  var polar = this;
  var angleAxis = polar.getAngleAxis();
  var radiusAxis = polar.getRadiusAxis();
  angleAxis.scale.setExtent(Infinity, -Infinity);
  radiusAxis.scale.setExtent(Infinity, -Infinity);
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem === polar) {
      var data_1 = seriesModel.getData();
      each$f(getDataDimensionsOnAxis(data_1, "radius"), function(dim) {
        radiusAxis.scale.unionExtentFromData(data_1, dim);
      });
      each$f(getDataDimensionsOnAxis(data_1, "angle"), function(dim) {
        angleAxis.scale.unionExtentFromData(data_1, dim);
      });
    }
  });
  niceScaleExtent(angleAxis.scale, angleAxis.model);
  niceScaleExtent(radiusAxis.scale, radiusAxis.model);
  if (angleAxis.type === "category" && !angleAxis.onBand) {
    var extent3 = angleAxis.getExtent();
    var diff = 360 / angleAxis.scale.count();
    angleAxis.inverse ? extent3[1] += diff : extent3[1] -= diff;
    angleAxis.setExtent(extent3[0], extent3[1]);
  }
}
function isAngleAxisModel(axisModel) {
  return axisModel.mainType === "angleAxis";
}
function setAxis(axis, axisModel) {
  axis.type = axisModel.get("type");
  axis.scale = createScaleByModel$1(axisModel);
  axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
  axis.inverse = axisModel.get("inverse");
  if (isAngleAxisModel(axisModel)) {
    axis.inverse = axis.inverse !== axisModel.get("clockwise");
    var startAngle = axisModel.get("startAngle");
    axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
  }
  axisModel.axis = axis;
  axis.model = axisModel;
}
var polarCreator = {
  dimensions: polarDimensions,
  create: function(ecModel, api) {
    var polarList = [];
    ecModel.eachComponent("polar", function(polarModel, idx) {
      var polar = new Polar$1(idx + "");
      polar.update = updatePolarScale;
      var radiusAxis = polar.getRadiusAxis();
      var angleAxis = polar.getAngleAxis();
      var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      var angleAxisModel = polarModel.findAxisModel("angleAxis");
      setAxis(radiusAxis, radiusAxisModel);
      setAxis(angleAxis, angleAxisModel);
      resizePolar(polar, polarModel, api);
      polarList.push(polar);
      polarModel.coordinateSystem = polar;
      polar.model = polarModel;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "polar") {
        var polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
        seriesModel.coordinateSystem = polarModel.coordinateSystem;
      }
    });
    return polarList;
  }
};
var polarCreator$1 = polarCreator;
var elementList = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function getAxisLineShape(polar, rExtent, angle) {
  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
  var start2 = polar.coordToPoint([rExtent[0], angle]);
  var end2 = polar.coordToPoint([rExtent[1], angle]);
  return {
    x1: start2[0],
    y1: start2[1],
    x2: end2[0],
    y2: end2[1]
  };
}
function getRadiusIdx(polar) {
  var radiusAxis = polar.getRadiusAxis();
  return radiusAxis.inverse ? 0 : 1;
}
function fixAngleOverlap(list) {
  var firstItem = list[0];
  var lastItem = list[list.length - 1];
  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
    list.pop();
  }
}
var AngleAxisView = function(_super) {
  __extends(AngleAxisView2, _super);
  function AngleAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = AngleAxisView2.type;
    _this.axisPointerClass = "PolarAxisPointer";
    return _this;
  }
  AngleAxisView2.prototype.render = function(angleAxisModel, ecModel) {
    this.group.removeAll();
    if (!angleAxisModel.get("show")) {
      return;
    }
    var angleAxis = angleAxisModel.axis;
    var polar = angleAxis.polar;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var ticksAngles = angleAxis.getTicksCoords();
    var minorTickAngles = angleAxis.getMinorTicksCoords();
    var labels = map$1(angleAxis.getViewLabels(), function(labelItem) {
      labelItem = clone$4(labelItem);
      var scale2 = angleAxis.scale;
      var tickValue = scale2.type === "ordinal" ? scale2.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      labelItem.coord = angleAxis.dataToCoord(tickValue);
      return labelItem;
    });
    fixAngleOverlap(labels);
    fixAngleOverlap(ticksAngles);
    each$f(elementList, function(name) {
      if (angleAxisModel.get([name, "show"]) && (!angleAxis.scale.isBlank() || name === "axisLine")) {
        angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
      }
    }, this);
  };
  AngleAxisView2.type = "angleAxis";
  return AngleAxisView2;
}(AxisView$1);
var angelAxisElementsBuilders = {
  axisLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var lineStyleModel = angleAxisModel.getModel(["axisLine", "lineStyle"]);
    var rId = getRadiusIdx(polar);
    var r0Id = rId ? 0 : 1;
    var shape;
    if (radiusExtent[r0Id] === 0) {
      shape = new Circle$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    } else {
      shape = new Ring$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId],
          r0: radiusExtent[r0Id]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    }
    shape.style.fill = null;
    group.add(shape);
  },
  axisTick: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var tickModel = angleAxisModel.getModel("axisTick");
    var tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
    var radius = radiusExtent[getRadiusIdx(polar)];
    var lines = map$1(ticksAngles, function(tickAngleItem) {
      return new Line$3({
        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
      });
    });
    group.add(mergePath(lines, {
      style: defaults(tickModel.getModel("lineStyle").getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    var tickModel = angleAxisModel.getModel("axisTick");
    var minorTickModel = angleAxisModel.getModel("minorTick");
    var tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
    var radius = radiusExtent[getRadiusIdx(polar)];
    var lines = [];
    for (var i = 0; i < minorTickAngles.length; i++) {
      for (var k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line$3({
          shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath(lines, {
      style: defaults(minorTickModel.getModel("lineStyle").getLineStyle(), defaults(tickModel.getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      }))
    }));
  },
  axisLabel: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
    var rawCategoryData = angleAxisModel.getCategories(true);
    var commonLabelModel = angleAxisModel.getModel("axisLabel");
    var labelMargin = commonLabelModel.get("margin");
    var triggerEvent = angleAxisModel.get("triggerEvent");
    each$f(labels, function(labelItem, idx) {
      var labelModel = commonLabelModel;
      var tickValue = labelItem.tickValue;
      var r = radiusExtent[getRadiusIdx(polar)];
      var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
      var cx = polar.cx;
      var cy = polar.cy;
      var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? "center" : p[0] > cx ? "left" : "right";
      var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? "middle" : p[1] > cy ? "top" : "bottom";
      if (rawCategoryData && rawCategoryData[tickValue]) {
        var rawCategoryItem = rawCategoryData[tickValue];
        if (isObject$3(rawCategoryItem) && rawCategoryItem.textStyle) {
          labelModel = new Model$1(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);
        }
      }
      var textEl = new ZRText$1({
        silent: AxisBuilder$1.isLabelSilent(angleAxisModel),
        style: createTextStyle$1(labelModel, {
          x: p[0],
          y: p[1],
          fill: labelModel.getTextColor() || angleAxisModel.get(["axisLine", "lineStyle", "color"]),
          text: labelItem.formattedLabel,
          align: labelTextAlign,
          verticalAlign: labelTextVerticalAlign
        })
      });
      group.add(textEl);
      if (triggerEvent) {
        var eventData = AxisBuilder$1.makeAxisEventDataBase(angleAxisModel);
        eventData.targetType = "axisLabel";
        eventData.value = labelItem.rawLabel;
        getECData(textEl).eventData = eventData;
      }
    }, this);
  },
  splitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    var splitLineModel = angleAxisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    var lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var splitLines = [];
    for (var i = 0; i < ticksAngles.length; i++) {
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Line$3({
        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
      }));
    }
    for (var i = 0; i < splitLines.length; i++) {
      group.add(mergePath(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyleModel.getLineStyle()),
        silent: true,
        z: angleAxisModel.get("z")
      }));
    }
  },
  minorSplitLine: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    var minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var lines = [];
    for (var i = 0; i < minorTickAngles.length; i++) {
      for (var k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line$3({
          shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath(lines, {
      style: lineStyleModel.getLineStyle(),
      silent: true,
      z: angleAxisModel.get("z")
    }));
  },
  splitArea: function(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!ticksAngles.length) {
      return;
    }
    var splitAreaModel = angleAxisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    var splitAreas = [];
    var RADIAN2 = Math.PI / 180;
    var prevAngle = -ticksAngles[0].coord * RADIAN2;
    var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
    var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
    var clockwise = angleAxisModel.get("clockwise");
    for (var i = 1, len2 = ticksAngles.length; i <= len2; i++) {
      var coord = i === len2 ? ticksAngles[0].coord : ticksAngles[i].coord;
      var colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0,
          r: r1,
          startAngle: prevAngle,
          endAngle: -coord * RADIAN2,
          clockwise
        },
        silent: true
      }));
      prevAngle = -coord * RADIAN2;
    }
    for (var i = 0; i < splitAreas.length; i++) {
      group.add(mergePath(splitAreas[i], {
        style: defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
var AngleAxisView$1 = AngleAxisView;
var axisBuilderAttrs$1 = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs$1 = ["splitLine", "splitArea", "minorSplitLine"];
var RadiusAxisView = function(_super) {
  __extends(RadiusAxisView2, _super);
  function RadiusAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = RadiusAxisView2.type;
    _this.axisPointerClass = "PolarAxisPointer";
    return _this;
  }
  RadiusAxisView2.prototype.render = function(radiusAxisModel, ecModel) {
    this.group.removeAll();
    if (!radiusAxisModel.get("show")) {
      return;
    }
    var oldAxisGroup = this._axisGroup;
    var newAxisGroup = this._axisGroup = new Group$4();
    this.group.add(newAxisGroup);
    var radiusAxis = radiusAxisModel.axis;
    var polar = radiusAxis.polar;
    var angleAxis = polar.getAngleAxis();
    var ticksCoords = radiusAxis.getTicksCoords();
    var minorTicksCoords = radiusAxis.getMinorTicksCoords();
    var axisAngle = angleAxis.getExtent()[0];
    var radiusExtent = radiusAxis.getExtent();
    var layout2 = layoutAxis(polar, radiusAxisModel, axisAngle);
    var axisBuilder = new AxisBuilder$1(radiusAxisModel, layout2);
    each$f(axisBuilderAttrs$1, axisBuilder.add, axisBuilder);
    newAxisGroup.add(axisBuilder.getGroup());
    groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);
    each$f(selfBuilderAttrs$1, function(name) {
      if (radiusAxisModel.get([name, "show"]) && !radiusAxis.scale.isBlank()) {
        axisElementBuilders$1[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
      }
    }, this);
  };
  RadiusAxisView2.type = "radiusAxis";
  return RadiusAxisView2;
}(AxisView$1);
var axisElementBuilders$1 = {
  splitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    var splitLineModel = radiusAxisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    var lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var splitLines = [];
    for (var i = 0; i < ticksCoords.length; i++) {
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Circle$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: ticksCoords[i].coord
        }
      }));
    }
    for (var i = 0; i < splitLines.length; i++) {
      group.add(mergePath(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length],
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }));
    }
  },
  minorSplitLine: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
    if (!minorTicksCoords.length) {
      return;
    }
    var minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
    var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    var lines = [];
    for (var i = 0; i < minorTicksCoords.length; i++) {
      for (var k = 0; k < minorTicksCoords[i].length; k++) {
        lines.push(new Circle$1({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: minorTicksCoords[i][k].coord
          }
        }));
      }
    }
    group.add(mergePath(lines, {
      style: defaults({
        fill: null
      }, lineStyleModel.getLineStyle()),
      silent: true
    }));
  },
  splitArea: function(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    if (!ticksCoords.length) {
      return;
    }
    var splitAreaModel = radiusAxisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    var splitAreas = [];
    var prevRadius = ticksCoords[0].coord;
    for (var i = 1; i < ticksCoords.length; i++) {
      var colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector$1({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0: prevRadius,
          r: ticksCoords[i].coord,
          startAngle: 0,
          endAngle: Math.PI * 2
        },
        silent: true
      }));
      prevRadius = ticksCoords[i].coord;
    }
    for (var i = 0; i < splitAreas.length; i++) {
      group.add(mergePath(splitAreas[i], {
        style: defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
function layoutAxis(polar, radiusAxisModel, axisAngle) {
  return {
    position: [polar.cx, polar.cy],
    rotation: axisAngle / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
    z2: 1
  };
}
var RadiusAxisView$1 = RadiusAxisView;
function getSeriesStackId(seriesModel) {
  return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
}
function getAxisKey(polar, axis) {
  return axis.dim + polar.model.componentIndex;
}
function barLayoutPolar(seriesType2, ecModel, api) {
  var lastStackCoords = {};
  var barWidthAndOffset = calRadialBar(filter(ecModel.getSeriesByType(seriesType2), function(seriesModel) {
    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
  }));
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (seriesModel.coordinateSystem.type !== "polar") {
      return;
    }
    var data = seriesModel.getData();
    var polar = seriesModel.coordinateSystem;
    var baseAxis = polar.getBaseAxis();
    var axisKey = getAxisKey(polar, baseAxis);
    var stackId = getSeriesStackId(seriesModel);
    var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
    var columnOffset = columnLayoutInfo.offset;
    var columnWidth = columnLayoutInfo.width;
    var valueAxis2 = polar.getOtherAxis(baseAxis);
    var cx = seriesModel.coordinateSystem.cx;
    var cy = seriesModel.coordinateSystem.cy;
    var barMinHeight = seriesModel.get("barMinHeight") || 0;
    var barMinAngle = seriesModel.get("barMinAngle") || 0;
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    var valueDim = data.mapDimension(valueAxis2.dim);
    var baseDim = data.mapDimension(baseAxis.dim);
    var stacked = isDimensionStacked$2(data, valueDim);
    var clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
    var valueAxisStart = valueAxis2.dataToCoord(0);
    for (var idx = 0, len2 = data.count(); idx < len2; idx++) {
      var value = data.get(valueDim, idx);
      var baseValue = data.get(baseDim, idx);
      var sign2 = value >= 0 ? "p" : "n";
      var baseCoord = valueAxisStart;
      if (stacked) {
        if (!lastStackCoords[stackId][baseValue]) {
          lastStackCoords[stackId][baseValue] = {
            p: valueAxisStart,
            n: valueAxisStart
          };
        }
        baseCoord = lastStackCoords[stackId][baseValue][sign2];
      }
      var r0 = void 0;
      var r = void 0;
      var startAngle = void 0;
      var endAngle = void 0;
      if (valueAxis2.dim === "radius") {
        var radiusSpan = valueAxis2.dataToCoord(value) - valueAxisStart;
        var angle = baseAxis.dataToCoord(baseValue);
        if (Math.abs(radiusSpan) < barMinHeight) {
          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
        }
        r0 = baseCoord;
        r = baseCoord + radiusSpan;
        startAngle = angle - columnOffset;
        endAngle = startAngle - columnWidth;
        stacked && (lastStackCoords[stackId][baseValue][sign2] = r);
      } else {
        var angleSpan = valueAxis2.dataToCoord(value, clampLayout) - valueAxisStart;
        var radius = baseAxis.dataToCoord(baseValue);
        if (Math.abs(angleSpan) < barMinAngle) {
          angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
        }
        r0 = radius + columnOffset;
        r = r0 + columnWidth;
        startAngle = baseCoord;
        endAngle = baseCoord + angleSpan;
        stacked && (lastStackCoords[stackId][baseValue][sign2] = endAngle);
      }
      data.setItemLayout(idx, {
        cx,
        cy,
        r0,
        r,
        startAngle: -startAngle * Math.PI / 180,
        endAngle: -endAngle * Math.PI / 180,
        clockwise: startAngle >= endAngle
      });
    }
  });
}
function calRadialBar(barSeries) {
  var columnsMap = {};
  each$f(barSeries, function(seriesModel, idx) {
    var data = seriesModel.getData();
    var polar = seriesModel.coordinateSystem;
    var baseAxis = polar.getBaseAxis();
    var axisKey = getAxisKey(polar, baseAxis);
    var axisExtent = baseAxis.getExtent();
    var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    var columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    };
    var stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    var stackId = getSeriesStackId(seriesModel);
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    var barWidth = parsePercent$1(seriesModel.get("barWidth"), bandWidth);
    var barMaxWidth = parsePercent$1(seriesModel.get("barMaxWidth"), bandWidth);
    var barGap = seriesModel.get("barGap");
    var barCategoryGap = seriesModel.get("barCategoryGap");
    if (barWidth && !stacks[stackId].width) {
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      stacks[stackId].width = barWidth;
      columnsOnAxis.remainedWidth -= barWidth;
    }
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    barGap != null && (columnsOnAxis.gap = barGap);
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  var result = {};
  each$f(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    var stacks = columnsOnAxis.stacks;
    var bandWidth = columnsOnAxis.bandWidth;
    var categoryGap = parsePercent$1(columnsOnAxis.categoryGap, bandWidth);
    var barGapPercent = parsePercent$1(columnsOnAxis.gap, 1);
    var remainedWidth = columnsOnAxis.remainedWidth;
    var autoWidthCount = columnsOnAxis.autoWidthCount;
    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each$f(stacks, function(column, stack) {
      var maxWidth = column.maxWidth;
      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);
        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }
        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    var widthSum = 0;
    var lastColumn;
    each$f(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    var offset = -widthSum / 2;
    each$f(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
var angleAxisExtraOption = {
  startAngle: 90,
  clockwise: true,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
};
var radiusAxisExtraOption = {
  splitNumber: 5
};
var PolarView = function(_super) {
  __extends(PolarView2, _super);
  function PolarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PolarView2.type;
    return _this;
  }
  PolarView2.type = "polar";
  return PolarView2;
}(ComponentView$1);
function install$E(registers) {
  use(install$G);
  AxisView$1.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer$1);
  registers.registerCoordinateSystem("polar", polarCreator$1);
  registers.registerComponentModel(PolarModel$1);
  registers.registerComponentView(PolarView);
  axisModelCreator(registers, "angle", AngleAxisModel, angleAxisExtraOption);
  axisModelCreator(registers, "radius", RadiusAxisModel, radiusAxisExtraOption);
  registers.registerComponentView(AngleAxisView$1);
  registers.registerComponentView(RadiusAxisView$1);
  registers.registerLayout(curry$1(barLayoutPolar, "bar"));
}
function layout$1(axisModel, opt) {
  opt = opt || {};
  var single = axisModel.coordinateSystem;
  var axis = axisModel.axis;
  var layout2 = {};
  var axisPosition = axis.position;
  var orient = axis.orient;
  var rect = single.getRect();
  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  var positionMap = {
    horizontal: {
      top: rectBound[2],
      bottom: rectBound[3]
    },
    vertical: {
      left: rectBound[0],
      right: rectBound[1]
    }
  };
  layout2.position = [orient === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0], orient === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]];
  var r = {
    horizontal: 0,
    vertical: 1
  };
  layout2.rotation = Math.PI / 2 * r[orient];
  var directionMap = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = directionMap[axisPosition];
  if (axisModel.get(["axisTick", "inside"])) {
    layout2.tickDirection = -layout2.tickDirection;
  }
  if (retrieve$2(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout2.labelDirection = -layout2.labelDirection;
  }
  var labelRotation = opt.rotate;
  labelRotation == null && (labelRotation = axisModel.get(["axisLabel", "rotate"]));
  layout2.labelRotation = axisPosition === "top" ? -labelRotation : labelRotation;
  layout2.z2 = 1;
  return layout2;
}
var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
var selfBuilderAttrs = ["splitArea", "splitLine"];
var SingleAxisView = function(_super) {
  __extends(SingleAxisView2, _super);
  function SingleAxisView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SingleAxisView2.type;
    _this.axisPointerClass = "SingleAxisPointer";
    return _this;
  }
  SingleAxisView2.prototype.render = function(axisModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();
    var oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group$4();
    var layout2 = layout$1(axisModel);
    var axisBuilder = new AxisBuilder$1(axisModel, layout2);
    each$f(axisBuilderAttrs, axisBuilder.add, axisBuilder);
    group.add(this._axisGroup);
    group.add(axisBuilder.getGroup());
    each$f(selfBuilderAttrs, function(name) {
      if (axisModel.get([name, "show"])) {
        axisElementBuilders[name](this, this.group, this._axisGroup, axisModel);
      }
    }, this);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
  };
  SingleAxisView2.prototype.remove = function() {
    rectCoordAxisHandleRemove(this);
  };
  SingleAxisView2.type = "singleAxis";
  return SingleAxisView2;
}(AxisView$1);
var axisElementBuilders = {
  splitLine: function(axisView, group, axisGroup, axisModel) {
    var axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine");
    var lineStyleModel = splitLineModel.getModel("lineStyle");
    var lineColors = lineStyleModel.get("color");
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    var gridRect = axisModel.coordinateSystem.getRect();
    var isHorizontal = axis.isHorizontal();
    var splitLines = [];
    var lineCount = 0;
    var ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    var p12 = [];
    var p22 = [];
    for (var i = 0; i < ticksCoords.length; ++i) {
      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (isHorizontal) {
        p12[0] = tickCoord;
        p12[1] = gridRect.y;
        p22[0] = tickCoord;
        p22[1] = gridRect.y + gridRect.height;
      } else {
        p12[0] = gridRect.x;
        p12[1] = tickCoord;
        p22[0] = gridRect.x + gridRect.width;
        p22[1] = tickCoord;
      }
      var colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Line$3({
        subPixelOptimize: true,
        shape: {
          x1: p12[0],
          y1: p12[1],
          x2: p22[0],
          y2: p22[1]
        },
        silent: true
      }));
    }
    var lineStyle = lineStyleModel.getLineStyle(["color"]);
    for (var i = 0; i < splitLines.length; ++i) {
      group.add(mergePath(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyle),
        silent: true
      }));
    }
  },
  splitArea: function(axisView, group, axisGroup, axisModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, axisModel);
  }
};
var SingleAxisView$1 = SingleAxisView;
var SingleAxisModel = function(_super) {
  __extends(SingleAxisModel2, _super);
  function SingleAxisModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SingleAxisModel2.type;
    return _this;
  }
  SingleAxisModel2.prototype.getCoordSysModel = function() {
    return this;
  };
  SingleAxisModel2.type = "singleAxis";
  SingleAxisModel2.layoutMode = "box";
  SingleAxisModel2.defaultOption = {
    left: "5%",
    top: "5%",
    right: "5%",
    bottom: "5%",
    type: "value",
    position: "bottom",
    orient: "horizontal",
    axisLine: {
      show: true,
      lineStyle: {
        width: 1,
        type: "solid"
      }
    },
    tooltip: {
      show: true
    },
    axisTick: {
      show: true,
      length: 6,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      interval: "auto"
    },
    splitLine: {
      show: true,
      lineStyle: {
        type: "dashed",
        opacity: 0.2
      }
    }
  };
  return SingleAxisModel2;
}(ComponentModel$1);
mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
var SingleAxisModel$1 = SingleAxisModel;
var SingleAxis = function(_super) {
  __extends(SingleAxis2, _super);
  function SingleAxis2(dim, scale2, coordExtent, axisType, position2) {
    var _this = _super.call(this, dim, scale2, coordExtent) || this;
    _this.type = axisType || "value";
    _this.position = position2 || "bottom";
    return _this;
  }
  SingleAxis2.prototype.isHorizontal = function() {
    var position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  };
  SingleAxis2.prototype.pointToData = function(point, clamp2) {
    return this.coordinateSystem.pointToData(point)[0];
  };
  return SingleAxis2;
}(Axis$1);
var SingleAxis$1 = SingleAxis;
var singleDimensions = ["single"];
var Single = function() {
  function Single2(axisModel, ecModel, api) {
    this.type = "single";
    this.dimension = "single";
    this.dimensions = singleDimensions;
    this.axisPointerEnabled = true;
    this.model = axisModel;
    this._init(axisModel, ecModel, api);
  }
  Single2.prototype._init = function(axisModel, ecModel, api) {
    var dim = this.dimension;
    var axis = new SingleAxis$1(dim, createScaleByModel$1(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
    var isCategory2 = axis.type === "category";
    axis.onBand = isCategory2 && axisModel.get("boundaryGap");
    axis.inverse = axisModel.get("inverse");
    axis.orient = axisModel.get("orient");
    axisModel.axis = axis;
    axis.model = axisModel;
    axis.coordinateSystem = this;
    this._axis = axis;
  };
  Single2.prototype.update = function(ecModel, api) {
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem === this) {
        var data_1 = seriesModel.getData();
        each$f(data_1.mapDimensionsAll(this.dimension), function(dim) {
          this._axis.scale.unionExtentFromData(data_1, dim);
        }, this);
        niceScaleExtent(this._axis.scale, this._axis.model);
      }
    }, this);
  };
  Single2.prototype.resize = function(axisModel, api) {
    this._rect = getLayoutRect({
      left: axisModel.get("left"),
      top: axisModel.get("top"),
      right: axisModel.get("right"),
      bottom: axisModel.get("bottom"),
      width: axisModel.get("width"),
      height: axisModel.get("height")
    }, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._adjustAxis();
  };
  Single2.prototype.getRect = function() {
    return this._rect;
  };
  Single2.prototype._adjustAxis = function() {
    var rect = this._rect;
    var axis = this._axis;
    var isHorizontal = axis.isHorizontal();
    var extent3 = isHorizontal ? [0, rect.width] : [0, rect.height];
    var idx = axis.reverse ? 1 : 0;
    axis.setExtent(extent3[idx], extent3[1 - idx]);
    this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
  };
  Single2.prototype._updateAxisTransform = function(axis, coordBase) {
    var axisExtent = axis.getExtent();
    var extentSum = axisExtent[0] + axisExtent[1];
    var isHorizontal = axis.isHorizontal();
    axis.toGlobalCoord = isHorizontal ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return extentSum - coord + coordBase;
    };
    axis.toLocalCoord = isHorizontal ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return extentSum - coord + coordBase;
    };
  };
  Single2.prototype.getAxis = function() {
    return this._axis;
  };
  Single2.prototype.getBaseAxis = function() {
    return this._axis;
  };
  Single2.prototype.getAxes = function() {
    return [this._axis];
  };
  Single2.prototype.getTooltipAxes = function() {
    return {
      baseAxes: [this.getAxis()],
      otherAxes: []
    };
  };
  Single2.prototype.containPoint = function(point) {
    var rect = this.getRect();
    var axis = this.getAxis();
    var orient = axis.orient;
    if (orient === "horizontal") {
      return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;
    } else {
      return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;
    }
  };
  Single2.prototype.pointToData = function(point) {
    var axis = this.getAxis();
    return [axis.coordToData(axis.toLocalCoord(point[axis.orient === "horizontal" ? 0 : 1]))];
  };
  Single2.prototype.dataToPoint = function(val) {
    var axis = this.getAxis();
    var rect = this.getRect();
    var pt = [];
    var idx = axis.orient === "horizontal" ? 0 : 1;
    if (val instanceof Array) {
      val = val[0];
    }
    pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
    pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
    return pt;
  };
  Single2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys$1(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  };
  Single2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys$1(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  };
  return Single2;
}();
function getCoordSys$1(finder) {
  var seriesModel = finder.seriesModel;
  var singleModel = finder.singleAxisModel;
  return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
function create$1(ecModel, api) {
  var singles = [];
  ecModel.eachComponent("singleAxis", function(axisModel, idx) {
    var single = new Single(axisModel, ecModel, api);
    single.name = "single_" + idx;
    single.resize(axisModel, api);
    axisModel.coordinateSystem = single;
    singles.push(single);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "singleAxis") {
      var singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
    }
  });
  return singles;
}
var singleCreator = {
  create: create$1,
  dimensions: singleDimensions
};
var singleCreator$1 = singleCreator;
var XY$1 = ["x", "y"];
var WH$1 = ["width", "height"];
var SingleAxisPointer = function(_super) {
  __extends(SingleAxisPointer2, _super);
  function SingleAxisPointer2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SingleAxisPointer2.prototype.makeElOption = function(elOption, value, axisModel, axisPointerModel, api) {
    var axis = axisModel.axis;
    var coordSys = axis.coordinateSystem;
    var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
    var pixelValue = coordSys.dataToPoint(value)[0];
    var axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      var elStyle = buildElStyle(axisPointerModel);
      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    var layoutInfo = layout$1(axisModel);
    buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
  };
  SingleAxisPointer2.prototype.getHandleTransform = function(value, axisModel, axisPointerModel) {
    var layoutInfo = layout$1(axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    var position2 = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: position2[0],
      y: position2[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  };
  SingleAxisPointer2.prototype.updateHandleTransform = function(transform2, delta, axisModel, axisPointerModel) {
    var axis = axisModel.axis;
    var coordSys = axis.coordinateSystem;
    var dimIndex = getPointDimIndex(axis);
    var axisExtent = getGlobalExtent(coordSys, dimIndex);
    var currPosition = [transform2.x, transform2.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    var cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform2.rotation,
      cursorPoint,
      tooltipOption: {
        verticalAlign: "middle"
      }
    };
  };
  return SingleAxisPointer2;
}(BaseAxisPointer$1);
var pointerShapeBuilder = {
  line: function(axis, pixelValue, otherExtent) {
    var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    var bandWidth = axis.getBandWidth();
    var span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
    };
  }
};
function getPointDimIndex(axis) {
  return axis.isHorizontal() ? 0 : 1;
}
function getGlobalExtent(coordSys, dimIndex) {
  var rect = coordSys.getRect();
  return [rect[XY$1[dimIndex]], rect[XY$1[dimIndex]] + rect[WH$1[dimIndex]]];
}
var SingleAxisPointer$1 = SingleAxisPointer;
var SingleView = function(_super) {
  __extends(SingleView2, _super);
  function SingleView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SingleView2.type;
    return _this;
  }
  SingleView2.type = "single";
  return SingleView2;
}(ComponentView$1);
function install$D(registers) {
  use(install$G);
  AxisView$1.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer$1);
  registers.registerComponentView(SingleView);
  registers.registerComponentView(SingleAxisView$1);
  registers.registerComponentModel(SingleAxisModel$1);
  axisModelCreator(registers, "single", SingleAxisModel$1, SingleAxisModel$1.defaultOption);
  registers.registerCoordinateSystem("single", singleCreator$1);
}
var CalendarModel = function(_super) {
  __extends(CalendarModel2, _super);
  function CalendarModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CalendarModel2.type;
    return _this;
  }
  CalendarModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);
    _super.prototype.init.apply(this, arguments);
    mergeAndNormalizeLayoutParams$1(option, inputPositionParams);
  };
  CalendarModel2.prototype.mergeOption = function(option) {
    _super.prototype.mergeOption.apply(this, arguments);
    mergeAndNormalizeLayoutParams$1(this.option, option);
  };
  CalendarModel2.prototype.getCellSize = function() {
    return this.option.cellSize;
  };
  CalendarModel2.type = "calendar";
  CalendarModel2.defaultOption = {
    z: 2,
    left: 80,
    top: 60,
    cellSize: 20,
    orient: "horizontal",
    splitLine: {
      show: true,
      lineStyle: {
        color: "#000",
        width: 1,
        type: "solid"
      }
    },
    itemStyle: {
      color: "#fff",
      borderWidth: 1,
      borderColor: "#ccc"
    },
    dayLabel: {
      show: true,
      firstDay: 0,
      position: "start",
      margin: "50%",
      color: "#000"
    },
    monthLabel: {
      show: true,
      position: "start",
      margin: 5,
      align: "center",
      formatter: null,
      color: "#000"
    },
    yearLabel: {
      show: true,
      position: null,
      margin: 30,
      formatter: null,
      color: "#ccc",
      fontFamily: "sans-serif",
      fontWeight: "bolder",
      fontSize: 20
    }
  };
  return CalendarModel2;
}(ComponentModel$1);
function mergeAndNormalizeLayoutParams$1(target, raw) {
  var cellSize = target.cellSize;
  var cellSizeArr;
  if (!isArray$1(cellSize)) {
    cellSizeArr = target.cellSize = [cellSize, cellSize];
  } else {
    cellSizeArr = cellSize;
  }
  if (cellSizeArr.length === 1) {
    cellSizeArr[1] = cellSizeArr[0];
  }
  var ignoreSize = map$1([0, 1], function(hvIdx) {
    if (sizeCalculable(raw, hvIdx)) {
      cellSizeArr[hvIdx] = "auto";
    }
    return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== "auto";
  });
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize
  });
}
var CalendarModel$1 = CalendarModel;
var CalendarView = function(_super) {
  __extends(CalendarView2, _super);
  function CalendarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = CalendarView2.type;
    return _this;
  }
  CalendarView2.prototype.render = function(calendarModel, ecModel, api) {
    var group = this.group;
    group.removeAll();
    var coordSys = calendarModel.coordinateSystem;
    var rangeData = coordSys.getRangeInfo();
    var orient = coordSys.getOrient();
    var localeModel = ecModel.getLocaleModel();
    this._renderDayRect(calendarModel, rangeData, group);
    this._renderLines(calendarModel, rangeData, orient, group);
    this._renderYearText(calendarModel, rangeData, orient, group);
    this._renderMonthText(calendarModel, localeModel, orient, group);
    this._renderWeekText(calendarModel, localeModel, rangeData, orient, group);
  };
  CalendarView2.prototype._renderDayRect = function(calendarModel, rangeData, group) {
    var coordSys = calendarModel.coordinateSystem;
    var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
    var sw = coordSys.getCellWidth();
    var sh2 = coordSys.getCellHeight();
    for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
      var point = coordSys.dataToRect([i], false).tl;
      var rect = new Rect$3({
        shape: {
          x: point[0],
          y: point[1],
          width: sw,
          height: sh2
        },
        cursor: "default",
        style: itemRectStyleModel
      });
      group.add(rect);
    }
  };
  CalendarView2.prototype._renderLines = function(calendarModel, rangeData, orient, group) {
    var self2 = this;
    var coordSys = calendarModel.coordinateSystem;
    var lineStyleModel = calendarModel.getModel(["splitLine", "lineStyle"]).getLineStyle();
    var show = calendarModel.get(["splitLine", "show"]);
    var lineWidth = lineStyleModel.lineWidth;
    this._tlpoints = [];
    this._blpoints = [];
    this._firstDayOfMonth = [];
    this._firstDayPoints = [];
    var firstDay = rangeData.start;
    for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
      addPoints(firstDay.formatedDate);
      if (i === 0) {
        firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
      }
      var date = firstDay.date;
      date.setMonth(date.getMonth() + 1);
      firstDay = coordSys.getDateInfo(date);
    }
    addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
    function addPoints(date2) {
      self2._firstDayOfMonth.push(coordSys.getDateInfo(date2));
      self2._firstDayPoints.push(coordSys.dataToRect([date2], false).tl);
      var points2 = self2._getLinePointsOfOneWeek(calendarModel, date2, orient);
      self2._tlpoints.push(points2[0]);
      self2._blpoints.push(points2[points2.length - 1]);
      show && self2._drawSplitline(points2, lineStyleModel, group);
    }
    show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient), lineStyleModel, group);
    show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient), lineStyleModel, group);
  };
  CalendarView2.prototype._getEdgesPoints = function(points2, lineWidth, orient) {
    var rs = [points2[0].slice(), points2[points2.length - 1].slice()];
    var idx = orient === "horizontal" ? 0 : 1;
    rs[0][idx] = rs[0][idx] - lineWidth / 2;
    rs[1][idx] = rs[1][idx] + lineWidth / 2;
    return rs;
  };
  CalendarView2.prototype._drawSplitline = function(points2, lineStyle, group) {
    var poyline = new Polyline$3({
      z2: 20,
      shape: {
        points: points2
      },
      style: lineStyle
    });
    group.add(poyline);
  };
  CalendarView2.prototype._getLinePointsOfOneWeek = function(calendarModel, date, orient) {
    var coordSys = calendarModel.coordinateSystem;
    var parsedDate = coordSys.getDateInfo(date);
    var points2 = [];
    for (var i = 0; i < 7; i++) {
      var tmpD = coordSys.getNextNDay(parsedDate.time, i);
      var point = coordSys.dataToRect([tmpD.time], false);
      points2[2 * tmpD.day] = point.tl;
      points2[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
    }
    return points2;
  };
  CalendarView2.prototype._formatterLabel = function(formatter, params) {
    if (isString(formatter) && formatter) {
      return formatTplSimple(formatter, params);
    }
    if (isFunction$1(formatter)) {
      return formatter(params);
    }
    return params.nameMap;
  };
  CalendarView2.prototype._yearTextPositionControl = function(textEl, point, orient, position2, margin) {
    var x = point[0];
    var y = point[1];
    var aligns = ["center", "bottom"];
    if (position2 === "bottom") {
      y += margin;
      aligns = ["center", "top"];
    } else if (position2 === "left") {
      x -= margin;
    } else if (position2 === "right") {
      x += margin;
      aligns = ["center", "top"];
    } else {
      y -= margin;
    }
    var rotate2 = 0;
    if (position2 === "left" || position2 === "right") {
      rotate2 = Math.PI / 2;
    }
    return {
      rotation: rotate2,
      x,
      y,
      style: {
        align: aligns[0],
        verticalAlign: aligns[1]
      }
    };
  };
  CalendarView2.prototype._renderYearText = function(calendarModel, rangeData, orient, group) {
    var yearLabel = calendarModel.getModel("yearLabel");
    if (!yearLabel.get("show")) {
      return;
    }
    var margin = yearLabel.get("margin");
    var pos = yearLabel.get("position");
    if (!pos) {
      pos = orient !== "horizontal" ? "top" : "left";
    }
    var points2 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
    var xc = (points2[0][0] + points2[1][0]) / 2;
    var yc = (points2[0][1] + points2[1][1]) / 2;
    var idx = orient === "horizontal" ? 0 : 1;
    var posPoints = {
      top: [xc, points2[idx][1]],
      bottom: [xc, points2[1 - idx][1]],
      left: [points2[1 - idx][0], yc],
      right: [points2[idx][0], yc]
    };
    var name = rangeData.start.y;
    if (+rangeData.end.y > +rangeData.start.y) {
      name = name + "-" + rangeData.end.y;
    }
    var formatter = yearLabel.get("formatter");
    var params = {
      start: rangeData.start.y,
      end: rangeData.end.y,
      nameMap: name
    };
    var content = this._formatterLabel(formatter, params);
    var yearText = new ZRText$1({
      z2: 30,
      style: createTextStyle$1(yearLabel, {
        text: content
      })
    });
    yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
    group.add(yearText);
  };
  CalendarView2.prototype._monthTextPositionControl = function(point, isCenter, orient, position2, margin) {
    var align = "left";
    var vAlign = "top";
    var x = point[0];
    var y = point[1];
    if (orient === "horizontal") {
      y = y + margin;
      if (isCenter) {
        align = "center";
      }
      if (position2 === "start") {
        vAlign = "bottom";
      }
    } else {
      x = x + margin;
      if (isCenter) {
        vAlign = "middle";
      }
      if (position2 === "start") {
        align = "right";
      }
    }
    return {
      x,
      y,
      align,
      verticalAlign: vAlign
    };
  };
  CalendarView2.prototype._renderMonthText = function(calendarModel, localeModel, orient, group) {
    var monthLabel = calendarModel.getModel("monthLabel");
    if (!monthLabel.get("show")) {
      return;
    }
    var nameMap = monthLabel.get("nameMap");
    var margin = monthLabel.get("margin");
    var pos = monthLabel.get("position");
    var align = monthLabel.get("align");
    var termPoints = [this._tlpoints, this._blpoints];
    if (!nameMap || isString(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      nameMap = localeModel.get(["time", "monthAbbr"]) || [];
    }
    var idx = pos === "start" ? 0 : 1;
    var axis = orient === "horizontal" ? 0 : 1;
    margin = pos === "start" ? -margin : margin;
    var isCenter = align === "center";
    for (var i = 0; i < termPoints[idx].length - 1; i++) {
      var tmp = termPoints[idx][i].slice();
      var firstDay = this._firstDayOfMonth[i];
      if (isCenter) {
        var firstDayPoints = this._firstDayPoints[i];
        tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
      }
      var formatter = monthLabel.get("formatter");
      var name_1 = nameMap[+firstDay.m - 1];
      var params = {
        yyyy: firstDay.y,
        yy: (firstDay.y + "").slice(2),
        MM: firstDay.m,
        M: +firstDay.m,
        nameMap: name_1
      };
      var content = this._formatterLabel(formatter, params);
      var monthText = new ZRText$1({
        z2: 30,
        style: extend$1(createTextStyle$1(monthLabel, {
          text: content
        }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin))
      });
      group.add(monthText);
    }
  };
  CalendarView2.prototype._weekTextPositionControl = function(point, orient, position2, margin, cellSize) {
    var align = "center";
    var vAlign = "middle";
    var x = point[0];
    var y = point[1];
    var isStart = position2 === "start";
    if (orient === "horizontal") {
      x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
      align = isStart ? "right" : "left";
    } else {
      y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
      vAlign = isStart ? "bottom" : "top";
    }
    return {
      x,
      y,
      align,
      verticalAlign: vAlign
    };
  };
  CalendarView2.prototype._renderWeekText = function(calendarModel, localeModel, rangeData, orient, group) {
    var dayLabel = calendarModel.getModel("dayLabel");
    if (!dayLabel.get("show")) {
      return;
    }
    var coordSys = calendarModel.coordinateSystem;
    var pos = dayLabel.get("position");
    var nameMap = dayLabel.get("nameMap");
    var margin = dayLabel.get("margin");
    var firstDayOfWeek = coordSys.getFirstDayOfWeek();
    if (!nameMap || isString(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      var dayOfWeekShort = localeModel.get(["time", "dayOfWeekShort"]);
      nameMap = dayOfWeekShort || map$1(localeModel.get(["time", "dayOfWeekAbbr"]), function(val) {
        return val[0];
      });
    }
    var start2 = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
    var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
    margin = parsePercent$1(margin, Math.min(cellSize[1], cellSize[0]));
    if (pos === "start") {
      start2 = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
      margin = -margin;
    }
    for (var i = 0; i < 7; i++) {
      var tmpD = coordSys.getNextNDay(start2, i);
      var point = coordSys.dataToRect([tmpD.time], false).center;
      var day = i;
      day = Math.abs((i + firstDayOfWeek) % 7);
      var weekText = new ZRText$1({
        z2: 30,
        style: extend$1(createTextStyle$1(dayLabel, {
          text: nameMap[day]
        }), this._weekTextPositionControl(point, orient, pos, margin, cellSize))
      });
      group.add(weekText);
    }
  };
  CalendarView2.type = "calendar";
  return CalendarView2;
}(ComponentView$1);
var CalendarView$1 = CalendarView;
var PROXIMATE_ONE_DAY = 864e5;
var Calendar = function() {
  function Calendar2(calendarModel, ecModel, api) {
    this.type = "calendar";
    this.dimensions = Calendar2.dimensions;
    this.getDimensionsInfo = Calendar2.getDimensionsInfo;
    this._model = calendarModel;
  }
  Calendar2.getDimensionsInfo = function() {
    return [{
      name: "time",
      type: "time"
    }, "value"];
  };
  Calendar2.prototype.getRangeInfo = function() {
    return this._rangeInfo;
  };
  Calendar2.prototype.getModel = function() {
    return this._model;
  };
  Calendar2.prototype.getRect = function() {
    return this._rect;
  };
  Calendar2.prototype.getCellWidth = function() {
    return this._sw;
  };
  Calendar2.prototype.getCellHeight = function() {
    return this._sh;
  };
  Calendar2.prototype.getOrient = function() {
    return this._orient;
  };
  Calendar2.prototype.getFirstDayOfWeek = function() {
    return this._firstDayOfWeek;
  };
  Calendar2.prototype.getDateInfo = function(date) {
    date = parseDate(date);
    var y = date.getFullYear();
    var m2 = date.getMonth() + 1;
    var mStr = m2 < 10 ? "0" + m2 : "" + m2;
    var d = date.getDate();
    var dStr = d < 10 ? "0" + d : "" + d;
    var day = date.getDay();
    day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
    return {
      y: y + "",
      m: mStr,
      d: dStr,
      day,
      time: date.getTime(),
      formatedDate: y + "-" + mStr + "-" + dStr,
      date
    };
  };
  Calendar2.prototype.getNextNDay = function(date, n) {
    n = n || 0;
    if (n === 0) {
      return this.getDateInfo(date);
    }
    date = new Date(this.getDateInfo(date).time);
    date.setDate(date.getDate() + n);
    return this.getDateInfo(date);
  };
  Calendar2.prototype.update = function(ecModel, api) {
    this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
    this._orient = this._model.get("orient");
    this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
    this._rangeInfo = this._getRangeInfo(this._initRangeOption());
    var weeks = this._rangeInfo.weeks || 1;
    var whNames = ["width", "height"];
    var cellSize = this._model.getCellSize().slice();
    var layoutParams = this._model.getBoxLayoutParams();
    var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
    each$f([0, 1], function(idx) {
      if (cellSizeSpecified(cellSize, idx)) {
        layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
      }
    });
    var whGlobal = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);
    each$f([0, 1], function(idx) {
      if (!cellSizeSpecified(cellSize, idx)) {
        cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
      }
    });
    function cellSizeSpecified(cellSize2, idx) {
      return cellSize2[idx] != null && cellSize2[idx] !== "auto";
    }
    this._sw = cellSize[0];
    this._sh = cellSize[1];
  };
  Calendar2.prototype.dataToPoint = function(data, clamp2) {
    isArray$1(data) && (data = data[0]);
    clamp2 == null && (clamp2 = true);
    var dayInfo = this.getDateInfo(data);
    var range = this._rangeInfo;
    var date = dayInfo.formatedDate;
    if (clamp2 && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
      return [NaN, NaN];
    }
    var week = dayInfo.day;
    var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
    if (this._orient === "vertical") {
      return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
    }
    return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
  };
  Calendar2.prototype.pointToData = function(point) {
    var date = this.pointToDate(point);
    return date && date.time;
  };
  Calendar2.prototype.dataToRect = function(data, clamp2) {
    var point = this.dataToPoint(data, clamp2);
    return {
      contentShape: {
        x: point[0] - (this._sw - this._lineWidth) / 2,
        y: point[1] - (this._sh - this._lineWidth) / 2,
        width: this._sw - this._lineWidth,
        height: this._sh - this._lineWidth
      },
      center: point,
      tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
      tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
      br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
      bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
    };
  };
  Calendar2.prototype.pointToDate = function(point) {
    var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
    var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
    var range = this._rangeInfo.range;
    if (this._orient === "vertical") {
      return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
    }
    return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
  };
  Calendar2.prototype.convertToPixel = function(ecModel, finder, value) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  };
  Calendar2.prototype.convertFromPixel = function(ecModel, finder, pixel) {
    var coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  };
  Calendar2.prototype.containPoint = function(point) {
    console.warn("Not implemented.");
    return false;
  };
  Calendar2.prototype._initRangeOption = function() {
    var range = this._model.get("range");
    var normalizedRange;
    if (isArray$1(range) && range.length === 1) {
      range = range[0];
    }
    if (!isArray$1(range)) {
      var rangeStr = range.toString();
      if (/^\d{4}$/.test(rangeStr)) {
        normalizedRange = [rangeStr + "-01-01", rangeStr + "-12-31"];
      }
      if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
        var start2 = this.getDateInfo(rangeStr);
        var firstDay = start2.date;
        firstDay.setMonth(firstDay.getMonth() + 1);
        var end2 = this.getNextNDay(firstDay, -1);
        normalizedRange = [start2.formatedDate, end2.formatedDate];
      }
      if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
        normalizedRange = [rangeStr, rangeStr];
      }
    } else {
      normalizedRange = range;
    }
    if (!normalizedRange) {
      return range;
    }
    var tmp = this._getRangeInfo(normalizedRange);
    if (tmp.start.time > tmp.end.time) {
      normalizedRange.reverse();
    }
    return normalizedRange;
  };
  Calendar2.prototype._getRangeInfo = function(range) {
    var parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
    var reversed;
    if (parsedRange[0].time > parsedRange[1].time) {
      reversed = true;
      parsedRange.reverse();
    }
    var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;
    var date = new Date(parsedRange[0].time);
    var startDateNum = date.getDate();
    var endDateNum = parsedRange[1].date.getDate();
    date.setDate(startDateNum + allDay - 1);
    var dateNum = date.getDate();
    if (dateNum !== endDateNum) {
      var sign2 = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;
      while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign2 > 0) {
        allDay -= sign2;
        date.setDate(dateNum - sign2);
      }
    }
    var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
    var nthWeek = reversed ? -weeks + 1 : weeks - 1;
    reversed && parsedRange.reverse();
    return {
      range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
      start: parsedRange[0],
      end: parsedRange[1],
      allDay,
      weeks,
      nthWeek,
      fweek: parsedRange[0].day,
      lweek: parsedRange[1].day
    };
  };
  Calendar2.prototype._getDateByWeeksAndDay = function(nthWeek, day, range) {
    var rangeInfo = this._getRangeInfo(range);
    if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
      return null;
    }
    var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
    var date = new Date(rangeInfo.start.time);
    date.setDate(+rangeInfo.start.d + nthDay);
    return this.getDateInfo(date);
  };
  Calendar2.create = function(ecModel, api) {
    var calendarList = [];
    ecModel.eachComponent("calendar", function(calendarModel) {
      var calendar = new Calendar2(calendarModel, ecModel, api);
      calendarList.push(calendar);
      calendarModel.coordinateSystem = calendar;
    });
    ecModel.eachSeries(function(calendarSeries) {
      if (calendarSeries.get("coordinateSystem") === "calendar") {
        calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
      }
    });
    return calendarList;
  };
  Calendar2.dimensions = ["time", "value"];
  return Calendar2;
}();
function getCoordSys(finder) {
  var calendarModel = finder.calendarModel;
  var seriesModel = finder.seriesModel;
  var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
  return coordSys;
}
var Calendar$1 = Calendar;
function install$C(registers) {
  registers.registerComponentModel(CalendarModel$1);
  registers.registerComponentView(CalendarView$1);
  registers.registerCoordinateSystem("calendar", Calendar$1);
}
function setKeyInfoToNewElOption(resultItem, newElOption) {
  var existElOption = resultItem.existing;
  newElOption.id = resultItem.keyInfo.id;
  !newElOption.type && existElOption && (newElOption.type = existElOption.type);
  if (newElOption.parentId == null) {
    var newElParentOption = newElOption.parentOption;
    if (newElParentOption) {
      newElOption.parentId = newElParentOption.id;
    } else if (existElOption) {
      newElOption.parentId = existElOption.parentId;
    }
  }
  newElOption.parentOption = null;
}
function isSetLoc(obj, props) {
  var isSet;
  each$f(props, function(prop) {
    obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
  });
  return isSet;
}
function mergeNewElOptionToExist(existList, index, newElOption) {
  var newElOptCopy = extend$1({}, newElOption);
  var existElOption = existList[index];
  var $action = newElOption.$action || "merge";
  if ($action === "merge") {
    if (existElOption) {
      merge(existElOption, newElOptCopy, true);
      mergeLayoutParam(existElOption, newElOptCopy, {
        ignoreSize: true
      });
      copyLayoutParams(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption, "shape");
      copyTransitionInfo(newElOption, existElOption, "style");
      copyTransitionInfo(newElOption, existElOption, "extra");
      newElOption.clipPath = existElOption.clipPath;
    } else {
      existList[index] = newElOptCopy;
    }
  } else if ($action === "replace") {
    existList[index] = newElOptCopy;
  } else if ($action === "remove") {
    existElOption && (existList[index] = null);
  }
}
var TRANSITION_PROPS_TO_COPY = ["transition", "enterFrom", "leaveTo"];
var ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function copyTransitionInfo(target, source, targetProp) {
  if (targetProp) {
    if (!target[targetProp] && source[targetProp]) {
      target[targetProp] = {};
    }
    target = target[targetProp];
    source = source[targetProp];
  }
  if (!target || !source) {
    return;
  }
  var props = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY;
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    if (target[prop] == null && source[prop] != null) {
      target[prop] = source[prop];
    }
  }
}
function setLayoutInfoToExist(existItem, newElOption) {
  if (!existItem) {
    return;
  }
  existItem.hv = newElOption.hv = [
    isSetLoc(newElOption, ["left", "right"]),
    isSetLoc(newElOption, ["top", "bottom"])
  ];
  if (existItem.type === "group") {
    var existingGroupOpt = existItem;
    var newGroupOpt = newElOption;
    existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);
    existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);
  }
}
var GraphicComponentModel = function(_super) {
  __extends(GraphicComponentModel2, _super);
  function GraphicComponentModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphicComponentModel2.type;
    _this.preventAutoZ = true;
    return _this;
  }
  GraphicComponentModel2.prototype.mergeOption = function(option, ecModel) {
    var elements = this.option.elements;
    this.option.elements = null;
    _super.prototype.mergeOption.call(this, option, ecModel);
    this.option.elements = elements;
  };
  GraphicComponentModel2.prototype.optionUpdated = function(newOption, isInit) {
    var thisOption = this.option;
    var newList = (isInit ? thisOption : newOption).elements;
    var existList = thisOption.elements = isInit ? [] : thisOption.elements;
    var flattenedList = [];
    this._flatten(newList, flattenedList, null);
    var mappingResult = mappingToExists(existList, flattenedList, "normalMerge");
    var elOptionsToUpdate = this._elOptionsToUpdate = [];
    each$f(mappingResult, function(resultItem, index) {
      var newElOption = resultItem.newOption;
      if (!newElOption) {
        return;
      }
      elOptionsToUpdate.push(newElOption);
      setKeyInfoToNewElOption(resultItem, newElOption);
      mergeNewElOptionToExist(existList, index, newElOption);
      setLayoutInfoToExist(existList[index], newElOption);
    }, this);
    thisOption.elements = filter(existList, function(item) {
      item && delete item.$action;
      return item != null;
    });
  };
  GraphicComponentModel2.prototype._flatten = function(optionList, result, parentOption) {
    each$f(optionList, function(option) {
      if (!option) {
        return;
      }
      if (parentOption) {
        option.parentOption = parentOption;
      }
      result.push(option);
      var children = option.children;
      if (option.type === "group" && children) {
        this._flatten(children, result, option);
      }
      delete option.children;
    }, this);
  };
  GraphicComponentModel2.prototype.useElOptionsToUpdate = function() {
    var els = this._elOptionsToUpdate;
    this._elOptionsToUpdate = null;
    return els;
  };
  GraphicComponentModel2.type = "graphic";
  GraphicComponentModel2.defaultOption = {
    elements: []
  };
  return GraphicComponentModel2;
}(ComponentModel$1);
var nonShapeGraphicElements = {
  path: null,
  compoundPath: null,
  group: Group$4,
  image: ZRImage$1,
  text: ZRText$1
};
var inner$7 = makeInner();
var GraphicComponentView = function(_super) {
  __extends(GraphicComponentView2, _super);
  function GraphicComponentView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = GraphicComponentView2.type;
    return _this;
  }
  GraphicComponentView2.prototype.init = function() {
    this._elMap = createHashMap();
  };
  GraphicComponentView2.prototype.render = function(graphicModel, ecModel, api) {
    if (graphicModel !== this._lastGraphicModel) {
      this._clear();
    }
    this._lastGraphicModel = graphicModel;
    this._updateElements(graphicModel);
    this._relocate(graphicModel, api);
  };
  GraphicComponentView2.prototype._updateElements = function(graphicModel) {
    var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
    if (!elOptionsToUpdate) {
      return;
    }
    var elMap = this._elMap;
    var rootGroup = this.group;
    var globalZ = graphicModel.get("z");
    var globalZLevel = graphicModel.get("zlevel");
    each$f(elOptionsToUpdate, function(elOption) {
      var id = convertOptionIdName(elOption.id, null);
      var elExisting = id != null ? elMap.get(id) : null;
      var parentId = convertOptionIdName(elOption.parentId, null);
      var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
      var elType = elOption.type;
      var elOptionStyle = elOption.style;
      if (elType === "text" && elOptionStyle) {
        if (elOption.hv && elOption.hv[1]) {
          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;
        }
      }
      var textContentOption = elOption.textContent;
      var textConfig = elOption.textConfig;
      if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
        var convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true);
        if (!textConfig && convertResult.textConfig) {
          textConfig = elOption.textConfig = convertResult.textConfig;
        }
        if (!textContentOption && convertResult.textContent) {
          textContentOption = convertResult.textContent;
        }
      }
      var elOptionCleaned = getCleanedElOption(elOption);
      var $action = elOption.$action || "merge";
      var isMerge = $action === "merge";
      var isReplace = $action === "replace";
      if (isMerge) {
        var isInit = !elExisting;
        var el_1 = elExisting;
        if (isInit) {
          el_1 = createEl(id, targetElParent, elOption.type, elMap);
        } else {
          el_1 && (inner$7(el_1).isNew = false);
          stopPreviousKeyframeAnimationAndRestore(el_1);
        }
        if (el_1) {
          applyUpdateTransition(el_1, elOptionCleaned, graphicModel, {
            isInit
          });
          updateCommonAttrs(el_1, elOption, globalZ, globalZLevel);
        }
      } else if (isReplace) {
        removeEl$1(elExisting, elOption, elMap, graphicModel);
        var el_2 = createEl(id, targetElParent, elOption.type, elMap);
        if (el_2) {
          applyUpdateTransition(el_2, elOptionCleaned, graphicModel, {
            isInit: true
          });
          updateCommonAttrs(el_2, elOption, globalZ, globalZLevel);
        }
      } else if ($action === "remove") {
        updateLeaveTo(elExisting, elOption);
        removeEl$1(elExisting, elOption, elMap, graphicModel);
      }
      var el = elMap.get(id);
      if (el && textContentOption) {
        if (isMerge) {
          var textContentExisting = el.getTextContent();
          textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new ZRText$1(textContentOption));
        } else if (isReplace) {
          el.setTextContent(new ZRText$1(textContentOption));
        }
      }
      if (el) {
        var clipPathOption = elOption.clipPath;
        if (clipPathOption) {
          var clipPathType = clipPathOption.type;
          var clipPath = void 0;
          var isInit = false;
          if (isMerge) {
            var oldClipPath = el.getClipPath();
            isInit = !oldClipPath || inner$7(oldClipPath).type !== clipPathType;
            clipPath = isInit ? newEl(clipPathType) : oldClipPath;
          } else if (isReplace) {
            isInit = true;
            clipPath = newEl(clipPathType);
          }
          el.setClipPath(clipPath);
          applyUpdateTransition(clipPath, clipPathOption, graphicModel, {
            isInit
          });
          applyKeyframeAnimation(clipPath, clipPathOption.keyframeAnimation, graphicModel);
        }
        var elInner = inner$7(el);
        el.setTextConfig(textConfig);
        elInner.option = elOption;
        setEventData(el, graphicModel, elOption);
        setTooltipConfig({
          el,
          componentModel: graphicModel,
          itemName: el.name,
          itemTooltipOption: elOption.tooltip
        });
        applyKeyframeAnimation(el, elOption.keyframeAnimation, graphicModel);
      }
    });
  };
  GraphicComponentView2.prototype._relocate = function(graphicModel, api) {
    var elOptions = graphicModel.option.elements;
    var rootGroup = this.group;
    var elMap = this._elMap;
    var apiWidth = api.getWidth();
    var apiHeight = api.getHeight();
    var xy = ["x", "y"];
    for (var i = 0; i < elOptions.length; i++) {
      var elOption = elOptions[i];
      var id = convertOptionIdName(elOption.id, null);
      var el = id != null ? elMap.get(id) : null;
      if (!el || !el.isGroup) {
        continue;
      }
      var parentEl = el.parent;
      var isParentRoot = parentEl === rootGroup;
      var elInner = inner$7(el);
      var parentElInner = inner$7(parentEl);
      elInner.width = parsePercent$1(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0;
      elInner.height = parsePercent$1(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0;
    }
    for (var i = elOptions.length - 1; i >= 0; i--) {
      var elOption = elOptions[i];
      var id = convertOptionIdName(elOption.id, null);
      var el = id != null ? elMap.get(id) : null;
      if (!el) {
        continue;
      }
      var parentEl = el.parent;
      var parentElInner = inner$7(parentEl);
      var containerInfo = parentEl === rootGroup ? {
        width: apiWidth,
        height: apiHeight
      } : {
        width: parentElInner.width,
        height: parentElInner.height
      };
      var layoutPos = {};
      var layouted = positionElement(el, elOption, containerInfo, null, {
        hv: elOption.hv,
        boundingMode: elOption.bounding
      }, layoutPos);
      if (!inner$7(el).isNew && layouted) {
        var transition = elOption.transition;
        var animatePos = {};
        for (var k = 0; k < xy.length; k++) {
          var key = xy[k];
          var val = layoutPos[key];
          if (transition && (isTransitionAll(transition) || indexOf(transition, key) >= 0)) {
            animatePos[key] = val;
          } else {
            el[key] = val;
          }
        }
        updateProps$1(el, animatePos, graphicModel, 0);
      } else {
        el.attr(layoutPos);
      }
    }
  };
  GraphicComponentView2.prototype._clear = function() {
    var _this = this;
    var elMap = this._elMap;
    elMap.each(function(el) {
      removeEl$1(el, inner$7(el).option, elMap, _this._lastGraphicModel);
    });
    this._elMap = createHashMap();
  };
  GraphicComponentView2.prototype.dispose = function() {
    this._clear();
  };
  GraphicComponentView2.type = "graphic";
  return GraphicComponentView2;
}(ComponentView$1);
function newEl(graphicType) {
  var Clz = hasOwn(nonShapeGraphicElements, graphicType) ? nonShapeGraphicElements[graphicType] : getShapeClass(graphicType);
  var el = new Clz({});
  inner$7(el).type = graphicType;
  return el;
}
function createEl(id, targetElParent, graphicType, elMap) {
  var el = newEl(graphicType);
  targetElParent.add(el);
  elMap.set(id, el);
  inner$7(el).id = id;
  inner$7(el).isNew = true;
  return el;
}
function removeEl$1(elExisting, elOption, elMap, graphicModel) {
  var existElParent = elExisting && elExisting.parent;
  if (existElParent) {
    elExisting.type === "group" && elExisting.traverse(function(el) {
      removeEl$1(el, elOption, elMap, graphicModel);
    });
    applyLeaveTransition(elExisting, elOption, graphicModel);
    elMap.removeKey(inner$7(elExisting).id);
  }
}
function updateCommonAttrs(el, elOption, defaultZ, defaultZlevel) {
  if (!el.isGroup) {
    var elDisplayable = el;
    elDisplayable.z = retrieve2(elOption.z, defaultZ || 0);
    elDisplayable.zlevel = retrieve2(elOption.zlevel, defaultZlevel || 0);
    var optZ2 = elOption.z2;
    optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
  }
  each$f(keys(elOption), function(key) {
    var val = elOption[key];
    if (key.indexOf("on") === 0 && isFunction$1(val)) {
      el[key] = val;
    }
  });
  el.draggable = elOption.draggable;
  elOption.name != null && (el.name = elOption.name);
  elOption.id != null && (el.id = elOption.id);
}
function getCleanedElOption(elOption) {
  elOption = extend$1({}, elOption);
  each$f(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(LOCATION_PARAMS), function(name) {
    delete elOption[name];
  });
  return elOption;
}
function setEventData(el, graphicModel, elOption) {
  var eventData = getECData(el).eventData;
  if (!el.silent && !el.ignore && !eventData) {
    eventData = getECData(el).eventData = {
      componentType: "graphic",
      componentIndex: graphicModel.componentIndex,
      name: el.name
    };
  }
  if (eventData) {
    eventData.info = elOption.info;
  }
}
function install$B(registers) {
  registers.registerComponentModel(GraphicComponentModel);
  registers.registerComponentView(GraphicComponentView);
  registers.registerPreprocessor(function(option) {
    var graphicOption = option.graphic;
    if (isArray$1(graphicOption)) {
      if (!graphicOption[0] || !graphicOption[0].elements) {
        option.graphic = [{
          elements: graphicOption
        }];
      } else {
        option.graphic = [option.graphic[0]];
      }
    } else if (graphicOption && !graphicOption.elements) {
      option.graphic = [{
        elements: [graphicOption]
      }];
    }
  });
}
var DATA_ZOOM_AXIS_DIMENSIONS = ["x", "y", "radius", "angle", "single"];
var SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
function isCoordSupported(seriesModel) {
  var coordType = seriesModel.get("coordinateSystem");
  return indexOf(SERIES_COORDS, coordType) >= 0;
}
function getAxisMainType(axisDim) {
  return axisDim + "Axis";
}
function findEffectedDataZooms(ecModel, payload) {
  var axisRecords = createHashMap();
  var effectedModels = [];
  var effectedModelMap = createHashMap();
  ecModel.eachComponent({
    mainType: "dataZoom",
    query: payload
  }, function(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid)) {
      addToEffected(dataZoomModel);
    }
  });
  var foundNewLink;
  do {
    foundNewLink = false;
    ecModel.eachComponent("dataZoom", processSingle);
  } while (foundNewLink);
  function processSingle(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
      addToEffected(dataZoomModel);
      foundNewLink = true;
    }
  }
  function addToEffected(dataZoom) {
    effectedModelMap.set(dataZoom.uid, true);
    effectedModels.push(dataZoom);
    markAxisControlled(dataZoom);
  }
  function isLinked(dataZoomModel) {
    var isLink = false;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var axisIdxArr = axisRecords.get(axisDim);
      if (axisIdxArr && axisIdxArr[axisIndex]) {
        isLink = true;
      }
    });
    return isLink;
  }
  function markAxisControlled(dataZoomModel) {
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
    });
  }
  return effectedModels;
}
function collectReferCoordSysModelInfo(dataZoomModel) {
  var ecModel = dataZoomModel.ecModel;
  var coordSysInfoWrap = {
    infoList: [],
    infoMap: createHashMap()
  };
  dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
    var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    if (!axisModel) {
      return;
    }
    var coordSysModel = axisModel.getCoordSysModel();
    if (!coordSysModel) {
      return;
    }
    var coordSysUid = coordSysModel.uid;
    var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
    if (!coordSysInfo) {
      coordSysInfo = {
        model: coordSysModel,
        axisModels: []
      };
      coordSysInfoWrap.infoList.push(coordSysInfo);
      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
    }
    coordSysInfo.axisModels.push(axisModel);
  });
  return coordSysInfoWrap;
}
var DataZoomAxisInfo = function() {
  function DataZoomAxisInfo2() {
    this.indexList = [];
    this.indexMap = [];
  }
  DataZoomAxisInfo2.prototype.add = function(axisCmptIdx) {
    if (!this.indexMap[axisCmptIdx]) {
      this.indexList.push(axisCmptIdx);
      this.indexMap[axisCmptIdx] = true;
    }
  };
  return DataZoomAxisInfo2;
}();
var DataZoomModel = function(_super) {
  __extends(DataZoomModel2, _super);
  function DataZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = DataZoomModel2.type;
    _this._autoThrottle = true;
    _this._noTarget = true;
    _this._rangePropMode = ["percent", "percent"];
    return _this;
  }
  DataZoomModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputRawOption = retrieveRawOption(option);
    this.settledOption = inputRawOption;
    this.mergeDefaultAndTheme(option, ecModel);
    this._doInit(inputRawOption);
  };
  DataZoomModel2.prototype.mergeOption = function(newOption) {
    var inputRawOption = retrieveRawOption(newOption);
    merge(this.option, newOption, true);
    merge(this.settledOption, inputRawOption, true);
    this._doInit(inputRawOption);
  };
  DataZoomModel2.prototype._doInit = function(inputRawOption) {
    var thisOption = this.option;
    this._setDefaultThrottle(inputRawOption);
    this._updateRangeUse(inputRawOption);
    var settledOption = this.settledOption;
    each$f([["start", "startValue"], ["end", "endValue"]], function(names, index) {
      if (this._rangePropMode[index] === "value") {
        thisOption[names[0]] = settledOption[names[0]] = null;
      }
    }, this);
    this._resetTarget();
  };
  DataZoomModel2.prototype._resetTarget = function() {
    var optionOrient = this.get("orient", true);
    var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
    if (hasAxisSpecified) {
      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
    } else {
      this._orient = optionOrient || "horizontal";
      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
    }
    this._noTarget = true;
    targetAxisIndexMap.each(function(axisInfo) {
      if (axisInfo.indexList.length) {
        this._noTarget = false;
      }
    }, this);
  };
  DataZoomModel2.prototype._fillSpecifiedTargetAxis = function(targetAxisIndexMap) {
    var hasAxisSpecified = false;
    each$f(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
      var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
      if (!refering.specified) {
        return;
      }
      hasAxisSpecified = true;
      var axisInfo = new DataZoomAxisInfo();
      each$f(refering.models, function(axisModel) {
        axisInfo.add(axisModel.componentIndex);
      });
      targetAxisIndexMap.set(axisDim, axisInfo);
    }, this);
    return hasAxisSpecified;
  };
  DataZoomModel2.prototype._fillAutoTargetAxisByOrient = function(targetAxisIndexMap, orient) {
    var ecModel = this.ecModel;
    var needAuto = true;
    if (needAuto) {
      var axisDim = orient === "vertical" ? "y" : "x";
      var axisModels = ecModel.findComponents({
        mainType: axisDim + "Axis"
      });
      setParallelAxis(axisModels, axisDim);
    }
    if (needAuto) {
      var axisModels = ecModel.findComponents({
        mainType: "singleAxis",
        filter: function(axisModel) {
          return axisModel.get("orient", true) === orient;
        }
      });
      setParallelAxis(axisModels, "single");
    }
    function setParallelAxis(axisModels2, axisDim2) {
      var axisModel = axisModels2[0];
      if (!axisModel) {
        return;
      }
      var axisInfo = new DataZoomAxisInfo();
      axisInfo.add(axisModel.componentIndex);
      targetAxisIndexMap.set(axisDim2, axisInfo);
      needAuto = false;
      if (axisDim2 === "x" || axisDim2 === "y") {
        var gridModel_1 = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
        gridModel_1 && each$f(axisModels2, function(axModel) {
          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) {
            axisInfo.add(axModel.componentIndex);
          }
        });
      }
    }
    if (needAuto) {
      each$f(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim2) {
        if (!needAuto) {
          return;
        }
        var axisModels2 = ecModel.findComponents({
          mainType: getAxisMainType(axisDim2),
          filter: function(axisModel) {
            return axisModel.get("type", true) === "category";
          }
        });
        if (axisModels2[0]) {
          var axisInfo = new DataZoomAxisInfo();
          axisInfo.add(axisModels2[0].componentIndex);
          targetAxisIndexMap.set(axisDim2, axisInfo);
          needAuto = false;
        }
      }, this);
    }
  };
  DataZoomModel2.prototype._makeAutoOrientByTargetAxis = function() {
    var dim;
    this.eachTargetAxis(function(axisDim) {
      !dim && (dim = axisDim);
    }, this);
    return dim === "y" ? "vertical" : "horizontal";
  };
  DataZoomModel2.prototype._setDefaultThrottle = function(inputRawOption) {
    if (inputRawOption.hasOwnProperty("throttle")) {
      this._autoThrottle = false;
    }
    if (this._autoThrottle) {
      var globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  };
  DataZoomModel2.prototype._updateRangeUse = function(inputRawOption) {
    var rangePropMode = this._rangePropMode;
    var rangeModeInOption = this.get("rangeMode");
    each$f([["start", "startValue"], ["end", "endValue"]], function(names, index) {
      var percentSpecified = inputRawOption[names[0]] != null;
      var valueSpecified = inputRawOption[names[1]] != null;
      if (percentSpecified && !valueSpecified) {
        rangePropMode[index] = "percent";
      } else if (!percentSpecified && valueSpecified) {
        rangePropMode[index] = "value";
      } else if (rangeModeInOption) {
        rangePropMode[index] = rangeModeInOption[index];
      } else if (percentSpecified) {
        rangePropMode[index] = "percent";
      }
    });
  };
  DataZoomModel2.prototype.noTarget = function() {
    return this._noTarget;
  };
  DataZoomModel2.prototype.getFirstTargetAxisModel = function() {
    var firstAxisModel;
    this.eachTargetAxis(function(axisDim, axisIndex) {
      if (firstAxisModel == null) {
        firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      }
    }, this);
    return firstAxisModel;
  };
  DataZoomModel2.prototype.eachTargetAxis = function(callback, context) {
    this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
      each$f(axisInfo.indexList, function(axisIndex) {
        callback.call(context, axisDim, axisIndex);
      });
    });
  };
  DataZoomModel2.prototype.getAxisProxy = function(axisDim, axisIndex) {
    var axisModel = this.getAxisModel(axisDim, axisIndex);
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
  };
  DataZoomModel2.prototype.getAxisModel = function(axisDim, axisIndex) {
    var axisInfo = this._targetAxisInfoMap.get(axisDim);
    if (axisInfo && axisInfo.indexMap[axisIndex]) {
      return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    }
  };
  DataZoomModel2.prototype.setRawRange = function(opt) {
    var thisOption = this.option;
    var settledOption = this.settledOption;
    each$f([["start", "startValue"], ["end", "endValue"]], function(names) {
      if (opt[names[0]] != null || opt[names[1]] != null) {
        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
      }
    }, this);
    this._updateRangeUse(opt);
  };
  DataZoomModel2.prototype.setCalculatedRange = function(opt) {
    var option = this.option;
    each$f(["start", "startValue", "end", "endValue"], function(name) {
      option[name] = opt[name];
    });
  };
  DataZoomModel2.prototype.getPercentRange = function() {
    var axisProxy = this.findRepresentativeAxisProxy();
    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  };
  DataZoomModel2.prototype.getValueRange = function(axisDim, axisIndex) {
    if (axisDim == null && axisIndex == null) {
      var axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
    }
  };
  DataZoomModel2.prototype.findRepresentativeAxisProxy = function(axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
    var firstProxy;
    var axisDimList = this._targetAxisInfoMap.keys();
    for (var i = 0; i < axisDimList.length; i++) {
      var axisDim = axisDimList[i];
      var axisInfo = this._targetAxisInfoMap.get(axisDim);
      for (var j = 0; j < axisInfo.indexList.length; j++) {
        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
        if (proxy.hostedBy(this)) {
          return proxy;
        }
        if (!firstProxy) {
          firstProxy = proxy;
        }
      }
    }
    return firstProxy;
  };
  DataZoomModel2.prototype.getRangePropMode = function() {
    return this._rangePropMode.slice();
  };
  DataZoomModel2.prototype.getOrient = function() {
    return this._orient;
  };
  DataZoomModel2.type = "dataZoom";
  DataZoomModel2.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"];
  DataZoomModel2.defaultOption = {
    z: 4,
    filterMode: "filter",
    start: 0,
    end: 100
  };
  return DataZoomModel2;
}(ComponentModel$1);
function retrieveRawOption(option) {
  var ret2 = {};
  each$f(["start", "end", "startValue", "endValue", "throttle"], function(name) {
    option.hasOwnProperty(name) && (ret2[name] = option[name]);
  });
  return ret2;
}
var DataZoomModel$1 = DataZoomModel;
var SelectDataZoomModel = function(_super) {
  __extends(SelectDataZoomModel2, _super);
  function SelectDataZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SelectDataZoomModel2.type;
    return _this;
  }
  SelectDataZoomModel2.type = "dataZoom.select";
  return SelectDataZoomModel2;
}(DataZoomModel$1);
var SelectZoomModel = SelectDataZoomModel;
var DataZoomView = function(_super) {
  __extends(DataZoomView2, _super);
  function DataZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = DataZoomView2.type;
    return _this;
  }
  DataZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api;
  };
  DataZoomView2.type = "dataZoom";
  return DataZoomView2;
}(ComponentView$1);
var DataZoomView$1 = DataZoomView;
var SelectDataZoomView = function(_super) {
  __extends(SelectDataZoomView2, _super);
  function SelectDataZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SelectDataZoomView2.type;
    return _this;
  }
  SelectDataZoomView2.type = "dataZoom.select";
  return SelectDataZoomView2;
}(DataZoomView$1);
var SelectZoomView = SelectDataZoomView;
var each$7 = each$f;
var asc$1 = asc$2;
var AxisProxy = function() {
  function AxisProxy2(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel;
  }
  AxisProxy2.prototype.hostedBy = function(dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  };
  AxisProxy2.prototype.getDataValueWindow = function() {
    return this._valueWindow.slice();
  };
  AxisProxy2.prototype.getDataPercentWindow = function() {
    return this._percentWindow.slice();
  };
  AxisProxy2.prototype.getTargetSeriesModels = function() {
    var seriesModels = [];
    this.ecModel.eachSeries(function(seriesModel) {
      if (isCoordSupported(seriesModel)) {
        var axisMainType = getAxisMainType(this._dimName);
        var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
        if (axisModel && this._axisIndex === axisModel.componentIndex) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  };
  AxisProxy2.prototype.getAxisModel = function() {
    return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
  };
  AxisProxy2.prototype.getMinMaxSpan = function() {
    return clone$4(this._minMaxSpan);
  };
  AxisProxy2.prototype.calculateDataWindow = function(opt) {
    var dataExtent = this._dataExtent;
    var axisModel = this.getAxisModel();
    var scale2 = axisModel.axis.scale;
    var rangePropMode = this._dataZoomModel.getRangePropMode();
    var percentExtent = [0, 100];
    var percentWindow = [];
    var valueWindow = [];
    var hasPropModeValue;
    each$7(["start", "end"], function(prop, idx) {
      var boundPercent = opt[prop];
      var boundValue = opt[prop + "Value"];
      if (rangePropMode[idx] === "percent") {
        boundPercent == null && (boundPercent = percentExtent[idx]);
        boundValue = scale2.parse(linearMap$2(boundPercent, percentExtent, dataExtent));
      } else {
        hasPropModeValue = true;
        boundValue = boundValue == null ? dataExtent[idx] : scale2.parse(boundValue);
        boundPercent = linearMap$2(boundValue, dataExtent, percentExtent);
      }
      valueWindow[idx] = boundValue;
      percentWindow[idx] = boundPercent;
    });
    asc$1(valueWindow);
    asc$1(percentWindow);
    var spans = this._minMaxSpan;
    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
      var suffix = toValue ? "Span" : "ValueSpan";
      sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
      for (var i = 0; i < 2; i++) {
        toWindow[i] = linearMap$2(fromWindow[i], fromExtent, toExtent, true);
        toValue && (toWindow[i] = scale2.parse(toWindow[i]));
      }
    }
    return {
      valueWindow,
      percentWindow
    };
  };
  AxisProxy2.prototype.reset = function(dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    var targetSeries = this.getTargetSeriesModels();
    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
    this._updateMinMaxSpan();
    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    this._setAxisModel();
  };
  AxisProxy2.prototype.filterData = function(dataZoomModel, api) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    var axisDim = this._dimName;
    var seriesModels = this.getTargetSeriesModels();
    var filterMode = dataZoomModel.get("filterMode");
    var valueWindow = this._valueWindow;
    if (filterMode === "none") {
      return;
    }
    each$7(seriesModels, function(seriesModel) {
      var seriesData = seriesModel.getData();
      var dataDims = seriesData.mapDimensionsAll(axisDim);
      if (!dataDims.length) {
        return;
      }
      if (filterMode === "weakFilter") {
        var store_1 = seriesData.getStore();
        var dataDimIndices_1 = map$1(dataDims, function(dim) {
          return seriesData.getDimensionIndex(dim);
        }, seriesData);
        seriesData.filterSelf(function(dataIndex) {
          var leftOut;
          var rightOut;
          var hasValue;
          for (var i = 0; i < dataDims.length; i++) {
            var value = store_1.get(dataDimIndices_1[i], dataIndex);
            var thisHasValue = !isNaN(value);
            var thisLeftOut = value < valueWindow[0];
            var thisRightOut = value > valueWindow[1];
            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }
            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          }
          return hasValue && leftOut && rightOut;
        });
      } else {
        each$7(dataDims, function(dim) {
          if (filterMode === "empty") {
            seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            var range = {};
            range[dim] = valueWindow;
            seriesData.selectRange(range);
          }
        });
      }
      each$7(dataDims, function(dim) {
        seriesData.setApproximateExtent(valueWindow, dim);
      });
    });
    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  };
  AxisProxy2.prototype._updateMinMaxSpan = function() {
    var minMaxSpan = this._minMaxSpan = {};
    var dataZoomModel = this._dataZoomModel;
    var dataExtent = this._dataExtent;
    each$7(["min", "max"], function(minMax) {
      var percentSpan = dataZoomModel.get(minMax + "Span");
      var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
      if (valueSpan != null) {
        percentSpan = linearMap$2(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      } else if (percentSpan != null) {
        valueSpan = linearMap$2(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
      }
      minMaxSpan[minMax + "Span"] = percentSpan;
      minMaxSpan[minMax + "ValueSpan"] = valueSpan;
    }, this);
  };
  AxisProxy2.prototype._setAxisModel = function() {
    var axisModel = this.getAxisModel();
    var percentWindow = this._percentWindow;
    var valueWindow = this._valueWindow;
    if (!percentWindow) {
      return;
    }
    var precision = getPixelPrecision(valueWindow, [0, 500]);
    precision = Math.min(precision, 20);
    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
    if (percentWindow[0] !== 0) {
      rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
    }
    if (percentWindow[1] !== 100) {
      rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
    }
    rawExtentInfo.freeze();
  };
  return AxisProxy2;
}();
function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  var dataExtent = [Infinity, -Infinity];
  each$7(seriesModels, function(seriesModel) {
    unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
  });
  var axisModel = axisProxy.getAxisModel();
  var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
  return [rawExtentResult.min, rawExtentResult.max];
}
var AxisProxy$1 = AxisProxy;
var dataZoomProcessor = {
  getTargetSeries: function(ecModel) {
    function eachAxisModel(cb) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
          cb(axisDim, axisIndex, axisModel, dataZoomModel);
        });
      });
    }
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      axisModel.__dzAxisProxy = null;
    });
    var proxyList = [];
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      if (!axisModel.__dzAxisProxy) {
        axisModel.__dzAxisProxy = new AxisProxy$1(axisDim, axisIndex, dataZoomModel, ecModel);
        proxyList.push(axisModel.__dzAxisProxy);
      }
    });
    var seriesModelMap = createHashMap();
    each$f(proxyList, function(axisProxy) {
      each$f(axisProxy.getTargetSeriesModels(), function(seriesModel) {
        seriesModelMap.set(seriesModel.uid, seriesModel);
      });
    });
    return seriesModelMap;
  },
  overallReset: function(ecModel, api) {
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
      });
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
      });
    });
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        var percentRange = axisProxy.getDataPercentWindow();
        var valueRange = axisProxy.getDataValueWindow();
        dataZoomModel.setCalculatedRange({
          start: percentRange[0],
          end: percentRange[1],
          startValue: valueRange[0],
          endValue: valueRange[1]
        });
      }
    });
  }
};
var dataZoomProcessor$1 = dataZoomProcessor;
function installDataZoomAction(registers) {
  registers.registerAction("dataZoom", function(payload, ecModel) {
    var effectedModels = findEffectedDataZooms(ecModel, payload);
    each$f(effectedModels, function(dataZoomModel) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
}
var installed$1 = false;
function installCommon$1(registers) {
  if (installed$1) {
    return;
  }
  installed$1 = true;
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor$1);
  installDataZoomAction(registers);
  registers.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  });
}
function install$A(registers) {
  registers.registerComponentModel(SelectZoomModel);
  registers.registerComponentView(SelectZoomView);
  installCommon$1(registers);
}
var ToolboxFeature = function() {
  function ToolboxFeature2() {
  }
  return ToolboxFeature2;
}();
var features = {};
function registerFeature(name, ctor) {
  features[name] = ctor;
}
function getFeature(name) {
  return features[name];
}
var ToolboxModel = function(_super) {
  __extends(ToolboxModel2, _super);
  function ToolboxModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ToolboxModel2.type;
    return _this;
  }
  ToolboxModel2.prototype.optionUpdated = function() {
    _super.prototype.optionUpdated.apply(this, arguments);
    var ecModel = this.ecModel;
    each$f(this.option.feature, function(featureOpt, featureName) {
      var Feature = getFeature(featureName);
      if (Feature) {
        if (Feature.getDefaultOption) {
          Feature.defaultOption = Feature.getDefaultOption(ecModel);
        }
        merge(featureOpt, Feature.defaultOption);
      }
    });
  };
  ToolboxModel2.type = "toolbox";
  ToolboxModel2.layoutMode = {
    type: "box",
    ignoreSize: true
  };
  ToolboxModel2.defaultOption = {
    show: true,
    z: 6,
    orient: "horizontal",
    left: "right",
    top: "top",
    backgroundColor: "transparent",
    borderColor: "#ccc",
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemSize: 15,
    itemGap: 8,
    showTitle: true,
    iconStyle: {
      borderColor: "#666",
      color: "none"
    },
    emphasis: {
      iconStyle: {
        borderColor: "#3E98C5"
      }
    },
    tooltip: {
      show: false,
      position: "bottom"
    }
  };
  return ToolboxModel2;
}(ComponentModel$1);
var ToolboxModel$1 = ToolboxModel;
function layout(group, componentModel, api) {
  var boxLayoutParams = componentModel.getBoxLayoutParams();
  var padding = componentModel.get("padding");
  var viewportSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
  box(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height);
  positionElement(group, boxLayoutParams, viewportSize, padding);
}
function makeBackground(rect, componentModel) {
  var padding = normalizeCssArray(componentModel.get("padding"));
  var style = componentModel.getItemStyle(["color", "opacity"]);
  style.fill = componentModel.get("backgroundColor");
  rect = new Rect$3({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get("borderRadius")
    },
    style,
    silent: true,
    z2: -1
  });
  return rect;
}
var ToolboxView = function(_super) {
  __extends(ToolboxView2, _super);
  function ToolboxView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ToolboxView2.prototype.render = function(toolboxModel, ecModel, api, payload) {
    var group = this.group;
    group.removeAll();
    if (!toolboxModel.get("show")) {
      return;
    }
    var itemSize = +toolboxModel.get("itemSize");
    var featureOpts = toolboxModel.get("feature") || {};
    var features2 = this._features || (this._features = {});
    var featureNames = [];
    each$f(featureOpts, function(opt, name) {
      featureNames.push(name);
    });
    new DataDiffer$1(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry$1(processFeature, null)).execute();
    this._featureNames = featureNames;
    function processFeature(newIndex, oldIndex) {
      var featureName = featureNames[newIndex];
      var oldName = featureNames[oldIndex];
      var featureOpt = featureOpts[featureName];
      var featureModel = new Model$1(featureOpt, toolboxModel, toolboxModel.ecModel);
      var feature;
      if (payload && payload.newTitle != null && payload.featureName === featureName) {
        featureOpt.title = payload.newTitle;
      }
      if (featureName && !oldName) {
        if (isUserFeatureName(featureName)) {
          feature = {
            onclick: featureModel.option.onclick,
            featureName
          };
        } else {
          var Feature = getFeature(featureName);
          if (!Feature) {
            return;
          }
          feature = new Feature();
        }
        features2[featureName] = feature;
      } else {
        feature = features2[oldName];
        if (!feature) {
          return;
        }
      }
      feature.uid = getUID("toolbox-feature");
      feature.model = featureModel;
      feature.ecModel = ecModel;
      feature.api = api;
      var isToolboxFeature = feature instanceof ToolboxFeature;
      if (!featureName && oldName) {
        isToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
        return;
      }
      if (!featureModel.get("show") || isToolboxFeature && feature.unusable) {
        isToolboxFeature && feature.remove && feature.remove(ecModel, api);
        return;
      }
      createIconPaths(featureModel, feature, featureName);
      featureModel.setIconStatus = function(iconName, status) {
        var option = this.option;
        var iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status;
        if (iconPaths[iconName]) {
          (status === "emphasis" ? enterEmphasis : leaveEmphasis)(iconPaths[iconName]);
        }
      };
      if (feature instanceof ToolboxFeature) {
        if (feature.render) {
          feature.render(featureModel, ecModel, api, payload);
        }
      }
    }
    function createIconPaths(featureModel, feature, featureName) {
      var iconStyleModel = featureModel.getModel("iconStyle");
      var iconStyleEmphasisModel = featureModel.getModel(["emphasis", "iconStyle"]);
      var icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get("icon");
      var titles = featureModel.get("title") || {};
      var iconsMap;
      var titlesMap;
      if (isString(icons)) {
        iconsMap = {};
        iconsMap[featureName] = icons;
      } else {
        iconsMap = icons;
      }
      if (isString(titles)) {
        titlesMap = {};
        titlesMap[featureName] = titles;
      } else {
        titlesMap = titles;
      }
      var iconPaths = featureModel.iconPaths = {};
      each$f(iconsMap, function(iconStr, iconName) {
        var path = createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        });
        path.setStyle(iconStyleModel.getItemStyle());
        var pathEmphasisState = path.ensureState("emphasis");
        pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();
        var textContent = new ZRText$1({
          style: {
            text: titlesMap[iconName],
            align: iconStyleEmphasisModel.get("textAlign"),
            borderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
            padding: iconStyleEmphasisModel.get("textPadding"),
            fill: null
          },
          ignore: true
        });
        path.setTextContent(textContent);
        setTooltipConfig({
          el: path,
          componentModel: toolboxModel,
          itemName: iconName,
          formatterParamsExtra: {
            title: titlesMap[iconName]
          }
        });
        path.__title = titlesMap[iconName];
        path.on("mouseover", function() {
          var hoverStyle = iconStyleEmphasisModel.getItemStyle();
          var defaultTextPosition = toolboxModel.get("orient") === "vertical" ? toolboxModel.get("right") == null ? "right" : "left" : toolboxModel.get("bottom") == null ? "bottom" : "top";
          textContent.setStyle({
            fill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || "#000",
            backgroundColor: iconStyleEmphasisModel.get("textBackgroundColor")
          });
          path.setTextConfig({
            position: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
          });
          textContent.ignore = !toolboxModel.get("showTitle");
          enterEmphasis(this);
        }).on("mouseout", function() {
          if (featureModel.get(["iconStatus", iconName]) !== "emphasis") {
            leaveEmphasis(this);
          }
          textContent.hide();
        });
        (featureModel.get(["iconStatus", iconName]) === "emphasis" ? enterEmphasis : leaveEmphasis)(path);
        group.add(path);
        path.on("click", bind$1(feature.onclick, feature, ecModel, api, iconName));
        iconPaths[iconName] = path;
      });
    }
    layout(group, toolboxModel, api);
    group.add(makeBackground(group.getBoundingRect(), toolboxModel));
    group.eachChild(function(icon) {
      var titleText = icon.__title;
      var emphasisState = icon.ensureState("emphasis");
      var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});
      var textContent = icon.getTextContent();
      var emphasisTextState = textContent && textContent.states.emphasis;
      if (emphasisTextState && !isFunction$1(emphasisTextState) && titleText) {
        var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});
        var rect = getBoundingRect(titleText, ZRText$1.makeFont(emphasisTextStyle));
        var offsetX = icon.x + group.x;
        var offsetY = icon.y + group.y + itemSize;
        var needPutOnTop = false;
        if (offsetY + rect.height > api.getHeight()) {
          emphasisTextConfig.position = "top";
          needPutOnTop = true;
        }
        var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;
        if (offsetX + rect.width / 2 > api.getWidth()) {
          emphasisTextConfig.position = ["100%", topOffset];
          emphasisTextStyle.align = "right";
        } else if (offsetX - rect.width / 2 < 0) {
          emphasisTextConfig.position = [0, topOffset];
          emphasisTextStyle.align = "left";
        }
      }
    });
  };
  ToolboxView2.prototype.updateView = function(toolboxModel, ecModel, api, payload) {
    each$f(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
    });
  };
  ToolboxView2.prototype.remove = function(ecModel, api) {
    each$f(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api);
    });
    this.group.removeAll();
  };
  ToolboxView2.prototype.dispose = function(ecModel, api) {
    each$f(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api);
    });
  };
  ToolboxView2.type = "toolbox";
  return ToolboxView2;
}(ComponentView$1);
function isUserFeatureName(featureName) {
  return featureName.indexOf("my") === 0;
}
var ToolboxView$1 = ToolboxView;
var SaveAsImage = function(_super) {
  __extends(SaveAsImage2, _super);
  function SaveAsImage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SaveAsImage2.prototype.onclick = function(ecModel, api) {
    var model = this.model;
    var title = model.get("name") || ecModel.get("title.0.text") || "echarts";
    var isSvg = api.getZr().painter.getType() === "svg";
    var type = isSvg ? "svg" : model.get("type", true) || "png";
    var url = api.getConnectedDataURL({
      type,
      backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || "#fff",
      connectedBackgroundColor: model.get("connectedBackgroundColor"),
      excludeComponents: model.get("excludeComponents"),
      pixelRatio: model.get("pixelRatio")
    });
    var browser = env$1.browser;
    if (isFunction$1(MouseEvent) && (browser.newEdge || !browser.ie && !browser.edge)) {
      var $a = document.createElement("a");
      $a.download = title + "." + type;
      $a.target = "_blank";
      $a.href = url;
      var evt = new MouseEvent("click", {
        view: document.defaultView,
        bubbles: true,
        cancelable: false
      });
      $a.dispatchEvent(evt);
    } else {
      if (window.navigator.msSaveOrOpenBlob || isSvg) {
        var parts = url.split(",");
        var base64Encoded = parts[0].indexOf("base64") > -1;
        var bstr = isSvg ? decodeURIComponent(parts[1]) : parts[1];
        base64Encoded && (bstr = window.atob(bstr));
        var filename = title + "." + type;
        if (window.navigator.msSaveOrOpenBlob) {
          var n = bstr.length;
          var u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          var blob = new Blob([u8arr]);
          window.navigator.msSaveOrOpenBlob(blob, filename);
        } else {
          var frame = document.createElement("iframe");
          document.body.appendChild(frame);
          var cw = frame.contentWindow;
          var doc = cw.document;
          doc.open("image/svg+xml", "replace");
          doc.write(bstr);
          doc.close();
          cw.focus();
          doc.execCommand("SaveAs", true, filename);
          document.body.removeChild(frame);
        }
      } else {
        var lang = model.get("lang");
        var html = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || "") + '" /></body>';
        var tab = window.open();
        tab.document.write(html);
        tab.document.title = title;
      }
    }
  };
  SaveAsImage2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
      title: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
      type: "png",
      connectedBackgroundColor: "#fff",
      name: "",
      excludeComponents: ["toolbox"],
      lang: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
    };
    return defaultOption2;
  };
  return SaveAsImage2;
}(ToolboxFeature);
var SaveAsImage$1 = SaveAsImage;
var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
var radioTypes = [["line", "bar"], ["stack"]];
var MagicType = function(_super) {
  __extends(MagicType2, _super);
  function MagicType2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MagicType2.prototype.getIcons = function() {
    var model = this.model;
    var availableIcons = model.get("icon");
    var icons = {};
    each$f(model.get("type"), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  MagicType2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      type: [],
      icon: {
        line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
        bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
        stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "magicType", "title"]),
      option: {},
      seriesIndex: {}
    };
    return defaultOption2;
  };
  MagicType2.prototype.onclick = function(ecModel, api, type) {
    var model = this.model;
    var seriesIndex = model.get(["seriesIndex", type]);
    if (!seriesOptGenreator[type]) {
      return;
    }
    var newOption = {
      series: []
    };
    var generateNewSeriesTypes = function(seriesModel) {
      var seriesType2 = seriesModel.subType;
      var seriesId = seriesModel.id;
      var newSeriesOpt = seriesOptGenreator[type](seriesType2, seriesId, seriesModel, model);
      if (newSeriesOpt) {
        defaults(newSeriesOpt, seriesModel.option);
        newOption.series.push(newSeriesOpt);
      }
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
        var categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
        if (categoryAxis2) {
          var axisDim = categoryAxis2.dim;
          var axisType = axisDim + "Axis";
          var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
          var axisIndex = axisModel.componentIndex;
          newOption[axisType] = newOption[axisType] || [];
          for (var i = 0; i <= axisIndex; i++) {
            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
          }
          newOption[axisType][axisIndex].boundaryGap = type === "bar";
        }
      }
    };
    each$f(radioTypes, function(radio) {
      if (indexOf(radio, type) >= 0) {
        each$f(radio, function(item) {
          model.setIconStatus(item, "normal");
        });
      }
    });
    model.setIconStatus(type, "emphasis");
    ecModel.eachComponent({
      mainType: "series",
      query: seriesIndex == null ? null : {
        seriesIndex
      }
    }, generateNewSeriesTypes);
    var newTitle;
    var currentType = type;
    if (type === "stack") {
      newTitle = merge({
        stack: model.option.title.tiled,
        tiled: model.option.title.stack
      }, model.option.title);
      if (model.get(["iconStatus", type]) !== "emphasis") {
        currentType = "tiled";
      }
    }
    api.dispatchAction({
      type: "changeMagicType",
      currentType,
      newOption,
      newTitle,
      featureName: "magicType"
    });
  };
  return MagicType2;
}(ToolboxFeature);
var seriesOptGenreator = {
  "line": function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "bar") {
      return merge({
        id: seriesId,
        type: "line",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "line"]) || {}, true);
    }
  },
  "bar": function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "line") {
      return merge({
        id: seriesId,
        type: "bar",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "bar"]) || {}, true);
    }
  },
  "stack": function(seriesType2, seriesId, seriesModel, model) {
    var isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
    if (seriesType2 === "line" || seriesType2 === "bar") {
      model.setIconStatus("stack", isStack ? "normal" : "emphasis");
      return merge({
        id: seriesId,
        stack: isStack ? "" : INNER_STACK_KEYWORD
      }, model.get(["option", "stack"]) || {}, true);
    }
  }
};
registerAction({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
var MagicType$1 = MagicType;
var BLOCK_SPLITER = new Array(60).join("-");
var ITEM_SPLITER = "	";
function groupSeries(ecModel) {
  var seriesGroupByCategoryAxis = {};
  var otherSeries = [];
  var meta = [];
  ecModel.eachRawSeries(function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
      var baseAxis = coordSys.getBaseAxis();
      if (baseAxis.type === "category") {
        var key = baseAxis.dim + "_" + baseAxis.index;
        if (!seriesGroupByCategoryAxis[key]) {
          seriesGroupByCategoryAxis[key] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }
        seriesGroupByCategoryAxis[key].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis,
    other: otherSeries,
    meta
  };
}
function assembleSeriesWithCategoryAxis(groups) {
  var tables = [];
  each$f(groups, function(group, key) {
    var categoryAxis2 = group.categoryAxis;
    var valueAxis2 = group.valueAxis;
    var valueAxisDim = valueAxis2.dim;
    var headers = [" "].concat(map$1(group.series, function(series) {
      return series.name;
    }));
    var columns = [categoryAxis2.model.getCategories()];
    each$f(group.series, function(series) {
      var rawData = series.getRawData();
      columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
        return val;
      }));
    });
    var lines = [headers.join(ITEM_SPLITER)];
    for (var i = 0; i < columns[0].length; i++) {
      var items = [];
      for (var j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }
      lines.push(items.join(ITEM_SPLITER));
    }
    tables.push(lines.join("\n"));
  });
  return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function assembleOtherSeries(series) {
  return map$1(series, function(series2) {
    var data = series2.getRawData();
    var lines = [series2.name];
    var vals = [];
    data.each(data.dimensions, function() {
      var argLen = arguments.length;
      var dataIndex = arguments[argLen - 1];
      var name = data.getName(dataIndex);
      for (var i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }
      lines.push((name ? name + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
    });
    return lines.join("\n");
  }).join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function getContentFromModel(ecModel) {
  var result = groupSeries(ecModel);
  return {
    value: filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
      return !!str.replace(/[\n\t\s]/g, "");
    }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
    meta: result.meta
  };
}
function trim(str) {
  return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function isTSVFormat(block) {
  var firstLine = block.slice(0, block.indexOf("\n"));
  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}
var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
function parseTSVContents(tsv) {
  var tsvLines = tsv.split(/\n+/g);
  var headers = trim(tsvLines.shift()).split(itemSplitRegex);
  var categories = [];
  var series = map$1(headers, function(header) {
    return {
      name: header,
      data: []
    };
  });
  for (var i = 0; i < tsvLines.length; i++) {
    var items = trim(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());
    for (var j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }
  return {
    series,
    categories
  };
}
function parseListContents(str) {
  var lines = str.split(/\n+/g);
  var seriesName = trim(lines.shift());
  var data = [];
  for (var i = 0; i < lines.length; i++) {
    var line = trim(lines[i]);
    if (!line) {
      continue;
    }
    var items = line.split(itemSplitRegex);
    var name_1 = "";
    var value = void 0;
    var hasName = false;
    if (isNaN(items[0])) {
      hasName = true;
      name_1 = items[0];
      items = items.slice(1);
      data[i] = {
        name: name_1,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }
    for (var j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }
    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }
  return {
    name: seriesName,
    data
  };
}
function parseContents(str, blockMetaList) {
  var blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
  var newOption = {
    series: []
  };
  each$f(blocks, function(block, idx) {
    if (isTSVFormat(block)) {
      var result = parseTSVContents(block);
      var blockMeta = blockMetaList[idx];
      var axisKey = blockMeta.axisDim + "Axis";
      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      var result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}
var DataView = function(_super) {
  __extends(DataView2, _super);
  function DataView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataView2.prototype.onclick = function(ecModel, api) {
    var container = api.getDom();
    var model = this.model;
    if (this._dom) {
      container.removeChild(this._dom);
    }
    var root2 = document.createElement("div");
    root2.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;";
    root2.style.backgroundColor = model.get("backgroundColor") || "#fff";
    var header = document.createElement("h4");
    var lang = model.get("lang") || [];
    header.innerHTML = lang[0] || model.get("title");
    header.style.cssText = "margin: 10px 20px;";
    header.style.color = model.get("textColor");
    var viewMain = document.createElement("div");
    var textarea = document.createElement("textarea");
    viewMain.style.cssText = "display:block;width:100%;overflow:auto;";
    var optionToContent = model.get("optionToContent");
    var contentToOption = model.get("contentToOption");
    var result = getContentFromModel(ecModel);
    if (isFunction$1(optionToContent)) {
      var htmlOrDom = optionToContent(api.getOption());
      if (isString(htmlOrDom)) {
        viewMain.innerHTML = htmlOrDom;
      } else if (isDom(htmlOrDom)) {
        viewMain.appendChild(htmlOrDom);
      }
    } else {
      viewMain.appendChild(textarea);
      textarea.readOnly = model.get("readOnly");
      textarea.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;";
      textarea.style.color = model.get("textColor");
      textarea.style.borderColor = model.get("textareaBorderColor");
      textarea.style.backgroundColor = model.get("textareaColor");
      textarea.value = result.value;
    }
    var blockMetaList = result.meta;
    var buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
    var buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
    var closeButton = document.createElement("div");
    var refreshButton = document.createElement("div");
    buttonStyle += ";background-color:" + model.get("buttonColor");
    buttonStyle += ";color:" + model.get("buttonTextColor");
    var self2 = this;
    function close() {
      container.removeChild(root2);
      self2._dom = null;
    }
    addEventListener(closeButton, "click", close);
    addEventListener(refreshButton, "click", function() {
      if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
        close();
        return;
      }
      var newOption;
      try {
        if (isFunction$1(contentToOption)) {
          newOption = contentToOption(viewMain, api.getOption());
        } else {
          newOption = parseContents(textarea.value, blockMetaList);
        }
      } catch (e2) {
        close();
        throw new Error("Data view format error " + e2);
      }
      if (newOption) {
        api.dispatchAction({
          type: "changeDataView",
          newOption
        });
      }
      close();
    });
    closeButton.innerHTML = lang[1];
    refreshButton.innerHTML = lang[2];
    refreshButton.style.cssText = buttonStyle;
    closeButton.style.cssText = buttonStyle;
    !model.get("readOnly") && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);
    root2.appendChild(header);
    root2.appendChild(viewMain);
    root2.appendChild(buttonContainer);
    viewMain.style.height = container.clientHeight - 80 + "px";
    container.appendChild(root2);
    this._dom = root2;
  };
  DataView2.prototype.remove = function(ecModel, api) {
    this._dom && api.getDom().removeChild(this._dom);
  };
  DataView2.prototype.dispose = function(ecModel, api) {
    this.remove(ecModel, api);
  };
  DataView2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      readOnly: false,
      optionToContent: null,
      contentToOption: null,
      icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
      title: ecModel.getLocaleModel().get(["toolbox", "dataView", "title"]),
      lang: ecModel.getLocaleModel().get(["toolbox", "dataView", "lang"]),
      backgroundColor: "#fff",
      textColor: "#000",
      textareaColor: "#fff",
      textareaBorderColor: "#333",
      buttonColor: "#c23531",
      buttonTextColor: "#fff"
    };
    return defaultOption2;
  };
  return DataView2;
}(ToolboxFeature);
function tryMergeDataOption(newData, originalData) {
  return map$1(newData, function(newVal, idx) {
    var original = originalData && originalData[idx];
    if (isObject$3(original) && !isArray$1(original)) {
      var newValIsObject = isObject$3(newVal) && !isArray$1(newVal);
      if (!newValIsObject) {
        newVal = {
          value: newVal
        };
      }
      var shouldDeleteName = original.name != null && newVal.name == null;
      newVal = defaults(newVal, original);
      shouldDeleteName && delete newVal.name;
      return newVal;
    } else {
      return newVal;
    }
  });
}
registerAction({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  var newSeriesOptList = [];
  each$f(payload.newOption.series, function(seriesOpt) {
    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
    if (!seriesModel) {
      newSeriesOptList.push(extend$1({
        type: "scatter"
      }, seriesOpt));
    } else {
      var originalData = seriesModel.get("data");
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(defaults({
    series: newSeriesOptList
  }, payload.newOption));
});
var DataView$1 = DataView;
var each$6 = each$f;
var inner$6 = makeInner();
function push(ecModel, newSnapshot) {
  var storedSnapshots = getStoreSnapshots(ecModel);
  each$6(newSnapshot, function(batchItem, dataZoomId) {
    var i = storedSnapshots.length - 1;
    for (; i >= 0; i--) {
      var snapshot = storedSnapshots[i];
      if (snapshot[dataZoomId]) {
        break;
      }
    }
    if (i < 0) {
      var dataZoomModel = ecModel.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: dataZoomId
      })[0];
      if (dataZoomModel) {
        var percentRange = dataZoomModel.getPercentRange();
        storedSnapshots[0][dataZoomId] = {
          dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  storedSnapshots.push(newSnapshot);
}
function pop(ecModel) {
  var storedSnapshots = getStoreSnapshots(ecModel);
  var head = storedSnapshots[storedSnapshots.length - 1];
  storedSnapshots.length > 1 && storedSnapshots.pop();
  var snapshot = {};
  each$6(head, function(batchItem, dataZoomId) {
    for (var i = storedSnapshots.length - 1; i >= 0; i--) {
      batchItem = storedSnapshots[i][dataZoomId];
      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
function clear(ecModel) {
  inner$6(ecModel).snapshots = null;
}
function count(ecModel) {
  return getStoreSnapshots(ecModel).length;
}
function getStoreSnapshots(ecModel) {
  var store = inner$6(ecModel);
  if (!store.snapshots) {
    store.snapshots = [{}];
  }
  return store.snapshots;
}
var RestoreOption = function(_super) {
  __extends(RestoreOption2, _super);
  function RestoreOption2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RestoreOption2.prototype.onclick = function(ecModel, api) {
    clear(ecModel);
    api.dispatchAction({
      type: "restore",
      from: this.uid
    });
  };
  RestoreOption2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
      title: ecModel.getLocaleModel().get(["toolbox", "restore", "title"])
    };
    return defaultOption2;
  };
  return RestoreOption2;
}(ToolboxFeature);
registerAction({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  ecModel.resetOption("recreate");
});
var Restore = RestoreOption;
var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];
var BrushTargetManager = function() {
  function BrushTargetManager2(finder, ecModel, opt) {
    var _this = this;
    this._targetInfoList = [];
    var foundCpts = parseFinder(ecModel, finder);
    each$f(targetInfoBuilders, function(builder, type) {
      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
        builder(foundCpts, _this._targetInfoList);
      }
    });
  }
  BrushTargetManager2.prototype.setOutputRanges = function(areas, ecModel) {
    this.matchOutputRanges(areas, ecModel, function(area2, coordRange, coordSys) {
      (area2.coordRanges || (area2.coordRanges = [])).push(coordRange);
      if (!area2.coordRange) {
        area2.coordRange = coordRange;
        var result = coordConvert[area2.brushType](0, coordSys, coordRange);
        area2.__rangeOffset = {
          offset: diffProcessor[area2.brushType](result.values, area2.range, [1, 1]),
          xyMinMax: result.xyMinMax
        };
      }
    });
    return areas;
  };
  BrushTargetManager2.prototype.matchOutputRanges = function(areas, ecModel, cb) {
    each$f(areas, function(area2) {
      var targetInfo = this.findTargetInfo(area2, ecModel);
      if (targetInfo && targetInfo !== true) {
        each$f(targetInfo.coordSyses, function(coordSys) {
          var result = coordConvert[area2.brushType](1, coordSys, area2.range, true);
          cb(area2, result.values, coordSys, ecModel);
        });
      }
    }, this);
  };
  BrushTargetManager2.prototype.setInputRanges = function(areas, ecModel) {
    each$f(areas, function(area2) {
      var targetInfo = this.findTargetInfo(area2, ecModel);
      area2.range = area2.range || [];
      if (targetInfo && targetInfo !== true) {
        area2.panelId = targetInfo.panelId;
        var result = coordConvert[area2.brushType](0, targetInfo.coordSys, area2.coordRange);
        var rangeOffset = area2.__rangeOffset;
        area2.range = rangeOffset ? diffProcessor[area2.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
      }
    }, this);
  };
  BrushTargetManager2.prototype.makePanelOpts = function(api, getDefaultBrushType) {
    return map$1(this._targetInfoList, function(targetInfo) {
      var rect = targetInfo.getPanelRect();
      return {
        panelId: targetInfo.panelId,
        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
        clipPath: makeRectPanelClipPath(rect),
        isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
      };
    });
  };
  BrushTargetManager2.prototype.controlSeries = function(area2, seriesModel, ecModel) {
    var targetInfo = this.findTargetInfo(area2, ecModel);
    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
  };
  BrushTargetManager2.prototype.findTargetInfo = function(area2, ecModel) {
    var targetInfoList = this._targetInfoList;
    var foundCpts = parseFinder(ecModel, area2);
    for (var i = 0; i < targetInfoList.length; i++) {
      var targetInfo = targetInfoList[i];
      var areaPanelId = area2.panelId;
      if (areaPanelId) {
        if (targetInfo.panelId === areaPanelId) {
          return targetInfo;
        }
      } else {
        for (var j = 0; j < targetInfoMatchers.length; j++) {
          if (targetInfoMatchers[j](foundCpts, targetInfo)) {
            return targetInfo;
          }
        }
      }
    }
    return true;
  };
  return BrushTargetManager2;
}();
function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}
function parseFinder(ecModel, finder) {
  return parseFinder$1(ecModel, finder, {
    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
  });
}
var targetInfoBuilders = {
  grid: function(foundCpts, targetInfoList) {
    var xAxisModels = foundCpts.xAxisModels;
    var yAxisModels = foundCpts.yAxisModels;
    var gridModels = foundCpts.gridModels;
    var gridModelMap = createHashMap();
    var xAxesHas = {};
    var yAxesHas = {};
    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }
    each$f(xAxisModels, function(axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    each$f(yAxisModels, function(axisModel) {
      var gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    each$f(gridModels, function(gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function(gridModel) {
      var grid = gridModel.coordinateSystem;
      var cartesians = [];
      each$f(grid.getCartesians(), function(cartesian, index) {
        if (indexOf(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf(yAxisModels, cartesian.getAxis("y").model) >= 0) {
          cartesians.push(cartesian);
        }
      });
      targetInfoList.push({
        panelId: "grid--" + gridModel.id,
        gridModel,
        coordSysModel: gridModel,
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilders.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function(foundCpts, targetInfoList) {
    each$f(foundCpts.geoModels, function(geoModel) {
      var coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: "geo--" + geoModel.id,
        geoModel,
        coordSysModel: geoModel,
        coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilders.geo
      });
    });
  }
};
var targetInfoMatchers = [
  function(foundCpts, targetInfo) {
    var xAxisModel = foundCpts.xAxisModel;
    var yAxisModel = foundCpts.yAxisModel;
    var gridModel = foundCpts.gridModel;
    !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
    !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
    return gridModel && gridModel === targetInfo.gridModel;
  },
  function(foundCpts, targetInfo) {
    var geoModel = foundCpts.geoModel;
    return geoModel && geoModel === targetInfo.geoModel;
  }
];
var panelRectBuilders = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var coordSys = this.coordSys;
    var rect = coordSys.getBoundingRect().clone();
    rect.applyTransform(getTransform$1(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: curry$1(axisConvert, 0),
  lineY: curry$1(axisConvert, 1),
  rect: function(to, coordSys, rangeOrCoordRange, clamp2) {
    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2);
    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2);
    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
    return {
      values,
      xyMinMax: values
    };
  },
  polygon: function(to, coordSys, rangeOrCoordRange, clamp2) {
    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    var values = map$1(rangeOrCoordRange, function(item) {
      var p = to ? coordSys.pointToData(item, clamp2) : coordSys.dataToPoint(item, clamp2);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
      return p;
    });
    return {
      values,
      xyMinMax
    };
  }
};
function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  var axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
  var values = formatMinMax(map$1([0, 1], function(i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  var xyMinMax = [];
  xyMinMax[axisNameIndex] = values;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {
    values,
    xyMinMax
  };
}
var diffProcessor = {
  lineX: curry$1(axisDiffProcessor, 0),
  lineY: curry$1(axisDiffProcessor, 1),
  rect: function(values, refer, scales) {
    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
  },
  polygon: function(values, refer, scales) {
    return map$1(values, function(item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};
function axisDiffProcessor(axisNameIndex, values, refer, scales) {
  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
}
function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  var sizeCurr = getSize(xyMinMaxCurr);
  var sizeOrigin = getSize(xyMinMaxOrigin);
  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}
function getSize(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}
var BrushTargetManager$1 = BrushTargetManager;
var each$5 = each$f;
var DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_");
var DataZoomFeature = function(_super) {
  __extends(DataZoomFeature2, _super);
  function DataZoomFeature2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataZoomFeature2.prototype.render = function(featureModel, ecModel, api, payload) {
    if (!this._brushController) {
      this._brushController = new BrushController$1(api.getZr());
      this._brushController.on("brush", bind$1(this._onBrush, this)).mount();
    }
    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
    updateBackBtnStatus(featureModel, ecModel);
  };
  DataZoomFeature2.prototype.onclick = function(ecModel, api, type) {
    handlers[type].call(this);
  };
  DataZoomFeature2.prototype.remove = function(ecModel, api) {
    this._brushController && this._brushController.unmount();
  };
  DataZoomFeature2.prototype.dispose = function(ecModel, api) {
    this._brushController && this._brushController.dispose();
  };
  DataZoomFeature2.prototype._onBrush = function(eventParam) {
    var areas = eventParam.areas;
    if (!eventParam.isEnd || !areas.length) {
      return;
    }
    var snapshot = {};
    var ecModel = this.ecModel;
    this._brushController.updateCovers([]);
    var brushTargetManager = new BrushTargetManager$1(makeAxisFinder(this.model), ecModel, {
      include: ["grid"]
    });
    brushTargetManager.matchOutputRanges(areas, ecModel, function(area2, coordRange, coordSys) {
      if (coordSys.type !== "cartesian2d") {
        return;
      }
      var brushType = area2.brushType;
      if (brushType === "rect") {
        setBatch("x", coordSys, coordRange[0]);
        setBatch("y", coordSys, coordRange[1]);
      } else {
        setBatch({
          lineX: "x",
          lineY: "y"
        }[brushType], coordSys, coordRange);
      }
    });
    push(ecModel, snapshot);
    this._dispatchZoomAction(snapshot);
    function setBatch(dimName, coordSys, minMax) {
      var axis = coordSys.getAxis(dimName);
      var axisModel = axis.model;
      var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
        minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
      }
      dataZoomModel && (snapshot[dataZoomModel.id] = {
        dataZoomId: dataZoomModel.id,
        startValue: minMax[0],
        endValue: minMax[1]
      });
    }
    function findDataZoom(dimName, axisModel, ecModel2) {
      var found;
      ecModel2.eachComponent({
        mainType: "dataZoom",
        subType: "select"
      }, function(dzModel) {
        var has2 = dzModel.getAxisModel(dimName, axisModel.componentIndex);
        has2 && (found = dzModel);
      });
      return found;
    }
  };
  DataZoomFeature2.prototype._dispatchZoomAction = function(snapshot) {
    var batch = [];
    each$5(snapshot, function(batchItem, dataZoomId) {
      batch.push(clone$4(batchItem));
    });
    batch.length && this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      batch
    });
  };
  DataZoomFeature2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      filterMode: "filter",
      icon: {
        zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
        back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
      brushStyle: {
        borderWidth: 0,
        color: "rgba(210,219,238,0.2)"
      }
    };
    return defaultOption2;
  };
  return DataZoomFeature2;
}(ToolboxFeature);
var handlers = {
  zoom: function() {
    var nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: nextActive
    });
  },
  back: function() {
    this._dispatchZoomAction(pop(this.ecModel));
  }
};
function makeAxisFinder(dzFeatureModel) {
  var setting = {
    xAxisIndex: dzFeatureModel.get("xAxisIndex", true),
    yAxisIndex: dzFeatureModel.get("yAxisIndex", true),
    xAxisId: dzFeatureModel.get("xAxisId", true),
    yAxisId: dzFeatureModel.get("yAxisId", true)
  };
  if (setting.xAxisIndex == null && setting.xAxisId == null) {
    setting.xAxisIndex = "all";
  }
  if (setting.yAxisIndex == null && setting.yAxisId == null) {
    setting.yAxisIndex = "all";
  }
  return setting;
}
function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus("back", count(ecModel) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
  var zoomActive = view._isZoomActive;
  if (payload && payload.type === "takeGlobalCursor") {
    zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
  }
  view._isZoomActive = zoomActive;
  featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
  var brushTargetManager = new BrushTargetManager$1(makeAxisFinder(featureModel), ecModel, {
    include: ["grid"]
  });
  var panels = brushTargetManager.makePanelOpts(api, function(targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
  });
  view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {
    brushType: "auto",
    brushStyle: featureModel.getModel("brushStyle").getItemStyle()
  } : false);
}
registerInternalOptionCreator("dataZoom", function(ecModel) {
  var toolboxModel = ecModel.getComponent("toolbox", 0);
  var featureDataZoomPath = ["feature", "dataZoom"];
  if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {
    return;
  }
  var dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);
  var dzOptions = [];
  var finder = makeAxisFinder(dzFeatureModel);
  var finderResult = parseFinder$1(ecModel, finder);
  each$5(finderResult.xAxisModels, function(axisModel) {
    return buildInternalOptions(axisModel, "xAxis", "xAxisIndex");
  });
  each$5(finderResult.yAxisModels, function(axisModel) {
    return buildInternalOptions(axisModel, "yAxis", "yAxisIndex");
  });
  function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {
    var axisIndex = axisModel.componentIndex;
    var newOpt = {
      type: "select",
      $fromToolbox: true,
      filterMode: dzFeatureModel.get("filterMode", true) || "filter",
      id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
    };
    newOpt[axisIndexPropName] = axisIndex;
    dzOptions.push(newOpt);
  }
  return dzOptions;
});
var DataZoom = DataZoomFeature;
function install$z(registers) {
  registers.registerComponentModel(ToolboxModel$1);
  registers.registerComponentView(ToolboxView$1);
  registerFeature("saveAsImage", SaveAsImage$1);
  registerFeature("magicType", MagicType$1);
  registerFeature("dataView", DataView$1);
  registerFeature("dataZoom", DataZoom);
  registerFeature("restore", Restore);
  use(install$A);
}
var TooltipModel = function(_super) {
  __extends(TooltipModel2, _super);
  function TooltipModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipModel2.type;
    return _this;
  }
  TooltipModel2.type = "tooltip";
  TooltipModel2.dependencies = ["axisPointer"];
  TooltipModel2.defaultOption = {
    z: 60,
    show: true,
    showContent: true,
    trigger: "item",
    triggerOn: "mousemove|click",
    alwaysShowContent: false,
    displayMode: "single",
    renderMode: "auto",
    confine: null,
    showDelay: 0,
    hideDelay: 100,
    transitionDuration: 0.4,
    enterable: false,
    backgroundColor: "#fff",
    shadowBlur: 10,
    shadowColor: "rgba(0, 0, 0, .2)",
    shadowOffsetX: 1,
    shadowOffsetY: 2,
    borderRadius: 4,
    borderWidth: 1,
    padding: null,
    extraCssText: "",
    axisPointer: {
      type: "line",
      axis: "auto",
      animation: "auto",
      animationDurationUpdate: 200,
      animationEasingUpdate: "exponentialOut",
      crossStyle: {
        color: "#999",
        width: 1,
        type: "dashed",
        textStyle: {}
      }
    },
    textStyle: {
      color: "#666",
      fontSize: 14
    }
  };
  return TooltipModel2;
}(ComponentModel$1);
var TooltipModel$1 = TooltipModel;
function shouldTooltipConfine(tooltipModel) {
  var confineOption = tooltipModel.get("confine");
  return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
}
function testStyle(styleProps) {
  if (!env$1.domSupported) {
    return;
  }
  var style = document.documentElement.style;
  for (var i = 0, len2 = styleProps.length; i < len2; i++) {
    if (styleProps[i] in style) {
      return styleProps[i];
    }
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(styleVendor, styleProp) {
  if (!styleVendor) {
    return styleProp;
  }
  styleProp = toCamelCase(styleProp, true);
  var idx = styleVendor.indexOf(styleProp);
  styleVendor = idx === -1 ? styleProp : "-" + styleVendor.slice(0, idx) + "-" + styleProp;
  return styleVendor.toLowerCase();
}
function getComputedStyle(el, style) {
  var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
  return stl ? style ? stl[style] : stl : null;
}
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (env$1.transform3dSupported ? "will-change:transform;" : "");
function mirrorPos(pos) {
  pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
  return pos;
}
function assembleArrow(tooltipModel, borderColor, arrowPosition) {
  if (!isString(arrowPosition) || arrowPosition === "inside") {
    return "";
  }
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var borderWidth = tooltipModel.get("borderWidth");
  borderColor = convertToColorString(borderColor);
  var arrowPos = mirrorPos(arrowPosition);
  var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
  var positionStyle = "";
  var transformStyle = CSS_TRANSFORM_VENDOR + ":";
  var rotateDeg;
  if (indexOf(["left", "right"], arrowPos) > -1) {
    positionStyle += "top:50%";
    transformStyle += "translateY(-50%) rotate(" + (rotateDeg = arrowPos === "left" ? -225 : -45) + "deg)";
  } else {
    positionStyle += "left:50%";
    transformStyle += "translateX(-50%) rotate(" + (rotateDeg = arrowPos === "top" ? 225 : 45) + "deg)";
  }
  var rotateRadian = rotateDeg * Math.PI / 180;
  var arrowWH = arrowSize + borderWidth;
  var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
  var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
  positionStyle += ";" + arrowPos + ":-" + arrowOffset + "px";
  var borderStyle = borderColor + " solid " + borderWidth + "px;";
  var styleCss = ["position:absolute;width:" + arrowSize + "px;height:" + arrowSize + "px;", positionStyle + ";" + transformStyle + ";", "border-bottom:" + borderStyle, "border-right:" + borderStyle, "background-color:" + backgroundColor2 + ";"];
  return '<div style="' + styleCss.join("") + '"></div>';
}
function assembleTransition(duration, onlyFade) {
  var transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
  var transitionOption = " " + duration / 2 + "s " + transitionCurve;
  var transitionText = "opacity" + transitionOption + ",visibility" + transitionOption;
  if (!onlyFade) {
    transitionOption = " " + duration + "s " + transitionCurve;
    transitionText += env$1.transformSupported ? "," + CSS_TRANSFORM_VENDOR + transitionOption : ",left" + transitionOption + ",top" + transitionOption;
  }
  return CSS_TRANSITION_VENDOR + ":" + transitionText;
}
function assembleTransform(x, y, toString) {
  var x0 = x.toFixed(0) + "px";
  var y0 = y.toFixed(0) + "px";
  if (!env$1.transformSupported) {
    return toString ? "top:" + y0 + ";left:" + x0 + ";" : [["top", y0], ["left", x0]];
  }
  var is3d = env$1.transform3dSupported;
  var translate2 = "translate" + (is3d ? "3d" : "") + "(" + x0 + "," + y0 + (is3d ? ",0" : "") + ")";
  return toString ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
}
function assembleFont(textStyleModel) {
  var cssText = [];
  var fontSize = textStyleModel.get("fontSize");
  var color = textStyleModel.getTextColor();
  color && cssText.push("color:" + color);
  cssText.push("font:" + textStyleModel.getFont());
  fontSize && cssText.push("line-height:" + Math.round(fontSize * 3 / 2) + "px");
  var shadowColor = textStyleModel.get("textShadowColor");
  var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
  var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
  var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
  shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
  each$f(["decoration", "align"], function(name) {
    var val = textStyleModel.get(name);
    val && cssText.push("text-" + name + ":" + val);
  });
  return cssText.join(";");
}
function assembleCssText(tooltipModel, enableTransition, onlyFade) {
  var cssText = [];
  var transitionDuration = tooltipModel.get("transitionDuration");
  var backgroundColor2 = tooltipModel.get("backgroundColor");
  var shadowBlur = tooltipModel.get("shadowBlur");
  var shadowColor = tooltipModel.get("shadowColor");
  var shadowOffsetX = tooltipModel.get("shadowOffsetX");
  var shadowOffsetY = tooltipModel.get("shadowOffsetY");
  var textStyleModel = tooltipModel.getModel("textStyle");
  var padding = getPaddingFromTooltipModel(tooltipModel, "html");
  var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
  cssText.push("box-shadow:" + boxShadow);
  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
  if (backgroundColor2) {
    cssText.push("background-color:" + backgroundColor2);
  }
  each$f(["width", "color", "radius"], function(name) {
    var borderName = "border-" + name;
    var camelCase = toCamelCase(borderName);
    var val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
  });
  cssText.push(assembleFont(textStyleModel));
  if (padding != null) {
    cssText.push("padding:" + normalizeCssArray(padding).join("px ") + "px");
  }
  return cssText.join(";") + ";";
}
function makeStyleCoord$1(out2, zr, appendToBody, zrX, zrY) {
  var zrPainter = zr && zr.painter;
  if (appendToBody) {
    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
    if (zrViewportRoot) {
      transformLocalCoord(out2, zrViewportRoot, document.body, zrX, zrY);
    }
  } else {
    out2[0] = zrX;
    out2[1] = zrY;
    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
    if (viewportRootOffset) {
      out2[0] += viewportRootOffset.offsetLeft;
      out2[1] += viewportRootOffset.offsetTop;
    }
  }
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipHTMLContent = function() {
  function TooltipHTMLContent2(container, api, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._firstShow = true;
    this._longHide = true;
    if (env$1.wxa) {
      return null;
    }
    var el = document.createElement("div");
    el.domBelongToZr = true;
    this.el = el;
    var zr = this._zr = api.getZr();
    var appendToBody = this._appendToBody = opt && opt.appendToBody;
    makeStyleCoord$1(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
    if (appendToBody) {
      document.body.appendChild(el);
    } else {
      container.appendChild(el);
    }
    this._container = container;
    var self2 = this;
    el.onmouseenter = function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    };
    el.onmousemove = function(e2) {
      e2 = e2 || window.event;
      if (!self2._enterable) {
        var handler = zr.handler;
        var zrViewportRoot = zr.painter.getViewportRoot();
        normalizeEvent(zrViewportRoot, e2, true);
        handler.dispatch("mousemove", e2);
      }
    };
    el.onmouseleave = function() {
      self2._inContent = false;
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
    };
  }
  TooltipHTMLContent2.prototype.update = function(tooltipModel) {
    var container = this._container;
    var position2 = getComputedStyle(container, "position");
    var domStyle = container.style;
    if (domStyle.position !== "absolute" && position2 !== "absolute") {
      domStyle.position = "relative";
    }
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this.el.className = tooltipModel.get("className") || "";
  };
  TooltipHTMLContent2.prototype.show = function(tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    var el = this.el;
    var style = el.style;
    var styleCoord = this._styleCoord;
    if (!el.innerHTML) {
      style.display = "none";
    } else {
      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + assembleTransform(styleCoord[0], styleCoord[1], true) + ("border-color:" + convertToColorString(nearPointColor) + ";") + (tooltipModel.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none"));
    }
    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  };
  TooltipHTMLContent2.prototype.setContent = function(content, markers, tooltipModel, borderColor, arrowPosition) {
    var el = this.el;
    if (content == null) {
      el.innerHTML = "";
      return;
    }
    var arrow = "";
    if (isString(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
      arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
    }
    if (isString(content)) {
      el.innerHTML = content + arrow;
    } else if (content) {
      el.innerHTML = "";
      if (!isArray$1(content)) {
        content = [content];
      }
      for (var i = 0; i < content.length; i++) {
        if (isDom(content[i]) && content[i].parentNode !== el) {
          el.appendChild(content[i]);
        }
      }
      if (arrow && el.childNodes.length) {
        var arrowEl = document.createElement("div");
        arrowEl.innerHTML = arrow;
        el.appendChild(arrowEl);
      }
    }
  };
  TooltipHTMLContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipHTMLContent2.prototype.getSize = function() {
    var el = this.el;
    return [el.offsetWidth, el.offsetHeight];
  };
  TooltipHTMLContent2.prototype.moveTo = function(zrX, zrY) {
    var styleCoord = this._styleCoord;
    makeStyleCoord$1(styleCoord, this._zr, this._appendToBody, zrX, zrY);
    if (styleCoord[0] != null && styleCoord[1] != null) {
      var style_1 = this.el.style;
      var transforms = assembleTransform(styleCoord[0], styleCoord[1]);
      each$f(transforms, function(transform2) {
        style_1[transform2[0]] = transform2[1];
      });
    }
  };
  TooltipHTMLContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipHTMLContent2.prototype.hide = function() {
    var _this = this;
    var style = this.el.style;
    style.visibility = "hidden";
    style.opacity = "0";
    env$1.transform3dSupported && (style.willChange = "");
    this._show = false;
    this._longHideTimeout = setTimeout(function() {
      return _this._longHide = true;
    }, 500);
  };
  TooltipHTMLContent2.prototype.hideLater = function(time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind$1(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };
  TooltipHTMLContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipHTMLContent2.prototype.dispose = function() {
    this.el.parentNode.removeChild(this.el);
  };
  return TooltipHTMLContent2;
}();
var TooltipHTMLContent$1 = TooltipHTMLContent;
var TooltipRichContent = function() {
  function TooltipRichContent2(api) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._zr = api.getZr();
    makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
  }
  TooltipRichContent2.prototype.update = function(tooltipModel) {
    var alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
  };
  TooltipRichContent2.prototype.show = function() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    this.el.show();
    this._show = true;
  };
  TooltipRichContent2.prototype.setContent = function(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    var _this = this;
    if (isObject$3(content)) {
      throwError("");
    }
    if (this.el) {
      this._zr.remove(this.el);
    }
    var textStyleModel = tooltipModel.getModel("textStyle");
    this.el = new ZRText$1({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        borderWidth: 1,
        borderColor,
        textShadowColor: textStyleModel.get("textShadowColor"),
        fill: tooltipModel.get(["textStyle", "color"]),
        padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
        verticalAlign: "top",
        align: "left"
      },
      z: tooltipModel.get("z")
    });
    each$f(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(propName) {
      _this.el.style[propName] = tooltipModel.get(propName);
    });
    each$f(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(propName) {
      _this.el.style[propName] = textStyleModel.get(propName) || 0;
    });
    this._zr.add(this.el);
    var self2 = this;
    this.el.on("mouseover", function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    });
    this.el.on("mouseout", function() {
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
      self2._inContent = false;
    });
  };
  TooltipRichContent2.prototype.setEnterable = function(enterable) {
    this._enterable = enterable;
  };
  TooltipRichContent2.prototype.getSize = function() {
    var el = this.el;
    var bounding = this.el.getBoundingRect();
    var shadowOuterSize = calcShadowOuterSize(el.style);
    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
  };
  TooltipRichContent2.prototype.moveTo = function(x, y) {
    var el = this.el;
    if (el) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, x, y);
      x = styleCoord[0];
      y = styleCoord[1];
      var style = el.style;
      var borderWidth = mathMaxWith0(style.borderWidth || 0);
      var shadowOuterSize = calcShadowOuterSize(style);
      el.x = x + borderWidth + shadowOuterSize.left;
      el.y = y + borderWidth + shadowOuterSize.top;
      el.markRedraw();
    }
  };
  TooltipRichContent2.prototype._moveIfResized = function() {
    var ratioX = this._styleCoord[2];
    var ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  };
  TooltipRichContent2.prototype.hide = function() {
    if (this.el) {
      this.el.hide();
    }
    this._show = false;
  };
  TooltipRichContent2.prototype.hideLater = function(time) {
    if (this._show && !(this._inContent && this._enterable)) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind$1(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  };
  TooltipRichContent2.prototype.isShow = function() {
    return this._show;
  };
  TooltipRichContent2.prototype.dispose = function() {
    this._zr.remove(this.el);
  };
  return TooltipRichContent2;
}();
function mathMaxWith0(val) {
  return Math.max(0, val);
}
function calcShadowOuterSize(style) {
  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}
function makeStyleCoord(out2, zr, zrX, zrY) {
  out2[0] = zrX;
  out2[1] = zrY;
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipRichContent$1 = TooltipRichContent;
var proxyRect = new Rect$3({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
});
var TooltipView = function(_super) {
  __extends(TooltipView2, _super);
  function TooltipView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TooltipView2.type;
    return _this;
  }
  TooltipView2.prototype.init = function(ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    var tooltipModel = ecModel.getComponent("tooltip");
    var renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
    this._tooltipContent = renderMode === "richText" ? new TooltipRichContent$1(api) : new TooltipHTMLContent$1(api.getDom(), api, {
      appendToBody: tooltipModel.get("appendToBody", true)
    });
  };
  TooltipView2.prototype.render = function(tooltipModel, ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api;
    this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
    var tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    this._initGlobalListener();
    this._keepShow();
    if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
      createOrUpdate(this, "_updatePosition", 50, "fixRate");
    } else {
      clear$1(this, "_updatePosition");
    }
  };
  TooltipView2.prototype._initGlobalListener = function() {
    var tooltipModel = this._tooltipModel;
    var triggerOn = tooltipModel.get("triggerOn");
    register$1("itemTooltip", this._api, bind$1(function(currTrigger, e2, dispatchAction2) {
      if (triggerOn !== "none") {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e2, dispatchAction2);
        } else if (currTrigger === "leave") {
          this._hide(dispatchAction2);
        }
      }
    }, this));
  };
  TooltipView2.prototype._keepShow = function() {
    var tooltipModel = this._tooltipModel;
    var ecModel = this._ecModel;
    var api = this._api;
    if (this._lastX != null && this._lastY != null && tooltipModel.get("triggerOn") !== "none") {
      var self_1 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function() {
        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
          x: self_1._lastX,
          y: self_1._lastY,
          dataByCoordSys: self_1._lastDataByCoordSys
        });
      });
    }
  };
  TooltipView2.prototype.manuallyShowTip = function(tooltipModel, ecModel, api, payload) {
    if (payload.from === this.uid || env$1.node || !api.getDom()) {
      return;
    }
    var dispatchAction2 = makeDispatchAction(payload, api);
    this._ticket = "";
    var dataByCoordSys = payload.dataByCoordSys;
    var cmptRef = findComponentReference(payload, ecModel, api);
    if (cmptRef) {
      var rect = cmptRef.el.getBoundingRect().clone();
      rect.applyTransform(cmptRef.el.transform);
      this._tryShow({
        offsetX: rect.x + rect.width / 2,
        offsetY: rect.y + rect.height / 2,
        target: cmptRef.el,
        position: payload.position,
        positionDefault: "bottom"
      }, dispatchAction2);
    } else if (payload.tooltip && payload.x != null && payload.y != null) {
      var el = proxyRect;
      el.x = payload.x;
      el.y = payload.y;
      el.update();
      getECData(el).tooltipConfig = {
        name: null,
        option: payload.tooltip
      };
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction2);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction2);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
        return;
      }
      var pointInfo = findPointFromSeries(payload, ecModel);
      var cx = pointInfo.point[0];
      var cy = pointInfo.point[1];
      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          target: pointInfo.el,
          position: payload.position,
          positionDefault: "bottom"
        }, dispatchAction2);
      }
    } else if (payload.x != null && payload.y != null) {
      api.dispatchAction({
        type: "updateAxisPointer",
        x: payload.x,
        y: payload.y
      });
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction2);
    }
  };
  TooltipView2.prototype.manuallyHideTip = function(tooltipModel, ecModel, api, payload) {
    var tooltipContent = this._tooltipContent;
    if (!this._alwaysShowContent && this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
    }
    this._lastX = this._lastY = this._lastDataByCoordSys = null;
    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction(payload, api));
    }
  };
  TooltipView2.prototype._manuallyAxisShowTip = function(tooltipModel, ecModel, api, payload) {
    var seriesIndex = payload.seriesIndex;
    var dataIndex = payload.dataIndex;
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (!seriesModel) {
      return;
    }
    var data = seriesModel.getData();
    var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);
    if (tooltipCascadedModel.get("trigger") !== "axis") {
      return;
    }
    api.dispatchAction({
      type: "updateAxisPointer",
      seriesIndex,
      dataIndex,
      position: payload.position
    });
    return true;
  };
  TooltipView2.prototype._tryShow = function(e2, dispatchAction2) {
    var el = e2.target;
    var tooltipModel = this._tooltipModel;
    if (!tooltipModel) {
      return;
    }
    this._lastX = e2.offsetX;
    this._lastY = e2.offsetY;
    var dataByCoordSys = e2.dataByCoordSys;
    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e2);
    } else if (el) {
      this._lastDataByCoordSys = null;
      var seriesDispatcher_1;
      var cmptDispatcher_1;
      findEventDispatcher(el, function(target) {
        if (getECData(target).dataIndex != null) {
          seriesDispatcher_1 = target;
          return true;
        }
        if (getECData(target).tooltipConfig != null) {
          cmptDispatcher_1 = target;
          return true;
        }
      }, true);
      if (seriesDispatcher_1) {
        this._showSeriesItemTooltip(e2, seriesDispatcher_1, dispatchAction2);
      } else if (cmptDispatcher_1) {
        this._showComponentItemTooltip(e2, cmptDispatcher_1, dispatchAction2);
      } else {
        this._hide(dispatchAction2);
      }
    } else {
      this._lastDataByCoordSys = null;
      this._hide(dispatchAction2);
    }
  };
  TooltipView2.prototype._showOrMove = function(tooltipModel, cb) {
    var delay = tooltipModel.get("showDelay");
    cb = bind$1(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  };
  TooltipView2.prototype._showAxisTooltip = function(dataByCoordSys, e2) {
    var ecModel = this._ecModel;
    var globalTooltipModel = this._tooltipModel;
    var point = [e2.offsetX, e2.offsetY];
    var singleTooltipModel = buildTooltipModel([e2.tooltipOption], globalTooltipModel);
    var renderMode = this._renderMode;
    var cbParamsList = [];
    var articleMarkup = createTooltipMarkup("section", {
      blocks: [],
      noHeader: true
    });
    var markupTextArrLegacy = [];
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    each$f(dataByCoordSys, function(itemCoordSys) {
      each$f(itemCoordSys.dataByAxis, function(axisItem) {
        var axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
        var axisValue = axisItem.value;
        if (!axisModel || axisValue == null) {
          return;
        }
        var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        var axisSectionMarkup = createTooltipMarkup("section", {
          header: axisValueLabel,
          noHeader: !trim$1(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        each$f(axisItem.seriesDataIndices, function(idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var cbParams = series.getDataParams(dataIndex);
          if (cbParams.dataIndex < 0) {
            return;
          }
          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = getAxisRawValue(axisModel.axis, {
            value: axisValue
          });
          cbParams.axisValueLabel = axisValueLabel;
          cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
          var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
          var frag = seriesTooltipResult.frag;
          if (frag) {
            var valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
            axisSectionMarkup.blocks.push(valueFormatter ? extend$1({
              valueFormatter
            }, frag) : frag);
          }
          if (seriesTooltipResult.text) {
            markupTextArrLegacy.push(seriesTooltipResult.text);
          }
          cbParamsList.push(cbParams);
        });
      });
    });
    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    var positionExpr = e2.position;
    var orderMode = singleTooltipModel.get("order");
    var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    var blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
    var allMarkupText = markupTextArrLegacy.join(blockBreak);
    this._showOrMove(singleTooltipModel, function() {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
      }
    });
  };
  TooltipView2.prototype._showSeriesItemTooltip = function(e2, dispatcher, dispatchAction2) {
    var ecModel = this._ecModel;
    var ecData = getECData(dispatcher);
    var seriesIndex = ecData.seriesIndex;
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    var dataModel = ecData.dataModel || seriesModel;
    var dataIndex = ecData.dataIndex;
    var dataType = ecData.dataType;
    var data = dataModel.getData(dataType);
    var renderMode = this._renderMode;
    var positionDefault = e2.positionDefault;
    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var tooltipTrigger = tooltipModel.get("trigger");
    if (tooltipTrigger != null && tooltipTrigger !== "item") {
      return;
    }
    var params = dataModel.getDataParams(dataIndex, dataType);
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
    var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
    var orderMode = tooltipModel.get("order");
    var valueFormatter = tooltipModel.get("valueFormatter");
    var frag = seriesTooltipResult.frag;
    var markupText = frag ? buildTooltipMarkup(valueFormatter ? extend$1({
      valueFormatter
    }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
    var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
    this._showOrMove(tooltipModel, function() {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markupStyleCreator);
    });
    dispatchAction2({
      type: "showTip",
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex,
      from: this.uid
    });
  };
  TooltipView2.prototype._showComponentItemTooltip = function(e2, el, dispatchAction2) {
    var ecData = getECData(el);
    var tooltipConfig = ecData.tooltipConfig;
    var tooltipOpt = tooltipConfig.option || {};
    if (isString(tooltipOpt)) {
      var content = tooltipOpt;
      tooltipOpt = {
        content,
        formatter: content
      };
    }
    var tooltipModelCascade = [tooltipOpt];
    var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
    if (cmpt) {
      tooltipModelCascade.push(cmpt);
    }
    tooltipModelCascade.push({
      formatter: tooltipOpt.content
    });
    var positionDefault = e2.positionDefault;
    var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {
      position: positionDefault
    } : null);
    var defaultHtml = subTooltipModel.get("content");
    var asyncTicket = Math.random() + "";
    var markupStyleCreator = new TooltipMarkupStyleCreator();
    this._showOrMove(subTooltipModel, function() {
      var formatterParams = clone$4(subTooltipModel.get("formatterParams") || {});
      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el, markupStyleCreator);
    });
    dispatchAction2({
      type: "showTip",
      from: this.uid
    });
  };
  TooltipView2.prototype._showTooltipContent = function(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
    this._ticket = "";
    if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
      return;
    }
    var tooltipContent = this._tooltipContent;
    var formatter = tooltipModel.get("formatter");
    positionExpr = positionExpr || tooltipModel.get("position");
    var html = defaultHtml;
    var nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"));
    var nearPointColor = nearPoint.color;
    if (formatter) {
      if (isString(formatter)) {
        var useUTC = tooltipModel.ecModel.get("useUTC");
        var params0 = isArray$1(params) ? params[0] : params;
        var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
        html = formatter;
        if (isTimeAxis) {
          html = format(params0.axisValue, html, useUTC);
        }
        html = formatTpl(html, params, true);
      } else if (isFunction$1(formatter)) {
        var callback = bind$1(function(cbTicket, html2) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
            this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html = formatter(params, asyncTicket, callback);
      } else {
        html = formatter;
      }
    }
    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
    tooltipContent.show(tooltipModel, nearPointColor);
    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
  };
  TooltipView2.prototype._getNearestPoint = function(point, tooltipDataParams, trigger2, borderColor) {
    if (trigger2 === "axis" || isArray$1(tooltipDataParams)) {
      return {
        color: borderColor || (this._renderMode === "html" ? "#fff" : "none")
      };
    }
    if (!isArray$1(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  };
  TooltipView2.prototype._updatePosition = function(tooltipModel, positionExpr, x, y, content, params, el) {
    var viewWidth = this._api.getWidth();
    var viewHeight = this._api.getHeight();
    positionExpr = positionExpr || tooltipModel.get("position");
    var contentSize = content.getSize();
    var align = tooltipModel.get("align");
    var vAlign = tooltipModel.get("verticalAlign");
    var rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);
    if (isFunction$1(positionExpr)) {
      positionExpr = positionExpr([x, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }
    if (isArray$1(positionExpr)) {
      x = parsePercent$1(positionExpr[0], viewWidth);
      y = parsePercent$1(positionExpr[1], viewHeight);
    } else if (isObject$3(positionExpr)) {
      var boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      var layoutRect = getLayoutRect(boxLayoutPosition, {
        width: viewWidth,
        height: viewHeight
      });
      x = layoutRect.x;
      y = layoutRect.y;
      align = null;
      vAlign = null;
    } else if (isString(positionExpr) && el) {
      var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
      x = pos[0];
      y = pos[1];
    } else {
      var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
      x = pos[0];
      y = pos[1];
    }
    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
    if (shouldTooltipConfine(tooltipModel)) {
      var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }
    content.moveTo(x, y);
  };
  TooltipView2.prototype._updateContentNotChangedOnAxis = function(dataByCoordSys, cbParamsList) {
    var lastCoordSys = this._lastDataByCoordSys;
    var lastCbParamsList = this._cbParamsList;
    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each$f(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each$f(lastDataByAxis, function(lastItem, indexAxis) {
        var thisItem = thisDataByAxis[indexAxis] || {};
        var lastIndices = lastItem.seriesDataIndices || [];
        var newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each$f(lastIndices, function(lastIdxItem, j) {
          var newIdxItem = newIndices[j];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
        lastCbParamsList && each$f(lastItem.seriesDataIndices, function(idxItem) {
          var seriesIdx = idxItem.seriesIndex;
          var cbParams = cbParamsList[seriesIdx];
          var lastCbParams = lastCbParamsList[seriesIdx];
          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
            contentNotChanged = false;
          }
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    this._cbParamsList = cbParamsList;
    return !!contentNotChanged;
  };
  TooltipView2.prototype._hide = function(dispatchAction2) {
    this._lastDataByCoordSys = null;
    dispatchAction2({
      type: "hideTip",
      from: this.uid
    });
  };
  TooltipView2.prototype.dispose = function(ecModel, api) {
    if (env$1.node || !api.getDom()) {
      return;
    }
    clear$1(this, "_updatePosition");
    this._tooltipContent.dispose();
    unregister("itemTooltip", api);
  };
  TooltipView2.type = "tooltip";
  return TooltipView2;
}(ComponentView$1);
function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
  var ecModel = globalTooltipModel.ecModel;
  var resultModel;
  if (defaultTooltipOption) {
    resultModel = new Model$1(defaultTooltipOption, ecModel, ecModel);
    resultModel = new Model$1(globalTooltipModel.option, resultModel, ecModel);
  } else {
    resultModel = globalTooltipModel;
  }
  for (var i = modelCascade.length - 1; i >= 0; i--) {
    var tooltipOpt = modelCascade[i];
    if (tooltipOpt) {
      if (tooltipOpt instanceof Model$1) {
        tooltipOpt = tooltipOpt.get("tooltip", true);
      }
      if (isString(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }
      if (tooltipOpt) {
        resultModel = new Model$1(tooltipOpt, resultModel, ecModel);
      }
    }
  }
  return resultModel;
}
function makeDispatchAction(payload, api) {
  return payload.dispatchAction || bind$1(api.dispatchAction, api);
}
function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
  var size = content.getSize();
  var width = size[0];
  var height = size[1];
  if (gapH != null) {
    if (x + width + gapH + 2 > viewWidth) {
      x -= width + gapH;
    } else {
      x += gapH;
    }
  }
  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }
  return [x, y];
}
function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
  var size = content.getSize();
  var width = size[0];
  var height = size[1];
  x = Math.min(x + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x = Math.max(x, 0);
  y = Math.max(y, 0);
  return [x, y];
}
function calcTooltipPosition(position2, rect, contentSize, borderWidth) {
  var domWidth = contentSize[0];
  var domHeight = contentSize[1];
  var offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
  var x = 0;
  var y = 0;
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  switch (position2) {
    case "inside":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "top":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - offset;
      break;
    case "bottom":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + offset;
      break;
    case "left":
      x = rect.x - domWidth - offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "right":
      x = rect.x + rectWidth + offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }
  return [x, y];
}
function isCenterAlign(align) {
  return align === "center" || align === "middle";
}
function findComponentReference(payload, ecModel, api) {
  var queryOptionMap = preParseFinder(payload).queryOptionMap;
  var componentMainType = queryOptionMap.keys()[0];
  if (!componentMainType || componentMainType === "series") {
    return;
  }
  var queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
    useDefault: false,
    enableAll: false,
    enableNone: false
  });
  var model = queryResult.models[0];
  if (!model) {
    return;
  }
  var view = api.getViewOfComponentModel(model);
  var el;
  view.group.traverse(function(subEl) {
    var tooltipConfig = getECData(subEl).tooltipConfig;
    if (tooltipConfig && tooltipConfig.name === payload.name) {
      el = subEl;
      return true;
    }
  });
  if (el) {
    return {
      componentMainType,
      componentIndex: model.componentIndex,
      el
    };
  }
}
var TooltipView$1 = TooltipView;
function install$y(registers) {
  use(install$G);
  registers.registerComponentModel(TooltipModel$1);
  registers.registerComponentView(TooltipView$1);
  registers.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop$1);
  registers.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop$1);
}
var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
function brushPreprocessor(option, isNew) {
  var brushComponents = normalizeToArray(option ? option.brush : []);
  if (!brushComponents.length) {
    return;
  }
  var brushComponentSpecifiedBtns = [];
  each$f(brushComponents, function(brushOpt) {
    var tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
    if (tbs instanceof Array) {
      brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
    }
  });
  var toolbox = option && option.toolbox;
  if (isArray$1(toolbox)) {
    toolbox = toolbox[0];
  }
  if (!toolbox) {
    toolbox = {
      feature: {}
    };
    option.toolbox = [toolbox];
  }
  var toolboxFeature = toolbox.feature || (toolbox.feature = {});
  var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
  var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
  brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
  removeDuplicate(brushTypes);
  if (isNew && !brushTypes.length) {
    brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
  }
}
function removeDuplicate(arr) {
  var map2 = {};
  each$f(arr, function(val) {
    map2[val] = 1;
  });
  arr.length = 0;
  each$f(map2, function(flag, val) {
    arr.push(val);
  });
}
var each$4 = each$f;
function hasKeys(obj) {
  if (obj) {
    for (var name_1 in obj) {
      if (obj.hasOwnProperty(name_1)) {
        return true;
      }
    }
  }
}
function createVisualMappings(option, stateList, supplementVisualOption) {
  var visualMappings = {};
  each$4(stateList, function(state) {
    var mappings = visualMappings[state] = createMappings();
    each$4(option[state], function(visualData, visualType) {
      if (!VisualMapping$1.isValidType(visualType)) {
        return;
      }
      var mappingOption = {
        type: visualType,
        visual: visualData
      };
      supplementVisualOption && supplementVisualOption(mappingOption, state);
      mappings[visualType] = new VisualMapping$1(mappingOption);
      if (visualType === "opacity") {
        mappingOption = clone$4(mappingOption);
        mappingOption.type = "colorAlpha";
        mappings.__hidden.__alphaForOpacity = new VisualMapping$1(mappingOption);
      }
    });
  });
  return visualMappings;
  function createMappings() {
    var Creater = function() {
    };
    Creater.prototype.__hidden = Creater.prototype;
    var obj = new Creater();
    return obj;
  }
}
function replaceVisualOption(thisOption, newOption, keys2) {
  var has2;
  each$f(keys2, function(key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      has2 = true;
    }
  });
  has2 && each$f(keys2, function(key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      thisOption[key] = clone$4(newOption[key]);
    } else {
      delete thisOption[key];
    }
  });
}
function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
  var visualTypesMap = {};
  each$f(stateList, function(state) {
    var visualTypes = VisualMapping$1.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  var dataIndex;
  function getVisual(key) {
    return getItemVisualFromData(data, dataIndex, key);
  }
  function setVisual(key, value) {
    setItemVisualFromData(data, dataIndex, key, value);
  }
  if (dimension == null) {
    data.each(eachItem);
  } else {
    data.each([dimension], eachItem);
  }
  function eachItem(valueOrIndex, index) {
    dataIndex = dimension == null ? valueOrIndex : index;
    var rawDataItem = data.getRawDataItem(dataIndex);
    if (rawDataItem && rawDataItem.visualMap === false) {
      return;
    }
    var valueState = getValueState.call(scope, valueOrIndex);
    var mappings = visualMappings[valueState];
    var visualTypes = visualTypesMap[valueState];
    for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
      var type = visualTypes[i];
      mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
    }
  }
}
function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
  var visualTypesMap = {};
  each$f(stateList, function(state) {
    var visualTypes = VisualMapping$1.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  return {
    progress: function progress(params, data) {
      var dimIndex;
      if (dim != null) {
        dimIndex = data.getDimensionIndex(dim);
      }
      function getVisual(key) {
        return getItemVisualFromData(data, dataIndex, key);
      }
      function setVisual(key, value2) {
        setItemVisualFromData(data, dataIndex, key, value2);
      }
      var dataIndex;
      var store = data.getStore();
      while ((dataIndex = params.next()) != null) {
        var rawDataItem = data.getRawDataItem(dataIndex);
        if (rawDataItem && rawDataItem.visualMap === false) {
          continue;
        }
        var value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex;
        var valueState = getValueState(value);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];
        for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
        }
      }
    }
  };
}
function makeBrushCommonSelectorForSeries(area2) {
  var brushType = area2.brushType;
  var selectors = {
    point: function(itemLayout) {
      return selector[brushType].point(itemLayout, selectors, area2);
    },
    rect: function(itemLayout) {
      return selector[brushType].rect(itemLayout, selectors, area2);
    }
  };
  return selectors;
}
var selector = {
  lineX: getLineSelectors(0),
  lineY: getLineSelectors(1),
  rect: {
    point: function(itemLayout, selectors, area2) {
      return itemLayout && area2.boundingRect.contain(itemLayout[0], itemLayout[1]);
    },
    rect: function(itemLayout, selectors, area2) {
      return itemLayout && area2.boundingRect.intersect(itemLayout);
    }
  },
  polygon: {
    point: function(itemLayout, selectors, area2) {
      return itemLayout && area2.boundingRect.contain(itemLayout[0], itemLayout[1]) && contain(area2.range, itemLayout[0], itemLayout[1]);
    },
    rect: function(itemLayout, selectors, area2) {
      var points2 = area2.range;
      if (!itemLayout || points2.length <= 1) {
        return false;
      }
      var x = itemLayout.x;
      var y = itemLayout.y;
      var width = itemLayout.width;
      var height = itemLayout.height;
      var p = points2[0];
      if (contain(points2, x, y) || contain(points2, x + width, y) || contain(points2, x, y + height) || contain(points2, x + width, y + height) || BoundingRect$1.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points2) || linePolygonIntersect(x, y, x, y + height, points2) || linePolygonIntersect(x + width, y, x + width, y + height, points2) || linePolygonIntersect(x, y + height, x + width, y + height, points2)) {
        return true;
      }
    }
  }
};
function getLineSelectors(xyIndex) {
  var xy = ["x", "y"];
  var wh = ["width", "height"];
  return {
    point: function(itemLayout, selectors, area2) {
      if (itemLayout) {
        var range = area2.range;
        var p = itemLayout[xyIndex];
        return inLineRange(p, range);
      }
    },
    rect: function(itemLayout, selectors, area2) {
      if (itemLayout) {
        var range = area2.range;
        var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
        layoutRange[1] < layoutRange[0] && layoutRange.reverse();
        return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
      }
    }
  };
}
function inLineRange(p, range) {
  return range[0] <= p && p <= range[1];
}
var STATE_LIST = ["inBrush", "outOfBrush"];
var DISPATCH_METHOD = "__ecBrushSelect";
var DISPATCH_FLAG = "__ecInBrushSelectEvent";
function layoutCovers(ecModel) {
  ecModel.eachComponent({
    mainType: "brush"
  }, function(brushModel) {
    var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager$1(brushModel.option, ecModel);
    brushTargetManager.setInputRanges(brushModel.areas, ecModel);
  });
}
function brushVisual(ecModel, api, payload) {
  var brushSelected = [];
  var throttleType;
  var throttleDelay;
  ecModel.eachComponent({
    mainType: "brush"
  }, function(brushModel) {
    payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : {
      brushType: false
    });
  });
  layoutCovers(ecModel);
  ecModel.eachComponent({
    mainType: "brush"
  }, function(brushModel, brushIndex) {
    var thisBrushSelected = {
      brushId: brushModel.id,
      brushIndex,
      brushName: brushModel.name,
      areas: clone$4(brushModel.areas),
      selected: []
    };
    brushSelected.push(thisBrushSelected);
    var brushOption = brushModel.option;
    var brushLink = brushOption.brushLink;
    var linkedSeriesMap = [];
    var selectedDataIndexForLink = [];
    var rangeInfoBySeries = [];
    var hasBrushExists = false;
    if (!brushIndex) {
      throttleType = brushOption.throttleType;
      throttleDelay = brushOption.throttleDelay;
    }
    var areas = map$1(brushModel.areas, function(area2) {
      var builder = boundingRectBuilders[area2.brushType];
      var selectableArea = defaults({
        boundingRect: builder ? builder(area2) : void 0
      }, area2);
      selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea);
      return selectableArea;
    });
    var visualMappings = createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
      mappingOption.mappingMethod = "fixed";
    });
    isArray$1(brushLink) && each$f(brushLink, function(seriesIndex) {
      linkedSeriesMap[seriesIndex] = 1;
    });
    function linkOthers(seriesIndex) {
      return brushLink === "all" || !!linkedSeriesMap[seriesIndex];
    }
    function brushed(rangeInfoList) {
      return !!rangeInfoList.length;
    }
    ecModel.eachSeries(function(seriesModel, seriesIndex) {
      var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
      seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
    });
    function stepAParallel(seriesModel, seriesIndex) {
      var coordSys = seriesModel.coordinateSystem;
      hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();
      linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
        activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
      });
    }
    function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
      if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {
        return;
      }
      each$f(areas, function(area2) {
        if (brushModel.brushTargetManager.controlSeries(area2, seriesModel, ecModel)) {
          rangeInfoList.push(area2);
        }
        hasBrushExists = hasBrushExists || brushed(rangeInfoList);
      });
      if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
        var data_1 = seriesModel.getData();
        data_1.each(function(dataIndex) {
          if (checkInRange(seriesModel, rangeInfoList, data_1, dataIndex)) {
            selectedDataIndexForLink[dataIndex] = 1;
          }
        });
      }
    }
    ecModel.eachSeries(function(seriesModel, seriesIndex) {
      var seriesBrushSelected = {
        seriesId: seriesModel.id,
        seriesIndex,
        seriesName: seriesModel.name,
        dataIndex: []
      };
      thisBrushSelected.selected.push(seriesBrushSelected);
      var rangeInfoList = rangeInfoBySeries[seriesIndex];
      var data = seriesModel.getData();
      var getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
        return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
      } : function(dataIndex) {
        return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
      };
      (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && applyVisual(STATE_LIST, visualMappings, data, getValueState);
    });
  });
  dispatchAction$1(api, throttleType, throttleDelay, brushSelected, payload);
}
function dispatchAction$1(api, throttleType, throttleDelay, brushSelected, payload) {
  if (!payload) {
    return;
  }
  var zr = api.getZr();
  if (zr[DISPATCH_FLAG]) {
    return;
  }
  if (!zr[DISPATCH_METHOD]) {
    zr[DISPATCH_METHOD] = doDispatch;
  }
  var fn = createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
  fn(api, brushSelected);
}
function doDispatch(api, brushSelected) {
  if (!api.isDisposed()) {
    var zr = api.getZr();
    zr[DISPATCH_FLAG] = true;
    api.dispatchAction({
      type: "brushSelect",
      batch: brushSelected
    });
    zr[DISPATCH_FLAG] = false;
  }
}
function checkInRange(seriesModel, rangeInfoList, data, dataIndex) {
  for (var i = 0, len2 = rangeInfoList.length; i < len2; i++) {
    var area2 = rangeInfoList[i];
    if (seriesModel.brushSelector(dataIndex, data, area2.selectors, area2)) {
      return true;
    }
  }
}
function brushModelNotControll(brushModel, seriesIndex) {
  var seriesIndices = brushModel.option.seriesIndex;
  return seriesIndices != null && seriesIndices !== "all" && (isArray$1(seriesIndices) ? indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
}
var boundingRectBuilders = {
  rect: function(area2) {
    return getBoundingRectFromMinMax(area2.range);
  },
  polygon: function(area2) {
    var minMax;
    var range = area2.range;
    for (var i = 0, len2 = range.length; i < len2; i++) {
      minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
      var rg = range[i];
      rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
      rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
      rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
      rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
    }
    return minMax && getBoundingRectFromMinMax(minMax);
  }
};
function getBoundingRectFromMinMax(minMax) {
  return new BoundingRect$1(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
}
var BrushView = function(_super) {
  __extends(BrushView2, _super);
  function BrushView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BrushView2.type;
    return _this;
  }
  BrushView2.prototype.init = function(ecModel, api) {
    this.ecModel = ecModel;
    this.api = api;
    this.model;
    (this._brushController = new BrushController$1(api.getZr())).on("brush", bind$1(this._onBrush, this)).mount();
  };
  BrushView2.prototype.render = function(brushModel, ecModel, api, payload) {
    this.model = brushModel;
    this._updateController(brushModel, ecModel, api, payload);
  };
  BrushView2.prototype.updateTransform = function(brushModel, ecModel, api, payload) {
    layoutCovers(ecModel);
    this._updateController(brushModel, ecModel, api, payload);
  };
  BrushView2.prototype.updateVisual = function(brushModel, ecModel, api, payload) {
    this.updateTransform(brushModel, ecModel, api, payload);
  };
  BrushView2.prototype.updateView = function(brushModel, ecModel, api, payload) {
    this._updateController(brushModel, ecModel, api, payload);
  };
  BrushView2.prototype._updateController = function(brushModel, ecModel, api, payload) {
    (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
  };
  BrushView2.prototype.dispose = function() {
    this._brushController.dispose();
  };
  BrushView2.prototype._onBrush = function(eventParam) {
    var modelId = this.model.id;
    var areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel);
    (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({
      type: "brush",
      brushId: modelId,
      areas: clone$4(areas),
      $from: modelId
    });
    eventParam.isEnd && this.api.dispatchAction({
      type: "brushEnd",
      brushId: modelId,
      areas: clone$4(areas),
      $from: modelId
    });
  };
  BrushView2.type = "brush";
  return BrushView2;
}(ComponentView$1);
var BrushView$1 = BrushView;
var DEFAULT_OUT_OF_BRUSH_COLOR = "#ddd";
var BrushModel = function(_super) {
  __extends(BrushModel2, _super);
  function BrushModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = BrushModel2.type;
    _this.areas = [];
    _this.brushOption = {};
    return _this;
  }
  BrushModel2.prototype.optionUpdated = function(newOption, isInit) {
    var thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
    var inBrush = thisOption.inBrush = thisOption.inBrush || {};
    thisOption.outOfBrush = thisOption.outOfBrush || {
      color: DEFAULT_OUT_OF_BRUSH_COLOR
    };
    if (!inBrush.hasOwnProperty("liftZ")) {
      inBrush.liftZ = 5;
    }
  };
  BrushModel2.prototype.setAreas = function(areas) {
    if (!areas) {
      return;
    }
    this.areas = map$1(areas, function(area2) {
      return generateBrushOption(this.option, area2);
    }, this);
  };
  BrushModel2.prototype.setBrushOption = function(brushOption) {
    this.brushOption = generateBrushOption(this.option, brushOption);
    this.brushType = this.brushOption.brushType;
  };
  BrushModel2.type = "brush";
  BrushModel2.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"];
  BrushModel2.defaultOption = {
    seriesIndex: "all",
    brushType: "rect",
    brushMode: "single",
    transformable: true,
    brushStyle: {
      borderWidth: 1,
      color: "rgba(210,219,238,0.3)",
      borderColor: "#D2DBEE"
    },
    throttleType: "fixRate",
    throttleDelay: 0,
    removeOnClick: true,
    z: 1e4
  };
  return BrushModel2;
}(ComponentModel$1);
function generateBrushOption(option, brushOption) {
  return merge({
    brushType: option.brushType,
    brushMode: option.brushMode,
    transformable: option.transformable,
    brushStyle: new Model$1(option.brushStyle).getItemStyle(),
    removeOnClick: option.removeOnClick,
    z: option.z
  }, brushOption, true);
}
var BrushModel$1 = BrushModel;
var ICON_TYPES = ["rect", "polygon", "lineX", "lineY", "keep", "clear"];
var BrushFeature = function(_super) {
  __extends(BrushFeature2, _super);
  function BrushFeature2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  BrushFeature2.prototype.render = function(featureModel, ecModel, api) {
    var brushType;
    var brushMode;
    var isBrushed;
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel) {
      brushType = brushModel.brushType;
      brushMode = brushModel.brushOption.brushMode || "single";
      isBrushed = isBrushed || !!brushModel.areas.length;
    });
    this._brushType = brushType;
    this._brushMode = brushMode;
    each$f(featureModel.get("type", true), function(type) {
      featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
    });
  };
  BrushFeature2.prototype.updateView = function(featureModel, ecModel, api) {
    this.render(featureModel, ecModel, api);
  };
  BrushFeature2.prototype.getIcons = function() {
    var model = this.model;
    var availableIcons = model.get("icon", true);
    var icons = {};
    each$f(model.get("type", true), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  BrushFeature2.prototype.onclick = function(ecModel, api, type) {
    var brushType = this._brushType;
    var brushMode = this._brushMode;
    if (type === "clear") {
      api.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      });
      api.dispatchAction({
        type: "brush",
        command: "clear",
        areas: []
      });
    } else {
      api.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: type === "keep" ? brushType : brushType === type ? false : type,
          brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
        }
      });
    }
  };
  BrushFeature2.getDefaultOption = function(ecModel) {
    var defaultOption2 = {
      show: true,
      type: ICON_TYPES.slice(),
      icon: {
        rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
        polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
        lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
        lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
        keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
        clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "brush", "title"])
    };
    return defaultOption2;
  };
  return BrushFeature2;
}(ToolboxFeature);
var BrushFeature$1 = BrushFeature;
function install$x(registers) {
  registers.registerComponentView(BrushView$1);
  registers.registerComponentModel(BrushModel$1);
  registers.registerPreprocessor(brushPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual);
  registers.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "brush",
      query: payload
    }, function(brushModel) {
      brushModel.setAreas(payload.areas);
    });
  });
  registers.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, noop$1);
  registers.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, noop$1);
  registerFeature("brush", BrushFeature$1);
}
var TitleModel = function(_super) {
  __extends(TitleModel2, _super);
  function TitleModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  TitleModel2.type = "title";
  TitleModel2.defaultOption = {
    z: 6,
    show: true,
    text: "",
    target: "blank",
    subtext: "",
    subtarget: "blank",
    left: 0,
    top: 0,
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    textStyle: {
      fontSize: 18,
      fontWeight: "bold",
      color: "#464646"
    },
    subtextStyle: {
      fontSize: 12,
      color: "#6E7079"
    }
  };
  return TitleModel2;
}(ComponentModel$1);
var TitleView = function(_super) {
  __extends(TitleView2, _super);
  function TitleView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TitleView2.type;
    return _this;
  }
  TitleView2.prototype.render = function(titleModel, ecModel, api) {
    this.group.removeAll();
    if (!titleModel.get("show")) {
      return;
    }
    var group = this.group;
    var textStyleModel = titleModel.getModel("textStyle");
    var subtextStyleModel = titleModel.getModel("subtextStyle");
    var textAlign = titleModel.get("textAlign");
    var textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
    var textEl = new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        text: titleModel.get("text"),
        fill: textStyleModel.getTextColor()
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var textRect = textEl.getBoundingRect();
    var subText = titleModel.get("subtext");
    var subTextEl = new ZRText$1({
      style: createTextStyle$1(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get("itemGap"),
        verticalAlign: "top"
      }, {
        disableBox: true
      }),
      z2: 10
    });
    var link = titleModel.get("link");
    var sublink = titleModel.get("sublink");
    var triggerEvent = titleModel.get("triggerEvent", true);
    textEl.silent = !link && !triggerEvent;
    subTextEl.silent = !sublink && !triggerEvent;
    if (link) {
      textEl.on("click", function() {
        windowOpen(link, "_" + titleModel.get("target"));
      });
    }
    if (sublink) {
      subTextEl.on("click", function() {
        windowOpen(sublink, "_" + titleModel.get("subtarget"));
      });
    }
    getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
      componentType: "title",
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl);
    var groupRect = group.getBoundingRect();
    var layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    var layoutRect = getLayoutRect(layoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    }, titleModel.get("padding"));
    if (!textAlign) {
      textAlign = titleModel.get("left") || titleModel.get("right");
      if (textAlign === "middle") {
        textAlign = "center";
      }
      if (textAlign === "right") {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === "center") {
        layoutRect.x += layoutRect.width / 2;
      }
    }
    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
      if (textVerticalAlign === "center") {
        textVerticalAlign = "middle";
      }
      if (textVerticalAlign === "bottom") {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === "middle") {
        layoutRect.y += layoutRect.height / 2;
      }
      textVerticalAlign = textVerticalAlign || "top";
    }
    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    var alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle);
    groupRect = group.getBoundingRect();
    var padding = layoutRect.margin;
    var style = titleModel.getItemStyle(["color", "opacity"]);
    style.fill = titleModel.get("backgroundColor");
    var rect = new Rect$3({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get("borderRadius")
      },
      style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  };
  TitleView2.type = "title";
  return TitleView2;
}(ComponentView$1);
function install$w(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}
var TimelineModel = function(_super) {
  __extends(TimelineModel2, _super);
  function TimelineModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TimelineModel2.type;
    _this.layoutMode = "box";
    return _this;
  }
  TimelineModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    this._initData();
  };
  TimelineModel2.prototype.mergeOption = function(option) {
    _super.prototype.mergeOption.apply(this, arguments);
    this._initData();
  };
  TimelineModel2.prototype.setCurrentIndex = function(currentIndex) {
    if (currentIndex == null) {
      currentIndex = this.option.currentIndex;
    }
    var count2 = this._data.count();
    if (this.option.loop) {
      currentIndex = (currentIndex % count2 + count2) % count2;
    } else {
      currentIndex >= count2 && (currentIndex = count2 - 1);
      currentIndex < 0 && (currentIndex = 0);
    }
    this.option.currentIndex = currentIndex;
  };
  TimelineModel2.prototype.getCurrentIndex = function() {
    return this.option.currentIndex;
  };
  TimelineModel2.prototype.isIndexMax = function() {
    return this.getCurrentIndex() >= this._data.count() - 1;
  };
  TimelineModel2.prototype.setPlayState = function(state) {
    this.option.autoPlay = !!state;
  };
  TimelineModel2.prototype.getPlayState = function() {
    return !!this.option.autoPlay;
  };
  TimelineModel2.prototype._initData = function() {
    var thisOption = this.option;
    var dataArr = thisOption.data || [];
    var axisType = thisOption.axisType;
    var names = this._names = [];
    var processedDataArr;
    if (axisType === "category") {
      processedDataArr = [];
      each$f(dataArr, function(item, index) {
        var value = convertOptionIdName(getDataItemValue(item), "");
        var newItem;
        if (isObject$3(item)) {
          newItem = clone$4(item);
          newItem.value = index;
        } else {
          newItem = index;
        }
        processedDataArr.push(newItem);
        names.push(value);
      });
    } else {
      processedDataArr = dataArr;
    }
    var dimType = {
      category: "ordinal",
      time: "time",
      value: "number"
    }[axisType] || "number";
    var data = this._data = new SeriesData$1([{
      name: "value",
      type: dimType
    }], this);
    data.initData(processedDataArr, names);
  };
  TimelineModel2.prototype.getData = function() {
    return this._data;
  };
  TimelineModel2.prototype.getCategories = function() {
    if (this.get("axisType") === "category") {
      return this._names.slice();
    }
  };
  TimelineModel2.type = "timeline";
  TimelineModel2.defaultOption = {
    z: 4,
    show: true,
    axisType: "time",
    realtime: true,
    left: "20%",
    top: null,
    right: "20%",
    bottom: 0,
    width: null,
    height: 40,
    padding: 5,
    controlPosition: "left",
    autoPlay: false,
    rewind: false,
    loop: true,
    playInterval: 2e3,
    currentIndex: 0,
    itemStyle: {},
    label: {
      color: "#000"
    },
    data: []
  };
  return TimelineModel2;
}(ComponentModel$1);
var TimelineModel$1 = TimelineModel;
var SliderTimelineModel = function(_super) {
  __extends(SliderTimelineModel2, _super);
  function SliderTimelineModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderTimelineModel2.type;
    return _this;
  }
  SliderTimelineModel2.type = "timeline.slider";
  SliderTimelineModel2.defaultOption = inheritDefaultOption(TimelineModel$1.defaultOption, {
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderWidth: 0,
    orient: "horizontal",
    inverse: false,
    tooltip: {
      trigger: "item"
    },
    symbol: "circle",
    symbolSize: 12,
    lineStyle: {
      show: true,
      width: 2,
      color: "#DAE1F5"
    },
    label: {
      position: "auto",
      show: true,
      interval: "auto",
      rotate: 0,
      color: "#A4B1D7"
    },
    itemStyle: {
      color: "#A4B1D7",
      borderWidth: 1
    },
    checkpointStyle: {
      symbol: "circle",
      symbolSize: 15,
      color: "#316bf3",
      borderColor: "#fff",
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: "rgba(0, 0, 0, 0.3)",
      animation: true,
      animationDuration: 300,
      animationEasing: "quinticInOut"
    },
    controlStyle: {
      show: true,
      showPlayBtn: true,
      showPrevBtn: true,
      showNextBtn: true,
      itemSize: 24,
      itemGap: 12,
      position: "left",
      playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
      stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
      nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
      prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
      prevBtnSize: 18,
      nextBtnSize: 18,
      color: "#A4B1D7",
      borderColor: "#A4B1D7",
      borderWidth: 1
    },
    emphasis: {
      label: {
        show: true,
        color: "#6f778d"
      },
      itemStyle: {
        color: "#316BF3"
      },
      controlStyle: {
        color: "#316BF3",
        borderColor: "#316BF3",
        borderWidth: 2
      }
    },
    progress: {
      lineStyle: {
        color: "#316BF3"
      },
      itemStyle: {
        color: "#316BF3"
      },
      label: {
        color: "#6f778d"
      }
    },
    data: []
  });
  return SliderTimelineModel2;
}(TimelineModel$1);
mixin(SliderTimelineModel, DataFormatMixin.prototype);
var SliderTimelineModel$1 = SliderTimelineModel;
var TimelineView = function(_super) {
  __extends(TimelineView2, _super);
  function TimelineView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = TimelineView2.type;
    return _this;
  }
  TimelineView2.type = "timeline";
  return TimelineView2;
}(ComponentView$1);
var TimelineView$1 = TimelineView;
var TimelineAxis = function(_super) {
  __extends(TimelineAxis2, _super);
  function TimelineAxis2(dim, scale2, coordExtent, axisType) {
    var _this = _super.call(this, dim, scale2, coordExtent) || this;
    _this.type = axisType || "value";
    return _this;
  }
  TimelineAxis2.prototype.getLabelModel = function() {
    return this.model.getModel("label");
  };
  TimelineAxis2.prototype.isHorizontal = function() {
    return this.model.get("orient") === "horizontal";
  };
  return TimelineAxis2;
}(Axis$1);
var TimelineAxis$1 = TimelineAxis;
var PI$2 = Math.PI;
var labelDataIndexStore = makeInner();
var SliderTimelineView = function(_super) {
  __extends(SliderTimelineView2, _super);
  function SliderTimelineView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderTimelineView2.type;
    return _this;
  }
  SliderTimelineView2.prototype.init = function(ecModel, api) {
    this.api = api;
  };
  SliderTimelineView2.prototype.render = function(timelineModel, ecModel, api) {
    this.model = timelineModel;
    this.api = api;
    this.ecModel = ecModel;
    this.group.removeAll();
    if (timelineModel.get("show", true)) {
      var layoutInfo_1 = this._layout(timelineModel, api);
      var mainGroup_1 = this._createGroup("_mainGroup");
      var labelGroup = this._createGroup("_labelGroup");
      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);
      timelineModel.formatTooltip = function(dataIndex) {
        var name = axis_1.scale.getLabel({
          value: dataIndex
        });
        return createTooltipMarkup("nameValue", {
          noName: true,
          value: name
        });
      };
      each$f(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name) {
        this["_render" + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);
      }, this);
      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);
      this._position(layoutInfo_1, timelineModel);
    }
    this._doPlayStop();
    this._updateTicksStatus();
  };
  SliderTimelineView2.prototype.remove = function() {
    this._clearTimer();
    this.group.removeAll();
  };
  SliderTimelineView2.prototype.dispose = function() {
    this._clearTimer();
  };
  SliderTimelineView2.prototype._layout = function(timelineModel, api) {
    var labelPosOpt = timelineModel.get(["label", "position"]);
    var orient = timelineModel.get("orient");
    var viewRect2 = getViewRect(timelineModel, api);
    var parsedLabelPos;
    if (labelPosOpt == null || labelPosOpt === "auto") {
      parsedLabelPos = orient === "horizontal" ? viewRect2.y + viewRect2.height / 2 < api.getHeight() / 2 ? "-" : "+" : viewRect2.x + viewRect2.width / 2 < api.getWidth() / 2 ? "+" : "-";
    } else if (isString(labelPosOpt)) {
      parsedLabelPos = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[orient][labelPosOpt];
    } else {
      parsedLabelPos = labelPosOpt;
    }
    var labelAlignMap = {
      horizontal: "center",
      vertical: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "left" : "right"
    };
    var labelBaselineMap = {
      horizontal: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "top" : "bottom",
      vertical: "middle"
    };
    var rotationMap = {
      horizontal: 0,
      vertical: PI$2 / 2
    };
    var mainLength = orient === "vertical" ? viewRect2.height : viewRect2.width;
    var controlModel = timelineModel.getModel("controlStyle");
    var showControl = controlModel.get("show", true);
    var controlSize = showControl ? controlModel.get("itemSize") : 0;
    var controlGap = showControl ? controlModel.get("itemGap") : 0;
    var sizePlusGap = controlSize + controlGap;
    var labelRotation = timelineModel.get(["label", "rotate"]) || 0;
    labelRotation = labelRotation * PI$2 / 180;
    var playPosition;
    var prevBtnPosition;
    var nextBtnPosition;
    var controlPosition = controlModel.get("position", true);
    var showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
    var showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
    var showNextBtn = showControl && controlModel.get("showNextBtn", true);
    var xLeft = 0;
    var xRight = mainLength;
    if (controlPosition === "left" || controlPosition === "bottom") {
      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    } else {
      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    }
    var axisExtent = [xLeft, xRight];
    if (timelineModel.get("inverse")) {
      axisExtent.reverse();
    }
    return {
      viewRect: viewRect2,
      mainLength,
      orient,
      rotation: rotationMap[orient],
      labelRotation,
      labelPosOpt: parsedLabelPos,
      labelAlign: timelineModel.get(["label", "align"]) || labelAlignMap[orient],
      labelBaseline: timelineModel.get(["label", "verticalAlign"]) || timelineModel.get(["label", "baseline"]) || labelBaselineMap[orient],
      playPosition,
      prevBtnPosition,
      nextBtnPosition,
      axisExtent,
      controlSize,
      controlGap
    };
  };
  SliderTimelineView2.prototype._position = function(layoutInfo, timelineModel) {
    var mainGroup = this._mainGroup;
    var labelGroup = this._labelGroup;
    var viewRect2 = layoutInfo.viewRect;
    if (layoutInfo.orient === "vertical") {
      var m2 = create$2();
      var rotateOriginX = viewRect2.x;
      var rotateOriginY = viewRect2.y + viewRect2.height;
      translate(m2, m2, [-rotateOriginX, -rotateOriginY]);
      rotate(m2, m2, -PI$2 / 2);
      translate(m2, m2, [rotateOriginX, rotateOriginY]);
      viewRect2 = viewRect2.clone();
      viewRect2.applyTransform(m2);
    }
    var viewBound = getBound(viewRect2);
    var mainBound = getBound(mainGroup.getBoundingRect());
    var labelBound = getBound(labelGroup.getBoundingRect());
    var mainPosition = [mainGroup.x, mainGroup.y];
    var labelsPosition = [labelGroup.x, labelGroup.y];
    labelsPosition[0] = mainPosition[0] = viewBound[0][0];
    var labelPosOpt = layoutInfo.labelPosOpt;
    if (labelPosOpt == null || isString(labelPosOpt)) {
      var mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
    } else {
      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      labelsPosition[1] = mainPosition[1] + labelPosOpt;
    }
    mainGroup.setPosition(mainPosition);
    labelGroup.setPosition(labelsPosition);
    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
    setOrigin(mainGroup);
    setOrigin(labelGroup);
    function setOrigin(targetGroup) {
      targetGroup.originX = viewBound[0][0] - targetGroup.x;
      targetGroup.originY = viewBound[1][0] - targetGroup.y;
    }
    function getBound(rect) {
      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
    }
    function toBound(fromPos, from, to, dimIdx, boundIdx) {
      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
    }
  };
  SliderTimelineView2.prototype._createAxis = function(layoutInfo, timelineModel) {
    var data = timelineModel.getData();
    var axisType = timelineModel.get("axisType");
    var scale2 = createScaleByModel(timelineModel, axisType);
    scale2.getTicks = function() {
      return data.mapArray(["value"], function(value) {
        return {
          value
        };
      });
    };
    var dataExtent = data.getDataExtent("value");
    scale2.setExtent(dataExtent[0], dataExtent[1]);
    scale2.calcNiceTicks();
    var axis = new TimelineAxis$1("value", scale2, layoutInfo.axisExtent, axisType);
    axis.model = timelineModel;
    return axis;
  };
  SliderTimelineView2.prototype._createGroup = function(key) {
    var newGroup = this[key] = new Group$4();
    this.group.add(newGroup);
    return newGroup;
  };
  SliderTimelineView2.prototype._renderAxisLine = function(layoutInfo, group, axis, timelineModel) {
    var axisExtent = axis.getExtent();
    if (!timelineModel.get(["lineStyle", "show"])) {
      return;
    }
    var line = new Line$3({
      shape: {
        x1: axisExtent[0],
        y1: 0,
        x2: axisExtent[1],
        y2: 0
      },
      style: extend$1({
        lineCap: "round"
      }, timelineModel.getModel("lineStyle").getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(line);
    var progressLine = this._progressLine = new Line$3({
      shape: {
        x1: axisExtent[0],
        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
        y1: 0,
        y2: 0
      },
      style: defaults({
        lineCap: "round",
        lineWidth: line.style.lineWidth
      }, timelineModel.getModel(["progress", "lineStyle"]).getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(progressLine);
  };
  SliderTimelineView2.prototype._renderAxisTick = function(layoutInfo, group, axis, timelineModel) {
    var _this = this;
    var data = timelineModel.getData();
    var ticks = axis.scale.getTicks();
    this._tickSymbols = [];
    each$f(ticks, function(tick) {
      var tickCoord = axis.dataToCoord(tick.value);
      var itemModel = data.getItemModel(tick.value);
      var itemStyleModel = itemModel.getModel("itemStyle");
      var hoverStyleModel = itemModel.getModel(["emphasis", "itemStyle"]);
      var progressStyleModel = itemModel.getModel(["progress", "itemStyle"]);
      var symbolOpt = {
        x: tickCoord,
        y: 0,
        onclick: bind$1(_this._changeTimeline, _this, tick.value)
      };
      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
      el.ensureState("emphasis").style = hoverStyleModel.getItemStyle();
      el.ensureState("progress").style = progressStyleModel.getItemStyle();
      enableHoverEmphasis(el);
      var ecData = getECData(el);
      if (itemModel.get("tooltip")) {
        ecData.dataIndex = tick.value;
        ecData.dataModel = timelineModel;
      } else {
        ecData.dataIndex = ecData.dataModel = null;
      }
      _this._tickSymbols.push(el);
    });
  };
  SliderTimelineView2.prototype._renderAxisLabel = function(layoutInfo, group, axis, timelineModel) {
    var _this = this;
    var labelModel = axis.getLabelModel();
    if (!labelModel.get("show")) {
      return;
    }
    var data = timelineModel.getData();
    var labels = axis.getViewLabels();
    this._tickLabels = [];
    each$f(labels, function(labelItem) {
      var dataIndex = labelItem.tickValue;
      var itemModel = data.getItemModel(dataIndex);
      var normalLabelModel = itemModel.getModel("label");
      var hoverLabelModel = itemModel.getModel(["emphasis", "label"]);
      var progressLabelModel = itemModel.getModel(["progress", "label"]);
      var tickCoord = axis.dataToCoord(labelItem.tickValue);
      var textEl = new ZRText$1({
        x: tickCoord,
        y: 0,
        rotation: layoutInfo.labelRotation - layoutInfo.rotation,
        onclick: bind$1(_this._changeTimeline, _this, dataIndex),
        silent: false,
        style: createTextStyle$1(normalLabelModel, {
          text: labelItem.formattedLabel,
          align: layoutInfo.labelAlign,
          verticalAlign: layoutInfo.labelBaseline
        })
      });
      textEl.ensureState("emphasis").style = createTextStyle$1(hoverLabelModel);
      textEl.ensureState("progress").style = createTextStyle$1(progressLabelModel);
      group.add(textEl);
      enableHoverEmphasis(textEl);
      labelDataIndexStore(textEl).dataIndex = dataIndex;
      _this._tickLabels.push(textEl);
    });
  };
  SliderTimelineView2.prototype._renderControl = function(layoutInfo, group, axis, timelineModel) {
    var controlSize = layoutInfo.controlSize;
    var rotation = layoutInfo.rotation;
    var itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
    var hoverStyle = timelineModel.getModel(["emphasis", "controlStyle"]).getItemStyle();
    var playState = timelineModel.getPlayState();
    var inverse = timelineModel.get("inverse", true);
    makeBtn(layoutInfo.nextBtnPosition, "next", bind$1(this._changeTimeline, this, inverse ? "-" : "+"));
    makeBtn(layoutInfo.prevBtnPosition, "prev", bind$1(this._changeTimeline, this, inverse ? "+" : "-"));
    makeBtn(layoutInfo.playPosition, playState ? "stop" : "play", bind$1(this._handlePlayClick, this, !playState), true);
    function makeBtn(position2, iconName, onclick, willRotate) {
      if (!position2) {
        return;
      }
      var iconSize = parsePercent$2(retrieve2(timelineModel.get(["controlStyle", iconName + "BtnSize"]), controlSize), controlSize);
      var rect = [0, -iconSize / 2, iconSize, iconSize];
      var btn = makeControlIcon(timelineModel, iconName + "Icon", rect, {
        x: position2[0],
        y: position2[1],
        originX: controlSize / 2,
        originY: 0,
        rotation: willRotate ? -rotation : 0,
        rectHover: true,
        style: itemStyle,
        onclick
      });
      btn.ensureState("emphasis").style = hoverStyle;
      group.add(btn);
      enableHoverEmphasis(btn);
    }
  };
  SliderTimelineView2.prototype._renderCurrentPointer = function(layoutInfo, group, axis, timelineModel) {
    var data = timelineModel.getData();
    var currentIndex = timelineModel.getCurrentIndex();
    var pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
    var me = this;
    var callback = {
      onCreate: function(pointer) {
        pointer.draggable = true;
        pointer.drift = bind$1(me._handlePointerDrag, me);
        pointer.ondragend = bind$1(me._handlePointerDragend, me);
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);
      },
      onUpdate: function(pointer) {
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);
      }
    };
    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
  };
  SliderTimelineView2.prototype._handlePlayClick = function(nextState) {
    this._clearTimer();
    this.api.dispatchAction({
      type: "timelinePlayChange",
      playState: nextState,
      from: this.uid
    });
  };
  SliderTimelineView2.prototype._handlePointerDrag = function(dx, dy, e2) {
    this._clearTimer();
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY]);
  };
  SliderTimelineView2.prototype._handlePointerDragend = function(e2) {
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY], true);
  };
  SliderTimelineView2.prototype._pointerChangeTimeline = function(mousePos, trigger2) {
    var toCoord = this._toAxisCoord(mousePos)[0];
    var axis = this._axis;
    var axisExtent = asc$2(axis.getExtent().slice());
    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
    this._currentPointer.x = toCoord;
    this._currentPointer.markRedraw();
    this._progressLine.shape.x2 = toCoord;
    this._progressLine.dirty();
    var targetDataIndex = this._findNearestTick(toCoord);
    var timelineModel = this.model;
    if (trigger2 || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
      this._changeTimeline(targetDataIndex);
    }
  };
  SliderTimelineView2.prototype._doPlayStop = function() {
    var _this = this;
    this._clearTimer();
    if (this.model.getPlayState()) {
      this._timer = setTimeout(function() {
        var timelineModel = _this.model;
        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval"));
    }
  };
  SliderTimelineView2.prototype._toAxisCoord = function(vertex) {
    var trans = this._mainGroup.getLocalTransform();
    return applyTransform(vertex, trans, true);
  };
  SliderTimelineView2.prototype._findNearestTick = function(axisCoord) {
    var data = this.model.getData();
    var dist2 = Infinity;
    var targetDataIndex;
    var axis = this._axis;
    data.each(["value"], function(value, dataIndex) {
      var coord = axis.dataToCoord(value);
      var d = Math.abs(coord - axisCoord);
      if (d < dist2) {
        dist2 = d;
        targetDataIndex = dataIndex;
      }
    });
    return targetDataIndex;
  };
  SliderTimelineView2.prototype._clearTimer = function() {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  };
  SliderTimelineView2.prototype._changeTimeline = function(nextIndex) {
    var currentIndex = this.model.getCurrentIndex();
    if (nextIndex === "+") {
      nextIndex = currentIndex + 1;
    } else if (nextIndex === "-") {
      nextIndex = currentIndex - 1;
    }
    this.api.dispatchAction({
      type: "timelineChange",
      currentIndex: nextIndex,
      from: this.uid
    });
  };
  SliderTimelineView2.prototype._updateTicksStatus = function() {
    var currentIndex = this.model.getCurrentIndex();
    var tickSymbols = this._tickSymbols;
    var tickLabels = this._tickLabels;
    if (tickSymbols) {
      for (var i = 0; i < tickSymbols.length; i++) {
        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState("progress", i < currentIndex);
      }
    }
    if (tickLabels) {
      for (var i = 0; i < tickLabels.length; i++) {
        tickLabels && tickLabels[i] && tickLabels[i].toggleState("progress", labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);
      }
    }
  };
  SliderTimelineView2.type = "timeline.slider";
  return SliderTimelineView2;
}(TimelineView$1);
function createScaleByModel(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new OrdinalScale$1({
          ordinalMeta: model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new TimeScale$1({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new IntervalScale$1();
    }
  }
}
function getViewRect(model, api) {
  return getLayoutRect(model.getBoxLayoutParams(), {
    width: api.getWidth(),
    height: api.getHeight()
  }, model.get("padding"));
}
function makeControlIcon(timelineModel, objPath, rect, opts) {
  var style = opts.style;
  var icon = createIcon(timelineModel.get(["controlStyle", objPath]), opts || {}, new BoundingRect$1(rect[0], rect[1], rect[2], rect[3]));
  if (style) {
    icon.setStyle(style);
  }
  return icon;
}
function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
  var color = itemStyleModel.get("color");
  if (!symbol) {
    var symbolType = hostModel.get("symbol");
    symbol = createSymbol$1(symbolType, -1, -1, 2, 2, color);
    symbol.setStyle("strokeNoScale", true);
    group.add(symbol);
    callback && callback.onCreate(symbol);
  } else {
    symbol.setColor(color);
    group.add(symbol);
    callback && callback.onUpdate(symbol);
  }
  var itemStyle = itemStyleModel.getItemStyle(["color"]);
  symbol.setStyle(itemStyle);
  opt = merge({
    rectHover: true,
    z2: 100
  }, opt, true);
  var symbolSize = normalizeSymbolSize(hostModel.get("symbolSize"));
  opt.scaleX = symbolSize[0] / 2;
  opt.scaleY = symbolSize[1] / 2;
  var symbolOffset = normalizeSymbolOffset(hostModel.get("symbolOffset"), symbolSize);
  if (symbolOffset) {
    opt.x = (opt.x || 0) + symbolOffset[0];
    opt.y = (opt.y || 0) + symbolOffset[1];
  }
  var symbolRotate = hostModel.get("symbolRotate");
  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  symbol.attr(opt);
  symbol.updateTransform();
  return symbol;
}
function pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {
  if (pointer.dragging) {
    return;
  }
  var pointerModel = timelineModel.getModel("checkpointStyle");
  var toCoord = axis.dataToCoord(timelineModel.getData().get("value", dataIndex));
  if (noAnimation || !pointerModel.get("animation", true)) {
    pointer.attr({
      x: toCoord,
      y: 0
    });
    progressLine && progressLine.attr({
      shape: {
        x2: toCoord
      }
    });
  } else {
    var animationCfg = {
      duration: pointerModel.get("animationDuration", true),
      easing: pointerModel.get("animationEasing", true)
    };
    pointer.stopAnimation(null, true);
    pointer.animateTo({
      x: toCoord,
      y: 0
    }, animationCfg);
    progressLine && progressLine.animateTo({
      shape: {
        x2: toCoord
      }
    }, animationCfg);
  }
}
var SliderTimelineView$1 = SliderTimelineView;
function installTimelineAction(registers) {
  registers.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(payload, ecModel, api) {
    var timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.currentIndex != null) {
      timelineModel.setCurrentIndex(payload.currentIndex);
      if (!timelineModel.get("loop", true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {
        timelineModel.setPlayState(false);
        api.dispatchAction({
          type: "timelinePlayChange",
          playState: false,
          from: payload.from
        });
      }
    }
    ecModel.resetOption("timeline", {
      replaceMerge: timelineModel.get("replaceMerge", true)
    });
    return defaults({
      currentIndex: timelineModel.option.currentIndex
    }, payload);
  });
  registers.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(payload, ecModel) {
    var timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.playState != null) {
      timelineModel.setPlayState(payload.playState);
    }
  });
}
function timelinePreprocessor(option) {
  var timelineOpt = option && option.timeline;
  if (!isArray$1(timelineOpt)) {
    timelineOpt = timelineOpt ? [timelineOpt] : [];
  }
  each$f(timelineOpt, function(opt) {
    if (!opt) {
      return;
    }
    compatibleEC2(opt);
  });
}
function compatibleEC2(opt) {
  var type = opt.type;
  var ec2Types = {
    "number": "value",
    "time": "time"
  };
  if (ec2Types[type]) {
    opt.axisType = ec2Types[type];
    delete opt.type;
  }
  transferItem(opt);
  if (has$1(opt, "controlPosition")) {
    var controlStyle = opt.controlStyle || (opt.controlStyle = {});
    if (!has$1(controlStyle, "position")) {
      controlStyle.position = opt.controlPosition;
    }
    if (controlStyle.position === "none" && !has$1(controlStyle, "show")) {
      controlStyle.show = false;
      delete controlStyle.position;
    }
    delete opt.controlPosition;
  }
  each$f(opt.data || [], function(dataItem) {
    if (isObject$3(dataItem) && !isArray$1(dataItem)) {
      if (!has$1(dataItem, "value") && has$1(dataItem, "name")) {
        dataItem.value = dataItem.name;
      }
      transferItem(dataItem);
    }
  });
}
function transferItem(opt) {
  var itemStyle = opt.itemStyle || (opt.itemStyle = {});
  var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
  var label = opt.label || opt.label || {};
  var labelNormal = label.normal || (label.normal = {});
  var excludeLabelAttr = {
    normal: 1,
    emphasis: 1
  };
  each$f(label, function(value, name) {
    if (!excludeLabelAttr[name] && !has$1(labelNormal, name)) {
      labelNormal[name] = value;
    }
  });
  if (itemStyleEmphasis.label && !has$1(label, "emphasis")) {
    label.emphasis = itemStyleEmphasis.label;
    delete itemStyleEmphasis.label;
  }
}
function has$1(obj, attr) {
  return obj.hasOwnProperty(attr);
}
function install$v(registers) {
  registers.registerComponentModel(SliderTimelineModel$1);
  registers.registerComponentView(SliderTimelineView$1);
  registers.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  });
  installTimelineAction(registers);
  registers.registerPreprocessor(timelinePreprocessor);
}
function checkMarkerInSeries(seriesOpts, markerType) {
  if (!seriesOpts) {
    return false;
  }
  var seriesOptArr = isArray$1(seriesOpts) ? seriesOpts : [seriesOpts];
  for (var idx = 0; idx < seriesOptArr.length; idx++) {
    if (seriesOptArr[idx] && seriesOptArr[idx][markerType]) {
      return true;
    }
  }
  return false;
}
function fillLabel(opt) {
  defaultEmphasis(opt, "label", ["show"]);
}
var inner$5 = makeInner();
var MarkerModel = function(_super) {
  __extends(MarkerModel2, _super);
  function MarkerModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkerModel2.type;
    _this.createdBySelf = false;
    return _this;
  }
  MarkerModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    this._mergeOption(option, ecModel, false, true);
  };
  MarkerModel2.prototype.isAnimationEnabled = function() {
    if (env$1.node) {
      return false;
    }
    var hostSeries = this.__hostSeries;
    return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
  };
  MarkerModel2.prototype.mergeOption = function(newOpt, ecModel) {
    this._mergeOption(newOpt, ecModel, false, false);
  };
  MarkerModel2.prototype._mergeOption = function(newOpt, ecModel, createdBySelf, isInit) {
    var componentType = this.mainType;
    if (!createdBySelf) {
      ecModel.eachSeries(function(seriesModel) {
        var markerOpt = seriesModel.get(this.mainType, true);
        var markerModel = inner$5(seriesModel)[componentType];
        if (!markerOpt || !markerOpt.data) {
          inner$5(seriesModel)[componentType] = null;
          return;
        }
        if (!markerModel) {
          if (isInit) {
            fillLabel(markerOpt);
          }
          each$f(markerOpt.data, function(item) {
            if (item instanceof Array) {
              fillLabel(item[0]);
              fillLabel(item[1]);
            } else {
              fillLabel(item);
            }
          });
          markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);
          extend$1(markerModel, {
            mainType: this.mainType,
            seriesIndex: seriesModel.seriesIndex,
            name: seriesModel.name,
            createdBySelf: true
          });
          markerModel.__hostSeries = seriesModel;
        } else {
          markerModel._mergeOption(markerOpt, ecModel, true);
        }
        inner$5(seriesModel)[componentType] = markerModel;
      }, this);
    }
  };
  MarkerModel2.prototype.formatTooltip = function(dataIndex, multipleSeries, dataType) {
    var data = this.getData();
    var value = this.getRawValue(dataIndex);
    var itemName = data.getName(dataIndex);
    return createTooltipMarkup("section", {
      header: this.name,
      blocks: [createTooltipMarkup("nameValue", {
        name: itemName,
        value,
        noName: !itemName,
        noValue: value == null
      })]
    });
  };
  MarkerModel2.prototype.getData = function() {
    return this._data;
  };
  MarkerModel2.prototype.setData = function(data) {
    this._data = data;
  };
  MarkerModel2.getMarkerModelFromSeries = function(seriesModel, componentType) {
    return inner$5(seriesModel)[componentType];
  };
  MarkerModel2.type = "marker";
  MarkerModel2.dependencies = ["series", "grid", "polar", "geo"];
  return MarkerModel2;
}(ComponentModel$1);
mixin(MarkerModel, DataFormatMixin.prototype);
var MarkerModel$1 = MarkerModel;
var MarkPointModel = function(_super) {
  __extends(MarkPointModel2, _super);
  function MarkPointModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkPointModel2.type;
    return _this;
  }
  MarkPointModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
    return new MarkPointModel2(markerOpt, masterMarkerModel, ecModel);
  };
  MarkPointModel2.type = "markPoint";
  MarkPointModel2.defaultOption = {
    z: 5,
    symbol: "pin",
    symbolSize: 50,
    tooltip: {
      trigger: "item"
    },
    label: {
      show: true,
      position: "inside"
    },
    itemStyle: {
      borderWidth: 2
    },
    emphasis: {
      label: {
        show: true
      }
    }
  };
  return MarkPointModel2;
}(MarkerModel$1);
var MarkPointModel$1 = MarkPointModel;
function hasXOrY(item) {
  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}
function hasXAndY(item) {
  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
}
function markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
  var coordArr = [];
  var stacked = isDimensionStacked$2(data, targetDataDim);
  var calcDataDim = stacked ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
  var value = numCalculate(data, calcDataDim, markerType);
  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
  var coordArrValue = data.get(targetDataDim, dataIndex);
  var precision = getPrecision(data.get(targetDataDim, dataIndex));
  precision = Math.min(precision, 20);
  if (precision >= 0) {
    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
  }
  return [coordArr, coordArrValue];
}
var markerTypeCalculator = {
  min: curry$1(markerTypeCalculatorWithExtent, "min"),
  max: curry$1(markerTypeCalculatorWithExtent, "max"),
  average: curry$1(markerTypeCalculatorWithExtent, "average"),
  median: curry$1(markerTypeCalculatorWithExtent, "median")
};
function dataTransform(seriesModel, item) {
  var data = seriesModel.getData();
  var coordSys = seriesModel.coordinateSystem;
  if (item && !hasXAndY(item) && !isArray$1(item.coord) && coordSys) {
    var dims = coordSys.dimensions;
    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
    item = clone$4(item);
    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
      var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
      var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
      item.coord = coordInfo[0];
      item.value = coordInfo[1];
    } else {
      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
      for (var i = 0; i < 2; i++) {
        if (markerTypeCalculator[coord[i]]) {
          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
        }
      }
      item.coord = coord;
    }
  }
  return item;
}
function getAxisInfo(item, data, coordSys, seriesModel) {
  var ret2 = {};
  if (item.valueIndex != null || item.valueDim != null) {
    ret2.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
    ret2.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret2.valueDataDim));
    ret2.baseAxis = coordSys.getOtherAxis(ret2.valueAxis);
    ret2.baseDataDim = data.mapDimension(ret2.baseAxis.dim);
  } else {
    ret2.baseAxis = seriesModel.getBaseAxis();
    ret2.valueAxis = coordSys.getOtherAxis(ret2.baseAxis);
    ret2.baseDataDim = data.mapDimension(ret2.baseAxis.dim);
    ret2.valueDataDim = data.mapDimension(ret2.valueAxis.dim);
  }
  return ret2;
}
function dataDimToCoordDim(seriesModel, dataDim) {
  var dimItem = seriesModel.getData().getDimensionInfo(dataDim);
  return dimItem && dimItem.coordDim;
}
function dataFilter(coordSys, item) {
  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}
function createMarkerDimValueGetter(inCoordSys, dims) {
  return inCoordSys ? function(item, dimName, dataIndex, dimIndex) {
    var rawVal = dimIndex < 2 ? item.coord && item.coord[dimIndex] : item.value;
    return parseDataValue(rawVal, dims[dimIndex]);
  } : function(item, dimName, dataIndex, dimIndex) {
    return parseDataValue(item.value, dims[dimIndex]);
  };
}
function numCalculate(data, valueDataDim, type) {
  if (type === "average") {
    var sum_1 = 0;
    var count_1 = 0;
    data.each(valueDataDim, function(val, idx) {
      if (!isNaN(val)) {
        sum_1 += val;
        count_1++;
      }
    });
    return sum_1 / count_1;
  } else if (type === "median") {
    return data.getMedian(valueDataDim);
  } else {
    return data.getDataExtent(valueDataDim)[type === "max" ? 1 : 0];
  }
}
var inner$4 = makeInner();
var MarkerView = function(_super) {
  __extends(MarkerView2, _super);
  function MarkerView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkerView2.type;
    return _this;
  }
  MarkerView2.prototype.init = function() {
    this.markerGroupMap = createHashMap();
  };
  MarkerView2.prototype.render = function(markerModel, ecModel, api) {
    var _this = this;
    var markerGroupMap = this.markerGroupMap;
    markerGroupMap.each(function(item) {
      inner$4(item).keep = false;
    });
    ecModel.eachSeries(function(seriesModel) {
      var markerModel2 = MarkerModel$1.getMarkerModelFromSeries(seriesModel, _this.type);
      markerModel2 && _this.renderSeries(seriesModel, markerModel2, ecModel, api);
    });
    markerGroupMap.each(function(item) {
      !inner$4(item).keep && _this.group.remove(item.group);
    });
  };
  MarkerView2.prototype.markKeep = function(drawGroup) {
    inner$4(drawGroup).keep = true;
  };
  MarkerView2.prototype.blurSeries = function(seriesModelList) {
    var _this = this;
    each$f(seriesModelList, function(seriesModel) {
      var markerModel = MarkerModel$1.getMarkerModelFromSeries(seriesModel, _this.type);
      if (markerModel) {
        var data = markerModel.getData();
        data.eachItemGraphicEl(function(el) {
          if (el) {
            enterBlur(el);
          }
        });
      }
    });
  };
  MarkerView2.type = "marker";
  return MarkerView2;
}(ComponentView$1);
var MarkerView$1 = MarkerView;
function updateMarkerLayout(mpData, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  mpData.each(function(idx) {
    var itemModel = mpData.getItemModel(idx);
    var point;
    var xPx = parsePercent$1(itemModel.get("x"), api.getWidth());
    var yPx = parsePercent$1(itemModel.get("y"), api.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else if (seriesModel.getMarkerPosition) {
      point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
    } else if (coordSys) {
      var x = mpData.get(coordSys.dimensions[0], idx);
      var y = mpData.get(coordSys.dimensions[1], idx);
      point = coordSys.dataToPoint([x, y]);
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
    mpData.setItemLayout(idx, point);
  });
}
var MarkPointView = function(_super) {
  __extends(MarkPointView2, _super);
  function MarkPointView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkPointView2.type;
    return _this;
  }
  MarkPointView2.prototype.updateTransform = function(markPointModel, ecModel, api) {
    ecModel.eachSeries(function(seriesModel) {
      var mpModel = MarkerModel$1.getMarkerModelFromSeries(seriesModel, "markPoint");
      if (mpModel) {
        updateMarkerLayout(mpModel.getData(), seriesModel, api);
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  };
  MarkPointView2.prototype.renderSeries = function(seriesModel, mpModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var symbolDrawMap = this.markerGroupMap;
    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw$1());
    var mpData = createData(coordSys, seriesModel, mpModel);
    mpModel.setData(mpData);
    updateMarkerLayout(mpModel.getData(), seriesModel, api);
    mpData.each(function(idx) {
      var itemModel = mpData.getItemModel(idx);
      var symbol = itemModel.getShallow("symbol");
      var symbolSize = itemModel.getShallow("symbolSize");
      var symbolRotate = itemModel.getShallow("symbolRotate");
      var symbolOffset = itemModel.getShallow("symbolOffset");
      var symbolKeepAspect = itemModel.getShallow("symbolKeepAspect");
      if (isFunction$1(symbol) || isFunction$1(symbolSize) || isFunction$1(symbolRotate) || isFunction$1(symbolOffset)) {
        var rawIdx = mpModel.getRawValue(idx);
        var dataParams = mpModel.getDataParams(idx);
        if (isFunction$1(symbol)) {
          symbol = symbol(rawIdx, dataParams);
        }
        if (isFunction$1(symbolSize)) {
          symbolSize = symbolSize(rawIdx, dataParams);
        }
        if (isFunction$1(symbolRotate)) {
          symbolRotate = symbolRotate(rawIdx, dataParams);
        }
        if (isFunction$1(symbolOffset)) {
          symbolOffset = symbolOffset(rawIdx, dataParams);
        }
      }
      var style = itemModel.getModel("itemStyle").getItemStyle();
      var color = getVisualFromData(seriesData, "color");
      if (!style.fill) {
        style.fill = color;
      }
      mpData.setItemVisual(idx, {
        symbol,
        symbolSize,
        symbolRotate,
        symbolOffset,
        symbolKeepAspect,
        style
      });
    });
    symbolDraw.updateData(mpData);
    this.group.add(symbolDraw.group);
    mpData.eachItemGraphicEl(function(el) {
      el.traverse(function(child) {
        getECData(child).dataModel = mpModel;
      });
    });
    this.markKeep(symbolDraw);
    symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
  };
  MarkPointView2.type = "markPoint";
  return MarkPointView2;
}(MarkerView$1);
function createData(coordSys, seriesModel, mpModel) {
  var coordDimsInfos;
  if (coordSys) {
    coordDimsInfos = map$1(coordSys && coordSys.dimensions, function(coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
      return extend$1(extend$1({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
  } else {
    coordDimsInfos = [{
      name: "value",
      type: "float"
    }];
  }
  var mpData = new SeriesData$1(coordDimsInfos, mpModel);
  var dataOpt = map$1(mpModel.get("data"), curry$1(dataTransform, seriesModel));
  if (coordSys) {
    dataOpt = filter(dataOpt, curry$1(dataFilter, coordSys));
  }
  var dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
  mpData.initData(dataOpt, null, dimValueGetter);
  return mpData;
}
var MarkPointView$1 = MarkPointView;
function install$u(registers) {
  registers.registerComponentModel(MarkPointModel$1);
  registers.registerComponentView(MarkPointView$1);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markPoint")) {
      opt.markPoint = opt.markPoint || {};
    }
  });
}
var MarkLineModel = function(_super) {
  __extends(MarkLineModel2, _super);
  function MarkLineModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkLineModel2.type;
    return _this;
  }
  MarkLineModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
    return new MarkLineModel2(markerOpt, masterMarkerModel, ecModel);
  };
  MarkLineModel2.type = "markLine";
  MarkLineModel2.defaultOption = {
    z: 5,
    symbol: ["circle", "arrow"],
    symbolSize: [8, 16],
    symbolOffset: 0,
    precision: 2,
    tooltip: {
      trigger: "item"
    },
    label: {
      show: true,
      position: "end",
      distance: 5
    },
    lineStyle: {
      type: "dashed"
    },
    emphasis: {
      label: {
        show: true
      },
      lineStyle: {
        width: 3
      }
    },
    animationEasing: "linear"
  };
  return MarkLineModel2;
}(MarkerModel$1);
var MarkLineModel$1 = MarkLineModel;
var inner$3 = makeInner();
var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
  var data = seriesModel.getData();
  var itemArray;
  if (!isArray$1(item)) {
    var mlType = item.type;
    if (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || item.xAxis != null || item.yAxis != null) {
      var valueAxis2 = void 0;
      var value = void 0;
      if (item.yAxis != null || item.xAxis != null) {
        valueAxis2 = coordSys.getAxis(item.yAxis != null ? "y" : "x");
        value = retrieve$2(item.yAxis, item.xAxis);
      } else {
        var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
        valueAxis2 = axisInfo.valueAxis;
        var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
        value = numCalculate(data, valueDataDim, mlType);
      }
      var valueIndex = valueAxis2.dim === "x" ? 0 : 1;
      var baseIndex = 1 - valueIndex;
      var mlFrom = clone$4(item);
      var mlTo = {
        coord: []
      };
      mlFrom.type = null;
      mlFrom.coord = [];
      mlFrom.coord[baseIndex] = -Infinity;
      mlTo.coord[baseIndex] = Infinity;
      var precision = mlModel.get("precision");
      if (precision >= 0 && isNumber(value)) {
        value = +value.toFixed(Math.min(precision, 20));
      }
      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
      itemArray = [mlFrom, mlTo, {
        type: mlType,
        valueIndex: item.valueIndex,
        value
      }];
    } else {
      itemArray = [];
    }
  } else {
    itemArray = item;
  }
  var normalizedItem = [dataTransform(seriesModel, itemArray[0]), dataTransform(seriesModel, itemArray[1]), extend$1({}, itemArray[2])];
  normalizedItem[2].type = normalizedItem[2].type || null;
  merge(normalizedItem[2], normalizedItem[0]);
  merge(normalizedItem[2], normalizedItem[1]);
  return normalizedItem;
};
function isInifinity$1(val) {
  return !isNaN(val) && !isFinite(val);
}
function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  var dimName = coordSys.dimensions[dimIndex];
  return isInifinity$1(fromCoord[otherDimIndex]) && isInifinity$1(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}
function markLineFilter(coordSys, item) {
  if (coordSys.type === "cartesian2d") {
    var fromCoord = item[0].coord;
    var toCoord = item[1].coord;
    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }
  return dataFilter(coordSys, item[0]) && dataFilter(coordSys, item[1]);
}
function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point;
  var xPx = parsePercent$1(itemModel.get("x"), api.getWidth());
  var yPx = parsePercent$1(itemModel.get("y"), api.getHeight());
  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    if (seriesModel.getMarkerPosition) {
      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
    } else {
      var dims = coordSys.dimensions;
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      point = coordSys.dataToPoint([x, y]);
    }
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      var xAxis = coordSys.getAxis("x");
      var yAxis = coordSys.getAxis("y");
      var dims = coordSys.dimensions;
      if (isInifinity$1(data.get(dims[0], idx))) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
      } else if (isInifinity$1(data.get(dims[1], idx))) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
      }
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }
  data.setItemLayout(idx, point);
}
var MarkLineView = function(_super) {
  __extends(MarkLineView2, _super);
  function MarkLineView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkLineView2.type;
    return _this;
  }
  MarkLineView2.prototype.updateTransform = function(markLineModel, ecModel, api) {
    ecModel.eachSeries(function(seriesModel) {
      var mlModel = MarkerModel$1.getMarkerModelFromSeries(seriesModel, "markLine");
      if (mlModel) {
        var mlData_1 = mlModel.getData();
        var fromData_1 = inner$3(mlModel).from;
        var toData_1 = inner$3(mlModel).to;
        fromData_1.each(function(idx) {
          updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);
          updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);
        });
        mlData_1.each(function(idx) {
          mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);
        });
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  };
  MarkLineView2.prototype.renderSeries = function(seriesModel, mlModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var lineDrawMap = this.markerGroupMap;
    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw$1());
    this.group.add(lineDraw.group);
    var mlData = createList$2(coordSys, seriesModel, mlModel);
    var fromData = mlData.from;
    var toData = mlData.to;
    var lineData = mlData.line;
    inner$3(mlModel).from = fromData;
    inner$3(mlModel).to = toData;
    mlModel.setData(lineData);
    var symbolType = mlModel.get("symbol");
    var symbolSize = mlModel.get("symbolSize");
    var symbolRotate = mlModel.get("symbolRotate");
    var symbolOffset = mlModel.get("symbolOffset");
    if (!isArray$1(symbolType)) {
      symbolType = [symbolType, symbolType];
    }
    if (!isArray$1(symbolSize)) {
      symbolSize = [symbolSize, symbolSize];
    }
    if (!isArray$1(symbolRotate)) {
      symbolRotate = [symbolRotate, symbolRotate];
    }
    if (!isArray$1(symbolOffset)) {
      symbolOffset = [symbolOffset, symbolOffset];
    }
    mlData.from.each(function(idx) {
      updateDataVisualAndLayout(fromData, idx, true);
      updateDataVisualAndLayout(toData, idx, false);
    });
    lineData.each(function(idx) {
      var lineStyle = lineData.getItemModel(idx).getModel("lineStyle").getLineStyle();
      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
      if (lineStyle.stroke == null) {
        lineStyle.stroke = fromData.getItemVisual(idx, "style").fill;
      }
      lineData.setItemVisual(idx, {
        fromSymbolKeepAspect: fromData.getItemVisual(idx, "symbolKeepAspect"),
        fromSymbolOffset: fromData.getItemVisual(idx, "symbolOffset"),
        fromSymbolRotate: fromData.getItemVisual(idx, "symbolRotate"),
        fromSymbolSize: fromData.getItemVisual(idx, "symbolSize"),
        fromSymbol: fromData.getItemVisual(idx, "symbol"),
        toSymbolKeepAspect: toData.getItemVisual(idx, "symbolKeepAspect"),
        toSymbolOffset: toData.getItemVisual(idx, "symbolOffset"),
        toSymbolRotate: toData.getItemVisual(idx, "symbolRotate"),
        toSymbolSize: toData.getItemVisual(idx, "symbolSize"),
        toSymbol: toData.getItemVisual(idx, "symbol"),
        style: lineStyle
      });
    });
    lineDraw.updateData(lineData);
    mlData.line.eachItemGraphicEl(function(el, idx) {
      el.traverse(function(child) {
        getECData(child).dataModel = mlModel;
      });
    });
    function updateDataVisualAndLayout(data, idx, isFrom) {
      var itemModel = data.getItemModel(idx);
      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
      var style = itemModel.getModel("itemStyle").getItemStyle();
      if (style.fill == null) {
        style.fill = getVisualFromData(seriesData, "color");
      }
      data.setItemVisual(idx, {
        symbolKeepAspect: itemModel.get("symbolKeepAspect"),
        symbolOffset: retrieve2(itemModel.get("symbolOffset", true), symbolOffset[isFrom ? 0 : 1]),
        symbolRotate: retrieve2(itemModel.get("symbolRotate", true), symbolRotate[isFrom ? 0 : 1]),
        symbolSize: retrieve2(itemModel.get("symbolSize"), symbolSize[isFrom ? 0 : 1]),
        symbol: retrieve2(itemModel.get("symbol", true), symbolType[isFrom ? 0 : 1]),
        style
      });
    }
    this.markKeep(lineDraw);
    lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
  };
  MarkLineView2.type = "markLine";
  return MarkLineView2;
}(MarkerView$1);
function createList$2(coordSys, seriesModel, mlModel) {
  var coordDimsInfos;
  if (coordSys) {
    coordDimsInfos = map$1(coordSys && coordSys.dimensions, function(coordDim) {
      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
      return extend$1(extend$1({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
  } else {
    coordDimsInfos = [{
      name: "value",
      type: "float"
    }];
  }
  var fromData = new SeriesData$1(coordDimsInfos, mlModel);
  var toData = new SeriesData$1(coordDimsInfos, mlModel);
  var lineData = new SeriesData$1([], mlModel);
  var optData = map$1(mlModel.get("data"), curry$1(markLineTransform, seriesModel, coordSys, mlModel));
  if (coordSys) {
    optData = filter(optData, curry$1(markLineFilter, coordSys));
  }
  var dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
  fromData.initData(map$1(optData, function(item) {
    return item[0];
  }), null, dimValueGetter);
  toData.initData(map$1(optData, function(item) {
    return item[1];
  }), null, dimValueGetter);
  lineData.initData(map$1(optData, function(item) {
    return item[2];
  }));
  lineData.hasItemOption = true;
  return {
    from: fromData,
    to: toData,
    line: lineData
  };
}
var MarkLineView$1 = MarkLineView;
function install$t(registers) {
  registers.registerComponentModel(MarkLineModel$1);
  registers.registerComponentView(MarkLineView$1);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markLine")) {
      opt.markLine = opt.markLine || {};
    }
  });
}
var MarkAreaModel = function(_super) {
  __extends(MarkAreaModel2, _super);
  function MarkAreaModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkAreaModel2.type;
    return _this;
  }
  MarkAreaModel2.prototype.createMarkerModelFromSeries = function(markerOpt, masterMarkerModel, ecModel) {
    return new MarkAreaModel2(markerOpt, masterMarkerModel, ecModel);
  };
  MarkAreaModel2.type = "markArea";
  MarkAreaModel2.defaultOption = {
    z: 1,
    tooltip: {
      trigger: "item"
    },
    animation: false,
    label: {
      show: true,
      position: "top"
    },
    itemStyle: {
      borderWidth: 0
    },
    emphasis: {
      label: {
        show: true,
        position: "top"
      }
    }
  };
  return MarkAreaModel2;
}(MarkerModel$1);
var MarkAreaModel$1 = MarkAreaModel;
var inner$2 = makeInner();
var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
  var lt2 = dataTransform(seriesModel, item[0]);
  var rb2 = dataTransform(seriesModel, item[1]);
  var ltCoord = lt2.coord;
  var rbCoord = rb2.coord;
  ltCoord[0] = retrieve$2(ltCoord[0], -Infinity);
  ltCoord[1] = retrieve$2(ltCoord[1], -Infinity);
  rbCoord[0] = retrieve$2(rbCoord[0], Infinity);
  rbCoord[1] = retrieve$2(rbCoord[1], Infinity);
  var result = mergeAll([{}, lt2, rb2]);
  result.coord = [lt2.coord, rb2.coord];
  result.x0 = lt2.x;
  result.y0 = lt2.y;
  result.x1 = rb2.x;
  result.y1 = rb2.y;
  return result;
};
function isInifinity(val) {
  return !isNaN(val) && !isFinite(val);
}
function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  var otherDimIndex = 1 - dimIndex;
  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
}
function markAreaFilter(coordSys, item) {
  var fromCoord = item.coord[0];
  var toCoord = item.coord[1];
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord))) {
      return true;
    }
  }
  return dataFilter(coordSys, {
    coord: fromCoord,
    x: item.x0,
    y: item.y0
  }) || dataFilter(coordSys, {
    coord: toCoord,
    x: item.x1,
    y: item.y1
  });
}
function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
  var coordSys = seriesModel.coordinateSystem;
  var itemModel = data.getItemModel(idx);
  var point;
  var xPx = parsePercent$1(itemModel.get(dims[0]), api.getWidth());
  var yPx = parsePercent$1(itemModel.get(dims[1]), api.getHeight());
  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    if (seriesModel.getMarkerPosition) {
      point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
    } else {
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      var pt = [x, y];
      coordSys.clampData && coordSys.clampData(pt, pt);
      point = coordSys.dataToPoint(pt, true);
    }
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      var xAxis = coordSys.getAxis("x");
      var yAxis = coordSys.getAxis("y");
      var x = data.get(dims[0], idx);
      var y = data.get(dims[1], idx);
      if (isInifinity(x)) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
      } else if (isInifinity(y)) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
      }
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }
  return point;
}
var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
var MarkAreaView = function(_super) {
  __extends(MarkAreaView2, _super);
  function MarkAreaView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = MarkAreaView2.type;
    return _this;
  }
  MarkAreaView2.prototype.updateTransform = function(markAreaModel, ecModel, api) {
    ecModel.eachSeries(function(seriesModel) {
      var maModel = MarkerModel$1.getMarkerModelFromSeries(seriesModel, "markArea");
      if (maModel) {
        var areaData_1 = maModel.getData();
        areaData_1.each(function(idx) {
          var points2 = map$1(dimPermutations, function(dim) {
            return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);
          });
          areaData_1.setItemLayout(idx, points2);
          var el = areaData_1.getItemGraphicEl(idx);
          el.setShape("points", points2);
        });
      }
    }, this);
  };
  MarkAreaView2.prototype.renderSeries = function(seriesModel, maModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var seriesId = seriesModel.id;
    var seriesData = seriesModel.getData();
    var areaGroupMap = this.markerGroupMap;
    var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
      group: new Group$4()
    });
    this.group.add(polygonGroup.group);
    this.markKeep(polygonGroup);
    var areaData = createList$1(coordSys, seriesModel, maModel);
    maModel.setData(areaData);
    areaData.each(function(idx) {
      var points2 = map$1(dimPermutations, function(dim) {
        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
      });
      var xAxisScale = coordSys.getAxis("x").scale;
      var yAxisScale = coordSys.getAxis("y").scale;
      var xAxisExtent = xAxisScale.getExtent();
      var yAxisExtent = yAxisScale.getExtent();
      var xPointExtent = [xAxisScale.parse(areaData.get("x0", idx)), xAxisScale.parse(areaData.get("x1", idx))];
      var yPointExtent = [yAxisScale.parse(areaData.get("y0", idx)), yAxisScale.parse(areaData.get("y1", idx))];
      asc$2(xPointExtent);
      asc$2(yPointExtent);
      var overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]);
      var allClipped = !overlapped;
      areaData.setItemLayout(idx, {
        points: points2,
        allClipped
      });
      var style = areaData.getItemModel(idx).getModel("itemStyle").getItemStyle();
      var color = getVisualFromData(seriesData, "color");
      if (!style.fill) {
        style.fill = color;
        if (isString(style.fill)) {
          style.fill = modifyAlpha(style.fill, 0.4);
        }
      }
      if (!style.stroke) {
        style.stroke = color;
      }
      areaData.setItemVisual(idx, "style", style);
    });
    areaData.diff(inner$2(polygonGroup).data).add(function(idx) {
      var layout2 = areaData.getItemLayout(idx);
      if (!layout2.allClipped) {
        var polygon = new Polygon$1({
          shape: {
            points: layout2.points
          }
        });
        areaData.setItemGraphicEl(idx, polygon);
        polygonGroup.group.add(polygon);
      }
    }).update(function(newIdx, oldIdx) {
      var polygon = inner$2(polygonGroup).data.getItemGraphicEl(oldIdx);
      var layout2 = areaData.getItemLayout(newIdx);
      if (!layout2.allClipped) {
        if (polygon) {
          updateProps$1(polygon, {
            shape: {
              points: layout2.points
            }
          }, maModel, newIdx);
        } else {
          polygon = new Polygon$1({
            shape: {
              points: layout2.points
            }
          });
        }
        areaData.setItemGraphicEl(newIdx, polygon);
        polygonGroup.group.add(polygon);
      } else if (polygon) {
        polygonGroup.group.remove(polygon);
      }
    }).remove(function(idx) {
      var polygon = inner$2(polygonGroup).data.getItemGraphicEl(idx);
      polygonGroup.group.remove(polygon);
    }).execute();
    areaData.eachItemGraphicEl(function(polygon, idx) {
      var itemModel = areaData.getItemModel(idx);
      var style = areaData.getItemVisual(idx, "style");
      polygon.useStyle(areaData.getItemVisual(idx, "style"));
      setLabelStyle(polygon, getLabelStatesModels(itemModel), {
        labelFetcher: maModel,
        labelDataIndex: idx,
        defaultText: areaData.getName(idx) || "",
        inheritColor: isString(style.fill) ? modifyAlpha(style.fill, 1) : "#000"
      });
      setStatesStylesFromModel(polygon, itemModel);
      toggleHoverEmphasis(polygon, null, null, itemModel.get(["emphasis", "disabled"]));
      getECData(polygon).dataModel = maModel;
    });
    inner$2(polygonGroup).data = areaData;
    polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
  };
  MarkAreaView2.type = "markArea";
  return MarkAreaView2;
}(MarkerView$1);
function createList$1(coordSys, seriesModel, maModel) {
  var areaData;
  var dataDims;
  var dims = ["x0", "y0", "x1", "y1"];
  if (coordSys) {
    var coordDimsInfos_1 = map$1(coordSys && coordSys.dimensions, function(coordDim) {
      var data = seriesModel.getData();
      var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
      return extend$1(extend$1({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
    dataDims = map$1(dims, function(dim, idx) {
      return {
        name: dim,
        type: coordDimsInfos_1[idx % 2].type
      };
    });
    areaData = new SeriesData$1(dataDims, maModel);
  } else {
    dataDims = [{
      name: "value",
      type: "float"
    }];
    areaData = new SeriesData$1(dataDims, maModel);
  }
  var optData = map$1(maModel.get("data"), curry$1(markAreaTransform, seriesModel, coordSys, maModel));
  if (coordSys) {
    optData = filter(optData, curry$1(markAreaFilter, coordSys));
  }
  var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
    var rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
    return parseDataValue(rawVal, dataDims[dimIndex]);
  } : function(item, dimName, dataIndex, dimIndex) {
    return parseDataValue(item.value, dataDims[dimIndex]);
  };
  areaData.initData(optData, null, dimValueGetter);
  areaData.hasItemOption = true;
  return areaData;
}
var MarkAreaView$1 = MarkAreaView;
function install$s(registers) {
  registers.registerComponentModel(MarkAreaModel$1);
  registers.registerComponentView(MarkAreaView$1);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markArea")) {
      opt.markArea = opt.markArea || {};
    }
  });
}
var getDefaultSelectorOptions = function(ecModel, type) {
  if (type === "all") {
    return {
      type: "all",
      title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
    };
  } else if (type === "inverse") {
    return {
      type: "inverse",
      title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
    };
  }
};
var LegendModel = function(_super) {
  __extends(LegendModel2, _super);
  function LegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendModel2.type;
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    return _this;
  }
  LegendModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
    this._updateSelector(option);
  };
  LegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    this._updateSelector(option);
  };
  LegendModel2.prototype._updateSelector = function(option) {
    var selector2 = option.selector;
    var ecModel = this.ecModel;
    if (selector2 === true) {
      selector2 = option.selector = ["all", "inverse"];
    }
    if (isArray$1(selector2)) {
      each$f(selector2, function(item, index) {
        isString(item) && (item = {
          type: item
        });
        selector2[index] = merge(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  };
  LegendModel2.prototype.optionUpdated = function() {
    this._updateData(this.ecModel);
    var legendData = this._data;
    if (legendData[0] && this.get("selectedMode") === "single") {
      var hasSelected = false;
      for (var i = 0; i < legendData.length; i++) {
        var name_1 = legendData[i].get("name");
        if (this.isSelected(name_1)) {
          this.select(name_1);
          hasSelected = true;
          break;
        }
      }
      !hasSelected && this.select(legendData[0].get("name"));
    }
  };
  LegendModel2.prototype._updateData = function(ecModel) {
    var potentialData = [];
    var availableNames = [];
    ecModel.eachRawSeries(function(seriesModel) {
      var seriesName = seriesModel.name;
      availableNames.push(seriesName);
      var isPotential;
      if (seriesModel.legendVisualProvider) {
        var provider = seriesModel.legendVisualProvider;
        var names = provider.getAllNames();
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }
        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }
      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    this._availableNames = availableNames;
    var rawData = this.get("data") || potentialData;
    var legendData = map$1(rawData, function(dataItem) {
      if (isString(dataItem) || isNumber(dataItem)) {
        dataItem = {
          name: dataItem
        };
      }
      return new Model$1(dataItem, this, this.ecModel);
    }, this);
    this._data = legendData;
  };
  LegendModel2.prototype.getData = function() {
    return this._data;
  };
  LegendModel2.prototype.select = function(name) {
    var selected = this.option.selected;
    var selectedMode = this.get("selectedMode");
    if (selectedMode === "single") {
      var data = this._data;
      each$f(data, function(dataItem) {
        selected[dataItem.get("name")] = false;
      });
    }
    selected[name] = true;
  };
  LegendModel2.prototype.unSelect = function(name) {
    if (this.get("selectedMode") !== "single") {
      this.option.selected[name] = false;
    }
  };
  LegendModel2.prototype.toggleSelected = function(name) {
    var selected = this.option.selected;
    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }
    this[selected[name] ? "unSelect" : "select"](name);
  };
  LegendModel2.prototype.allSelect = function() {
    var data = this._data;
    var selected = this.option.selected;
    each$f(data, function(dataItem) {
      selected[dataItem.get("name", true)] = true;
    });
  };
  LegendModel2.prototype.inverseSelect = function() {
    var data = this._data;
    var selected = this.option.selected;
    each$f(data, function(dataItem) {
      var name = dataItem.get("name", true);
      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }
      selected[name] = !selected[name];
    });
  };
  LegendModel2.prototype.isSelected = function(name) {
    var selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
  };
  LegendModel2.prototype.getOrient = function() {
    return this.get("orient") === "vertical" ? {
      index: 1,
      name: "vertical"
    } : {
      index: 0,
      name: "horizontal"
    };
  };
  LegendModel2.type = "legend.plain";
  LegendModel2.dependencies = ["series"];
  LegendModel2.defaultOption = {
    z: 4,
    show: true,
    orient: "horizontal",
    left: "center",
    top: 0,
    align: "auto",
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    borderRadius: 0,
    borderWidth: 0,
    padding: 5,
    itemGap: 10,
    itemWidth: 25,
    itemHeight: 14,
    symbolRotate: "inherit",
    symbolKeepAspect: true,
    inactiveColor: "#ccc",
    inactiveBorderColor: "#ccc",
    inactiveBorderWidth: "auto",
    itemStyle: {
      color: "inherit",
      opacity: "inherit",
      borderColor: "inherit",
      borderWidth: "auto",
      borderCap: "inherit",
      borderJoin: "inherit",
      borderDashOffset: "inherit",
      borderMiterLimit: "inherit"
    },
    lineStyle: {
      width: "auto",
      color: "inherit",
      inactiveColor: "#ccc",
      inactiveWidth: 2,
      opacity: "inherit",
      type: "inherit",
      cap: "inherit",
      join: "inherit",
      dashOffset: "inherit",
      miterLimit: "inherit"
    },
    textStyle: {
      color: "#333"
    },
    selectedMode: true,
    selector: false,
    selectorLabel: {
      show: true,
      borderRadius: 10,
      padding: [3, 5, 3, 5],
      fontSize: 12,
      fontFamily: "sans-serif",
      color: "#666",
      borderWidth: 1,
      borderColor: "#666"
    },
    emphasis: {
      selectorLabel: {
        show: true,
        color: "#eee",
        backgroundColor: "#666"
      }
    },
    selectorPosition: "auto",
    selectorItemGap: 7,
    selectorButtonGap: 10,
    tooltip: {
      show: false
    }
  };
  return LegendModel2;
}(ComponentModel$1);
var LegendModel$1 = LegendModel;
var curry = curry$1;
var each$3 = each$f;
var Group$1 = Group$4;
var LegendView = function(_super) {
  __extends(LegendView2, _super);
  function LegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = LegendView2.type;
    _this.newlineDisabled = false;
    return _this;
  }
  LegendView2.prototype.init = function() {
    this.group.add(this._contentGroup = new Group$1());
    this.group.add(this._selectorGroup = new Group$1());
    this._isFirstRender = true;
  };
  LegendView2.prototype.getContentGroup = function() {
    return this._contentGroup;
  };
  LegendView2.prototype.getSelectorGroup = function() {
    return this._selectorGroup;
  };
  LegendView2.prototype.render = function(legendModel, ecModel, api) {
    var isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();
    if (!legendModel.get("show", true)) {
      return;
    }
    var itemAlign = legendModel.get("align");
    var orient = legendModel.get("orient");
    if (!itemAlign || itemAlign === "auto") {
      itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
    }
    var selector2 = legendModel.get("selector", true);
    var selectorPosition = legendModel.get("selectorPosition", true);
    if (selector2 && (!selectorPosition || selectorPosition === "auto")) {
      selectorPosition = orient === "horizontal" ? "end" : "start";
    }
    this.renderInner(itemAlign, legendModel, ecModel, api, selector2, orient, selectorPosition);
    var positionInfo = legendModel.getBoxLayoutParams();
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var padding = legendModel.get("padding");
    var maxSize = getLayoutRect(positionInfo, viewportSize, padding);
    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition);
    var layoutRect = getLayoutRect(defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw();
    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  };
  LegendView2.prototype.resetInner = function() {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  };
  LegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector2, orient, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var legendDrawnMap = createHashMap();
    var selectMode = legendModel.get("selectedMode");
    var excludeSeriesId = [];
    ecModel.eachRawSeries(function(seriesModel) {
      !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
    });
    each$3(legendModel.getData(), function(legendItemModel, dataIndex) {
      var name = legendItemModel.get("name");
      if (!this.newlineDisabled && (name === "" || name === "\n")) {
        var g2 = new Group$1();
        g2.newline = true;
        contentGroup.add(g2);
        return;
      }
      var seriesModel = ecModel.getSeriesByName(name)[0];
      if (legendDrawnMap.get(name)) {
        return;
      }
      if (seriesModel) {
        var data = seriesModel.getData();
        var lineVisualStyle = data.getVisual("legendLineStyle") || {};
        var legendIcon = data.getVisual("legendIcon");
        var style = data.getVisual("style");
        var itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode);
        itemGroup.on("click", curry(dispatchSelectAction, name, null, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
        legendDrawnMap.set(name, true);
      } else {
        ecModel.eachRawSeries(function(seriesModel2) {
          if (legendDrawnMap.get(name)) {
            return;
          }
          if (seriesModel2.legendVisualProvider) {
            var provider = seriesModel2.legendVisualProvider;
            if (!provider.containName(name)) {
              return;
            }
            var idx = provider.indexOfName(name);
            var style2 = provider.getItemVisual(idx, "style");
            var legendIcon2 = provider.getItemVisual(idx, "legendIcon");
            var colorArr = parse(style2.fill);
            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2;
              style2 = extend$1(extend$1({}, style2), {
                fill: stringify(colorArr, "rgba")
              });
            }
            var itemGroup2 = this._createItem(seriesModel2, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style2, legendIcon2, selectMode);
            itemGroup2.on("click", curry(dispatchSelectAction, null, name, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name, api, excludeSeriesId));
            legendDrawnMap.set(name, true);
          }
        }, this);
      }
    }, this);
    if (selector2) {
      this._createSelector(selector2, legendModel, api, orient, selectorPosition);
    }
  };
  LegendView2.prototype._createSelector = function(selector2, legendModel, api, orient, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    each$3(selector2, function createSelectorButton(selectorItem) {
      var type = selectorItem.type;
      var labelText = new ZRText$1({
        style: {
          x: 0,
          y: 0,
          align: "center",
          verticalAlign: "middle"
        },
        onclick: function() {
          api.dispatchAction({
            type: type === "all" ? "legendAllSelect" : "legendInverseSelect"
          });
        }
      });
      selectorGroup.add(labelText);
      var labelModel = legendModel.getModel("selectorLabel");
      var emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
      setLabelStyle(labelText, {
        normal: labelModel,
        emphasis: emphasisLabelModel
      }, {
        defaultText: selectorItem.title
      });
      enableHoverEmphasis(labelText);
    });
  };
  LegendView2.prototype._createItem = function(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode) {
    var drawType = seriesModel.visualDrawType;
    var itemWidth = legendModel.get("itemWidth");
    var itemHeight = legendModel.get("itemHeight");
    var isSelected = legendModel.isSelected(name);
    var iconRotate = legendItemModel.get("symbolRotate");
    var symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
    var legendIconType = legendItemModel.get("icon");
    legendIcon = legendIconType || legendIcon || "roundRect";
    var style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected);
    var itemGroup = new Group$1();
    var textStyleModel = legendItemModel.getModel("textStyle");
    if (isFunction$1(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
      itemGroup.add(seriesModel.getLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    } else {
      var rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
      itemGroup.add(getDefaultLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate: rotate2,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    }
    var textX = itemAlign === "left" ? itemWidth + 5 : -5;
    var textAlign = itemAlign;
    var formatter = legendModel.get("formatter");
    var content = name;
    if (isString(formatter) && formatter) {
      content = formatter.replace("{name}", name != null ? name : "");
    } else if (isFunction$1(formatter)) {
      content = formatter(name);
    }
    var inactiveColor = legendItemModel.get("inactiveColor");
    itemGroup.add(new ZRText$1({
      style: createTextStyle$1(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
        align: textAlign,
        verticalAlign: "middle"
      })
    }));
    var hitRect = new Rect$3({
      shape: itemGroup.getBoundingRect(),
      invisible: true
    });
    var tooltipModel = legendItemModel.getModel("tooltip");
    if (tooltipModel.get("show")) {
      setTooltipConfig({
        el: hitRect,
        componentModel: legendModel,
        itemName: name,
        itemTooltipOption: tooltipModel.option
      });
    }
    itemGroup.add(hitRect);
    itemGroup.eachChild(function(child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    enableHoverEmphasis(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  };
  LegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
    var contentGroup = this.getContentGroup();
    var selectorGroup = this.getSelectorGroup();
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
    var contentRect = contentGroup.getBoundingRect();
    var contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();
    if (selector2) {
      box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var selectorButtonGap = legendModel.get("selectorButtonGap", true);
      var orientIdx = legendModel.getOrient().index;
      var wh = orientIdx === 0 ? "width" : "height";
      var hw = orientIdx === 0 ? "height" : "width";
      var yx = orientIdx === 0 ? "y" : "x";
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
      }
      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  };
  LegendView2.prototype.remove = function() {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  };
  LegendView2.type = "legend.plain";
  return LegendView2;
}(ComponentView$1);
function getLegendStyle(iconType, legendModel, lineVisualStyle, itemVisualStyle, drawType, isSelected) {
  function handleCommonProps(style, visualStyle) {
    if (style.lineWidth === "auto") {
      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
    }
    each$3(style, function(propVal, propName) {
      style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
    });
  }
  var legendItemModel = legendModel.getModel("itemStyle");
  var itemStyle = legendItemModel.getItemStyle();
  var iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
  itemStyle.decal = itemVisualStyle.decal;
  if (itemStyle.fill === "inherit") {
    itemStyle.fill = itemVisualStyle[drawType];
  }
  if (itemStyle.stroke === "inherit") {
    itemStyle.stroke = itemVisualStyle[iconBrushType];
  }
  if (itemStyle.opacity === "inherit") {
    itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
  }
  handleCommonProps(itemStyle, itemVisualStyle);
  var legendLineModel = legendModel.getModel("lineStyle");
  var lineStyle = legendLineModel.getLineStyle();
  handleCommonProps(lineStyle, lineVisualStyle);
  itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
  itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
  lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
  if (!isSelected) {
    var borderWidth = legendModel.get("inactiveBorderWidth");
    var visualHasBorder = itemStyle[iconBrushType];
    itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
    itemStyle.fill = legendModel.get("inactiveColor");
    itemStyle.stroke = legendModel.get("inactiveBorderColor");
    lineStyle.stroke = legendLineModel.get("inactiveColor");
    lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
  }
  return {
    itemStyle,
    lineStyle
  };
}
function getDefaultLegendIcon(opt) {
  var symboType = opt.icon || "roundRect";
  var icon = createSymbol$1(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
  icon.setStyle(opt.itemStyle);
  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
  if (symboType.indexOf("empty") > -1) {
    icon.style.stroke = icon.style.fill;
    icon.style.fill = "#fff";
    icon.style.lineWidth = 2;
  }
  return icon;
}
function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
  api.dispatchAction({
    type: "legendToggleSelect",
    name: seriesName != null ? seriesName : dataName
  });
  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
}
function isUseHoverLayer(api) {
  var list = api.getZr().storage.getDisplayList();
  var emphasisState;
  var i = 0;
  var len2 = list.length;
  while (i < len2 && !(emphasisState = list[i].states.emphasis)) {
    i++;
  }
  return emphasisState && emphasisState.hoverLayer;
}
function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "highlight",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
  if (!isUseHoverLayer(api)) {
    api.dispatchAction({
      type: "downplay",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
var LegendView$1 = LegendView;
function legendFilter(ecModel) {
  var legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function(series) {
      for (var i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }
      return true;
    });
  }
}
function legendSelectActionHandler(methodName, payload, ecModel) {
  var selectedMap = {};
  var isToggleSelect = methodName === "toggleSelected";
  var isSelected;
  ecModel.eachComponent("legend", function(legendModel) {
    if (isToggleSelect && isSelected != null) {
      legendModel[isSelected ? "select" : "unSelect"](payload.name);
    } else if (methodName === "allSelect" || methodName === "inverseSelect") {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }
    var legendData = legendModel.getData();
    each$f(legendData, function(model) {
      var name = model.get("name");
      if (name === "\n" || name === "") {
        return;
      }
      var isItemSelected = legendModel.isSelected(name);
      if (selectedMap.hasOwnProperty(name)) {
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
  });
  return methodName === "allSelect" || methodName === "inverseSelect" ? {
    selected: selectedMap
  } : {
    name: payload.name,
    selected: selectedMap
  };
}
function installLegendAction(registers) {
  registers.registerAction("legendToggleSelect", "legendselectchanged", curry$1(legendSelectActionHandler, "toggleSelected"));
  registers.registerAction("legendAllSelect", "legendselectall", curry$1(legendSelectActionHandler, "allSelect"));
  registers.registerAction("legendInverseSelect", "legendinverseselect", curry$1(legendSelectActionHandler, "inverseSelect"));
  registers.registerAction("legendSelect", "legendselected", curry$1(legendSelectActionHandler, "select"));
  registers.registerAction("legendUnSelect", "legendunselected", curry$1(legendSelectActionHandler, "unSelect"));
}
function install$r(registers) {
  registers.registerComponentModel(LegendModel$1);
  registers.registerComponentView(LegendView$1);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  registers.registerSubTypeDefaulter("legend", function() {
    return "plain";
  });
  installLegendAction(registers);
}
var ScrollableLegendModel = function(_super) {
  __extends(ScrollableLegendModel2, _super);
  function ScrollableLegendModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendModel2.type;
    return _this;
  }
  ScrollableLegendModel2.prototype.setScrollDataIndex = function(scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  };
  ScrollableLegendModel2.prototype.init = function(option, parentModel, ecModel) {
    var inputPositionParams = getLayoutParams(option);
    _super.prototype.init.call(this, option, parentModel, ecModel);
    mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
  };
  ScrollableLegendModel2.prototype.mergeOption = function(option, ecModel) {
    _super.prototype.mergeOption.call(this, option, ecModel);
    mergeAndNormalizeLayoutParams(this, this.option, option);
  };
  ScrollableLegendModel2.type = "legend.scroll";
  ScrollableLegendModel2.defaultOption = inheritDefaultOption(LegendModel$1.defaultOption, {
    scrollDataIndex: 0,
    pageButtonItemGap: 5,
    pageButtonGap: null,
    pageButtonPosition: "end",
    pageFormatter: "{current}/{total}",
    pageIcons: {
      horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
      vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
    },
    pageIconColor: "#2f4554",
    pageIconInactiveColor: "#aaa",
    pageIconSize: 15,
    pageTextStyle: {
      color: "#333"
    },
    animationDurationUpdate: 800
  });
  return ScrollableLegendModel2;
}(LegendModel$1);
function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
  var orient = legendModel.getOrient();
  var ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize: !!ignoreSize
  });
}
var ScrollableLegendModel$1 = ScrollableLegendModel;
var Group = Group$4;
var WH = ["width", "height"];
var XY = ["x", "y"];
var ScrollableLegendView = function(_super) {
  __extends(ScrollableLegendView2, _super);
  function ScrollableLegendView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ScrollableLegendView2.type;
    _this.newlineDisabled = true;
    _this._currentIndex = 0;
    return _this;
  }
  ScrollableLegendView2.prototype.init = function() {
    _super.prototype.init.call(this);
    this.group.add(this._containerGroup = new Group());
    this._containerGroup.add(this.getContentGroup());
    this.group.add(this._controllerGroup = new Group());
  };
  ScrollableLegendView2.prototype.resetInner = function() {
    _super.prototype.resetInner.call(this);
    this._controllerGroup.removeAll();
    this._containerGroup.removeClipPath();
    this._containerGroup.__rectSize = null;
  };
  ScrollableLegendView2.prototype.renderInner = function(itemAlign, legendModel, ecModel, api, selector2, orient, selectorPosition) {
    var self2 = this;
    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector2, orient, selectorPosition);
    var controllerGroup = this._controllerGroup;
    var pageIconSize = legendModel.get("pageIconSize", true);
    var pageIconSizeArr = isArray$1(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton("pagePrev", 0);
    var pageTextStyleModel = legendModel.getModel("pageTextStyle");
    controllerGroup.add(new ZRText$1({
      name: "pageText",
      style: {
        text: "xx/xx",
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: "middle",
        align: "center"
      },
      silent: true
    }));
    createPageButton("pageNext", 1);
    function createPageButton(name, iconIdx) {
      var pageDataIndexName = name + "DataIndex";
      var icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
        onclick: bind$1(self2._pageGo, self2, pageDataIndexName, legendModel, api)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  };
  ScrollableLegendView2.prototype.layoutInner = function(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
    var selectorGroup = this.getSelectorGroup();
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var hw = WH[1 - orientIdx];
    var yx = XY[1 - orientIdx];
    selector2 && box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
    var selectorButtonGap = legendModel.get("selectorButtonGap", true);
    var selectorRect = selectorGroup.getBoundingRect();
    var selectorPos = [-selectorRect.x, -selectorRect.y];
    var processMaxSize = clone$4(maxSize);
    selector2 && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
    if (selector2) {
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
      } else {
        var offset = selectorRect[wh] + selectorButtonGap;
        selectorPos[orientIdx] -= offset;
        mainRect[xy] -= offset;
      }
      mainRect[wh] += selectorRect[wh] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }
    return mainRect;
  };
  ScrollableLegendView2.prototype._layoutContentAndController = function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
    var contentGroup = this.getContentGroup();
    var containerGroup = this._containerGroup;
    var controllerGroup = this._controllerGroup;
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    box("horizontal", controllerGroup, legendModel.get("pageButtonItemGap", true));
    var contentRect = contentGroup.getBoundingRect();
    var controllerRect = controllerGroup.getBoundingRect();
    var showController = this._showController = contentRect[wh] > maxSize[wh];
    var contentPos = [-contentRect.x, -contentRect.y];
    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    }
    var containerPos = [0, 0];
    var controllerPos = [-controllerRect.x, -controllerRect.y];
    var pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
    if (showController) {
      var pageButtonPosition = legendModel.get("pageButtonPosition", true);
      if (pageButtonPosition === "end") {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } else {
        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
      }
    }
    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos);
    var mainRect = {
      x: 0,
      y: 0
    };
    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];
    if (showController) {
      var clipShape = {
        x: 0,
        y: 0
      };
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new Rect$3({
        shape: clipShape
      }));
      containerGroup.__rectSize = clipShape[wh];
    } else {
      controllerGroup.eachChild(function(child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    }
    var pageInfo = this._getPageInfo(legendModel);
    pageInfo.pageIndex != null && updateProps$1(contentGroup, {
      x: pageInfo.contentPosition[0],
      y: pageInfo.contentPosition[1]
    }, showController ? legendModel : null);
    this._updatePageInfoView(legendModel, pageInfo);
    return mainRect;
  };
  ScrollableLegendView2.prototype._pageGo = function(to, legendModel, api) {
    var scrollDataIndex = this._getPageInfo(legendModel)[to];
    scrollDataIndex != null && api.dispatchAction({
      type: "legendScroll",
      scrollDataIndex,
      legendId: legendModel.id
    });
  };
  ScrollableLegendView2.prototype._updatePageInfoView = function(legendModel, pageInfo) {
    var controllerGroup = this._controllerGroup;
    each$f(["pagePrev", "pageNext"], function(name) {
      var key = name + "DataIndex";
      var canJump = pageInfo[key] != null;
      var icon = controllerGroup.childOfName(name);
      if (icon) {
        icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
        icon.cursor = canJump ? "pointer" : "default";
      }
    });
    var pageText = controllerGroup.childOfName("pageText");
    var pageFormatter = legendModel.get("pageFormatter");
    var pageIndex = pageInfo.pageIndex;
    var current = pageIndex != null ? pageIndex + 1 : 0;
    var total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle("text", isString(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({
      current,
      total
    }));
  };
  ScrollableLegendView2.prototype._getPageInfo = function(legendModel) {
    var scrollDataIndex = legendModel.get("scrollDataIndex", true);
    var contentGroup = this.getContentGroup();
    var containerRectSize = this._containerGroup.__rectSize;
    var orientIdx = legendModel.getOrient().index;
    var wh = WH[orientIdx];
    var xy = XY[orientIdx];
    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
    var children = contentGroup.children();
    var targetItem = children[targetItemIndex];
    var itemCount = children.length;
    var pCount = !itemCount ? 0 : 1;
    var result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };
    if (!targetItem) {
      return result;
    }
    var targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s;
    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
      currItemInfo = getItemInfo(children[i]);
      if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          winStartItemInfo = currItemInfo;
        }
        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
        }
      }
      winEndItemInfo = currItemInfo;
    }
    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
      currItemInfo = getItemInfo(children[i]);
      if ((!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;
        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }
        ++result.pageCount;
        ++result.pageIndex;
      }
      winStartItemInfo = currItemInfo;
    }
    return result;
    function getItemInfo(el) {
      if (el) {
        var itemRect = el.getBoundingRect();
        var start2 = itemRect[xy] + el[xy];
        return {
          s: start2,
          e: start2 + itemRect[wh],
          i: el.__legendDataIndex
        };
      }
    }
    function intersect2(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  };
  ScrollableLegendView2.prototype._findTargetItemIndex = function(targetDataIndex) {
    if (!this._showController) {
      return 0;
    }
    var index;
    var contentGroup = this.getContentGroup();
    var defaultIndex;
    contentGroup.eachChild(function(child, idx) {
      var legendDataIdx = child.__legendDataIndex;
      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }
      if (legendDataIdx === targetDataIndex) {
        index = idx;
      }
    });
    return index != null ? index : defaultIndex;
  };
  ScrollableLegendView2.type = "legend.scroll";
  return ScrollableLegendView2;
}(LegendView$1);
var ScrollableLegendView$1 = ScrollableLegendView;
function installScrollableLegendAction(registers) {
  registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
    var scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: payload
    }, function(legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}
function install$q(registers) {
  use(install$r);
  registers.registerComponentModel(ScrollableLegendModel$1);
  registers.registerComponentView(ScrollableLegendView$1);
  installScrollableLegendAction(registers);
}
function install$p(registers) {
  use(install$r);
  use(install$q);
}
var InsideZoomModel = function(_super) {
  __extends(InsideZoomModel2, _super);
  function InsideZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = InsideZoomModel2.type;
    return _this;
  }
  InsideZoomModel2.type = "dataZoom.inside";
  InsideZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
    disabled: false,
    zoomLock: false,
    zoomOnMouseWheel: true,
    moveOnMouseMove: true,
    moveOnMouseWheel: false,
    preventDefaultMouseMove: true
  });
  return InsideZoomModel2;
}(DataZoomModel$1);
var InsideZoomModel$1 = InsideZoomModel;
var inner$1 = makeInner();
function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
  inner$1(api).coordSysRecordMap.each(function(coordSysRecord) {
    var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
    if (dzInfo) {
      dzInfo.getRange = getRange;
    }
  });
}
function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
  var coordSysRecordMap = inner$1(api).coordSysRecordMap;
  var coordSysKeyArr = coordSysRecordMap.keys();
  for (var i = 0; i < coordSysKeyArr.length; i++) {
    var coordSysKey = coordSysKeyArr[i];
    var coordSysRecord = coordSysRecordMap.get(coordSysKey);
    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
    if (dataZoomInfoMap) {
      var dzUid = dataZoomModel.uid;
      var dzInfo = dataZoomInfoMap.get(dzUid);
      if (dzInfo) {
        dataZoomInfoMap.removeKey(dzUid);
        if (!dataZoomInfoMap.keys().length) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        }
      }
    }
  }
}
function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
  if (coordSysRecord) {
    coordSysRecordMap.removeKey(coordSysRecord.model.uid);
    var controller = coordSysRecord.controller;
    controller && controller.dispose();
  }
}
function createCoordSysRecord(api, coordSysModel) {
  var coordSysRecord = {
    model: coordSysModel,
    containsPoint: curry$1(containsPoint, coordSysModel),
    dispatchAction: curry$1(dispatchAction, api),
    dataZoomInfoMap: null,
    controller: null
  };
  var controller = coordSysRecord.controller = new RoamController$1(api.getZr());
  each$f(["pan", "zoom", "scrollMove"], function(eventName) {
    controller.on(eventName, function(event) {
      var batch = [];
      coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
        if (!event.isAvailableBehavior(dzInfo.model.option)) {
          return;
        }
        var method = (dzInfo.getRange || {})[eventName];
        var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
        !dzInfo.model.get("disabled", true) && range && batch.push({
          dataZoomId: dzInfo.model.id,
          start: range[0],
          end: range[1]
        });
      });
      batch.length && coordSysRecord.dispatchAction(batch);
    });
  });
  return coordSysRecord;
}
function dispatchAction(api, batch) {
  if (!api.isDisposed()) {
    api.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch
    });
  }
}
function containsPoint(coordSysModel, e2, x, y) {
  return coordSysModel.coordinateSystem.containPoint([x, y]);
}
function mergeControllerParams(dataZoomInfoMap) {
  var controlType;
  var prefix = "type_";
  var typePriority = {
    "type_true": 2,
    "type_move": 1,
    "type_false": 0,
    "type_undefined": -1
  };
  var preventDefaultMouseMove = true;
  dataZoomInfoMap.each(function(dataZoomInfo) {
    var dataZoomModel = dataZoomInfo.model;
    var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
      controlType = oneType;
    }
    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
  });
  return {
    controlType,
    opt: {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: true,
      preventDefaultMouseMove: !!preventDefaultMouseMove
    }
  };
}
function installDataZoomRoamProcessor(registers) {
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api) {
    var apiInner = inner$1(api);
    var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
    coordSysRecordMap.each(function(coordSysRecord) {
      coordSysRecord.dataZoomInfoMap = null;
    });
    ecModel.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(dataZoomModel) {
      var dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);
      each$f(dzReferCoordSysWrap.infoList, function(dzCoordSysInfo) {
        var coordSysUid = dzCoordSysInfo.model.uid;
        var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());
        dataZoomInfoMap.set(dataZoomModel.uid, {
          dzReferCoordSysInfo: dzCoordSysInfo,
          model: dataZoomModel,
          getRange: null
        });
      });
    });
    coordSysRecordMap.each(function(coordSysRecord) {
      var controller = coordSysRecord.controller;
      var firstDzInfo;
      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
      if (dataZoomInfoMap) {
        var firstDzKey = dataZoomInfoMap.keys()[0];
        if (firstDzKey != null) {
          firstDzInfo = dataZoomInfoMap.get(firstDzKey);
        }
      }
      if (!firstDzInfo) {
        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        return;
      }
      var controllerParams = mergeControllerParams(dataZoomInfoMap);
      controller.enable(controllerParams.controlType, controllerParams.opt);
      controller.setPointerChecker(coordSysRecord.containsPoint);
      createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
    });
  });
}
var InsideZoomView = function(_super) {
  __extends(InsideZoomView2, _super);
  function InsideZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dataZoom.inside";
    return _this;
  }
  InsideZoomView2.prototype.render = function(dataZoomModel, ecModel, api) {
    _super.prototype.render.apply(this, arguments);
    if (dataZoomModel.noTarget()) {
      this._clear();
      return;
    }
    this.range = dataZoomModel.getPercentRange();
    setViewInfoToCoordSysRecord(api, dataZoomModel, {
      pan: bind$1(getRangeHandlers.pan, this),
      zoom: bind$1(getRangeHandlers.zoom, this),
      scrollMove: bind$1(getRangeHandlers.scrollMove, this)
    });
  };
  InsideZoomView2.prototype.dispose = function() {
    this._clear();
    _super.prototype.dispose.apply(this, arguments);
  };
  InsideZoomView2.prototype._clear = function() {
    disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
    this.range = null;
  };
  InsideZoomView2.type = "dataZoom.inside";
  return InsideZoomView2;
}(DataZoomView$1);
var getRangeHandlers = {
  zoom: function(coordSysInfo, coordSysMainType, controller, e2) {
    var lastRange = this.range;
    var range = lastRange.slice();
    var axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var directionInfo = getDirectionInfo[coordSysMainType](null, [e2.originX, e2.originY], axisModel, controller, coordSysInfo);
    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    var scale2 = Math.max(1 / e2.scale, 0);
    range[0] = (range[0] - percentPoint) * scale2 + percentPoint;
    range[1] = (range[1] - percentPoint) * scale2 + percentPoint;
    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  },
  pan: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    var directionInfo = getDirectionInfo[coordSysMainType]([e2.oldX, e2.oldY], [e2.newX, e2.newY], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
  }),
  scrollMove: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e2.scrollDelta, e2.scrollDelta], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * e2.scrollDelta;
  })
};
function makeMover(getPercentDelta) {
  return function(coordSysInfo, coordSysMainType, controller, e2) {
    var lastRange = this.range;
    var range = lastRange.slice();
    var axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e2);
    sliderMove(percentDelta, range, [0, 100], "all");
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  };
}
var getDirectionInfo = {
  grid: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret2 = {};
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];
    if (axis.dim === "x") {
      ret2.pixel = newPoint[0] - oldPoint[0];
      ret2.pixelLength = rect.width;
      ret2.pixelStart = rect.x;
      ret2.signal = axis.inverse ? 1 : -1;
    } else {
      ret2.pixel = newPoint[1] - oldPoint[1];
      ret2.pixelLength = rect.height;
      ret2.pixelStart = rect.y;
      ret2.signal = axis.inverse ? -1 : 1;
    }
    return ret2;
  },
  polar: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var ret2 = {};
    var polar = coordSysInfo.model.coordinateSystem;
    var radiusExtent = polar.getRadiusAxis().getExtent();
    var angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);
    if (axisModel.mainType === "radiusAxis") {
      ret2.pixel = newPoint[0] - oldPoint[0];
      ret2.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret2.pixelStart = radiusExtent[0];
      ret2.signal = axis.inverse ? 1 : -1;
    } else {
      ret2.pixel = newPoint[1] - oldPoint[1];
      ret2.pixelLength = angleExtent[1] - angleExtent[0];
      ret2.pixelStart = angleExtent[0];
      ret2.signal = axis.inverse ? -1 : 1;
    }
    return ret2;
  },
  singleAxis: function(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    var axis = axisModel.axis;
    var rect = coordSysInfo.model.coordinateSystem.getRect();
    var ret2 = {};
    oldPoint = oldPoint || [0, 0];
    if (axis.orient === "horizontal") {
      ret2.pixel = newPoint[0] - oldPoint[0];
      ret2.pixelLength = rect.width;
      ret2.pixelStart = rect.x;
      ret2.signal = axis.inverse ? 1 : -1;
    } else {
      ret2.pixel = newPoint[1] - oldPoint[1];
      ret2.pixelLength = rect.height;
      ret2.pixelStart = rect.y;
      ret2.signal = axis.inverse ? -1 : 1;
    }
    return ret2;
  }
};
var InsideZoomView$1 = InsideZoomView;
function install$o(registers) {
  installCommon$1(registers);
  registers.registerComponentModel(InsideZoomModel$1);
  registers.registerComponentView(InsideZoomView$1);
  installDataZoomRoamProcessor(registers);
}
var SliderZoomModel = function(_super) {
  __extends(SliderZoomModel2, _super);
  function SliderZoomModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderZoomModel2.type;
    return _this;
  }
  SliderZoomModel2.type = "dataZoom.slider";
  SliderZoomModel2.layoutMode = "box";
  SliderZoomModel2.defaultOption = inheritDefaultOption(DataZoomModel$1.defaultOption, {
    show: true,
    right: "ph",
    top: "ph",
    width: "ph",
    height: "ph",
    left: null,
    bottom: null,
    borderColor: "#d2dbee",
    borderRadius: 3,
    backgroundColor: "rgba(47,69,84,0)",
    dataBackground: {
      lineStyle: {
        color: "#d2dbee",
        width: 0.5
      },
      areaStyle: {
        color: "#d2dbee",
        opacity: 0.2
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#8fb0f7",
        width: 0.5
      },
      areaStyle: {
        color: "#8fb0f7",
        opacity: 0.2
      }
    },
    fillerColor: "rgba(135,175,274,0.2)",
    handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
    handleSize: "100%",
    handleStyle: {
      color: "#fff",
      borderColor: "#ACB8D1"
    },
    moveHandleSize: 7,
    moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
    moveHandleStyle: {
      color: "#D2DBEE",
      opacity: 0.7
    },
    showDetail: true,
    showDataShadow: "auto",
    realtime: true,
    zoomLock: false,
    textStyle: {
      color: "#6E7079"
    },
    brushSelect: true,
    brushStyle: {
      color: "rgba(135,175,274,0.15)"
    },
    emphasis: {
      handleStyle: {
        borderColor: "#8FB0F7"
      },
      moveHandleStyle: {
        color: "#8FB0F7"
      }
    }
  });
  return SliderZoomModel2;
}(DataZoomModel$1);
var SliderZoomModel$1 = SliderZoomModel;
var Rect = Rect$3;
var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var DEFAULT_MOVE_HANDLE_SIZE = 7;
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
var REALTIME_ANIMATION_CONFIG = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
};
var SliderZoomView = function(_super) {
  __extends(SliderZoomView2, _super);
  function SliderZoomView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = SliderZoomView2.type;
    _this._displayables = {};
    return _this;
  }
  SliderZoomView2.prototype.init = function(ecModel, api) {
    this.api = api;
    this._onBrush = bind$1(this._onBrush, this);
    this._onBrushEnd = bind$1(this._onBrushEnd, this);
  };
  SliderZoomView2.prototype.render = function(dataZoomModel, ecModel, api, payload) {
    _super.prototype.render.apply(this, arguments);
    createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
    this._orient = dataZoomModel.getOrient();
    if (dataZoomModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    if (dataZoomModel.noTarget()) {
      this._clear();
      this.group.removeAll();
      return;
    }
    if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
      this._buildView();
    }
    this._updateView();
  };
  SliderZoomView2.prototype.dispose = function() {
    this._clear();
    _super.prototype.dispose.apply(this, arguments);
  };
  SliderZoomView2.prototype._clear = function() {
    clear$1(this, "_dispatchZoomAction");
    var zr = this.api.getZr();
    zr.off("mousemove", this._onBrush);
    zr.off("mouseup", this._onBrushEnd);
  };
  SliderZoomView2.prototype._buildView = function() {
    var thisGroup = this.group;
    thisGroup.removeAll();
    this._brushing = false;
    this._displayables.brushRect = null;
    this._resetLocation();
    this._resetInterval();
    var barGroup = this._displayables.sliderGroup = new Group$4();
    this._renderBackground();
    this._renderHandle();
    this._renderDataShadow();
    thisGroup.add(barGroup);
    this._positionGroup();
  };
  SliderZoomView2.prototype._resetLocation = function() {
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var showMoveHandle = dataZoomModel.get("brushSelect");
    var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
    var coordRect = this._findCoordRect();
    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var positionInfo = this._orient === HORIZONTAL ? {
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    };
    var layoutParams = getLayoutParams(dataZoomModel.option);
    each$f(["right", "top", "width", "height"], function(name) {
      if (layoutParams[name] === "ph") {
        layoutParams[name] = positionInfo[name];
      }
    });
    var layoutRect = getLayoutRect(layoutParams, ecSize);
    this._location = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  };
  SliderZoomView2.prototype._positionGroup = function() {
    var thisGroup = this.group;
    var location2 = this._location;
    var orient = this._orient;
    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    var inverse = targetAxisModel && targetAxisModel.get("inverse");
    var sliderGroup = this._displayables.sliderGroup;
    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: 1
    } : orient === HORIZONTAL && inverse ? {
      scaleY: otherAxisInverse ? 1 : -1,
      scaleX: -1
    } : orient === VERTICAL && !inverse ? {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: 1,
      rotation: Math.PI / 2
    } : {
      scaleY: otherAxisInverse ? -1 : 1,
      scaleX: -1,
      rotation: Math.PI / 2
    });
    var rect = thisGroup.getBoundingRect([sliderGroup]);
    thisGroup.x = location2.x - rect.x;
    thisGroup.y = location2.y - rect.y;
    thisGroup.markRedraw();
  };
  SliderZoomView2.prototype._getViewExtent = function() {
    return [0, this._size[0]];
  };
  SliderZoomView2.prototype._renderBackground = function() {
    var dataZoomModel = this.dataZoomModel;
    var size = this._size;
    var barGroup = this._displayables.sliderGroup;
    var brushSelect = dataZoomModel.get("brushSelect");
    barGroup.add(new Rect({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get("backgroundColor")
      },
      z2: -40
    }));
    var clickPanel = new Rect({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: "transparent"
      },
      z2: 0,
      onclick: bind$1(this._onClickPanel, this)
    });
    var zr = this.api.getZr();
    if (brushSelect) {
      clickPanel.on("mousedown", this._onBrushStart, this);
      clickPanel.cursor = "crosshair";
      zr.on("mousemove", this._onBrush);
      zr.on("mouseup", this._onBrushEnd);
    } else {
      zr.off("mousemove", this._onBrush);
      zr.off("mouseup", this._onBrushEnd);
    }
    barGroup.add(clickPanel);
  };
  SliderZoomView2.prototype._renderDataShadow = function() {
    var info = this._dataShadowInfo = this._prepareDataShadowInfo();
    this._displayables.dataShadowSegs = [];
    if (!info) {
      return;
    }
    var size = this._size;
    var oldSize = this._shadowSize || [];
    var seriesModel = info.series;
    var data = seriesModel.getRawData();
    var otherDim2 = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
    if (otherDim2 == null) {
      return;
    }
    var polygonPts = this._shadowPolygonPts;
    var polylinePts = this._shadowPolylinePts;
    if (data !== this._shadowData || otherDim2 !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      var otherDataExtent_1 = data.getDataExtent(otherDim2);
      var otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3;
      otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset];
      var otherShadowExtent_1 = [0, size[1]];
      var thisShadowExtent = [0, size[0]];
      var areaPoints_1 = [[size[0], 0], [0, 0]];
      var linePoints_1 = [];
      var step_1 = thisShadowExtent[1] / (data.count() - 1);
      var thisCoord_1 = 0;
      var stride_1 = Math.round(data.count() / size[0]);
      var lastIsEmpty_1;
      data.each([otherDim2], function(value, index) {
        if (stride_1 > 0 && index % stride_1) {
          thisCoord_1 += step_1;
          return;
        }
        var isEmpty = value == null || isNaN(value) || value === "";
        var otherCoord = isEmpty ? 0 : linearMap$2(value, otherDataExtent_1, otherShadowExtent_1, true);
        if (isEmpty && !lastIsEmpty_1 && index) {
          areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0]);
          linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0]);
        } else if (!isEmpty && lastIsEmpty_1) {
          areaPoints_1.push([thisCoord_1, 0]);
          linePoints_1.push([thisCoord_1, 0]);
        }
        areaPoints_1.push([thisCoord_1, otherCoord]);
        linePoints_1.push([thisCoord_1, otherCoord]);
        thisCoord_1 += step_1;
        lastIsEmpty_1 = isEmpty;
      });
      polygonPts = this._shadowPolygonPts = areaPoints_1;
      polylinePts = this._shadowPolylinePts = linePoints_1;
    }
    this._shadowData = data;
    this._shadowDim = otherDim2;
    this._shadowSize = [size[0], size[1]];
    var dataZoomModel = this.dataZoomModel;
    function createDataShadowGroup(isSelectedArea) {
      var model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
      var group2 = new Group$4();
      var polygon = new Polygon$1({
        shape: {
          points: polygonPts
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel("areaStyle").getAreaStyle(),
        silent: true,
        z2: -20
      });
      var polyline = new Polyline$3({
        shape: {
          points: polylinePts
        },
        segmentIgnoreThreshold: 1,
        style: model.getModel("lineStyle").getLineStyle(),
        silent: true,
        z2: -19
      });
      group2.add(polygon);
      group2.add(polyline);
      return group2;
    }
    for (var i = 0; i < 3; i++) {
      var group = createDataShadowGroup(i === 1);
      this._displayables.sliderGroup.add(group);
      this._displayables.dataShadowSegs.push(group);
    }
  };
  SliderZoomView2.prototype._prepareDataShadowInfo = function() {
    var dataZoomModel = this.dataZoomModel;
    var showDataShadow = dataZoomModel.get("showDataShadow");
    if (showDataShadow === false) {
      return;
    }
    var result;
    var ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
      each$f(seriesModels, function(seriesModel) {
        if (result) {
          return;
        }
        if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
          return;
        }
        var thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
        var otherDim2 = getOtherDim(axisDim);
        var otherAxisInverse;
        var coordSys = seriesModel.coordinateSystem;
        if (otherDim2 != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }
        otherDim2 = seriesModel.getData().mapDimension(otherDim2);
        result = {
          thisAxis,
          series: seriesModel,
          thisDim: axisDim,
          otherDim: otherDim2,
          otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  };
  SliderZoomView2.prototype._renderHandle = function() {
    var thisGroup = this.group;
    var displayables = this._displayables;
    var handles = displayables.handles = [null, null];
    var handleLabels = displayables.handleLabels = [null, null];
    var sliderGroup = this._displayables.sliderGroup;
    var size = this._size;
    var dataZoomModel = this.dataZoomModel;
    var api = this.api;
    var borderRadius = dataZoomModel.get("borderRadius") || 0;
    var brushSelect = dataZoomModel.get("brushSelect");
    var filler = displayables.filler = new Rect({
      silent: brushSelect,
      style: {
        fill: dataZoomModel.get("fillerColor")
      },
      textConfig: {
        position: "inside"
      }
    });
    sliderGroup.add(filler);
    sliderGroup.add(new Rect({
      silent: true,
      subPixelOptimize: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        r: borderRadius
      },
      style: {
        stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: "rgba(0,0,0,0)"
      }
    }));
    each$f([0, 1], function(handleIndex) {
      var iconStr = dataZoomModel.get("handleIcon");
      if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
        iconStr = "path://" + iconStr;
      }
      var path = createSymbol$1(iconStr, -1, 0, 2, 2, null, true);
      path.attr({
        cursor: getCursor$1(this._orient),
        draggable: true,
        drift: bind$1(this._onDragMove, this, handleIndex),
        ondragend: bind$1(this._onDragEnd, this),
        onmouseover: bind$1(this._showDataInfo, this, true),
        onmouseout: bind$1(this._showDataInfo, this, false),
        z2: 5
      });
      var bRect = path.getBoundingRect();
      var handleSize = dataZoomModel.get("handleSize");
      this._handleHeight = parsePercent$1(handleSize, this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
      path.style.strokeNoScale = true;
      path.rectHover = true;
      path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
      enableHoverEmphasis(path);
      var handleColor = dataZoomModel.get("handleColor");
      if (handleColor != null) {
        path.style.fill = handleColor;
      }
      sliderGroup.add(handles[handleIndex] = path);
      var textStyleModel = dataZoomModel.getModel("textStyle");
      thisGroup.add(handleLabels[handleIndex] = new ZRText$1({
        silent: true,
        invisible: true,
        style: createTextStyle$1(textStyleModel, {
          x: 0,
          y: 0,
          text: "",
          verticalAlign: "middle",
          align: "center",
          fill: textStyleModel.getTextColor(),
          font: textStyleModel.getFont()
        }),
        z2: 10
      }));
    }, this);
    var actualMoveZone = filler;
    if (brushSelect) {
      var moveHandleHeight = parsePercent$1(dataZoomModel.get("moveHandleSize"), size[1]);
      var moveHandle_1 = displayables.moveHandle = new Rect$3({
        style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
        silent: true,
        shape: {
          r: [0, 0, 2, 2],
          y: size[1] - 0.5,
          height: moveHandleHeight
        }
      });
      var iconSize = moveHandleHeight * 0.8;
      var moveHandleIcon = displayables.moveHandleIcon = createSymbol$1(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, "#fff", true);
      moveHandleIcon.silent = true;
      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
      moveHandle_1.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
      var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
      actualMoveZone = displayables.moveZone = new Rect$3({
        invisible: true,
        shape: {
          y: size[1] - moveZoneExpandSize,
          height: moveHandleHeight + moveZoneExpandSize
        }
      });
      actualMoveZone.on("mouseover", function() {
        api.enterEmphasis(moveHandle_1);
      }).on("mouseout", function() {
        api.leaveEmphasis(moveHandle_1);
      });
      sliderGroup.add(moveHandle_1);
      sliderGroup.add(moveHandleIcon);
      sliderGroup.add(actualMoveZone);
    }
    actualMoveZone.attr({
      draggable: true,
      cursor: getCursor$1(this._orient),
      drift: bind$1(this._onDragMove, this, "all"),
      ondragstart: bind$1(this._showDataInfo, this, true),
      ondragend: bind$1(this._onDragEnd, this),
      onmouseover: bind$1(this._showDataInfo, this, true),
      onmouseout: bind$1(this._showDataInfo, this, false)
    });
  };
  SliderZoomView2.prototype._resetInterval = function() {
    var range = this._range = this.dataZoomModel.getPercentRange();
    var viewExtent = this._getViewExtent();
    this._handleEnds = [linearMap$2(range[0], [0, 100], viewExtent, true), linearMap$2(range[1], [0, 100], viewExtent, true)];
  };
  SliderZoomView2.prototype._updateInterval = function(handleIndex, delta) {
    var dataZoomModel = this.dataZoomModel;
    var handleEnds = this._handleEnds;
    var viewExtend = this._getViewExtent();
    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    var percentExtent = [0, 100];
    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap$2(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap$2(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    var lastRange = this._range;
    var range = this._range = asc$2([linearMap$2(handleEnds[0], viewExtend, percentExtent, true), linearMap$2(handleEnds[1], viewExtend, percentExtent, true)]);
    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
  };
  SliderZoomView2.prototype._updateView = function(nonRealtime) {
    var displaybles = this._displayables;
    var handleEnds = this._handleEnds;
    var handleInterval = asc$2(handleEnds.slice());
    var size = this._size;
    each$f([0, 1], function(handleIndex) {
      var handle = displaybles.handles[handleIndex];
      var handleHeight = this._handleHeight;
      handle.attr({
        scaleX: handleHeight / 2,
        scaleY: handleHeight / 2,
        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
        y: size[1] / 2 - handleHeight / 2
      });
    }, this);
    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });
    var viewExtent = {
      x: handleInterval[0],
      width: handleInterval[1] - handleInterval[0]
    };
    if (displaybles.moveHandle) {
      displaybles.moveHandle.setShape(viewExtent);
      displaybles.moveZone.setShape(viewExtent);
      displaybles.moveZone.getBoundingRect();
      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
    }
    var dataShadowSegs = displaybles.dataShadowSegs;
    var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];
    for (var i = 0; i < dataShadowSegs.length; i++) {
      var segGroup = dataShadowSegs[i];
      var clipPath = segGroup.getClipPath();
      if (!clipPath) {
        clipPath = new Rect$3();
        segGroup.setClipPath(clipPath);
      }
      clipPath.setShape({
        x: segIntervals[i],
        y: 0,
        width: segIntervals[i + 1] - segIntervals[i],
        height: size[1]
      });
    }
    this._updateDataInfo(nonRealtime);
  };
  SliderZoomView2.prototype._updateDataInfo = function(nonRealtime) {
    var dataZoomModel = this.dataZoomModel;
    var displaybles = this._displayables;
    var handleLabels = displaybles.handleLabels;
    var orient = this._orient;
    var labelTexts = ["", ""];
    if (dataZoomModel.get("showDetail")) {
      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        var axis = axisProxy.getAxisModel().axis;
        var range = this._range;
        var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
      }
    }
    var orderedHandleEnds = asc$2(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);
    function setLabel(handleIndex) {
      var barTransform = getTransform$1(displaybles.handles[handleIndex].parent, this.group);
      var direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
      var offset = this._handleWidth / 2 + LABEL_GAP;
      var textPoint = applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        verticalAlign: orient === HORIZONTAL ? "middle" : direction,
        align: orient === HORIZONTAL ? direction : "center",
        text: labelTexts[handleIndex]
      });
    }
  };
  SliderZoomView2.prototype._formatLabel = function(value, axis) {
    var dataZoomModel = this.dataZoomModel;
    var labelFormatter = dataZoomModel.get("labelFormatter");
    var labelPrecision = dataZoomModel.get("labelPrecision");
    if (labelPrecision == null || labelPrecision === "auto") {
      labelPrecision = axis.getPixelPrecision();
    }
    var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({
      value: Math.round(value)
    }) : value.toFixed(Math.min(labelPrecision, 20));
    return isFunction$1(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
  };
  SliderZoomView2.prototype._showDataInfo = function(showOrHide) {
    showOrHide = this._dragging || showOrHide;
    var displayables = this._displayables;
    var handleLabels = displayables.handleLabels;
    handleLabels[0].attr("invisible", !showOrHide);
    handleLabels[1].attr("invisible", !showOrHide);
    displayables.moveHandle && this.api[showOrHide ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
  };
  SliderZoomView2.prototype._onDragMove = function(handleIndex, dx, dy, event) {
    this._dragging = true;
    stop(event.event);
    var barTransform = this._displayables.sliderGroup.getLocalTransform();
    var vertex = applyTransform([dx, dy], barTransform, true);
    var changed = this._updateInterval(handleIndex, vertex[0]);
    var realtime = this.dataZoomModel.get("realtime");
    this._updateView(!realtime);
    changed && realtime && this._dispatchZoomAction(true);
  };
  SliderZoomView2.prototype._onDragEnd = function() {
    this._dragging = false;
    this._showDataInfo(false);
    var realtime = this.dataZoomModel.get("realtime");
    !realtime && this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onClickPanel = function(e2) {
    var size = this._size;
    var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e2.offsetX, e2.offsetY);
    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }
    var handleEnds = this._handleEnds;
    var center2 = (handleEnds[0] + handleEnds[1]) / 2;
    var changed = this._updateInterval("all", localPoint[0] - center2);
    this._updateView();
    changed && this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onBrushStart = function(e2) {
    var x = e2.offsetX;
    var y = e2.offsetY;
    this._brushStart = new Point$1(x, y);
    this._brushing = true;
    this._brushStartTime = +new Date();
  };
  SliderZoomView2.prototype._onBrushEnd = function(e2) {
    if (!this._brushing) {
      return;
    }
    var brushRect = this._displayables.brushRect;
    this._brushing = false;
    if (!brushRect) {
      return;
    }
    brushRect.attr("ignore", true);
    var brushShape = brushRect.shape;
    var brushEndTime = +new Date();
    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
      return;
    }
    var viewExtend = this._getViewExtent();
    var percentExtent = [0, 100];
    this._range = asc$2([linearMap$2(brushShape.x, viewExtend, percentExtent, true), linearMap$2(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);
    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
    this._updateView();
    this._dispatchZoomAction(false);
  };
  SliderZoomView2.prototype._onBrush = function(e2) {
    if (this._brushing) {
      stop(e2.event);
      this._updateBrushRect(e2.offsetX, e2.offsetY);
    }
  };
  SliderZoomView2.prototype._updateBrushRect = function(mouseX, mouseY) {
    var displayables = this._displayables;
    var dataZoomModel = this.dataZoomModel;
    var brushRect = displayables.brushRect;
    if (!brushRect) {
      brushRect = displayables.brushRect = new Rect({
        silent: true,
        style: dataZoomModel.getModel("brushStyle").getItemStyle()
      });
      displayables.sliderGroup.add(brushRect);
    }
    brushRect.attr("ignore", false);
    var brushStart = this._brushStart;
    var sliderGroup = this._displayables.sliderGroup;
    var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
    var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
    var size = this._size;
    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
    brushRect.setShape({
      x: startPoint[0],
      y: 0,
      width: endPoint[0] - startPoint[0],
      height: size[1]
    });
  };
  SliderZoomView2.prototype._dispatchZoomAction = function(realtime) {
    var range = this._range;
    this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
      start: range[0],
      end: range[1]
    });
  };
  SliderZoomView2.prototype._findCoordRect = function() {
    var rect;
    var coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
    if (!rect && coordSysInfoList.length) {
      var coordSys = coordSysInfoList[0].model.coordinateSystem;
      rect = coordSys.getRect && coordSys.getRect();
    }
    if (!rect) {
      var width = this.api.getWidth();
      var height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }
    return rect;
  };
  SliderZoomView2.type = "dataZoom.slider";
  return SliderZoomView2;
}(DataZoomView$1);
function getOtherDim(thisDim) {
  var map2 = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return map2[thisDim];
}
function getCursor$1(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var SliderZoomView$1 = SliderZoomView;
function install$n(registers) {
  registers.registerComponentModel(SliderZoomModel$1);
  registers.registerComponentView(SliderZoomView$1);
  installCommon$1(registers);
}
function install$m(registers) {
  use(install$o);
  use(install$n);
}
var visualDefault = {
  get: function(visualType, key, isCategory2) {
    var value = clone$4((defaultOption$1[visualType] || {})[key]);
    return isCategory2 ? isArray$1(value) ? value[value.length - 1] : value : value;
  }
};
var defaultOption$1 = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
var visualDefault$1 = visualDefault;
var mapVisual = VisualMapping$1.mapVisual;
var eachVisual = VisualMapping$1.eachVisual;
var isArray = isArray$1;
var each$2 = each$f;
var asc = asc$2;
var linearMap$1 = linearMap$2;
var VisualMapModel = function(_super) {
  __extends(VisualMapModel2, _super);
  function VisualMapModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = VisualMapModel2.type;
    _this.stateList = ["inRange", "outOfRange"];
    _this.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"];
    _this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    _this.dataBound = [-Infinity, Infinity];
    _this.targetVisuals = {};
    _this.controllerVisuals = {};
    return _this;
  }
  VisualMapModel2.prototype.init = function(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  };
  VisualMapModel2.prototype.optionUpdated = function(newOption, isInit) {
    var thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
    this.textStyleModel = this.getModel("textStyle");
    this.resetItemSize();
    this.completeVisualOption();
  };
  VisualMapModel2.prototype.resetVisual = function(supplementVisualOption) {
    var stateList = this.stateList;
    supplementVisualOption = bind$1(supplementVisualOption, this);
    this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);
    this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);
  };
  VisualMapModel2.prototype.getItemSymbol = function() {
    return null;
  };
  VisualMapModel2.prototype.getTargetSeriesIndices = function() {
    var optionSeriesIndex = this.option.seriesIndex;
    var seriesIndices = [];
    if (optionSeriesIndex == null || optionSeriesIndex === "all") {
      this.ecModel.eachSeries(function(seriesModel, index) {
        seriesIndices.push(index);
      });
    } else {
      seriesIndices = normalizeToArray(optionSeriesIndex);
    }
    return seriesIndices;
  };
  VisualMapModel2.prototype.eachTargetSeries = function(callback, context) {
    each$f(this.getTargetSeriesIndices(), function(seriesIndex) {
      var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);
      if (seriesModel) {
        callback.call(context, seriesModel);
      }
    }, this);
  };
  VisualMapModel2.prototype.isTargetSeries = function(seriesModel) {
    var is = false;
    this.eachTargetSeries(function(model) {
      model === seriesModel && (is = true);
    });
    return is;
  };
  VisualMapModel2.prototype.formatValueText = function(value, isCategory2, edgeSymbols) {
    var option = this.option;
    var precision = option.precision;
    var dataBound = this.dataBound;
    var formatter = option.formatter;
    var isMinMax;
    edgeSymbols = edgeSymbols || ["<", ">"];
    if (isArray$1(value)) {
      value = value.slice();
      isMinMax = true;
    }
    var textValue = isCategory2 ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
    if (isString(formatter)) {
      return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
    } else if (isFunction$1(formatter)) {
      return isMinMax ? formatter(value[0], value[1]) : formatter(value);
    }
    if (isMinMax) {
      if (value[0] === dataBound[0]) {
        return edgeSymbols[0] + " " + textValue[1];
      } else if (value[1] === dataBound[1]) {
        return edgeSymbols[1] + " " + textValue[0];
      } else {
        return textValue[0] + " - " + textValue[1];
      }
    } else {
      return textValue;
    }
    function toFixed(val) {
      return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
    }
  };
  VisualMapModel2.prototype.resetExtent = function() {
    var thisOption = this.option;
    var extent3 = asc([thisOption.min, thisOption.max]);
    this._dataExtent = extent3;
  };
  VisualMapModel2.prototype.getDataDimensionIndex = function(data) {
    var optDim = this.option.dimension;
    if (optDim != null) {
      return data.getDimensionIndex(optDim);
    }
    var dimNames = data.dimensions;
    for (var i = dimNames.length - 1; i >= 0; i--) {
      var dimName = dimNames[i];
      var dimInfo = data.getDimensionInfo(dimName);
      if (!dimInfo.isCalculationCoord) {
        return dimInfo.storeDimIndex;
      }
    }
  };
  VisualMapModel2.prototype.getExtent = function() {
    return this._dataExtent.slice();
  };
  VisualMapModel2.prototype.completeVisualOption = function() {
    var ecModel = this.ecModel;
    var thisOption = this.option;
    var base2 = {
      inRange: thisOption.inRange,
      outOfRange: thisOption.outOfRange
    };
    var target = thisOption.target || (thisOption.target = {});
    var controller = thisOption.controller || (thisOption.controller = {});
    merge(target, base2);
    merge(controller, base2);
    var isCategory2 = this.isCategory();
    completeSingle.call(this, target);
    completeSingle.call(this, controller);
    completeInactive.call(this, target, "inRange", "outOfRange");
    completeController.call(this, controller);
    function completeSingle(base3) {
      if (isArray(thisOption.color) && !base3.inRange) {
        base3.inRange = {
          color: thisOption.color.slice().reverse()
        };
      }
      base3.inRange = base3.inRange || {
        color: ecModel.get("gradientColor")
      };
    }
    function completeInactive(base3, stateExist, stateAbsent) {
      var optExist = base3[stateExist];
      var optAbsent = base3[stateAbsent];
      if (optExist && !optAbsent) {
        optAbsent = base3[stateAbsent] = {};
        each$2(optExist, function(visualData, visualType) {
          if (!VisualMapping$1.isValidType(visualType)) {
            return;
          }
          var defa = visualDefault$1.get(visualType, "inactive", isCategory2);
          if (defa != null) {
            optAbsent[visualType] = defa;
            if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
              optAbsent.opacity = [0, 0];
            }
          }
        });
      }
    }
    function completeController(controller2) {
      var symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
      var symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
      var inactiveColor = this.get("inactiveColor");
      var itemSymbol = this.getItemSymbol();
      var defaultSymbol = itemSymbol || "roundRect";
      each$2(this.stateList, function(state) {
        var itemSize = this.itemSize;
        var visuals = controller2[state];
        if (!visuals) {
          visuals = controller2[state] = {
            color: isCategory2 ? inactiveColor : [inactiveColor]
          };
        }
        if (visuals.symbol == null) {
          visuals.symbol = symbolExists && clone$4(symbolExists) || (isCategory2 ? defaultSymbol : [defaultSymbol]);
        }
        if (visuals.symbolSize == null) {
          visuals.symbolSize = symbolSizeExists && clone$4(symbolSizeExists) || (isCategory2 ? itemSize[0] : [itemSize[0], itemSize[0]]);
        }
        visuals.symbol = mapVisual(visuals.symbol, function(symbol) {
          return symbol === "none" ? defaultSymbol : symbol;
        });
        var symbolSize = visuals.symbolSize;
        if (symbolSize != null) {
          var max_1 = -Infinity;
          eachVisual(symbolSize, function(value) {
            value > max_1 && (max_1 = value);
          });
          visuals.symbolSize = mapVisual(symbolSize, function(value) {
            return linearMap$1(value, [0, max_1], [0, itemSize[0]], true);
          });
        }
      }, this);
    }
  };
  VisualMapModel2.prototype.resetItemSize = function() {
    this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
  };
  VisualMapModel2.prototype.isCategory = function() {
    return !!this.option.categories;
  };
  VisualMapModel2.prototype.setSelected = function(selected) {
  };
  VisualMapModel2.prototype.getSelected = function() {
    return null;
  };
  VisualMapModel2.prototype.getValueState = function(value) {
    return null;
  };
  VisualMapModel2.prototype.getVisualMeta = function(getColorVisual2) {
    return null;
  };
  VisualMapModel2.type = "visualMap";
  VisualMapModel2.dependencies = ["series"];
  VisualMapModel2.defaultOption = {
    show: true,
    z: 4,
    seriesIndex: "all",
    min: 0,
    max: 200,
    left: 0,
    right: null,
    top: null,
    bottom: 0,
    itemWidth: null,
    itemHeight: null,
    inverse: false,
    orient: "vertical",
    backgroundColor: "rgba(0,0,0,0)",
    borderColor: "#ccc",
    contentColor: "#5793f3",
    inactiveColor: "#aaa",
    borderWidth: 0,
    padding: 5,
    textGap: 10,
    precision: 0,
    textStyle: {
      color: "#333"
    }
  };
  return VisualMapModel2;
}(ComponentModel$1);
var VisualMapModel$1 = VisualMapModel;
var DEFAULT_BAR_BOUND = [20, 140];
var ContinuousModel = function(_super) {
  __extends(ContinuousModel2, _super);
  function ContinuousModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ContinuousModel2.type;
    return _this;
  }
  ContinuousModel2.prototype.optionUpdated = function(newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);
    this.resetExtent();
    this.resetVisual(function(mappingOption) {
      mappingOption.mappingMethod = "linear";
      mappingOption.dataExtent = this.getExtent();
    });
    this._resetRange();
  };
  ContinuousModel2.prototype.resetItemSize = function() {
    _super.prototype.resetItemSize.apply(this, arguments);
    var itemSize = this.itemSize;
    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
  };
  ContinuousModel2.prototype._resetRange = function() {
    var dataExtent = this.getExtent();
    var range = this.option.range;
    if (!range || range.auto) {
      dataExtent.auto = 1;
      this.option.range = dataExtent;
    } else if (isArray$1(range)) {
      if (range[0] > range[1]) {
        range.reverse();
      }
      range[0] = Math.max(range[0], dataExtent[0]);
      range[1] = Math.min(range[1], dataExtent[1]);
    }
  };
  ContinuousModel2.prototype.completeVisualOption = function() {
    _super.prototype.completeVisualOption.apply(this, arguments);
    each$f(this.stateList, function(state) {
      var symbolSize = this.option.controller[state].symbolSize;
      if (symbolSize && symbolSize[0] !== symbolSize[1]) {
        symbolSize[0] = symbolSize[1] / 3;
      }
    }, this);
  };
  ContinuousModel2.prototype.setSelected = function(selected) {
    this.option.range = selected.slice();
    this._resetRange();
  };
  ContinuousModel2.prototype.getSelected = function() {
    var dataExtent = this.getExtent();
    var dataInterval = asc$2((this.get("range") || []).slice());
    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
    return dataInterval;
  };
  ContinuousModel2.prototype.getValueState = function(value) {
    var range = this.option.range;
    var dataExtent = this.getExtent();
    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
  };
  ContinuousModel2.prototype.findTargetDataIndices = function(range) {
    var result = [];
    this.eachTargetSeries(function(seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  ContinuousModel2.prototype.getVisualMeta = function(getColorVisual2) {
    var oVals = getColorStopValues(this, "outOfRange", this.getExtent());
    var iVals = getColorStopValues(this, "inRange", this.option.range.slice());
    var stops = [];
    function setStop(value, valueState) {
      stops.push({
        value,
        color: getColorVisual2(value, valueState)
      });
    }
    var iIdx = 0;
    var oIdx = 0;
    var iLen = iVals.length;
    var oLen = oVals.length;
    for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
      if (oVals[oIdx] < iVals[iIdx]) {
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
      first && stops.length && setStop(iVals[iIdx], "outOfRange");
      setStop(iVals[iIdx], "inRange");
    }
    for (var first = 1; oIdx < oLen; oIdx++) {
      if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
        if (first) {
          stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
          first = 0;
        }
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    var stopsLen = stops.length;
    return {
      stops,
      outerColors: [stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent"]
    };
  };
  ContinuousModel2.type = "visualMap.continuous";
  ContinuousModel2.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
    align: "auto",
    calculable: false,
    hoverLink: true,
    realtime: true,
    handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
    handleSize: "120%",
    handleStyle: {
      borderColor: "#fff",
      borderWidth: 1
    },
    indicatorIcon: "circle",
    indicatorSize: "50%",
    indicatorStyle: {
      borderColor: "#fff",
      borderWidth: 2,
      shadowBlur: 2,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: "rgba(0,0,0,0.2)"
    }
  });
  return ContinuousModel2;
}(VisualMapModel$1);
function getColorStopValues(visualMapModel, valueState, dataExtent) {
  if (dataExtent[0] === dataExtent[1]) {
    return dataExtent.slice();
  }
  var count2 = 200;
  var step = (dataExtent[1] - dataExtent[0]) / count2;
  var value = dataExtent[0];
  var stopValues = [];
  for (var i = 0; i <= count2 && value < dataExtent[1]; i++) {
    stopValues.push(value);
    value += step;
  }
  stopValues.push(dataExtent[1]);
  return stopValues;
}
var ContinuousModel$1 = ContinuousModel;
var VisualMapView = function(_super) {
  __extends(VisualMapView2, _super);
  function VisualMapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = VisualMapView2.type;
    _this.autoPositionValues = {
      left: 1,
      right: 1,
      top: 1,
      bottom: 1
    };
    return _this;
  }
  VisualMapView2.prototype.init = function(ecModel, api) {
    this.ecModel = ecModel;
    this.api = api;
  };
  VisualMapView2.prototype.render = function(visualMapModel, ecModel, api, payload) {
    this.visualMapModel = visualMapModel;
    if (visualMapModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    this.doRender(visualMapModel, ecModel, api, payload);
  };
  VisualMapView2.prototype.renderBackground = function(group) {
    var visualMapModel = this.visualMapModel;
    var padding = normalizeCssArray(visualMapModel.get("padding") || 0);
    var rect = group.getBoundingRect();
    group.add(new Rect$3({
      z2: -1,
      silent: true,
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[3] + padding[1],
        height: rect.height + padding[0] + padding[2]
      },
      style: {
        fill: visualMapModel.get("backgroundColor"),
        stroke: visualMapModel.get("borderColor"),
        lineWidth: visualMapModel.get("borderWidth")
      }
    }));
  };
  VisualMapView2.prototype.getControllerVisual = function(targetValue, visualCluster, opts) {
    opts = opts || {};
    var forceState = opts.forceState;
    var visualMapModel = this.visualMapModel;
    var visualObj = {};
    if (visualCluster === "color") {
      var defaultColor = visualMapModel.get("contentColor");
      visualObj.color = defaultColor;
    }
    function getter(key) {
      return visualObj[key];
    }
    function setter(key, value) {
      visualObj[key] = value;
    }
    var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
    var visualTypes = VisualMapping$1.prepareVisualTypes(mappings);
    each$f(visualTypes, function(type) {
      var visualMapping = mappings[type];
      if (opts.convertOpacityToAlpha && type === "opacity") {
        type = "colorAlpha";
        visualMapping = mappings.__alphaForOpacity;
      }
      if (VisualMapping$1.dependsOn(type, visualCluster)) {
        visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
      }
    });
    return visualObj[visualCluster];
  };
  VisualMapView2.prototype.positionGroup = function(group) {
    var model = this.visualMapModel;
    var api = this.api;
    positionElement(group, model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  VisualMapView2.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
  };
  VisualMapView2.type = "visualMap";
  return VisualMapView2;
}(ComponentView$1);
var VisualMapView$1 = VisualMapView;
var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
function getItemAlign(visualMapModel, api, itemSize) {
  var modelOption = visualMapModel.option;
  var itemAlign = modelOption.align;
  if (itemAlign != null && itemAlign !== "auto") {
    return itemAlign;
  }
  var ecSize = {
    width: api.getWidth(),
    height: api.getHeight()
  };
  var realIndex = modelOption.orient === "horizontal" ? 1 : 0;
  var reals = paramsSet[realIndex];
  var fakeValue = [0, null, 10];
  var layoutInput = {};
  for (var i = 0; i < 3; i++) {
    layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
    layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
  }
  var rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
  var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
  return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
}
function makeHighDownBatch(batch, visualMapModel) {
  each$f(batch || [], function(batchItem) {
    if (batchItem.dataIndex != null) {
      batchItem.dataIndexInside = batchItem.dataIndex;
      batchItem.dataIndex = null;
    }
    batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
  });
  return batch;
}
var linearMap = linearMap$2;
var each$1 = each$f;
var mathMin$1 = Math.min;
var mathMax$1 = Math.max;
var HOVER_LINK_SIZE = 12;
var HOVER_LINK_OUT = 6;
var ContinuousView = function(_super) {
  __extends(ContinuousView2, _super);
  function ContinuousView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = ContinuousView2.type;
    _this._shapes = {};
    _this._dataInterval = [];
    _this._handleEnds = [];
    _this._hoverLinkDataIndices = [];
    return _this;
  }
  ContinuousView2.prototype.doRender = function(visualMapModel, ecModel, api, payload) {
    this._api = api;
    if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
      this._buildView();
    }
  };
  ContinuousView2.prototype._buildView = function() {
    this.group.removeAll();
    var visualMapModel = this.visualMapModel;
    var thisGroup = this.group;
    this._orient = visualMapModel.get("orient");
    this._useHandle = visualMapModel.get("calculable");
    this._resetInterval();
    this._renderBar(thisGroup);
    var dataRangeText = visualMapModel.get("text");
    this._renderEndsText(thisGroup, dataRangeText, 0);
    this._renderEndsText(thisGroup, dataRangeText, 1);
    this._updateView(true);
    this.renderBackground(thisGroup);
    this._updateView();
    this._enableHoverLinkToSeries();
    this._enableHoverLinkFromSeries();
    this.positionGroup(thisGroup);
  };
  ContinuousView2.prototype._renderEndsText = function(group, dataRangeText, endsIndex) {
    if (!dataRangeText) {
      return;
    }
    var text = dataRangeText[1 - endsIndex];
    text = text != null ? text + "" : "";
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get("textGap");
    var itemSize = visualMapModel.itemSize;
    var barGroup = this._shapes.mainGroup;
    var position2 = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
    var align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
    var orient = this._orient;
    var textStyleModel = this.visualMapModel.textStyleModel;
    this.group.add(new ZRText$1({
      style: {
        x: position2[0],
        y: position2[1],
        verticalAlign: orient === "horizontal" ? "middle" : align,
        align: orient === "horizontal" ? align : "center",
        text,
        font: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor()
      }
    }));
  };
  ContinuousView2.prototype._renderBar = function(targetGroup) {
    var visualMapModel = this.visualMapModel;
    var shapes = this._shapes;
    var itemSize = visualMapModel.itemSize;
    var orient = this._orient;
    var useHandle = this._useHandle;
    var itemAlign = getItemAlign(visualMapModel, this.api, itemSize);
    var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);
    var gradientBarGroup = new Group$4();
    mainGroup.add(gradientBarGroup);
    gradientBarGroup.add(shapes.outOfRange = createPolygon());
    gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, bind$1(this._dragHandle, this, "all", false), bind$1(this._dragHandle, this, "all", true)));
    gradientBarGroup.setClipPath(new Rect$3({
      shape: {
        x: 0,
        y: 0,
        width: itemSize[0],
        height: itemSize[1],
        r: 3
      }
    }));
    var textRect = visualMapModel.textStyleModel.getTextRect("\u56FD");
    var textSize = mathMax$1(textRect.width, textRect.height);
    if (useHandle) {
      shapes.handleThumbs = [];
      shapes.handleLabels = [];
      shapes.handleLabelPoints = [];
      this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);
      this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);
    }
    this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);
    targetGroup.add(mainGroup);
  };
  ContinuousView2.prototype._createHandle = function(visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
    var onDrift = bind$1(this._dragHandle, this, handleIndex, false);
    var onDragEnd = bind$1(this._dragHandle, this, handleIndex, true);
    var handleSize = parsePercent$2(visualMapModel.get("handleSize"), itemSize[0]);
    var handleThumb = createSymbol$1(visualMapModel.get("handleIcon"), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
    var cursor = getCursor(this._orient);
    handleThumb.attr({
      cursor,
      draggable: true,
      drift: onDrift,
      ondragend: onDragEnd,
      onmousemove: function(e2) {
        stop(e2.event);
      }
    });
    handleThumb.x = itemSize[0] / 2;
    handleThumb.useStyle(visualMapModel.getModel("handleStyle").getItemStyle());
    handleThumb.setStyle({
      strokeNoScale: true,
      strokeFirst: true
    });
    handleThumb.style.lineWidth *= 2;
    handleThumb.ensureState("emphasis").style = visualMapModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
    setAsHighDownDispatcher(handleThumb, true);
    mainGroup.add(handleThumb);
    var textStyleModel = this.visualMapModel.textStyleModel;
    var handleLabel = new ZRText$1({
      cursor,
      draggable: true,
      drift: onDrift,
      onmousemove: function(e2) {
        stop(e2.event);
      },
      ondragend: onDragEnd,
      style: {
        x: 0,
        y: 0,
        text: "",
        font: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor()
      }
    });
    handleLabel.ensureState("blur").style = {
      opacity: 0.1
    };
    handleLabel.stateTransition = {
      duration: 200
    };
    this.group.add(handleLabel);
    var handleLabelPoint = [handleSize, 0];
    var shapes = this._shapes;
    shapes.handleThumbs[handleIndex] = handleThumb;
    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
    shapes.handleLabels[handleIndex] = handleLabel;
  };
  ContinuousView2.prototype._createIndicator = function(visualMapModel, mainGroup, itemSize, textSize, orient) {
    var scale2 = parsePercent$2(visualMapModel.get("indicatorSize"), itemSize[0]);
    var indicator = createSymbol$1(visualMapModel.get("indicatorIcon"), -scale2 / 2, -scale2 / 2, scale2, scale2, null, true);
    indicator.attr({
      cursor: "move",
      invisible: true,
      silent: true,
      x: itemSize[0] / 2
    });
    var indicatorStyle = visualMapModel.getModel("indicatorStyle").getItemStyle();
    if (indicator instanceof ZRImage$1) {
      var pathStyle = indicator.style;
      indicator.useStyle(extend$1({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, indicatorStyle));
    } else {
      indicator.useStyle(indicatorStyle);
    }
    mainGroup.add(indicator);
    var textStyleModel = this.visualMapModel.textStyleModel;
    var indicatorLabel = new ZRText$1({
      silent: true,
      invisible: true,
      style: {
        x: 0,
        y: 0,
        text: "",
        font: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor()
      }
    });
    this.group.add(indicatorLabel);
    var indicatorLabelPoint = [(orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];
    var shapes = this._shapes;
    shapes.indicator = indicator;
    shapes.indicatorLabel = indicatorLabel;
    shapes.indicatorLabelPoint = indicatorLabelPoint;
    this._firstShowIndicator = true;
  };
  ContinuousView2.prototype._dragHandle = function(handleIndex, isEnd, dx, dy) {
    if (!this._useHandle) {
      return;
    }
    this._dragging = !isEnd;
    if (!isEnd) {
      var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);
      this._updateInterval(handleIndex, vertex[1]);
      this._hideIndicator();
      this._updateView();
    }
    if (isEnd === !this.visualMapModel.get("realtime")) {
      this.api.dispatchAction({
        type: "selectDataRange",
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected: this._dataInterval.slice()
      });
    }
    if (isEnd) {
      !this._hovering && this._clearHoverLinkToSeries();
    } else if (useHoverLinkOnHandle(this.visualMapModel)) {
      this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
    }
  };
  ContinuousView2.prototype._resetInterval = function() {
    var visualMapModel = this.visualMapModel;
    var dataInterval = this._dataInterval = visualMapModel.getSelected();
    var dataExtent = visualMapModel.getExtent();
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
  };
  ContinuousView2.prototype._updateInterval = function(handleIndex, delta) {
    delta = delta || 0;
    var visualMapModel = this.visualMapModel;
    var handleEnds = this._handleEnds;
    var sizeExtent = [0, visualMapModel.itemSize[1]];
    sliderMove(delta, handleEnds, sizeExtent, handleIndex, 0);
    var dataExtent = visualMapModel.getExtent();
    this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
  };
  ContinuousView2.prototype._updateView = function(forSketch) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var shapes = this._shapes;
    var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
    var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
    var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
    var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
    shapes.inRange.setStyle({
      fill: visualInRange.barColor
    }).setShape("points", visualInRange.barPoints);
    shapes.outOfRange.setStyle({
      fill: visualOutOfRange.barColor
    }).setShape("points", visualOutOfRange.barPoints);
    this._updateHandle(inRangeHandleEnds, visualInRange);
  };
  ContinuousView2.prototype._createBarVisual = function(dataInterval, dataExtent, handleEnds, forceState) {
    var opts = {
      forceState,
      convertOpacityToAlpha: true
    };
    var colorStops = this._makeColorGradient(dataInterval, opts);
    var symbolSizes = [this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts)];
    var barPoints = this._createBarPoints(handleEnds, symbolSizes);
    return {
      barColor: new LinearGradient$1(0, 0, 0, 1, colorStops),
      barPoints,
      handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
    };
  };
  ContinuousView2.prototype._makeColorGradient = function(dataInterval, opts) {
    var sampleNumber = 100;
    var colorStops = [];
    var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
    colorStops.push({
      color: this.getControllerVisual(dataInterval[0], "color", opts),
      offset: 0
    });
    for (var i = 1; i < sampleNumber; i++) {
      var currValue = dataInterval[0] + step * i;
      if (currValue > dataInterval[1]) {
        break;
      }
      colorStops.push({
        color: this.getControllerVisual(currValue, "color", opts),
        offset: i / sampleNumber
      });
    }
    colorStops.push({
      color: this.getControllerVisual(dataInterval[1], "color", opts),
      offset: 1
    });
    return colorStops;
  };
  ContinuousView2.prototype._createBarPoints = function(handleEnds, symbolSizes) {
    var itemSize = this.visualMapModel.itemSize;
    return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
  };
  ContinuousView2.prototype._createBarGroup = function(itemAlign) {
    var orient = this._orient;
    var inverse = this.visualMapModel.get("inverse");
    return new Group$4(orient === "horizontal" && !inverse ? {
      scaleX: itemAlign === "bottom" ? 1 : -1,
      rotation: Math.PI / 2
    } : orient === "horizontal" && inverse ? {
      scaleX: itemAlign === "bottom" ? -1 : 1,
      rotation: -Math.PI / 2
    } : orient === "vertical" && !inverse ? {
      scaleX: itemAlign === "left" ? 1 : -1,
      scaleY: -1
    } : {
      scaleX: itemAlign === "left" ? 1 : -1
    });
  };
  ContinuousView2.prototype._updateHandle = function(handleEnds, visualInRange) {
    if (!this._useHandle) {
      return;
    }
    var shapes = this._shapes;
    var visualMapModel = this.visualMapModel;
    var handleThumbs = shapes.handleThumbs;
    var handleLabels = shapes.handleLabels;
    var itemSize = visualMapModel.itemSize;
    var dataExtent = visualMapModel.getExtent();
    each$1([0, 1], function(handleIndex) {
      var handleThumb = handleThumbs[handleIndex];
      handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
      handleThumb.y = handleEnds[handleIndex];
      var val = linearMap(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
      var symbolSize = this.getControllerVisual(val, "symbolSize");
      handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
      handleThumb.x = itemSize[0] - symbolSize / 2;
      var textPoint = applyTransform(shapes.handleLabelPoints[handleIndex], getTransform$1(handleThumb, this.group));
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
        verticalAlign: "middle",
        align: this._orient === "vertical" ? this._applyTransform("left", shapes.mainGroup) : "center"
      });
    }, this);
  };
  ContinuousView2.prototype._showIndicator = function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
    var visualMapModel = this.visualMapModel;
    var dataExtent = visualMapModel.getExtent();
    var itemSize = visualMapModel.itemSize;
    var sizeExtent = [0, itemSize[1]];
    var shapes = this._shapes;
    var indicator = shapes.indicator;
    if (!indicator) {
      return;
    }
    indicator.attr("invisible", false);
    var opts = {
      convertOpacityToAlpha: true
    };
    var color = this.getControllerVisual(cursorValue, "color", opts);
    var symbolSize = this.getControllerVisual(cursorValue, "symbolSize");
    var y = linearMap(cursorValue, dataExtent, sizeExtent, true);
    var x = itemSize[0] - symbolSize / 2;
    var oldIndicatorPos = {
      x: indicator.x,
      y: indicator.y
    };
    indicator.y = y;
    indicator.x = x;
    var textPoint = applyTransform(shapes.indicatorLabelPoint, getTransform$1(indicator, this.group));
    var indicatorLabel = shapes.indicatorLabel;
    indicatorLabel.attr("invisible", false);
    var align = this._applyTransform("left", shapes.mainGroup);
    var orient = this._orient;
    var isHorizontal = orient === "horizontal";
    indicatorLabel.setStyle({
      text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
      verticalAlign: isHorizontal ? align : "middle",
      align: isHorizontal ? "center" : align
    });
    var indicatorNewProps = {
      x,
      y,
      style: {
        fill: color
      }
    };
    var labelNewProps = {
      style: {
        x: textPoint[0],
        y: textPoint[1]
      }
    };
    if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
      var animationCfg = {
        duration: 100,
        easing: "cubicInOut",
        additive: true
      };
      indicator.x = oldIndicatorPos.x;
      indicator.y = oldIndicatorPos.y;
      indicator.animateTo(indicatorNewProps, animationCfg);
      indicatorLabel.animateTo(labelNewProps, animationCfg);
    } else {
      indicator.attr(indicatorNewProps);
      indicatorLabel.attr(labelNewProps);
    }
    this._firstShowIndicator = false;
    var handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        this._api.enterBlur(handleLabels[i]);
      }
    }
  };
  ContinuousView2.prototype._enableHoverLinkToSeries = function() {
    var self2 = this;
    this._shapes.mainGroup.on("mousemove", function(e2) {
      self2._hovering = true;
      if (!self2._dragging) {
        var itemSize = self2.visualMapModel.itemSize;
        var pos = self2._applyTransform([e2.offsetX, e2.offsetY], self2._shapes.mainGroup, true, true);
        pos[1] = mathMin$1(mathMax$1(0, pos[1]), itemSize[1]);
        self2._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
      }
    }).on("mouseout", function() {
      self2._hovering = false;
      !self2._dragging && self2._clearHoverLinkToSeries();
    });
  };
  ContinuousView2.prototype._enableHoverLinkFromSeries = function() {
    var zr = this.api.getZr();
    if (this.visualMapModel.option.hoverLink) {
      zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
      zr.on("mouseout", this._hideIndicator, this);
    } else {
      this._clearHoverLinkFromSeries();
    }
  };
  ContinuousView2.prototype._doHoverLinkToSeries = function(cursorPos, hoverOnBar) {
    var visualMapModel = this.visualMapModel;
    var itemSize = visualMapModel.itemSize;
    if (!visualMapModel.option.hoverLink) {
      return;
    }
    var sizeExtent = [0, itemSize[1]];
    var dataExtent = visualMapModel.getExtent();
    cursorPos = mathMin$1(mathMax$1(sizeExtent[0], cursorPos), sizeExtent[1]);
    var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
    var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
    var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
    var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];
    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
    hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
    if (hoverOnBar) {
      if (valueRange[0] === -Infinity) {
        this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
      } else if (valueRange[1] === Infinity) {
        this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
      } else {
        this._showIndicator(cursorValue, cursorValue, "\u2248 ", halfHoverLinkSize);
      }
    }
    var oldBatch = this._hoverLinkDataIndices;
    var newBatch = [];
    if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
      newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
    }
    var resultBatches = compressBatches(oldBatch, newBatch);
    this._dispatchHighDown("downplay", makeHighDownBatch(resultBatches[0], visualMapModel));
    this._dispatchHighDown("highlight", makeHighDownBatch(resultBatches[1], visualMapModel));
  };
  ContinuousView2.prototype._hoverLinkFromSeriesMouseOver = function(e2) {
    var el = e2.target;
    var visualMapModel = this.visualMapModel;
    if (!el || getECData(el).dataIndex == null) {
      return;
    }
    var ecData = getECData(el);
    var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);
    if (!visualMapModel.isTargetSeries(dataModel)) {
      return;
    }
    var data = dataModel.getData(ecData.dataType);
    var value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);
    if (!isNaN(value)) {
      this._showIndicator(value, value);
    }
  };
  ContinuousView2.prototype._hideIndicator = function() {
    var shapes = this._shapes;
    shapes.indicator && shapes.indicator.attr("invisible", true);
    shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
    var handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (var i = 0; i < handleLabels.length; i++) {
        this._api.leaveBlur(handleLabels[i]);
      }
    }
  };
  ContinuousView2.prototype._clearHoverLinkToSeries = function() {
    this._hideIndicator();
    var indices = this._hoverLinkDataIndices;
    this._dispatchHighDown("downplay", makeHighDownBatch(indices, this.visualMapModel));
    indices.length = 0;
  };
  ContinuousView2.prototype._clearHoverLinkFromSeries = function() {
    this._hideIndicator();
    var zr = this.api.getZr();
    zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
    zr.off("mouseout", this._hideIndicator);
  };
  ContinuousView2.prototype._applyTransform = function(vertex, element, inverse, global2) {
    var transform2 = getTransform$1(element, global2 ? null : this.group);
    return isArray$1(vertex) ? applyTransform(vertex, transform2, inverse) : transformDirection(vertex, transform2, inverse);
  };
  ContinuousView2.prototype._dispatchHighDown = function(type, batch) {
    batch && batch.length && this.api.dispatchAction({
      type,
      batch
    });
  };
  ContinuousView2.prototype.dispose = function() {
    this._clearHoverLinkFromSeries();
    this._clearHoverLinkToSeries();
  };
  ContinuousView2.prototype.remove = function() {
    this._clearHoverLinkFromSeries();
    this._clearHoverLinkToSeries();
  };
  ContinuousView2.type = "visualMap.continuous";
  return ContinuousView2;
}(VisualMapView$1);
function createPolygon(points2, cursor, onDrift, onDragEnd) {
  return new Polygon$1({
    shape: {
      points: points2
    },
    draggable: !!onDrift,
    cursor,
    drift: onDrift,
    onmousemove: function(e2) {
      stop(e2.event);
    },
    ondragend: onDragEnd
  });
}
function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
  var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
  var hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
  if (hoverLinkDataSize) {
    halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
  }
  return halfHoverLinkSize;
}
function useHoverLinkOnHandle(visualMapModel) {
  var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
  return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
}
function getCursor(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var ContinuousView$1 = ContinuousView;
var visualMapActionInfo = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  update: "update"
};
var visualMapActionHander = function(payload, ecModel) {
  ecModel.eachComponent({
    mainType: "visualMap",
    query: payload
  }, function(model) {
    model.setSelected(payload.selected);
  });
};
var visualMapEncodingHandlers = [
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      var resetDefines = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        var pipelineContext = seriesModel.pipelineContext;
        if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
          return;
        }
        resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind$1(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));
      });
      return resetDefines;
    }
  },
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      var visualMetaList = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        if (visualMapModel.isTargetSeries(seriesModel)) {
          var visualMeta = visualMapModel.getVisualMeta(bind$1(getColorVisual, null, seriesModel, visualMapModel)) || {
            stops: [],
            outerColors: []
          };
          var dimIdx = visualMapModel.getDataDimensionIndex(data);
          if (dimIdx >= 0) {
            visualMeta.dimension = dimIdx;
            visualMetaList.push(visualMeta);
          }
        }
      });
      seriesModel.getData().setVisual("visualMeta", visualMetaList);
    }
  }
];
function getColorVisual(seriesModel, visualMapModel, value, valueState) {
  var mappings = visualMapModel.targetVisuals[valueState];
  var visualTypes = VisualMapping$1.prepareVisualTypes(mappings);
  var resultVisual = {
    color: getVisualFromData(seriesModel.getData(), "color")
  };
  for (var i = 0, len2 = visualTypes.length; i < len2; i++) {
    var type = visualTypes[i];
    var mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
    mapping && mapping.applyVisual(value, getVisual, setVisual);
  }
  return resultVisual.color;
  function getVisual(key) {
    return resultVisual[key];
  }
  function setVisual(key, value2) {
    resultVisual[key] = value2;
  }
}
var each = each$f;
function visualMapPreprocessor(option) {
  var visualMap = option && option.visualMap;
  if (!isArray$1(visualMap)) {
    visualMap = visualMap ? [visualMap] : [];
  }
  each(visualMap, function(opt) {
    if (!opt) {
      return;
    }
    if (has(opt, "splitList") && !has(opt, "pieces")) {
      opt.pieces = opt.splitList;
      delete opt.splitList;
    }
    var pieces = opt.pieces;
    if (pieces && isArray$1(pieces)) {
      each(pieces, function(piece) {
        if (isObject$3(piece)) {
          if (has(piece, "start") && !has(piece, "min")) {
            piece.min = piece.start;
          }
          if (has(piece, "end") && !has(piece, "max")) {
            piece.max = piece.end;
          }
        }
      });
    }
  });
}
function has(obj, name) {
  return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
}
var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }
  installed = true;
  registers.registerSubTypeDefaulter("visualMap", function(option) {
    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
  });
  registers.registerAction(visualMapActionInfo, visualMapActionHander);
  each$f(visualMapEncodingHandlers, function(handler) {
    registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
  });
  registers.registerPreprocessor(visualMapPreprocessor);
}
function install$l(registers) {
  registers.registerComponentModel(ContinuousModel$1);
  registers.registerComponentView(ContinuousView$1);
  installCommon(registers);
}
var PiecewiseModel = function(_super) {
  __extends(PiecewiseModel2, _super);
  function PiecewiseModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PiecewiseModel2.type;
    _this._pieceList = [];
    return _this;
  }
  PiecewiseModel2.prototype.optionUpdated = function(newOption, isInit) {
    _super.prototype.optionUpdated.apply(this, arguments);
    this.resetExtent();
    var mode = this._mode = this._determineMode();
    this._pieceList = [];
    resetMethods[this._mode].call(this, this._pieceList);
    this._resetSelected(newOption, isInit);
    var categories = this.option.categories;
    this.resetVisual(function(mappingOption, state) {
      if (mode === "categories") {
        mappingOption.mappingMethod = "category";
        mappingOption.categories = clone$4(categories);
      } else {
        mappingOption.dataExtent = this.getExtent();
        mappingOption.mappingMethod = "piecewise";
        mappingOption.pieceList = map$1(this._pieceList, function(piece) {
          piece = clone$4(piece);
          if (state !== "inRange") {
            piece.visual = null;
          }
          return piece;
        });
      }
    });
  };
  PiecewiseModel2.prototype.completeVisualOption = function() {
    var option = this.option;
    var visualTypesInPieces = {};
    var visualTypes = VisualMapping$1.listVisualTypes();
    var isCategory2 = this.isCategory();
    each$f(option.pieces, function(piece) {
      each$f(visualTypes, function(visualType) {
        if (piece.hasOwnProperty(visualType)) {
          visualTypesInPieces[visualType] = 1;
        }
      });
    });
    each$f(visualTypesInPieces, function(v, visualType) {
      var exists = false;
      each$f(this.stateList, function(state) {
        exists = exists || has2(option, state, visualType) || has2(option.target, state, visualType);
      }, this);
      !exists && each$f(this.stateList, function(state) {
        (option[state] || (option[state] = {}))[visualType] = visualDefault$1.get(visualType, state === "inRange" ? "active" : "inactive", isCategory2);
      });
    }, this);
    function has2(obj, state, visualType) {
      return obj && obj[state] && obj[state].hasOwnProperty(visualType);
    }
    _super.prototype.completeVisualOption.apply(this, arguments);
  };
  PiecewiseModel2.prototype._resetSelected = function(newOption, isInit) {
    var thisOption = this.option;
    var pieceList = this._pieceList;
    var selected = (isInit ? thisOption : newOption).selected || {};
    thisOption.selected = selected;
    each$f(pieceList, function(piece, index) {
      var key = this.getSelectedMapKey(piece);
      if (!selected.hasOwnProperty(key)) {
        selected[key] = true;
      }
    }, this);
    if (thisOption.selectedMode === "single") {
      var hasSel_1 = false;
      each$f(pieceList, function(piece, index) {
        var key = this.getSelectedMapKey(piece);
        if (selected[key]) {
          hasSel_1 ? selected[key] = false : hasSel_1 = true;
        }
      }, this);
    }
  };
  PiecewiseModel2.prototype.getItemSymbol = function() {
    return this.get("itemSymbol");
  };
  PiecewiseModel2.prototype.getSelectedMapKey = function(piece) {
    return this._mode === "categories" ? piece.value + "" : piece.index + "";
  };
  PiecewiseModel2.prototype.getPieceList = function() {
    return this._pieceList;
  };
  PiecewiseModel2.prototype._determineMode = function() {
    var option = this.option;
    return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
  };
  PiecewiseModel2.prototype.setSelected = function(selected) {
    this.option.selected = clone$4(selected);
  };
  PiecewiseModel2.prototype.getValueState = function(value) {
    var index = VisualMapping$1.findPieceIndex(value, this._pieceList);
    return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? "inRange" : "outOfRange" : "outOfRange";
  };
  PiecewiseModel2.prototype.findTargetDataIndices = function(pieceIndex) {
    var result = [];
    var pieceList = this._pieceList;
    this.eachTargetSeries(function(seriesModel) {
      var dataIndices = [];
      var data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        var pIdx = VisualMapping$1.findPieceIndex(value, pieceList);
        pIdx === pieceIndex && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  };
  PiecewiseModel2.prototype.getRepresentValue = function(piece) {
    var representValue;
    if (this.isCategory()) {
      representValue = piece.value;
    } else {
      if (piece.value != null) {
        representValue = piece.value;
      } else {
        var pieceInterval = piece.interval || [];
        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
      }
    }
    return representValue;
  };
  PiecewiseModel2.prototype.getVisualMeta = function(getColorVisual2) {
    if (this.isCategory()) {
      return;
    }
    var stops = [];
    var outerColors = ["", ""];
    var visualMapModel = this;
    function setStop(interval, valueState) {
      var representValue = visualMapModel.getRepresentValue({
        interval
      });
      if (!valueState) {
        valueState = visualMapModel.getValueState(representValue);
      }
      var color = getColorVisual2(representValue, valueState);
      if (interval[0] === -Infinity) {
        outerColors[0] = color;
      } else if (interval[1] === Infinity) {
        outerColors[1] = color;
      } else {
        stops.push({
          value: interval[0],
          color
        }, {
          value: interval[1],
          color
        });
      }
    }
    var pieceList = this._pieceList.slice();
    if (!pieceList.length) {
      pieceList.push({
        interval: [-Infinity, Infinity]
      });
    } else {
      var edge = pieceList[0].interval[0];
      edge !== -Infinity && pieceList.unshift({
        interval: [-Infinity, edge]
      });
      edge = pieceList[pieceList.length - 1].interval[1];
      edge !== Infinity && pieceList.push({
        interval: [edge, Infinity]
      });
    }
    var curr = -Infinity;
    each$f(pieceList, function(piece) {
      var interval = piece.interval;
      if (interval) {
        interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
        setStop(interval.slice());
        curr = interval[1];
      }
    }, this);
    return {
      stops,
      outerColors
    };
  };
  PiecewiseModel2.type = "visualMap.piecewise";
  PiecewiseModel2.defaultOption = inheritDefaultOption(VisualMapModel$1.defaultOption, {
    selected: null,
    minOpen: false,
    maxOpen: false,
    align: "auto",
    itemWidth: 20,
    itemHeight: 14,
    itemSymbol: "roundRect",
    pieces: null,
    categories: null,
    splitNumber: 5,
    selectedMode: "multiple",
    itemGap: 10,
    hoverLink: true
  });
  return PiecewiseModel2;
}(VisualMapModel$1);
var resetMethods = {
  splitNumber: function(outPieceList) {
    var thisOption = this.option;
    var precision = Math.min(thisOption.precision, 20);
    var dataExtent = this.getExtent();
    var splitNumber = thisOption.splitNumber;
    splitNumber = Math.max(parseInt(splitNumber, 10), 1);
    thisOption.splitNumber = splitNumber;
    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
      precision++;
    }
    thisOption.precision = precision;
    splitStep = +splitStep.toFixed(precision);
    if (thisOption.minOpen) {
      outPieceList.push({
        interval: [-Infinity, dataExtent[0]],
        close: [0, 0]
      });
    }
    for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
      var max3 = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
      outPieceList.push({
        interval: [curr, max3],
        close: [1, 1]
      });
    }
    if (thisOption.maxOpen) {
      outPieceList.push({
        interval: [dataExtent[1], Infinity],
        close: [0, 0]
      });
    }
    reformIntervals(outPieceList);
    each$f(outPieceList, function(piece, index2) {
      piece.index = index2;
      piece.text = this.formatValueText(piece.interval);
    }, this);
  },
  categories: function(outPieceList) {
    var thisOption = this.option;
    each$f(thisOption.categories, function(cate) {
      outPieceList.push({
        text: this.formatValueText(cate, true),
        value: cate
      });
    }, this);
    normalizeReverse(thisOption, outPieceList);
  },
  pieces: function(outPieceList) {
    var thisOption = this.option;
    each$f(thisOption.pieces, function(pieceListItem, index) {
      if (!isObject$3(pieceListItem)) {
        pieceListItem = {
          value: pieceListItem
        };
      }
      var item = {
        text: "",
        index
      };
      if (pieceListItem.label != null) {
        item.text = pieceListItem.label;
      }
      if (pieceListItem.hasOwnProperty("value")) {
        var value = item.value = pieceListItem.value;
        item.interval = [value, value];
        item.close = [1, 1];
      } else {
        var interval = item.interval = [];
        var close_1 = item.close = [0, 0];
        var closeList = [1, 0, 1];
        var infinityList = [-Infinity, Infinity];
        var useMinMax = [];
        for (var lg = 0; lg < 2; lg++) {
          var names = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
          for (var i = 0; i < 3 && interval[lg] == null; i++) {
            interval[lg] = pieceListItem[names[i]];
            close_1[lg] = closeList[i];
            useMinMax[lg] = i === 2;
          }
          interval[lg] == null && (interval[lg] = infinityList[lg]);
        }
        useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);
        useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);
        if (interval[0] === interval[1] && close_1[0] && close_1[1]) {
          item.value = interval[0];
        }
      }
      item.visual = VisualMapping$1.retrieveVisuals(pieceListItem);
      outPieceList.push(item);
    }, this);
    normalizeReverse(thisOption, outPieceList);
    reformIntervals(outPieceList);
    each$f(outPieceList, function(piece) {
      var close = piece.close;
      var edgeSymbols = [["<", "\u2264"][close[1]], [">", "\u2265"][close[0]]];
      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
    }, this);
  }
};
function normalizeReverse(thisOption, pieceList) {
  var inverse = thisOption.inverse;
  if (thisOption.orient === "vertical" ? !inverse : inverse) {
    pieceList.reverse();
  }
}
var PiecewiseModel$1 = PiecewiseModel;
var PiecewiseVisualMapView = function(_super) {
  __extends(PiecewiseVisualMapView2, _super);
  function PiecewiseVisualMapView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = PiecewiseVisualMapView2.type;
    return _this;
  }
  PiecewiseVisualMapView2.prototype.doRender = function() {
    var thisGroup = this.group;
    thisGroup.removeAll();
    var visualMapModel = this.visualMapModel;
    var textGap = visualMapModel.get("textGap");
    var textStyleModel = visualMapModel.textStyleModel;
    var textFont = textStyleModel.getFont();
    var textFill = textStyleModel.getTextColor();
    var itemAlign = this._getItemAlign();
    var itemSize = visualMapModel.itemSize;
    var viewData = this._getViewData();
    var endsText = viewData.endsText;
    var showLabel = retrieve$2(visualMapModel.get("showLabel", true), !endsText);
    endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
    each$f(viewData.viewPieceList, function(item) {
      var piece = item.piece;
      var itemGroup = new Group$4();
      itemGroup.onclick = bind$1(this._onItemClick, this, piece);
      this._enableHoverLink(itemGroup, item.indexInModelPieceList);
      var representValue = visualMapModel.getRepresentValue(piece);
      this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
      if (showLabel) {
        var visualState = this.visualMapModel.getValueState(representValue);
        itemGroup.add(new ZRText$1({
          style: {
            x: itemAlign === "right" ? -textGap : itemSize[0] + textGap,
            y: itemSize[1] / 2,
            text: piece.text,
            verticalAlign: "middle",
            align: itemAlign,
            font: textFont,
            fill: textFill,
            opacity: visualState === "outOfRange" ? 0.5 : 1
          }
        }));
      }
      thisGroup.add(itemGroup);
    }, this);
    endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
    box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
    this.renderBackground(thisGroup);
    this.positionGroup(thisGroup);
  };
  PiecewiseVisualMapView2.prototype._enableHoverLink = function(itemGroup, pieceIndex) {
    var _this = this;
    itemGroup.on("mouseover", function() {
      return onHoverLink("highlight");
    }).on("mouseout", function() {
      return onHoverLink("downplay");
    });
    var onHoverLink = function(method) {
      var visualMapModel = _this.visualMapModel;
      visualMapModel.option.hoverLink && _this.api.dispatchAction({
        type: method,
        batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
      });
    };
  };
  PiecewiseVisualMapView2.prototype._getItemAlign = function() {
    var visualMapModel = this.visualMapModel;
    var modelOption = visualMapModel.option;
    if (modelOption.orient === "vertical") {
      return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
    } else {
      var align = modelOption.align;
      if (!align || align === "auto") {
        align = "left";
      }
      return align;
    }
  };
  PiecewiseVisualMapView2.prototype._renderEndsText = function(group, text, itemSize, showLabel, itemAlign) {
    if (!text) {
      return;
    }
    var itemGroup = new Group$4();
    var textStyleModel = this.visualMapModel.textStyleModel;
    itemGroup.add(new ZRText$1({
      style: {
        x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
        y: itemSize[1] / 2,
        verticalAlign: "middle",
        align: showLabel ? itemAlign : "center",
        text,
        font: textStyleModel.getFont(),
        fill: textStyleModel.getTextColor()
      }
    }));
    group.add(itemGroup);
  };
  PiecewiseVisualMapView2.prototype._getViewData = function() {
    var visualMapModel = this.visualMapModel;
    var viewPieceList = map$1(visualMapModel.getPieceList(), function(piece, index) {
      return {
        piece,
        indexInModelPieceList: index
      };
    });
    var endsText = visualMapModel.get("text");
    var orient = visualMapModel.get("orient");
    var inverse = visualMapModel.get("inverse");
    if (orient === "horizontal" ? inverse : !inverse) {
      viewPieceList.reverse();
    } else if (endsText) {
      endsText = endsText.slice().reverse();
    }
    return {
      viewPieceList,
      endsText
    };
  };
  PiecewiseVisualMapView2.prototype._createItemSymbol = function(group, representValue, shapeParam) {
    group.add(createSymbol$1(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color")));
  };
  PiecewiseVisualMapView2.prototype._onItemClick = function(piece) {
    var visualMapModel = this.visualMapModel;
    var option = visualMapModel.option;
    var selected = clone$4(option.selected);
    var newKey = visualMapModel.getSelectedMapKey(piece);
    if (option.selectedMode === "single") {
      selected[newKey] = true;
      each$f(selected, function(o, key) {
        selected[key] = key === newKey;
      });
    } else {
      selected[newKey] = !selected[newKey];
    }
    this.api.dispatchAction({
      type: "selectDataRange",
      from: this.uid,
      visualMapId: this.visualMapModel.id,
      selected
    });
  };
  PiecewiseVisualMapView2.type = "visualMap.piecewise";
  return PiecewiseVisualMapView2;
}(VisualMapView$1);
var PiecewiseView = PiecewiseVisualMapView;
function install$k(registers) {
  registers.registerComponentModel(PiecewiseModel$1);
  registers.registerComponentView(PiecewiseView);
  installCommon(registers);
}
function install$j(registers) {
  use(install$l);
  use(install$k);
}
var DEFAULT_OPTION = {
  label: {
    enabled: true
  },
  decal: {
    show: false
  }
};
var inner = makeInner();
var decalPaletteScope = {};
function ariaVisual(ecModel, api) {
  var ariaModel = ecModel.getModel("aria");
  if (!ariaModel.get("enabled")) {
    return;
  }
  var defaultOption2 = clone$4(DEFAULT_OPTION);
  merge(defaultOption2.label, ecModel.getLocaleModel().get("aria"), false);
  merge(ariaModel.option, defaultOption2, false);
  setDecal();
  setLabel();
  function setDecal() {
    var decalModel = ariaModel.getModel("decal");
    var useDecal = decalModel.get("show");
    if (useDecal) {
      var paletteScopeGroupByType_1 = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.isColorBySeries()) {
          return;
        }
        var decalScope = paletteScopeGroupByType_1.get(seriesModel.type);
        if (!decalScope) {
          decalScope = {};
          paletteScopeGroupByType_1.set(seriesModel.type, decalScope);
        }
        inner(seriesModel).scope = decalScope;
      });
      ecModel.eachRawSeries(function(seriesModel) {
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        if (isFunction$1(seriesModel.enableAriaDecal)) {
          seriesModel.enableAriaDecal();
          return;
        }
        var data = seriesModel.getData();
        if (!seriesModel.isColorBySeries()) {
          var dataAll_1 = seriesModel.getRawData();
          var idxMap_1 = {};
          var decalScope_1 = inner(seriesModel).scope;
          data.each(function(idx) {
            var rawIdx = data.getRawIndex(idx);
            idxMap_1[rawIdx] = idx;
          });
          var dataCount_1 = dataAll_1.count();
          dataAll_1.each(function(rawIdx) {
            var idx = idxMap_1[rawIdx];
            var name = dataAll_1.getName(rawIdx) || rawIdx + "";
            var paletteDecal2 = getDecalFromPalette(seriesModel.ecModel, name, decalScope_1, dataCount_1);
            var specifiedDecal2 = data.getItemVisual(idx, "decal");
            data.setItemVisual(idx, "decal", mergeDecal(specifiedDecal2, paletteDecal2));
          });
        } else {
          var paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());
          var specifiedDecal = data.getVisual("decal");
          data.setVisual("decal", mergeDecal(specifiedDecal, paletteDecal));
        }
        function mergeDecal(specifiedDecal2, paletteDecal2) {
          var resultDecal = specifiedDecal2 ? extend$1(extend$1({}, paletteDecal2), specifiedDecal2) : paletteDecal2;
          resultDecal.dirty = true;
          return resultDecal;
        }
      });
    }
  }
  function setLabel() {
    var labelLocale = ecModel.getLocaleModel().get("aria");
    var labelModel = ariaModel.getModel("label");
    labelModel.option = defaults(labelModel.option, labelLocale);
    if (!labelModel.get("enabled")) {
      return;
    }
    var dom = api.getZr().dom;
    if (labelModel.get("description")) {
      dom.setAttribute("aria-label", labelModel.get("description"));
      return;
    }
    var seriesCnt = ecModel.getSeriesCount();
    var maxDataCnt = labelModel.get(["data", "maxCount"]) || 10;
    var maxSeriesCnt = labelModel.get(["series", "maxCount"]) || 10;
    var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
    var ariaLabel;
    if (seriesCnt < 1) {
      return;
    } else {
      var title = getTitle();
      if (title) {
        var withTitle = labelModel.get(["general", "withTitle"]);
        ariaLabel = replace(withTitle, {
          title
        });
      } else {
        ariaLabel = labelModel.get(["general", "withoutTitle"]);
      }
      var seriesLabels_1 = [];
      var prefix = seriesCnt > 1 ? labelModel.get(["series", "multiple", "prefix"]) : labelModel.get(["series", "single", "prefix"]);
      ariaLabel += replace(prefix, {
        seriesCount: seriesCnt
      });
      ecModel.eachSeries(function(seriesModel, idx) {
        if (idx < displaySeriesCnt) {
          var seriesLabel = void 0;
          var seriesName = seriesModel.get("name");
          var withName = seriesName ? "withName" : "withoutName";
          seriesLabel = seriesCnt > 1 ? labelModel.get(["series", "multiple", withName]) : labelModel.get(["series", "single", withName]);
          seriesLabel = replace(seriesLabel, {
            seriesId: seriesModel.seriesIndex,
            seriesName: seriesModel.get("name"),
            seriesType: getSeriesTypeName(seriesModel.subType)
          });
          var data = seriesModel.getData();
          if (data.count() > maxDataCnt) {
            var partialLabel = labelModel.get(["data", "partialData"]);
            seriesLabel += replace(partialLabel, {
              displayCnt: maxDataCnt
            });
          } else {
            seriesLabel += labelModel.get(["data", "allData"]);
          }
          var middleSeparator_1 = labelModel.get(["data", "separator", "middle"]);
          var endSeparator_1 = labelModel.get(["data", "separator", "end"]);
          var dataLabels = [];
          for (var i = 0; i < data.count(); i++) {
            if (i < maxDataCnt) {
              var name_1 = data.getName(i);
              var value = data.getValues(i);
              var dataLabel = labelModel.get(["data", name_1 ? "withName" : "withoutName"]);
              dataLabels.push(replace(dataLabel, {
                name: name_1,
                value: value.join(middleSeparator_1)
              }));
            }
          }
          seriesLabel += dataLabels.join(middleSeparator_1) + endSeparator_1;
          seriesLabels_1.push(seriesLabel);
        }
      });
      var separatorModel = labelModel.getModel(["series", "multiple", "separator"]);
      var middleSeparator = separatorModel.get("middle");
      var endSeparator = separatorModel.get("end");
      ariaLabel += seriesLabels_1.join(middleSeparator) + endSeparator;
      dom.setAttribute("aria-label", ariaLabel);
    }
  }
  function replace(str, keyValues) {
    if (!isString(str)) {
      return str;
    }
    var result = str;
    each$f(keyValues, function(value, key) {
      result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
    });
    return result;
  }
  function getTitle() {
    var title = ecModel.get("title");
    if (title && title.length) {
      title = title[0];
    }
    return title && title.text;
  }
  function getSeriesTypeName(type) {
    return ecModel.getLocaleModel().get(["series", "typeNames"])[type] || "\u81EA\u5B9A\u4E49\u56FE";
  }
}
function ariaPreprocessor(option) {
  if (!option || !option.aria) {
    return;
  }
  var aria = option.aria;
  if (aria.show != null) {
    aria.enabled = aria.show;
  }
  aria.label = aria.label || {};
  each$f(["description", "general", "series", "data"], function(name) {
    if (aria[name] != null) {
      aria.label[name] = aria[name];
    }
  });
}
function install$i(registers) {
  registers.registerPreprocessor(ariaPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual);
}
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
  value: "eq",
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
};
var RegExpEvaluator = function() {
  function RegExpEvaluator2(rVal) {
    var condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;
    if (condValue == null) {
      var errMsg = "";
      throwError(errMsg);
    }
  }
  RegExpEvaluator2.prototype.evaluate = function(lVal) {
    var type = typeof lVal;
    return isString(type) ? this._condVal.test(lVal) : isNumber(type) ? this._condVal.test(lVal + "") : false;
  };
  return RegExpEvaluator2;
}();
var ConstConditionInternal = function() {
  function ConstConditionInternal2() {
  }
  ConstConditionInternal2.prototype.evaluate = function() {
    return this.value;
  };
  return ConstConditionInternal2;
}();
var AndConditionInternal = function() {
  function AndConditionInternal2() {
  }
  AndConditionInternal2.prototype.evaluate = function() {
    var children = this.children;
    for (var i = 0; i < children.length; i++) {
      if (!children[i].evaluate()) {
        return false;
      }
    }
    return true;
  };
  return AndConditionInternal2;
}();
var OrConditionInternal = function() {
  function OrConditionInternal2() {
  }
  OrConditionInternal2.prototype.evaluate = function() {
    var children = this.children;
    for (var i = 0; i < children.length; i++) {
      if (children[i].evaluate()) {
        return true;
      }
    }
    return false;
  };
  return OrConditionInternal2;
}();
var NotConditionInternal = function() {
  function NotConditionInternal2() {
  }
  NotConditionInternal2.prototype.evaluate = function() {
    return !this.child.evaluate();
  };
  return NotConditionInternal2;
}();
var RelationalConditionInternal = function() {
  function RelationalConditionInternal2() {
  }
  RelationalConditionInternal2.prototype.evaluate = function() {
    var needParse = !!this.valueParser;
    var getValue = this.getValue;
    var tarValRaw = getValue(this.valueGetterParam);
    var tarValParsed = needParse ? this.valueParser(tarValRaw) : null;
    for (var i = 0; i < this.subCondList.length; i++) {
      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {
        return false;
      }
    }
    return true;
  };
  return RelationalConditionInternal2;
}();
function parseOption(exprOption, getters) {
  if (exprOption === true || exprOption === false) {
    var cond = new ConstConditionInternal();
    cond.value = exprOption;
    return cond;
  }
  var errMsg = "";
  if (!isObjectNotArray(exprOption)) {
    throwError(errMsg);
  }
  if (exprOption.and) {
    return parseAndOrOption("and", exprOption, getters);
  } else if (exprOption.or) {
    return parseAndOrOption("or", exprOption, getters);
  } else if (exprOption.not) {
    return parseNotOption(exprOption, getters);
  }
  return parseRelationalOption(exprOption, getters);
}
function parseAndOrOption(op, exprOption, getters) {
  var subOptionArr = exprOption[op];
  var errMsg = "";
  if (!isArray$1(subOptionArr)) {
    throwError(errMsg);
  }
  if (!subOptionArr.length) {
    throwError(errMsg);
  }
  var cond = op === "and" ? new AndConditionInternal() : new OrConditionInternal();
  cond.children = map$1(subOptionArr, function(subOption) {
    return parseOption(subOption, getters);
  });
  if (!cond.children.length) {
    throwError(errMsg);
  }
  return cond;
}
function parseNotOption(exprOption, getters) {
  var subOption = exprOption.not;
  var errMsg = "";
  if (!isObjectNotArray(subOption)) {
    throwError(errMsg);
  }
  var cond = new NotConditionInternal();
  cond.child = parseOption(subOption, getters);
  if (!cond.child) {
    throwError(errMsg);
  }
  return cond;
}
function parseRelationalOption(exprOption, getters) {
  var errMsg = "";
  var valueGetterParam = getters.prepareGetValue(exprOption);
  var subCondList = [];
  var exprKeys = keys(exprOption);
  var parserName = exprOption.parser;
  var valueParser = parserName ? getRawValueParser(parserName) : null;
  for (var i = 0; i < exprKeys.length; i++) {
    var keyRaw = exprKeys[i];
    if (keyRaw === "parser" || getters.valueGetterAttrMap.get(keyRaw)) {
      continue;
    }
    var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;
    var condValueRaw = exprOption[keyRaw];
    var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;
    var evaluator = createFilterComparator(op, condValueParsed) || op === "reg" && new RegExpEvaluator(condValueParsed);
    if (!evaluator) {
      throwError(errMsg);
    }
    subCondList.push(evaluator);
  }
  if (!subCondList.length) {
    throwError(errMsg);
  }
  var cond = new RelationalConditionInternal();
  cond.valueGetterParam = valueGetterParam;
  cond.valueParser = valueParser;
  cond.getValue = getters.getValue;
  cond.subCondList = subCondList;
  return cond;
}
function isObjectNotArray(val) {
  return isObject$3(val) && !isArrayLike(val);
}
var ConditionalExpressionParsed = function() {
  function ConditionalExpressionParsed2(exprOption, getters) {
    this._cond = parseOption(exprOption, getters);
  }
  ConditionalExpressionParsed2.prototype.evaluate = function() {
    return this._cond.evaluate();
  };
  return ConditionalExpressionParsed2;
}();
function parseConditionalExpression(exprOption, getters) {
  return new ConditionalExpressionParsed(exprOption, getters);
}
var filterTransform = {
  type: "echarts:filter",
  transform: function(params) {
    var upstream = params.upstream;
    var rawItem;
    var condition = parseConditionalExpression(params.config, {
      valueGetterAttrMap: createHashMap({
        dimension: true
      }),
      prepareGetValue: function(exprOption) {
        var errMsg = "";
        var dimLoose = exprOption.dimension;
        if (!hasOwn(exprOption, "dimension")) {
          throwError(errMsg);
        }
        var dimInfo = upstream.getDimensionInfo(dimLoose);
        if (!dimInfo) {
          throwError(errMsg);
        }
        return {
          dimIdx: dimInfo.index
        };
      },
      getValue: function(param) {
        return upstream.retrieveValueFromItem(rawItem, param.dimIdx);
      }
    });
    var resultData = [];
    for (var i = 0, len2 = upstream.count(); i < len2; i++) {
      rawItem = upstream.getRawDataItem(i);
      if (condition.evaluate()) {
        resultData.push(rawItem);
      }
    }
    return {
      data: resultData
    };
  }
};
var sortTransform = {
  type: "echarts:sort",
  transform: function(params) {
    var upstream = params.upstream;
    var config = params.config;
    var errMsg = "";
    var orderExprList = normalizeToArray(config);
    if (!orderExprList.length) {
      throwError(errMsg);
    }
    var orderDefList = [];
    each$f(orderExprList, function(orderExpr) {
      var dimLoose = orderExpr.dimension;
      var order = orderExpr.order;
      var parserName = orderExpr.parser;
      var incomparable = orderExpr.incomparable;
      if (dimLoose == null) {
        throwError(errMsg);
      }
      if (order !== "asc" && order !== "desc") {
        throwError(errMsg);
      }
      if (incomparable && incomparable !== "min" && incomparable !== "max") {
        var errMsg_1 = "";
        throwError(errMsg_1);
      }
      if (order !== "asc" && order !== "desc") {
        var errMsg_2 = "";
        throwError(errMsg_2);
      }
      var dimInfo = upstream.getDimensionInfo(dimLoose);
      if (!dimInfo) {
        throwError(errMsg);
      }
      var parser = parserName ? getRawValueParser(parserName) : null;
      if (parserName && !parser) {
        throwError(errMsg);
      }
      orderDefList.push({
        dimIdx: dimInfo.index,
        parser,
        comparator: new SortOrderComparator(order, incomparable)
      });
    });
    var sourceFormat = upstream.sourceFormat;
    if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
      throwError(errMsg);
    }
    var resultData = [];
    for (var i = 0, len2 = upstream.count(); i < len2; i++) {
      resultData.push(upstream.getRawDataItem(i));
    }
    resultData.sort(function(item0, item1) {
      for (var i2 = 0; i2 < orderDefList.length; i2++) {
        var orderDef = orderDefList[i2];
        var val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);
        var val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);
        if (orderDef.parser) {
          val0 = orderDef.parser(val0);
          val1 = orderDef.parser(val1);
        }
        var result = orderDef.comparator.evaluate(val0, val1);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
    return {
      data: resultData
    };
  }
};
function install$h(registers) {
  registers.registerTransform(filterTransform);
  registers.registerTransform(sortTransform);
}
var DatasetModel = function(_super) {
  __extends(DatasetModel2, _super);
  function DatasetModel2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dataset";
    return _this;
  }
  DatasetModel2.prototype.init = function(option, parentModel, ecModel) {
    _super.prototype.init.call(this, option, parentModel, ecModel);
    this._sourceManager = new SourceManager(this);
    disableTransformOptionMerge(this);
  };
  DatasetModel2.prototype.mergeOption = function(newOption, ecModel) {
    _super.prototype.mergeOption.call(this, newOption, ecModel);
    disableTransformOptionMerge(this);
  };
  DatasetModel2.prototype.optionUpdated = function() {
    this._sourceManager.dirty();
  };
  DatasetModel2.prototype.getSourceManager = function() {
    return this._sourceManager;
  };
  DatasetModel2.type = "dataset";
  DatasetModel2.defaultOption = {
    seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
  };
  return DatasetModel2;
}(ComponentModel$1);
var DatasetView = function(_super) {
  __extends(DatasetView2, _super);
  function DatasetView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dataset";
    return _this;
  }
  DatasetView2.type = "dataset";
  return DatasetView2;
}(ComponentView$1);
function install$g(registers) {
  registers.registerComponentModel(DatasetModel);
  registers.registerComponentView(DatasetView);
}
var CMD = PathProxy$1.CMD;
function aroundEqual(a, b) {
  return Math.abs(a - b) < 1e-5;
}
function pathToBezierCurves(path) {
  var data = path.data;
  var len2 = path.len();
  var bezierArrayGroups = [];
  var currentSubpath;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;
  function createNewSubpath(x, y) {
    if (currentSubpath && currentSubpath.length > 2) {
      bezierArrayGroups.push(currentSubpath);
    }
    currentSubpath = [x, y];
  }
  function addLine(x02, y02, x12, y12) {
    if (!(aroundEqual(x02, x12) && aroundEqual(y02, y12))) {
      currentSubpath.push(x02, y02, x12, y12, x12, y12);
    }
  }
  function addArc(startAngle2, endAngle2, cx2, cy2, rx2, ry2) {
    var delta = Math.abs(endAngle2 - startAngle2);
    var len3 = Math.tan(delta / 4) * 4 / 3;
    var dir3 = endAngle2 < startAngle2 ? -1 : 1;
    var c1 = Math.cos(startAngle2);
    var s1 = Math.sin(startAngle2);
    var c2 = Math.cos(endAngle2);
    var s2 = Math.sin(endAngle2);
    var x12 = c1 * rx2 + cx2;
    var y12 = s1 * ry2 + cy2;
    var x4 = c2 * rx2 + cx2;
    var y4 = s2 * ry2 + cy2;
    var hx = rx2 * len3 * dir3;
    var hy = ry2 * len3 * dir3;
    currentSubpath.push(x12 - hx * s1, y12 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  }
  var x1;
  var y1;
  var x2;
  var y2;
  for (var i = 0; i < len2; ) {
    var cmd = data[i++];
    var isFirst = i === 1;
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {
        currentSubpath = [x0, y0];
      }
    }
    switch (cmd) {
      case CMD.M:
        xi = x0 = data[i++];
        yi = y0 = data[i++];
        createNewSubpath(x0, y0);
        break;
      case CMD.L:
        x1 = data[i++];
        y1 = data[i++];
        addLine(xi, yi, x1, y1);
        xi = x1;
        yi = y1;
        break;
      case CMD.C:
        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);
        break;
      case CMD.Q:
        x1 = data[i++];
        y1 = data[i++];
        x2 = data[i++];
        y2 = data[i++];
        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
        xi = x2;
        yi = y2;
        break;
      case CMD.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var startAngle = data[i++];
        var endAngle = data[i++] + startAngle;
        i += 1;
        var anticlockwise = !data[i++];
        x1 = Math.cos(startAngle) * rx + cx;
        y1 = Math.sin(startAngle) * ry + cy;
        if (isFirst) {
          x0 = x1;
          y0 = y1;
          createNewSubpath(x0, y0);
        } else {
          addLine(xi, yi, x1, y1);
        }
        xi = Math.cos(endAngle) * rx + cx;
        yi = Math.sin(endAngle) * ry + cy;
        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;
        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
          addArc(angle, nextAngle, cx, cy, rx, ry);
        }
        break;
      case CMD.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        x1 = x0 + data[i++];
        y1 = y0 + data[i++];
        createNewSubpath(x1, y0);
        addLine(x1, y0, x1, y1);
        addLine(x1, y1, x0, y1);
        addLine(x0, y1, x0, y0);
        addLine(x0, y0, x1, y0);
        break;
      case CMD.Z:
        currentSubpath && addLine(xi, yi, x0, y0);
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (currentSubpath && currentSubpath.length > 2) {
    bezierArrayGroups.push(currentSubpath);
  }
  return bezierArrayGroups;
}
function adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out2, scale2) {
  if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
    out2.push(x3, y3);
    return;
  }
  var PIXEL_DISTANCE = 2 / scale2;
  var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;
  var dx = x3 - x0;
  var dy = y3 - y0;
  var d = Math.sqrt(dx * dx + dy * dy);
  dx /= d;
  dy /= d;
  var dx1 = x1 - x0;
  var dy1 = y1 - y0;
  var dx2 = x2 - x3;
  var dy2 = y2 - y3;
  var cp1LenSqr = dx1 * dx1 + dy1 * dy1;
  var cp2LenSqr = dx2 * dx2 + dy2 * dy2;
  if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
    out2.push(x3, y3);
    return;
  }
  var projLen1 = dx * dx1 + dy * dy1;
  var projLen2 = -dx * dx2 - dy * dy2;
  var d1Sqr = cp1LenSqr - projLen1 * projLen1;
  var d2Sqr = cp2LenSqr - projLen2 * projLen2;
  if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
    out2.push(x3, y3);
    return;
  }
  var tmpSegX = [];
  var tmpSegY = [];
  cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);
  cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);
  adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out2, scale2);
  adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out2, scale2);
}
function pathToPolygons(path, scale2) {
  var bezierArrayGroups = pathToBezierCurves(path);
  var polygons = [];
  scale2 = scale2 || 1;
  for (var i = 0; i < bezierArrayGroups.length; i++) {
    var beziers = bezierArrayGroups[i];
    var polygon = [];
    var x0 = beziers[0];
    var y0 = beziers[1];
    polygon.push(x0, y0);
    for (var k = 2; k < beziers.length; ) {
      var x1 = beziers[k++];
      var y1 = beziers[k++];
      var x2 = beziers[k++];
      var y2 = beziers[k++];
      var x3 = beziers[k++];
      var y3 = beziers[k++];
      adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale2);
      x0 = x3;
      y0 = y3;
    }
    polygons.push(polygon);
  }
  return polygons;
}
function getDividingGrids(dimSize, rowDim, count2) {
  var rowSize = dimSize[rowDim];
  var columnSize = dimSize[1 - rowDim];
  var ratio = Math.abs(rowSize / columnSize);
  var rowCount = Math.ceil(Math.sqrt(ratio * count2));
  var columnCount = Math.floor(count2 / rowCount);
  if (columnCount === 0) {
    columnCount = 1;
    rowCount = count2;
  }
  var grids = [];
  for (var i = 0; i < rowCount; i++) {
    grids.push(columnCount);
  }
  var currentCount = rowCount * columnCount;
  var remained = count2 - currentCount;
  if (remained > 0) {
    for (var i = 0; i < remained; i++) {
      grids[i % rowCount] += 1;
    }
  }
  return grids;
}
function divideSector(sectorShape, count2, outShapes) {
  var r0 = sectorShape.r0;
  var r = sectorShape.r;
  var startAngle = sectorShape.startAngle;
  var endAngle = sectorShape.endAngle;
  var angle = Math.abs(endAngle - startAngle);
  var arcLen = angle * r;
  var deltaR = r - r0;
  var isAngleRow = arcLen > Math.abs(deltaR);
  var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count2);
  var rowSize = (isAngleRow ? angle : deltaR) / grids.length;
  for (var row = 0; row < grids.length; row++) {
    var columnSize = (isAngleRow ? deltaR : angle) / grids[row];
    for (var column = 0; column < grids[row]; column++) {
      var newShape = {};
      if (isAngleRow) {
        newShape.startAngle = startAngle + rowSize * row;
        newShape.endAngle = startAngle + rowSize * (row + 1);
        newShape.r0 = r0 + columnSize * column;
        newShape.r = r0 + columnSize * (column + 1);
      } else {
        newShape.startAngle = startAngle + columnSize * column;
        newShape.endAngle = startAngle + columnSize * (column + 1);
        newShape.r0 = r0 + rowSize * row;
        newShape.r = r0 + rowSize * (row + 1);
      }
      newShape.clockwise = sectorShape.clockwise;
      newShape.cx = sectorShape.cx;
      newShape.cy = sectorShape.cy;
      outShapes.push(newShape);
    }
  }
}
function divideRect(rectShape, count2, outShapes) {
  var width = rectShape.width;
  var height = rectShape.height;
  var isHorizontalRow = width > height;
  var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count2);
  var rowSizeDim = isHorizontalRow ? "width" : "height";
  var columnSizeDim = isHorizontalRow ? "height" : "width";
  var rowDim = isHorizontalRow ? "x" : "y";
  var columnDim = isHorizontalRow ? "y" : "x";
  var rowSize = rectShape[rowSizeDim] / grids.length;
  for (var row = 0; row < grids.length; row++) {
    var columnSize = rectShape[columnSizeDim] / grids[row];
    for (var column = 0; column < grids[row]; column++) {
      var newShape = {};
      newShape[rowDim] = row * rowSize;
      newShape[columnDim] = column * columnSize;
      newShape[rowSizeDim] = rowSize;
      newShape[columnSizeDim] = columnSize;
      newShape.x += rectShape.x;
      newShape.y += rectShape.y;
      outShapes.push(newShape);
    }
  }
}
function crossProduct2d(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
  if (Math.abs(nmCrossProduct) < 1e-6) {
    return null;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p < 0 || p > 1) {
    return null;
  }
  return new Point$1(p * mx + a1x, p * my + a1y);
}
function projPtOnLine(pt, lineA, lineB) {
  var dir3 = new Point$1();
  Point$1.sub(dir3, lineB, lineA);
  dir3.normalize();
  var dir22 = new Point$1();
  Point$1.sub(dir22, pt, lineA);
  var len2 = dir22.dot(dir3);
  return len2;
}
function addToPoly(poly, pt) {
  var last = poly[poly.length - 1];
  if (last && last[0] === pt[0] && last[1] === pt[1]) {
    return;
  }
  poly.push(pt);
}
function splitPolygonByLine(points2, lineA, lineB) {
  var len2 = points2.length;
  var intersections = [];
  for (var i = 0; i < len2; i++) {
    var p02 = points2[i];
    var p12 = points2[(i + 1) % len2];
    var intersectionPt = lineLineIntersect(p02[0], p02[1], p12[0], p12[1], lineA.x, lineA.y, lineB.x, lineB.y);
    if (intersectionPt) {
      intersections.push({
        projPt: projPtOnLine(intersectionPt, lineA, lineB),
        pt: intersectionPt,
        idx: i
      });
    }
  }
  if (intersections.length < 2) {
    return [{ points: points2 }, { points: points2 }];
  }
  intersections.sort(function(a, b) {
    return a.projPt - b.projPt;
  });
  var splitPt0 = intersections[0];
  var splitPt1 = intersections[intersections.length - 1];
  if (splitPt1.idx < splitPt0.idx) {
    var tmp = splitPt0;
    splitPt0 = splitPt1;
    splitPt1 = tmp;
  }
  var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];
  var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];
  var newPolyA = [splitPt0Arr];
  var newPolyB = [splitPt1Arr];
  for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {
    addToPoly(newPolyA, points2[i].slice());
  }
  addToPoly(newPolyA, splitPt1Arr);
  addToPoly(newPolyA, splitPt0Arr);
  for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len2; i++) {
    addToPoly(newPolyB, points2[i % len2].slice());
  }
  addToPoly(newPolyB, splitPt0Arr);
  addToPoly(newPolyB, splitPt1Arr);
  return [{
    points: newPolyA
  }, {
    points: newPolyB
  }];
}
function binaryDividePolygon(polygonShape) {
  var points2 = polygonShape.points;
  var min3 = [];
  var max3 = [];
  fromPoints(points2, min3, max3);
  var boundingRect = new BoundingRect$1(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
  var width = boundingRect.width;
  var height = boundingRect.height;
  var x = boundingRect.x;
  var y = boundingRect.y;
  var pt02 = new Point$1();
  var pt12 = new Point$1();
  if (width > height) {
    pt02.x = pt12.x = x + width / 2;
    pt02.y = y;
    pt12.y = y + height;
  } else {
    pt02.y = pt12.y = y + height / 2;
    pt02.x = x;
    pt12.x = x + width;
  }
  return splitPolygonByLine(points2, pt02, pt12);
}
function binaryDivideRecursive(divider, shape, count2, out2) {
  if (count2 === 1) {
    out2.push(shape);
  } else {
    var mid = Math.floor(count2 / 2);
    var sub2 = divider(shape);
    binaryDivideRecursive(divider, sub2[0], mid, out2);
    binaryDivideRecursive(divider, sub2[1], count2 - mid, out2);
  }
  return out2;
}
function clone(path, count2) {
  var paths = [];
  for (var i = 0; i < count2; i++) {
    paths.push(clonePath(path));
  }
  return paths;
}
function copyPathProps(source, target) {
  target.setStyle(source.style);
  target.z = source.z;
  target.z2 = source.z2;
  target.zlevel = source.zlevel;
}
function polygonConvert(points2) {
  var out2 = [];
  for (var i = 0; i < points2.length; ) {
    out2.push([points2[i++], points2[i++]]);
  }
  return out2;
}
function split(path, count2) {
  var outShapes = [];
  var shape = path.shape;
  var OutShapeCtor;
  switch (path.type) {
    case "rect":
      divideRect(shape, count2, outShapes);
      OutShapeCtor = Rect$3;
      break;
    case "sector":
      divideSector(shape, count2, outShapes);
      OutShapeCtor = Sector$1;
      break;
    case "circle":
      divideSector({
        r0: 0,
        r: shape.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: shape.cx,
        cy: shape.cy
      }, count2, outShapes);
      OutShapeCtor = Sector$1;
      break;
    default:
      var m2 = path.getComputedTransform();
      var scale2 = m2 ? Math.sqrt(Math.max(m2[0] * m2[0] + m2[1] * m2[1], m2[2] * m2[2] + m2[3] * m2[3])) : 1;
      var polygons = map$1(pathToPolygons(path.getUpdatedPathProxy(), scale2), function(poly) {
        return polygonConvert(poly);
      });
      var polygonCount = polygons.length;
      if (polygonCount === 0) {
        binaryDivideRecursive(binaryDividePolygon, {
          points: polygons[0]
        }, count2, outShapes);
      } else if (polygonCount === count2) {
        for (var i = 0; i < polygonCount; i++) {
          outShapes.push({
            points: polygons[i]
          });
        }
      } else {
        var totalArea_1 = 0;
        var items = map$1(polygons, function(poly) {
          var min3 = [];
          var max3 = [];
          fromPoints(poly, min3, max3);
          var area2 = (max3[1] - min3[1]) * (max3[0] - min3[0]);
          totalArea_1 += area2;
          return { poly, area: area2 };
        });
        items.sort(function(a, b) {
          return b.area - a.area;
        });
        var left = count2;
        for (var i = 0; i < polygonCount; i++) {
          var item = items[i];
          if (left <= 0) {
            break;
          }
          var selfCount = i === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count2);
          if (selfCount < 0) {
            continue;
          }
          binaryDivideRecursive(binaryDividePolygon, {
            points: item.poly
          }, selfCount, outShapes);
          left -= selfCount;
        }
      }
      OutShapeCtor = Polygon$1;
      break;
  }
  if (!OutShapeCtor) {
    return clone(path, count2);
  }
  var out2 = [];
  for (var i = 0; i < outShapes.length; i++) {
    var subPath = new OutShapeCtor();
    subPath.setShape(outShapes[i]);
    copyPathProps(path, subPath);
    out2.push(subPath);
  }
  return out2;
}
function alignSubpath(subpath1, subpath2) {
  var len1 = subpath1.length;
  var len2 = subpath2.length;
  if (len1 === len2) {
    return [subpath1, subpath2];
  }
  var tmpSegX = [];
  var tmpSegY = [];
  var shorterPath = len1 < len2 ? subpath1 : subpath2;
  var shorterLen = Math.min(len1, len2);
  var diff = Math.abs(len2 - len1) / 6;
  var shorterBezierCount = (shorterLen - 2) / 6;
  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
  var newSubpath = [shorterPath[0], shorterPath[1]];
  var remained = diff;
  for (var i = 2; i < shorterLen; ) {
    var x0 = shorterPath[i - 2];
    var y0 = shorterPath[i - 1];
    var x1 = shorterPath[i++];
    var y1 = shorterPath[i++];
    var x2 = shorterPath[i++];
    var y2 = shorterPath[i++];
    var x3 = shorterPath[i++];
    var y3 = shorterPath[i++];
    if (remained <= 0) {
      newSubpath.push(x1, y1, x2, y2, x3, y3);
      continue;
    }
    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
    for (var k = 1; k <= actualSubDivCount; k++) {
      var p = k / actualSubDivCount;
      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);
      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);
      x0 = tmpSegX[3];
      y0 = tmpSegY[3];
      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
      x1 = tmpSegX[5];
      y1 = tmpSegY[5];
      x2 = tmpSegX[6];
      y2 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpathSubpath, otherSubpath) {
  var len2 = lastSubpathSubpath.length;
  var lastX = lastSubpathSubpath[len2 - 2];
  var lastY = lastSubpathSubpath[len2 - 1];
  var newSubpath = [];
  for (var i = 0; i < otherSubpath.length; ) {
    newSubpath[i++] = lastX;
    newSubpath[i++] = lastY;
  }
  return newSubpath;
}
function alignBezierCurves(array1, array2) {
  var _a2;
  var lastSubpath1;
  var lastSubpath2;
  var newArray1 = [];
  var newArray2 = [];
  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {
    var subpath1 = array1[i];
    var subpath2 = array2[i];
    var newSubpath1 = void 0;
    var newSubpath2 = void 0;
    if (!subpath1) {
      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
      newSubpath2 = subpath2;
    } else if (!subpath2) {
      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
      newSubpath1 = subpath1;
    } else {
      _a2 = alignSubpath(subpath1, subpath2), newSubpath1 = _a2[0], newSubpath2 = _a2[1];
      lastSubpath1 = newSubpath1;
      lastSubpath2 = newSubpath2;
    }
    newArray1.push(newSubpath1);
    newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
function centroid(array) {
  var signedArea2 = 0;
  var cx = 0;
  var cy = 0;
  var len2 = array.length;
  for (var i = 0, j = len2 - 2; i < len2; j = i, i += 2) {
    var x0 = array[j];
    var y0 = array[j + 1];
    var x1 = array[i];
    var y1 = array[i + 1];
    var a = x0 * y1 - x1 * y0;
    signedArea2 += a;
    cx += (x0 + x1) * a;
    cy += (y0 + y1) * a;
  }
  if (signedArea2 === 0) {
    return [array[0] || 0, array[1] || 0];
  }
  return [cx / signedArea2 / 3, cy / signedArea2 / 3, signedArea2];
}
function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  var bezierCount = (fromSubBeziers.length - 2) / 6;
  var bestScore = Infinity;
  var bestOffset = 0;
  var len2 = fromSubBeziers.length;
  var len22 = len2 - 2;
  for (var offset = 0; offset < bezierCount; offset++) {
    var cursorOffset = offset * 6;
    var score = 0;
    for (var k = 0; k < len2; k += 2) {
      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len22 + 2;
      var x0 = fromSubBeziers[idx] - fromCp[0];
      var y0 = fromSubBeziers[idx + 1] - fromCp[1];
      var x1 = toSubBeziers[k] - toCp[0];
      var y1 = toSubBeziers[k + 1] - toCp[1];
      var dx = x1 - x0;
      var dy = y1 - y0;
      score += dx * dx + dy * dy;
    }
    if (score < bestScore) {
      bestScore = score;
      bestOffset = offset;
    }
  }
  return bestOffset;
}
function reverse(array) {
  var newArr = [];
  var len2 = array.length;
  for (var i = 0; i < len2; i += 2) {
    newArr[i] = array[len2 - i - 2];
    newArr[i + 1] = array[len2 - i - 1];
  }
  return newArr;
}
function findBestMorphingRotation(fromArr, toArr2, searchAngleIteration, searchAngleRange) {
  var result = [];
  var fromNeedsReverse;
  for (var i = 0; i < fromArr.length; i++) {
    var fromSubpathBezier = fromArr[i];
    var toSubpathBezier = toArr2[i];
    var fromCp = centroid(fromSubpathBezier);
    var toCp = centroid(toSubpathBezier);
    if (fromNeedsReverse == null) {
      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
    }
    var newFromSubpathBezier = [];
    var newToSubpathBezier = [];
    var bestAngle = 0;
    var bestScore = Infinity;
    var tmpArr2 = [];
    var len2 = fromSubpathBezier.length;
    if (fromNeedsReverse) {
      fromSubpathBezier = reverse(fromSubpathBezier);
    }
    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
    var len22 = len2 - 2;
    for (var k = 0; k < len22; k += 2) {
      var idx = (offset + k) % len22 + 2;
      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
    }
    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
    if (searchAngleIteration > 0) {
      var step = searchAngleRange / searchAngleIteration;
      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
        var sa = Math.sin(angle);
        var ca = Math.cos(angle);
        var score = 0;
        for (var k = 0; k < fromSubpathBezier.length; k += 2) {
          var x0 = newFromSubpathBezier[k];
          var y0 = newFromSubpathBezier[k + 1];
          var x1 = toSubpathBezier[k] - toCp[0];
          var y1 = toSubpathBezier[k + 1] - toCp[1];
          var newX1 = x1 * ca - y1 * sa;
          var newY1 = x1 * sa + y1 * ca;
          tmpArr2[k] = newX1;
          tmpArr2[k + 1] = newY1;
          var dx = newX1 - x0;
          var dy = newY1 - y0;
          score += dx * dx + dy * dy;
        }
        if (score < bestScore) {
          bestScore = score;
          bestAngle = angle;
          for (var m2 = 0; m2 < tmpArr2.length; m2++) {
            newToSubpathBezier[m2] = tmpArr2[m2];
          }
        }
      }
    } else {
      for (var i_1 = 0; i_1 < len2; i_1 += 2) {
        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];
        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];
      }
    }
    result.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp,
      toCp,
      rotation: -bestAngle
    });
  }
  return result;
}
function isCombineMorphing(path) {
  return path.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(obj, methodName, modifiers) {
  var savedMethodName = SAVED_METHOD_PREFIX + methodName;
  var originalMethod = obj[savedMethodName] || obj[methodName];
  if (!obj[savedMethodName]) {
    obj[savedMethodName] = obj[methodName];
  }
  var replace = modifiers.replace;
  var after = modifiers.after;
  var before = modifiers.before;
  obj[methodName] = function() {
    var args = arguments;
    var res;
    before && before.apply(this, args);
    if (replace) {
      res = replace.apply(this, args);
    } else {
      res = originalMethod.apply(this, args);
    }
    after && after.apply(this, args);
    return res;
  };
}
function restoreMethod(obj, methodName) {
  var savedMethodName = SAVED_METHOD_PREFIX + methodName;
  if (obj[savedMethodName]) {
    obj[methodName] = obj[savedMethodName];
    obj[savedMethodName] = null;
  }
}
function applyTransformOnBeziers(bezierCurves, mm) {
  for (var i = 0; i < bezierCurves.length; i++) {
    var subBeziers = bezierCurves[i];
    for (var k = 0; k < subBeziers.length; ) {
      var x = subBeziers[k];
      var y = subBeziers[k + 1];
      subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];
      subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];
    }
  }
}
function prepareMorphPath(fromPath, toPath) {
  var fromPathProxy = fromPath.getUpdatedPathProxy();
  var toPathProxy = toPath.getUpdatedPathProxy();
  var _a2 = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a2[0], toBezierCurves = _a2[1];
  var fromPathTransform = fromPath.getComputedTransform();
  var toPathTransform = toPath.getComputedTransform();
  function updateIdentityTransform() {
    this.transform = null;
  }
  fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);
  toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);
  saveAndModifyMethod(toPath, "updateTransform", { replace: updateIdentityTransform });
  toPath.transform = null;
  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
  var tmpArr2 = [];
  saveAndModifyMethod(toPath, "buildPath", { replace: function(path) {
    var t = toPath.__morphT;
    var onet = 1 - t;
    var newCp = [];
    for (var i = 0; i < morphingData.length; i++) {
      var item = morphingData[i];
      var from = item.from;
      var to = item.to;
      var angle = item.rotation * t;
      var fromCp = item.fromCp;
      var toCp = item.toCp;
      var sa = Math.sin(angle);
      var ca = Math.cos(angle);
      lerp$1(newCp, fromCp, toCp, t);
      for (var m2 = 0; m2 < from.length; m2 += 2) {
        var x0_1 = from[m2];
        var y0_1 = from[m2 + 1];
        var x1 = to[m2];
        var y1 = to[m2 + 1];
        var x = x0_1 * onet + x1 * t;
        var y = y0_1 * onet + y1 * t;
        tmpArr2[m2] = x * ca - y * sa + newCp[0];
        tmpArr2[m2 + 1] = x * sa + y * ca + newCp[1];
      }
      var x0 = tmpArr2[0];
      var y0 = tmpArr2[1];
      path.moveTo(x0, y0);
      for (var m2 = 2; m2 < from.length; ) {
        var x1 = tmpArr2[m2++];
        var y1 = tmpArr2[m2++];
        var x2 = tmpArr2[m2++];
        var y2 = tmpArr2[m2++];
        var x3 = tmpArr2[m2++];
        var y3 = tmpArr2[m2++];
        if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {
          path.lineTo(x3, y3);
        } else {
          path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        x0 = x3;
        y0 = y3;
      }
    }
  } });
}
function morphPath(fromPath, toPath, animationOpts) {
  if (!fromPath || !toPath) {
    return toPath;
  }
  var oldDone = animationOpts.done;
  var oldDuring = animationOpts.during;
  prepareMorphPath(fromPath, toPath);
  toPath.__morphT = 0;
  function restoreToPath() {
    restoreMethod(toPath, "buildPath");
    restoreMethod(toPath, "updateTransform");
    toPath.__morphT = -1;
    toPath.createPathProxy();
    toPath.dirtyShape();
  }
  toPath.animateTo({
    __morphT: 1
  }, defaults({
    during: function(p) {
      toPath.dirtyShape();
      oldDuring && oldDuring(p);
    },
    done: function() {
      restoreToPath();
      oldDone && oldDone();
    }
  }, animationOpts));
  return toPath;
}
function hilbert(x, y, minX, minY, maxX, maxY) {
  var bits = 16;
  x = maxX === minX ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));
  y = maxY === minY ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));
  var d = 0;
  var tmp;
  for (var s = (1 << bits) / 2; s > 0; s /= 2) {
    var rx = 0;
    var ry = 0;
    if ((x & s) > 0) {
      rx = 1;
    }
    if ((y & s) > 0) {
      ry = 1;
    }
    d += s * s * (3 * rx ^ ry);
    if (ry === 0) {
      if (rx === 1) {
        x = s - 1 - x;
        y = s - 1 - y;
      }
      tmp = x;
      x = y;
      y = tmp;
    }
  }
  return d;
}
function sortPaths(pathList) {
  var xMin = Infinity;
  var yMin = Infinity;
  var xMax = -Infinity;
  var yMax = -Infinity;
  var cps = map$1(pathList, function(path) {
    var rect = path.getBoundingRect();
    var m2 = path.getComputedTransform();
    var x = rect.x + rect.width / 2 + (m2 ? m2[4] : 0);
    var y = rect.y + rect.height / 2 + (m2 ? m2[5] : 0);
    xMin = Math.min(x, xMin);
    yMin = Math.min(y, yMin);
    xMax = Math.max(x, xMax);
    yMax = Math.max(y, yMax);
    return [x, y];
  });
  var items = map$1(cps, function(cp, idx) {
    return {
      cp,
      z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),
      path: pathList[idx]
    };
  });
  return items.sort(function(a, b) {
    return a.z - b.z;
  }).map(function(item) {
    return item.path;
  });
}
function defaultDividePath(param) {
  return split(param.path, param.count);
}
function createEmptyReturn() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function combineMorph(fromList, toPath, animationOpts) {
  var fromPathList = [];
  function addFromPath(fromList2) {
    for (var i2 = 0; i2 < fromList2.length; i2++) {
      var from2 = fromList2[i2];
      if (isCombineMorphing(from2)) {
        addFromPath(from2.childrenRef());
      } else if (from2 instanceof Path$1) {
        fromPathList.push(from2);
      }
    }
  }
  addFromPath(fromList);
  var separateCount = fromPathList.length;
  if (!separateCount) {
    return createEmptyReturn();
  }
  var dividePath = animationOpts.dividePath || defaultDividePath;
  var toSubPathList = dividePath({
    path: toPath,
    count: separateCount
  });
  if (toSubPathList.length !== separateCount) {
    console.error("Invalid morphing: unmatched splitted path");
    return createEmptyReturn();
  }
  fromPathList = sortPaths(fromPathList);
  toSubPathList = sortPaths(toSubPathList);
  var oldDone = animationOpts.done;
  var oldDuring = animationOpts.during;
  var individualDelay = animationOpts.individualDelay;
  var identityTransform = new Transformable();
  for (var i = 0; i < separateCount; i++) {
    var from = fromPathList[i];
    var to = toSubPathList[i];
    to.parent = toPath;
    to.copyTransform(identityTransform);
    if (!individualDelay) {
      prepareMorphPath(from, to);
    }
  }
  toPath.__isCombineMorphing = true;
  toPath.childrenRef = function() {
    return toSubPathList;
  };
  function addToSubPathListToZr(zr) {
    for (var i2 = 0; i2 < toSubPathList.length; i2++) {
      toSubPathList[i2].addSelfToZr(zr);
    }
  }
  saveAndModifyMethod(toPath, "addSelfToZr", {
    after: function(zr) {
      addToSubPathListToZr(zr);
    }
  });
  saveAndModifyMethod(toPath, "removeSelfFromZr", {
    after: function(zr) {
      for (var i2 = 0; i2 < toSubPathList.length; i2++) {
        toSubPathList[i2].removeSelfFromZr(zr);
      }
    }
  });
  function restoreToPath() {
    toPath.__isCombineMorphing = false;
    toPath.__morphT = -1;
    toPath.childrenRef = null;
    restoreMethod(toPath, "addSelfToZr");
    restoreMethod(toPath, "removeSelfFromZr");
  }
  var toLen = toSubPathList.length;
  if (individualDelay) {
    var animating_1 = toLen;
    var eachDone = function() {
      animating_1--;
      if (animating_1 === 0) {
        restoreToPath();
        oldDone && oldDone();
      }
    };
    for (var i = 0; i < toLen; i++) {
      var indivdualAnimationOpts = individualDelay ? defaults({
        delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),
        done: eachDone
      }, animationOpts) : animationOpts;
      morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);
    }
  } else {
    toPath.__morphT = 0;
    toPath.animateTo({
      __morphT: 1
    }, defaults({
      during: function(p) {
        for (var i2 = 0; i2 < toLen; i2++) {
          var child = toSubPathList[i2];
          child.__morphT = toPath.__morphT;
          child.dirtyShape();
        }
        oldDuring && oldDuring(p);
      },
      done: function() {
        restoreToPath();
        for (var i2 = 0; i2 < fromList.length; i2++) {
          restoreMethod(fromList[i2], "updateTransform");
        }
        oldDone && oldDone();
      }
    }, animationOpts));
  }
  if (toPath.__zr) {
    addToSubPathListToZr(toPath.__zr);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toSubPathList,
    count: toLen
  };
}
function separateMorph(fromPath, toPathList, animationOpts) {
  var toLen = toPathList.length;
  var fromPathList = [];
  var dividePath = animationOpts.dividePath || defaultDividePath;
  function addFromPath(fromList) {
    for (var i2 = 0; i2 < fromList.length; i2++) {
      var from = fromList[i2];
      if (isCombineMorphing(from)) {
        addFromPath(from.childrenRef());
      } else if (from instanceof Path$1) {
        fromPathList.push(from);
      }
    }
  }
  if (isCombineMorphing(fromPath)) {
    addFromPath(fromPath.childrenRef());
    var fromLen = fromPathList.length;
    if (fromLen < toLen) {
      var k = 0;
      for (var i = fromLen; i < toLen; i++) {
        fromPathList.push(clonePath(fromPathList[k++ % fromLen]));
      }
    }
    fromPathList.length = toLen;
  } else {
    fromPathList = dividePath({ path: fromPath, count: toLen });
    var fromPathTransform = fromPath.getComputedTransform();
    for (var i = 0; i < fromPathList.length; i++) {
      fromPathList[i].setLocalTransform(fromPathTransform);
    }
    if (fromPathList.length !== toLen) {
      console.error("Invalid morphing: unmatched splitted path");
      return createEmptyReturn();
    }
  }
  fromPathList = sortPaths(fromPathList);
  toPathList = sortPaths(toPathList);
  var individualDelay = animationOpts.individualDelay;
  for (var i = 0; i < toLen; i++) {
    var indivdualAnimationOpts = individualDelay ? defaults({
      delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])
    }, animationOpts) : animationOpts;
    morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toPathList,
    count: toPathList.length
  };
}
function isMultiple(elements) {
  return isArray$1(elements[0]);
}
function prepareMorphBatches(one, many) {
  var batches = [];
  var batchCount = one.length;
  for (var i = 0; i < batchCount; i++) {
    batches.push({
      one: one[i],
      many: []
    });
  }
  for (var i = 0; i < many.length; i++) {
    var len2 = many[i].length;
    var k = void 0;
    for (k = 0; k < len2; k++) {
      batches[k % batchCount].many.push(many[i][k]);
    }
  }
  var off = 0;
  for (var i = batchCount - 1; i >= 0; i--) {
    if (!batches[i].many.length) {
      var moveFrom = batches[off].many;
      if (moveFrom.length <= 1) {
        if (off) {
          off = 0;
        } else {
          return batches;
        }
      }
      var len2 = moveFrom.length;
      var mid = Math.ceil(len2 / 2);
      batches[i].many = moveFrom.slice(mid, len2);
      batches[off].many = moveFrom.slice(0, mid);
      off++;
    }
  }
  return batches;
}
var pathDividers = {
  clone: function(params) {
    var ret2 = [];
    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);
    for (var i = 0; i < params.count; i++) {
      var cloned = clonePath(params.path);
      cloned.setStyle("opacity", approxOpacity);
      ret2.push(cloned);
    }
    return ret2;
  },
  split: null
};
function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
  if (!from.length || !to.length) {
    return;
  }
  var updateAnimationCfg = getAnimationConfig("update", seriesModel, dataIndex);
  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
    return;
  }
  var animationDelay = seriesModel.getModel("universalTransition").get("delay");
  var animationCfg = Object.assign({
    setToFinal: true
  }, updateAnimationCfg);
  var many;
  var one;
  if (isMultiple(from)) {
    many = from;
    one = to;
  }
  if (isMultiple(to)) {
    many = to;
    one = from;
  }
  function morphOneBatch(batch, fromIsMany2, animateIndex2, animateCount2, forceManyOne) {
    var batchMany = batch.many;
    var batchOne = batch.one;
    if (batchMany.length === 1 && !forceManyOne) {
      var batchFrom = fromIsMany2 ? batchMany[0] : batchOne;
      var batchTo = fromIsMany2 ? batchOne : batchMany[0];
      if (isCombineMorphing(batchFrom)) {
        morphOneBatch({
          many: [batchFrom],
          one: batchTo
        }, true, animateIndex2, animateCount2, true);
      } else {
        var individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(animateIndex2, animateCount2)
        }, animationCfg) : animationCfg;
        morphPath(batchFrom, batchTo, individualAnimationCfg);
        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
      }
    } else {
      var separateAnimationCfg = defaults({
        dividePath: pathDividers[divideShape],
        individualDelay: animationDelay && function(idx, count3, fromPath, toPath) {
          return animationDelay(idx + animateIndex2, animateCount2);
        }
      }, animationCfg);
      var _a2 = fromIsMany2 ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg), fromIndividuals = _a2.fromIndividuals, toIndividuals = _a2.toIndividuals;
      var count2 = fromIndividuals.length;
      for (var k = 0; k < count2; k++) {
        var individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(k, count2)
        }, animationCfg) : animationCfg;
        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany2 ? batchMany[k] : batch.one, fromIsMany2 ? batch.one : batchMany[k], individualAnimationCfg);
      }
    }
  }
  var fromIsMany = many ? many === from : from.length > to.length;
  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);
  var animateCount = 0;
  for (var i = 0; i < morphBatches.length; i++) {
    animateCount += morphBatches[i].many.length;
  }
  var animateIndex = 0;
  for (var i = 0; i < morphBatches.length; i++) {
    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);
    animateIndex += morphBatches[i].many.length;
  }
}
function getPathList(elements) {
  if (!elements) {
    return [];
  }
  if (isArray$1(elements)) {
    var pathList_1 = [];
    for (var i = 0; i < elements.length; i++) {
      pathList_1.push(getPathList(elements[i]));
    }
    return pathList_1;
  }
  var pathList = [];
  elements.traverse(function(el) {
    if (el instanceof Path$1 && !el.disableMorphing && !el.invisible && !el.ignore) {
      pathList.push(el);
    }
  });
  return pathList;
}
var DATA_COUNT_THRESHOLD = 1e4;
var getUniversalTransitionGlobalStore = makeInner();
function getGroupIdDimension(data) {
  var dimensions = data.dimensions;
  for (var i = 0; i < dimensions.length; i++) {
    var dimInfo = data.getDimensionInfo(dimensions[i]);
    if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {
      return dimensions[i];
    }
  }
}
function flattenDataDiffItems(list) {
  var items = [];
  each$f(list, function(seriesInfo) {
    var data = seriesInfo.data;
    if (data.count() > DATA_COUNT_THRESHOLD) {
      return;
    }
    var indices = data.getIndices();
    var groupDim = getGroupIdDimension(data);
    for (var dataIndex = 0; dataIndex < indices.length; dataIndex++) {
      items.push({
        data,
        dim: seriesInfo.dim || groupDim,
        divide: seriesInfo.divide,
        dataIndex
      });
    }
  });
  return items;
}
function fadeInElement(newEl2, newSeries, newIndex) {
  newEl2.traverse(function(el) {
    if (el instanceof Path$1) {
      initProps(el, {
        style: {
          opacity: 0
        }
      }, newSeries, {
        dataIndex: newIndex,
        isFrom: true
      });
    }
  });
}
function removeEl(el) {
  if (el.parent) {
    var computedTransform = el.getComputedTransform();
    el.setLocalTransform(computedTransform);
    el.parent.remove(el);
  }
}
function stopAnimation(el) {
  el.stopAnimation();
  if (el.isGroup) {
    el.traverse(function(child) {
      child.stopAnimation();
    });
  }
}
function animateElementStyles(el, dataIndex, seriesModel) {
  var animationConfig = getAnimationConfig("update", seriesModel, dataIndex);
  animationConfig && el.traverse(function(child) {
    if (child instanceof Displayable$1) {
      var oldStyle = getOldStyle(child);
      if (oldStyle) {
        child.animateFrom({
          style: oldStyle
        }, animationConfig);
      }
    }
  });
}
function isAllIdSame(oldDiffItems, newDiffItems) {
  var len2 = oldDiffItems.length;
  if (len2 !== newDiffItems.length) {
    return false;
  }
  for (var i = 0; i < len2; i++) {
    var oldItem = oldDiffItems[i];
    var newItem = newDiffItems[i];
    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
      return false;
    }
  }
  return true;
}
function transitionBetween(oldList, newList, api) {
  var oldDiffItems = flattenDataDiffItems(oldList);
  var newDiffItems = flattenDataDiffItems(newList);
  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {
    if (rawFrom || from) {
      to.animateFrom({
        style: rawFrom && rawFrom !== from ? extend$1(extend$1({}, rawFrom.style), from.style) : from.style
      }, animationCfg);
    }
  }
  function findKeyDim(items) {
    for (var i2 = 0; i2 < items.length; i2++) {
      if (items[i2].dim) {
        return items[i2].dim;
      }
    }
  }
  var oldKeyDim = findKeyDim(oldDiffItems);
  var newKeyDim = findKeyDim(newDiffItems);
  var hasMorphAnimation = false;
  function createKeyGetter(isOld, onlyGetId) {
    return function(diffItem) {
      var data = diffItem.data;
      var dataIndex = diffItem.dataIndex;
      if (onlyGetId) {
        return data.getId(dataIndex);
      }
      var dataGroupId = data.hostModel && data.hostModel.get("dataGroupId");
      var keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim;
      var dimInfo = keyDim && data.getDimensionInfo(keyDim);
      var dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;
      if (dimInfo) {
        var key = data.get(dimInfo.name, dataIndex);
        if (dimOrdinalMeta) {
          return dimOrdinalMeta.categories[key] || key + "";
        }
        return key + "";
      }
      var itemVal = data.getRawDataItem(dataIndex);
      if (itemVal && itemVal.groupId) {
        return itemVal.groupId + "";
      }
      return dataGroupId || data.getId(dataIndex);
    };
  }
  var useId = isAllIdSame(oldDiffItems, newDiffItems);
  var isElementStillInChart = {};
  if (!useId) {
    for (var i = 0; i < newDiffItems.length; i++) {
      var newItem = newDiffItems[i];
      var el = newItem.data.getItemGraphicEl(newItem.dataIndex);
      if (el) {
        isElementStillInChart[el.id] = true;
      }
    }
  }
  function updateOneToOne(newIndex, oldIndex) {
    var oldItem = oldDiffItems[oldIndex];
    var newItem2 = newDiffItems[newIndex];
    var newSeries = newItem2.data.hostModel;
    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    var newEl2 = newItem2.data.getItemGraphicEl(newItem2.dataIndex);
    if (oldEl === newEl2) {
      newEl2 && animateElementStyles(newEl2, newItem2.dataIndex, newSeries);
      return;
    }
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    if (newEl2) {
      stopAnimation(newEl2);
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldEl), getPathList(newEl2), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl2, newSeries, newIndex);
      }
    }
  }
  new DataDiffer$1(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, "multiple").update(updateOneToOne).updateManyToOne(function(newIndex, oldIndices) {
    var newItem2 = newDiffItems[newIndex];
    var newData = newItem2.data;
    var newSeries = newData.hostModel;
    var newEl2 = newData.getItemGraphicEl(newItem2.dataIndex);
    var oldElsList = filter(map$1(oldIndices, function(idx) {
      return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex);
    }), function(oldEl) {
      return oldEl && oldEl !== newEl2 && !isElementStillInChart[oldEl.id];
    });
    if (newEl2) {
      stopAnimation(newEl2);
      if (oldElsList.length) {
        each$f(oldElsList, function(oldEl) {
          stopAnimation(oldEl);
          removeEl(oldEl);
        });
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl2), newItem2.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl2, newSeries, newItem2.dataIndex);
      }
    }
  }).updateOneToMany(function(newIndices, oldIndex) {
    var oldItem = oldDiffItems[oldIndex];
    var oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    var newElsList = filter(map$1(newIndices, function(idx) {
      return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex);
    }), function(el2) {
      return el2 && el2 !== oldEl;
    });
    var newSeris = newDiffItems[newIndices[0]].data.hostModel;
    if (newElsList.length) {
      each$f(newElsList, function(newEl2) {
        return stopAnimation(newEl2);
      });
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, newSeris, newIndices[0], updateMorphingPathProps);
      } else {
        each$f(newElsList, function(newEl2) {
          return fadeInElement(newEl2, newSeris, newIndices[0]);
        });
      }
    }
  }).updateManyToMany(function(newIndices, oldIndices) {
    new DataDiffer$1(oldIndices, newIndices, function(rawIdx) {
      return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex);
    }, function(rawIdx) {
      return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex);
    }).update(function(newIndex, oldIndex) {
      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
    }).execute();
  }).execute();
  if (hasMorphAnimation) {
    each$f(newList, function(_a2) {
      var data = _a2.data;
      var seriesModel = data.hostModel;
      var view = seriesModel && api.getViewOfSeriesModel(seriesModel);
      var animationCfg = getAnimationConfig("update", seriesModel, 0);
      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
        view.group.traverse(function(el2) {
          if (el2 instanceof Path$1 && !el2.animators.length) {
            el2.animateFrom({
              style: {
                opacity: 0
              }
            }, animationCfg);
          }
        });
      }
    });
  }
}
function getSeriesTransitionKey(series) {
  var seriesKey = series.getModel("universalTransition").get("seriesKey");
  if (!seriesKey) {
    return series.id;
  }
  return seriesKey;
}
function convertArraySeriesKeyToString(seriesKey) {
  if (isArray$1(seriesKey)) {
    return seriesKey.sort().join(",");
  }
  return seriesKey;
}
function getDivideShapeFromData(data) {
  if (data.hostModel) {
    return data.hostModel.getModel("universalTransition").get("divideShape");
  }
}
function findTransitionSeriesBatches(globalStore, params) {
  var updateBatches = createHashMap();
  var oldDataMap = createHashMap();
  var oldDataMapForSplit = createHashMap();
  each$f(globalStore.oldSeries, function(series, idx) {
    var oldData = globalStore.oldData[idx];
    var transitionKey = getSeriesTransitionKey(series);
    var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
    oldDataMap.set(transitionKeyStr, oldData);
    if (isArray$1(transitionKey)) {
      each$f(transitionKey, function(key) {
        oldDataMapForSplit.set(key, {
          data: oldData,
          key: transitionKeyStr
        });
      });
    }
  });
  each$f(params.updatedSeries, function(series) {
    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
      var newData = series.getData();
      var transitionKey = getSeriesTransitionKey(series);
      var transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
      var oldData = oldDataMap.get(transitionKeyStr);
      if (oldData) {
        updateBatches.set(transitionKeyStr, {
          oldSeries: [{
            divide: getDivideShapeFromData(oldData),
            data: oldData
          }],
          newSeries: [{
            divide: getDivideShapeFromData(newData),
            data: newData
          }]
        });
      } else {
        if (isArray$1(transitionKey)) {
          var oldSeries_1 = [];
          each$f(transitionKey, function(key) {
            var oldData2 = oldDataMap.get(key);
            if (oldData2) {
              oldSeries_1.push({
                divide: getDivideShapeFromData(oldData2),
                data: oldData2
              });
            }
          });
          if (oldSeries_1.length) {
            updateBatches.set(transitionKeyStr, {
              oldSeries: oldSeries_1,
              newSeries: [{
                data: newData,
                divide: getDivideShapeFromData(newData)
              }]
            });
          }
        } else {
          var oldData_1 = oldDataMapForSplit.get(transitionKey);
          if (oldData_1) {
            var batch = updateBatches.get(oldData_1.key);
            if (!batch) {
              batch = {
                oldSeries: [{
                  data: oldData_1.data,
                  divide: getDivideShapeFromData(oldData_1.data)
                }],
                newSeries: []
              };
              updateBatches.set(oldData_1.key, batch);
            }
            batch.newSeries.push({
              data: newData,
              divide: getDivideShapeFromData(newData)
            });
          }
        }
      }
    }
  });
  return updateBatches;
}
function querySeries(series, finder) {
  for (var i = 0; i < series.length; i++) {
    var found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;
    if (found) {
      return i;
    }
  }
}
function transitionSeriesFromOpt(transitionOpt, globalStore, params, api) {
  var from = [];
  var to = [];
  each$f(normalizeToArray(transitionOpt.from), function(finder) {
    var idx = querySeries(globalStore.oldSeries, finder);
    if (idx >= 0) {
      from.push({
        data: globalStore.oldData[idx],
        divide: getDivideShapeFromData(globalStore.oldData[idx]),
        dim: finder.dimension
      });
    }
  });
  each$f(normalizeToArray(transitionOpt.to), function(finder) {
    var idx = querySeries(params.updatedSeries, finder);
    if (idx >= 0) {
      var data = params.updatedSeries[idx].getData();
      to.push({
        data,
        divide: getDivideShapeFromData(data),
        dim: finder.dimension
      });
    }
  });
  if (from.length > 0 && to.length > 0) {
    transitionBetween(from, to, api);
  }
}
function installUniversalTransition(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", function(ecMOdel, api, params) {
    each$f(normalizeToArray(params.seriesTransition), function(transOpt) {
      each$f(normalizeToArray(transOpt.to), function(finder) {
        var series = params.updatedSeries;
        for (var i = 0; i < series.length; i++) {
          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {
            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;
          }
        }
      });
    });
  });
  registers.registerUpdateLifecycle("series:transition", function(ecModel, api, params) {
    var globalStore = getUniversalTransitionGlobalStore(api);
    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
      var transitionOpt = params.seriesTransition;
      if (transitionOpt) {
        each$f(normalizeToArray(transitionOpt), function(opt) {
          transitionSeriesFromOpt(opt, globalStore, params, api);
        });
      } else {
        var updateBatches_1 = findTransitionSeriesBatches(globalStore, params);
        each$f(updateBatches_1.keys(), function(key) {
          var batch = updateBatches_1.get(key);
          transitionBetween(batch.oldSeries, batch.newSeries, api);
        });
      }
      each$f(params.updatedSeries, function(series) {
        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {
          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;
        }
      });
    }
    var allSeries = ecModel.getSeries();
    var savedSeries = globalStore.oldSeries = [];
    var savedData = globalStore.oldData = [];
    for (var i = 0; i < allSeries.length; i++) {
      var data = allSeries[i].getData();
      if (data.count() < DATA_COUNT_THRESHOLD) {
        savedSeries.push(allSeries[i]);
        savedData.push(data);
      }
    }
  });
}
use([install$15]);
use([install$16]);
use([install$14, install$13, install$12, install$10, install$_, install$Y, install$X, install$W, install$V, install$U, install$T, install$R, install$Q, install$P, install$O, install$N, install$M, install$L, install$K, install$J, install$I, install$H]);
use(install$F);
use(install$E);
use(install$Z);
use(install$D);
use(install$S);
use(install$C);
use(install$B);
use(install$z);
use(install$y);
use(install$G);
use(install$x);
use(install$w);
use(install$v);
use(install$u);
use(install$t);
use(install$s);
use(install$p);
use(install$m);
use(install$o);
use(install$n);
use(install$j);
use(install$l);
use(install$k);
use(install$i);
use(install$h);
use(install$g);
use(installUniversalTransition);
use(installLabelLayout);
use([install$15, install$g]);
use(installLabelLayout);
function derive(makeDefaultOpt, initialize, proto) {
  if (typeof initialize == "object") {
    proto = initialize;
    initialize = null;
  }
  var _super = this;
  var propList;
  if (!(makeDefaultOpt instanceof Function)) {
    propList = [];
    for (var propName in makeDefaultOpt) {
      if (makeDefaultOpt.hasOwnProperty(propName)) {
        propList.push(propName);
      }
    }
  }
  var sub2 = function(options) {
    _super.apply(this, arguments);
    if (makeDefaultOpt instanceof Function) {
      extend(this, makeDefaultOpt.call(this, options));
    } else {
      extendWithPropList(this, makeDefaultOpt, propList);
    }
    if (this.constructor === sub2) {
      var initializers = sub2.__initializers__;
      for (var i = 0; i < initializers.length; i++) {
        initializers[i].apply(this, arguments);
      }
    }
  };
  sub2.__super__ = _super;
  if (!_super.__initializers__) {
    sub2.__initializers__ = [];
  } else {
    sub2.__initializers__ = _super.__initializers__.slice();
  }
  if (initialize) {
    sub2.__initializers__.push(initialize);
  }
  var Ctor = function() {
  };
  Ctor.prototype = _super.prototype;
  sub2.prototype = new Ctor();
  sub2.prototype.constructor = sub2;
  extend(sub2.prototype, proto);
  sub2.extend = _super.extend;
  sub2.derive = _super.extend;
  return sub2;
}
function extend(target, source) {
  if (!source) {
    return;
  }
  for (var name in source) {
    if (source.hasOwnProperty(name)) {
      target[name] = source[name];
    }
  }
}
function extendWithPropList(target, source, propList) {
  for (var i = 0; i < propList.length; i++) {
    var propName = propList[i];
    target[propName] = source[propName];
  }
}
var extendMixin = {
  extend: derive,
  derive
};
function Handler(action, context) {
  this.action = action;
  this.context = context;
}
var notifier = {
  trigger: function(name) {
    if (!this.hasOwnProperty("__handlers__")) {
      return;
    }
    if (!this.__handlers__.hasOwnProperty(name)) {
      return;
    }
    var hdls = this.__handlers__[name];
    var l = hdls.length, i = -1, args = arguments;
    switch (args.length) {
      case 1:
        while (++i < l) {
          hdls[i].action.call(hdls[i].context);
        }
        return;
      case 2:
        while (++i < l) {
          hdls[i].action.call(hdls[i].context, args[1]);
        }
        return;
      case 3:
        while (++i < l) {
          hdls[i].action.call(hdls[i].context, args[1], args[2]);
        }
        return;
      case 4:
        while (++i < l) {
          hdls[i].action.call(hdls[i].context, args[1], args[2], args[3]);
        }
        return;
      case 5:
        while (++i < l) {
          hdls[i].action.call(hdls[i].context, args[1], args[2], args[3], args[4]);
        }
        return;
      default:
        while (++i < l) {
          hdls[i].action.apply(hdls[i].context, Array.prototype.slice.call(args, 1));
        }
        return;
    }
  },
  on: function(name, action, context) {
    if (!name || !action) {
      return;
    }
    var handlers2 = this.__handlers__ || (this.__handlers__ = {});
    if (!handlers2[name]) {
      handlers2[name] = [];
    } else {
      if (this.has(name, action)) {
        return;
      }
    }
    var handler = new Handler(action, context || this);
    handlers2[name].push(handler);
    return this;
  },
  once: function(name, action, context) {
    if (!name || !action) {
      return;
    }
    var self2 = this;
    function wrapper() {
      self2.off(name, wrapper);
      action.apply(this, arguments);
    }
    return this.on(name, wrapper, context);
  },
  before: function(name, action, context) {
    if (!name || !action) {
      return;
    }
    name = "before" + name;
    return this.on(name, action, context);
  },
  after: function(name, action, context) {
    if (!name || !action) {
      return;
    }
    name = "after" + name;
    return this.on(name, action, context);
  },
  success: function(action, context) {
    return this.once("success", action, context);
  },
  error: function(action, context) {
    return this.once("error", action, context);
  },
  off: function(name, action) {
    var handlers2 = this.__handlers__ || (this.__handlers__ = {});
    if (!action) {
      handlers2[name] = [];
      return;
    }
    if (handlers2[name]) {
      var hdls = handlers2[name];
      var retains = [];
      for (var i = 0; i < hdls.length; i++) {
        if (action && hdls[i].action !== action) {
          retains.push(hdls[i]);
        }
      }
      handlers2[name] = retains;
    }
    return this;
  },
  has: function(name, action) {
    var handlers2 = this.__handlers__;
    if (!handlers2 || !handlers2[name]) {
      return false;
    }
    var hdls = handlers2[name];
    for (var i = 0; i < hdls.length; i++) {
      if (hdls[i].action === action) {
        return true;
      }
    }
  }
};
var notifier$1 = notifier;
var guid = 0;
var ArrayProto = Array.prototype;
var nativeForEach = ArrayProto.forEach;
var util = {
  genGUID: function() {
    return ++guid;
  },
  relative2absolute: function(path, basePath) {
    if (!basePath || path.match(/^\//)) {
      return path;
    }
    var pathParts = path.split("/");
    var basePathParts = basePath.split("/");
    var item = pathParts[0];
    while (item === "." || item === "..") {
      if (item === "..") {
        basePathParts.pop();
      }
      pathParts.shift();
      item = pathParts[0];
    }
    return basePathParts.join("/") + "/" + pathParts.join("/");
  },
  extend: function(target, source) {
    if (source) {
      for (var name in source) {
        if (source.hasOwnProperty(name)) {
          target[name] = source[name];
        }
      }
    }
    return target;
  },
  defaults: function(target, source) {
    if (source) {
      for (var propName in source) {
        if (target[propName] === void 0) {
          target[propName] = source[propName];
        }
      }
    }
    return target;
  },
  extendWithPropList: function(target, source, propList) {
    if (source) {
      for (var i = 0; i < propList.length; i++) {
        var propName = propList[i];
        target[propName] = source[propName];
      }
    }
    return target;
  },
  defaultsWithPropList: function(target, source, propList) {
    if (source) {
      for (var i = 0; i < propList.length; i++) {
        var propName = propList[i];
        if (target[propName] == null) {
          target[propName] = source[propName];
        }
      }
    }
    return target;
  },
  each: function(obj, iterator2, context) {
    if (!(obj && iterator2)) {
      return;
    }
    if (obj.forEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator2, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, len2 = obj.length; i < len2; i++) {
        iterator2.call(context, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          iterator2.call(context, obj[key], key, obj);
        }
      }
    }
  },
  isObject: function(obj) {
    return obj === Object(obj);
  },
  isArray: function(obj) {
    return Array.isArray(obj);
  },
  isArrayLike: function(obj) {
    if (!obj) {
      return false;
    } else {
      return obj.length === +obj.length;
    }
  },
  clone: function(obj) {
    if (!util.isObject(obj)) {
      return obj;
    } else if (util.isArray(obj)) {
      return obj.slice();
    } else if (util.isArrayLike(obj)) {
      var ret2 = new obj.constructor(obj.length);
      for (var i = 0; i < obj.length; i++) {
        ret2[i] = obj[i];
      }
      return ret2;
    } else {
      return util.extend({}, obj);
    }
  }
};
var util$1 = util;
var Base = function() {
  this.__uid__ = util$1.genGUID();
};
Base.__initializers__ = [
  function(opts) {
    util$1.extend(this, opts);
  }
];
util$1.extend(Base, extendMixin);
util$1.extend(Base.prototype, notifier$1);
var Base$1 = Base;
var EXTENSION_LIST = [
  "OES_texture_float",
  "OES_texture_half_float",
  "OES_texture_float_linear",
  "OES_texture_half_float_linear",
  "OES_standard_derivatives",
  "OES_vertex_array_object",
  "OES_element_index_uint",
  "WEBGL_compressed_texture_s3tc",
  "WEBGL_depth_texture",
  "EXT_texture_filter_anisotropic",
  "EXT_shader_texture_lod",
  "WEBGL_draw_buffers",
  "EXT_frag_depth",
  "EXT_sRGB",
  "ANGLE_instanced_arrays"
];
var PARAMETER_NAMES = [
  "MAX_TEXTURE_SIZE",
  "MAX_CUBE_MAP_TEXTURE_SIZE"
];
function GLInfo(_gl) {
  var extensions2 = {};
  var parameters = {};
  for (var i = 0; i < EXTENSION_LIST.length; i++) {
    var extName = EXTENSION_LIST[i];
    createExtension(extName);
  }
  for (var i = 0; i < PARAMETER_NAMES.length; i++) {
    var name = PARAMETER_NAMES[i];
    parameters[name] = _gl.getParameter(_gl[name]);
  }
  this.getExtension = function(name2) {
    if (!(name2 in extensions2)) {
      createExtension(name2);
    }
    return extensions2[name2];
  };
  this.getParameter = function(name2) {
    return parameters[name2];
  };
  function createExtension(name2) {
    if (_gl.getExtension) {
      var ext = _gl.getExtension(name2);
      if (!ext) {
        ext = _gl.getExtension("MOZ_" + name2);
      }
      if (!ext) {
        ext = _gl.getExtension("WEBKIT_" + name2);
      }
      extensions2[name2] = ext;
    }
  }
}
var glenum = {
  DEPTH_BUFFER_BIT: 256,
  STENCIL_BUFFER_BIT: 1024,
  COLOR_BUFFER_BIT: 16384,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  ZERO: 0,
  ONE: 1,
  SRC_COLOR: 768,
  ONE_MINUS_SRC_COLOR: 769,
  SRC_ALPHA: 770,
  ONE_MINUS_SRC_ALPHA: 771,
  DST_ALPHA: 772,
  ONE_MINUS_DST_ALPHA: 773,
  DST_COLOR: 774,
  ONE_MINUS_DST_COLOR: 775,
  SRC_ALPHA_SATURATE: 776,
  FUNC_ADD: 32774,
  BLEND_EQUATION: 32777,
  BLEND_EQUATION_RGB: 32777,
  BLEND_EQUATION_ALPHA: 34877,
  FUNC_SUBTRACT: 32778,
  FUNC_REVERSE_SUBTRACT: 32779,
  BLEND_DST_RGB: 32968,
  BLEND_SRC_RGB: 32969,
  BLEND_DST_ALPHA: 32970,
  BLEND_SRC_ALPHA: 32971,
  CONSTANT_COLOR: 32769,
  ONE_MINUS_CONSTANT_COLOR: 32770,
  CONSTANT_ALPHA: 32771,
  ONE_MINUS_CONSTANT_ALPHA: 32772,
  BLEND_COLOR: 32773,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  ARRAY_BUFFER_BINDING: 34964,
  ELEMENT_ARRAY_BUFFER_BINDING: 34965,
  STREAM_DRAW: 35040,
  STATIC_DRAW: 35044,
  DYNAMIC_DRAW: 35048,
  BUFFER_SIZE: 34660,
  BUFFER_USAGE: 34661,
  CURRENT_VERTEX_ATTRIB: 34342,
  FRONT: 1028,
  BACK: 1029,
  FRONT_AND_BACK: 1032,
  CULL_FACE: 2884,
  BLEND: 3042,
  DITHER: 3024,
  STENCIL_TEST: 2960,
  DEPTH_TEST: 2929,
  SCISSOR_TEST: 3089,
  POLYGON_OFFSET_FILL: 32823,
  SAMPLE_ALPHA_TO_COVERAGE: 32926,
  SAMPLE_COVERAGE: 32928,
  NO_ERROR: 0,
  INVALID_ENUM: 1280,
  INVALID_VALUE: 1281,
  INVALID_OPERATION: 1282,
  OUT_OF_MEMORY: 1285,
  CW: 2304,
  CCW: 2305,
  LINE_WIDTH: 2849,
  ALIASED_POINT_SIZE_RANGE: 33901,
  ALIASED_LINE_WIDTH_RANGE: 33902,
  CULL_FACE_MODE: 2885,
  FRONT_FACE: 2886,
  DEPTH_RANGE: 2928,
  DEPTH_WRITEMASK: 2930,
  DEPTH_CLEAR_VALUE: 2931,
  DEPTH_FUNC: 2932,
  STENCIL_CLEAR_VALUE: 2961,
  STENCIL_FUNC: 2962,
  STENCIL_FAIL: 2964,
  STENCIL_PASS_DEPTH_FAIL: 2965,
  STENCIL_PASS_DEPTH_PASS: 2966,
  STENCIL_REF: 2967,
  STENCIL_VALUE_MASK: 2963,
  STENCIL_WRITEMASK: 2968,
  STENCIL_BACK_FUNC: 34816,
  STENCIL_BACK_FAIL: 34817,
  STENCIL_BACK_PASS_DEPTH_FAIL: 34818,
  STENCIL_BACK_PASS_DEPTH_PASS: 34819,
  STENCIL_BACK_REF: 36003,
  STENCIL_BACK_VALUE_MASK: 36004,
  STENCIL_BACK_WRITEMASK: 36005,
  VIEWPORT: 2978,
  SCISSOR_BOX: 3088,
  COLOR_CLEAR_VALUE: 3106,
  COLOR_WRITEMASK: 3107,
  UNPACK_ALIGNMENT: 3317,
  PACK_ALIGNMENT: 3333,
  MAX_TEXTURE_SIZE: 3379,
  MAX_VIEWPORT_DIMS: 3386,
  SUBPIXEL_BITS: 3408,
  RED_BITS: 3410,
  GREEN_BITS: 3411,
  BLUE_BITS: 3412,
  ALPHA_BITS: 3413,
  DEPTH_BITS: 3414,
  STENCIL_BITS: 3415,
  POLYGON_OFFSET_UNITS: 10752,
  POLYGON_OFFSET_FACTOR: 32824,
  TEXTURE_BINDING_2D: 32873,
  SAMPLE_BUFFERS: 32936,
  SAMPLES: 32937,
  SAMPLE_COVERAGE_VALUE: 32938,
  SAMPLE_COVERAGE_INVERT: 32939,
  COMPRESSED_TEXTURE_FORMATS: 34467,
  DONT_CARE: 4352,
  FASTEST: 4353,
  NICEST: 4354,
  GENERATE_MIPMAP_HINT: 33170,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DEPTH_COMPONENT: 6402,
  ALPHA: 6406,
  RGB: 6407,
  RGBA: 6408,
  LUMINANCE: 6409,
  LUMINANCE_ALPHA: 6410,
  UNSIGNED_SHORT_4_4_4_4: 32819,
  UNSIGNED_SHORT_5_5_5_1: 32820,
  UNSIGNED_SHORT_5_6_5: 33635,
  FRAGMENT_SHADER: 35632,
  VERTEX_SHADER: 35633,
  MAX_VERTEX_ATTRIBS: 34921,
  MAX_VERTEX_UNIFORM_VECTORS: 36347,
  MAX_VARYING_VECTORS: 36348,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 35661,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 35660,
  MAX_TEXTURE_IMAGE_UNITS: 34930,
  MAX_FRAGMENT_UNIFORM_VECTORS: 36349,
  SHADER_TYPE: 35663,
  DELETE_STATUS: 35712,
  LINK_STATUS: 35714,
  VALIDATE_STATUS: 35715,
  ATTACHED_SHADERS: 35717,
  ACTIVE_UNIFORMS: 35718,
  ACTIVE_ATTRIBUTES: 35721,
  SHADING_LANGUAGE_VERSION: 35724,
  CURRENT_PROGRAM: 35725,
  NEVER: 512,
  LESS: 513,
  EQUAL: 514,
  LEQUAL: 515,
  GREATER: 516,
  NOTEQUAL: 517,
  GEQUAL: 518,
  ALWAYS: 519,
  KEEP: 7680,
  REPLACE: 7681,
  INCR: 7682,
  DECR: 7683,
  INVERT: 5386,
  INCR_WRAP: 34055,
  DECR_WRAP: 34056,
  VENDOR: 7936,
  RENDERER: 7937,
  VERSION: 7938,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  TEXTURE_2D: 3553,
  TEXTURE: 5890,
  TEXTURE_CUBE_MAP: 34067,
  TEXTURE_BINDING_CUBE_MAP: 34068,
  TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
  MAX_CUBE_MAP_TEXTURE_SIZE: 34076,
  TEXTURE0: 33984,
  TEXTURE1: 33985,
  TEXTURE2: 33986,
  TEXTURE3: 33987,
  TEXTURE4: 33988,
  TEXTURE5: 33989,
  TEXTURE6: 33990,
  TEXTURE7: 33991,
  TEXTURE8: 33992,
  TEXTURE9: 33993,
  TEXTURE10: 33994,
  TEXTURE11: 33995,
  TEXTURE12: 33996,
  TEXTURE13: 33997,
  TEXTURE14: 33998,
  TEXTURE15: 33999,
  TEXTURE16: 34e3,
  TEXTURE17: 34001,
  TEXTURE18: 34002,
  TEXTURE19: 34003,
  TEXTURE20: 34004,
  TEXTURE21: 34005,
  TEXTURE22: 34006,
  TEXTURE23: 34007,
  TEXTURE24: 34008,
  TEXTURE25: 34009,
  TEXTURE26: 34010,
  TEXTURE27: 34011,
  TEXTURE28: 34012,
  TEXTURE29: 34013,
  TEXTURE30: 34014,
  TEXTURE31: 34015,
  ACTIVE_TEXTURE: 34016,
  REPEAT: 10497,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  INT_VEC2: 35667,
  INT_VEC3: 35668,
  INT_VEC4: 35669,
  BOOL: 35670,
  BOOL_VEC2: 35671,
  BOOL_VEC3: 35672,
  BOOL_VEC4: 35673,
  FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  SAMPLER_2D: 35678,
  SAMPLER_CUBE: 35680,
  VERTEX_ATTRIB_ARRAY_ENABLED: 34338,
  VERTEX_ATTRIB_ARRAY_SIZE: 34339,
  VERTEX_ATTRIB_ARRAY_STRIDE: 34340,
  VERTEX_ATTRIB_ARRAY_TYPE: 34341,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 34922,
  VERTEX_ATTRIB_ARRAY_POINTER: 34373,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 34975,
  COMPILE_STATUS: 35713,
  LOW_FLOAT: 36336,
  MEDIUM_FLOAT: 36337,
  HIGH_FLOAT: 36338,
  LOW_INT: 36339,
  MEDIUM_INT: 36340,
  HIGH_INT: 36341,
  FRAMEBUFFER: 36160,
  RENDERBUFFER: 36161,
  RGBA4: 32854,
  RGB5_A1: 32855,
  RGB565: 36194,
  DEPTH_COMPONENT16: 33189,
  STENCIL_INDEX: 6401,
  STENCIL_INDEX8: 36168,
  DEPTH_STENCIL: 34041,
  RENDERBUFFER_WIDTH: 36162,
  RENDERBUFFER_HEIGHT: 36163,
  RENDERBUFFER_INTERNAL_FORMAT: 36164,
  RENDERBUFFER_RED_SIZE: 36176,
  RENDERBUFFER_GREEN_SIZE: 36177,
  RENDERBUFFER_BLUE_SIZE: 36178,
  RENDERBUFFER_ALPHA_SIZE: 36179,
  RENDERBUFFER_DEPTH_SIZE: 36180,
  RENDERBUFFER_STENCIL_SIZE: 36181,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 36048,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 36049,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 36050,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 36051,
  COLOR_ATTACHMENT0: 36064,
  DEPTH_ATTACHMENT: 36096,
  STENCIL_ATTACHMENT: 36128,
  DEPTH_STENCIL_ATTACHMENT: 33306,
  NONE: 0,
  FRAMEBUFFER_COMPLETE: 36053,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 36054,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 36055,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 36057,
  FRAMEBUFFER_UNSUPPORTED: 36061,
  FRAMEBUFFER_BINDING: 36006,
  RENDERBUFFER_BINDING: 36007,
  MAX_RENDERBUFFER_SIZE: 34024,
  INVALID_FRAMEBUFFER_OPERATION: 1286,
  UNPACK_FLIP_Y_WEBGL: 37440,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 37441,
  CONTEXT_LOST_WEBGL: 37442,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 37443,
  BROWSER_DEFAULT_WEBGL: 37444
};
function get(options) {
  var xhr = new XMLHttpRequest();
  xhr.open("get", options.url);
  xhr.responseType = options.responseType || "text";
  if (options.onprogress) {
    xhr.onprogress = function(e2) {
      if (e2.lengthComputable) {
        var percent = e2.loaded / e2.total;
        options.onprogress(percent, e2.loaded, e2.total);
      } else {
        options.onprogress(null);
      }
    };
  }
  xhr.onload = function(e2) {
    if (xhr.status >= 400) {
      options.onerror && options.onerror();
    } else {
      options.onload && options.onload(xhr.response);
    }
  };
  if (options.onerror) {
    xhr.onerror = options.onerror;
  }
  xhr.send(null);
}
var request = {
  get
};
var supportWebGL;
var vendor = {};
vendor.supportWebGL = function() {
  if (supportWebGL == null) {
    try {
      var canvas = document.createElement("canvas");
      var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
      if (!gl) {
        throw new Error();
      }
    } catch (e2) {
      supportWebGL = false;
    }
  }
  return supportWebGL;
};
vendor.Int8Array = typeof Int8Array === "undefined" ? Array : Int8Array;
vendor.Uint8Array = typeof Uint8Array === "undefined" ? Array : Uint8Array;
vendor.Uint16Array = typeof Uint16Array === "undefined" ? Array : Uint16Array;
vendor.Uint32Array = typeof Uint32Array === "undefined" ? Array : Uint32Array;
vendor.Int16Array = typeof Int16Array === "undefined" ? Array : Int16Array;
vendor.Float32Array = typeof Float32Array === "undefined" ? Array : Float32Array;
vendor.Float64Array = typeof Float64Array === "undefined" ? Array : Float64Array;
var g = {};
if (typeof window !== "undefined") {
  g = window;
} else if (typeof global !== "undefined") {
  g = global;
}
vendor.requestAnimationFrame = g.requestAnimationFrame || g.msRequestAnimationFrame || g.mozRequestAnimationFrame || g.webkitRequestAnimationFrame || function(func) {
  setTimeout(func, 16);
};
vendor.createCanvas = function() {
  return document.createElement("canvas");
};
vendor.createImage = function() {
  return new g.Image();
};
vendor.request = {
  get: request.get
};
vendor.addEventListener = function(dom, type, func, useCapture) {
  dom.addEventListener(type, func, useCapture);
};
vendor.removeEventListener = function(dom, type, func) {
  dom.removeEventListener(type, func);
};
var vendor$1 = vendor;
var LinkedList = function() {
  this.head = null;
  this.tail = null;
  this._length = 0;
};
LinkedList.prototype.insert = function(val) {
  var entry = new LinkedList.Entry(val);
  this.insertEntry(entry);
  return entry;
};
LinkedList.prototype.insertAt = function(idx, val) {
  if (idx < 0) {
    return;
  }
  var next = this.head;
  var cursor = 0;
  while (next && cursor != idx) {
    next = next.next;
    cursor++;
  }
  if (next) {
    var entry = new LinkedList.Entry(val);
    var prev = next.prev;
    if (!prev) {
      this.head = entry;
    } else {
      prev.next = entry;
      entry.prev = prev;
    }
    entry.next = next;
    next.prev = entry;
  } else {
    this.insert(val);
  }
};
LinkedList.prototype.insertBeforeEntry = function(val, next) {
  var entry = new LinkedList.Entry(val);
  var prev = next.prev;
  if (!prev) {
    this.head = entry;
  } else {
    prev.next = entry;
    entry.prev = prev;
  }
  entry.next = next;
  next.prev = entry;
  this._length++;
};
LinkedList.prototype.insertEntry = function(entry) {
  if (!this.head) {
    this.head = this.tail = entry;
  } else {
    this.tail.next = entry;
    entry.prev = this.tail;
    this.tail = entry;
  }
  this._length++;
};
LinkedList.prototype.remove = function(entry) {
  var prev = entry.prev;
  var next = entry.next;
  if (prev) {
    prev.next = next;
  } else {
    this.head = next;
  }
  if (next) {
    next.prev = prev;
  } else {
    this.tail = prev;
  }
  entry.next = entry.prev = null;
  this._length--;
};
LinkedList.prototype.removeAt = function(idx) {
  if (idx < 0) {
    return;
  }
  var curr = this.head;
  var cursor = 0;
  while (curr && cursor != idx) {
    curr = curr.next;
    cursor++;
  }
  if (curr) {
    this.remove(curr);
    return curr.value;
  }
};
LinkedList.prototype.getHead = function() {
  if (this.head) {
    return this.head.value;
  }
};
LinkedList.prototype.getTail = function() {
  if (this.tail) {
    return this.tail.value;
  }
};
LinkedList.prototype.getAt = function(idx) {
  if (idx < 0) {
    return;
  }
  var curr = this.head;
  var cursor = 0;
  while (curr && cursor != idx) {
    curr = curr.next;
    cursor++;
  }
  return curr.value;
};
LinkedList.prototype.indexOf = function(value) {
  var curr = this.head;
  var cursor = 0;
  while (curr) {
    if (curr.value === value) {
      return cursor;
    }
    curr = curr.next;
    cursor++;
  }
};
LinkedList.prototype.length = function() {
  return this._length;
};
LinkedList.prototype.isEmpty = function() {
  return this._length === 0;
};
LinkedList.prototype.forEach = function(cb, context) {
  var curr = this.head;
  var idx = 0;
  var haveContext = typeof context != "undefined";
  while (curr) {
    if (haveContext) {
      cb.call(context, curr.value, idx);
    } else {
      cb(curr.value, idx);
    }
    curr = curr.next;
    idx++;
  }
};
LinkedList.prototype.clear = function() {
  this.tail = this.head = null;
  this._length = 0;
};
LinkedList.Entry = function(val) {
  this.value = val;
  this.next = null;
  this.prev = null;
};
var LinkedList$1 = LinkedList;
var LRU = function(maxSize) {
  this._list = new LinkedList$1();
  this._map = {};
  this._maxSize = maxSize || 10;
};
LRU.prototype.setMaxSize = function(size) {
  this._maxSize = size;
};
LRU.prototype.put = function(key, value) {
  if (!this._map.hasOwnProperty(key)) {
    var len2 = this._list.length();
    if (len2 >= this._maxSize && len2 > 0) {
      var leastUsedEntry = this._list.head;
      this._list.remove(leastUsedEntry);
      delete this._map[leastUsedEntry.key];
    }
    var entry = this._list.insert(value);
    entry.key = key;
    this._map[key] = entry;
  }
};
LRU.prototype.get = function(key) {
  var entry = this._map[key];
  if (this._map.hasOwnProperty(key)) {
    if (entry !== this._list.tail) {
      this._list.remove(entry);
      this._list.insertEntry(entry);
    }
    return entry.value;
  }
};
LRU.prototype.remove = function(key) {
  var entry = this._map[key];
  if (typeof entry !== "undefined") {
    delete this._map[key];
    this._list.remove(entry);
  }
};
LRU.prototype.clear = function() {
  this._list.clear();
  this._map = {};
};
var LRUCache = LRU;
var colorUtil = {};
var kCSSColorTable = {
  "transparent": [0, 0, 0, 0],
  "aliceblue": [240, 248, 255, 1],
  "antiquewhite": [250, 235, 215, 1],
  "aqua": [0, 255, 255, 1],
  "aquamarine": [127, 255, 212, 1],
  "azure": [240, 255, 255, 1],
  "beige": [245, 245, 220, 1],
  "bisque": [255, 228, 196, 1],
  "black": [0, 0, 0, 1],
  "blanchedalmond": [255, 235, 205, 1],
  "blue": [0, 0, 255, 1],
  "blueviolet": [138, 43, 226, 1],
  "brown": [165, 42, 42, 1],
  "burlywood": [222, 184, 135, 1],
  "cadetblue": [95, 158, 160, 1],
  "chartreuse": [127, 255, 0, 1],
  "chocolate": [210, 105, 30, 1],
  "coral": [255, 127, 80, 1],
  "cornflowerblue": [100, 149, 237, 1],
  "cornsilk": [255, 248, 220, 1],
  "crimson": [220, 20, 60, 1],
  "cyan": [0, 255, 255, 1],
  "darkblue": [0, 0, 139, 1],
  "darkcyan": [0, 139, 139, 1],
  "darkgoldenrod": [184, 134, 11, 1],
  "darkgray": [169, 169, 169, 1],
  "darkgreen": [0, 100, 0, 1],
  "darkgrey": [169, 169, 169, 1],
  "darkkhaki": [189, 183, 107, 1],
  "darkmagenta": [139, 0, 139, 1],
  "darkolivegreen": [85, 107, 47, 1],
  "darkorange": [255, 140, 0, 1],
  "darkorchid": [153, 50, 204, 1],
  "darkred": [139, 0, 0, 1],
  "darksalmon": [233, 150, 122, 1],
  "darkseagreen": [143, 188, 143, 1],
  "darkslateblue": [72, 61, 139, 1],
  "darkslategray": [47, 79, 79, 1],
  "darkslategrey": [47, 79, 79, 1],
  "darkturquoise": [0, 206, 209, 1],
  "darkviolet": [148, 0, 211, 1],
  "deeppink": [255, 20, 147, 1],
  "deepskyblue": [0, 191, 255, 1],
  "dimgray": [105, 105, 105, 1],
  "dimgrey": [105, 105, 105, 1],
  "dodgerblue": [30, 144, 255, 1],
  "firebrick": [178, 34, 34, 1],
  "floralwhite": [255, 250, 240, 1],
  "forestgreen": [34, 139, 34, 1],
  "fuchsia": [255, 0, 255, 1],
  "gainsboro": [220, 220, 220, 1],
  "ghostwhite": [248, 248, 255, 1],
  "gold": [255, 215, 0, 1],
  "goldenrod": [218, 165, 32, 1],
  "gray": [128, 128, 128, 1],
  "green": [0, 128, 0, 1],
  "greenyellow": [173, 255, 47, 1],
  "grey": [128, 128, 128, 1],
  "honeydew": [240, 255, 240, 1],
  "hotpink": [255, 105, 180, 1],
  "indianred": [205, 92, 92, 1],
  "indigo": [75, 0, 130, 1],
  "ivory": [255, 255, 240, 1],
  "khaki": [240, 230, 140, 1],
  "lavender": [230, 230, 250, 1],
  "lavenderblush": [255, 240, 245, 1],
  "lawngreen": [124, 252, 0, 1],
  "lemonchiffon": [255, 250, 205, 1],
  "lightblue": [173, 216, 230, 1],
  "lightcoral": [240, 128, 128, 1],
  "lightcyan": [224, 255, 255, 1],
  "lightgoldenrodyellow": [250, 250, 210, 1],
  "lightgray": [211, 211, 211, 1],
  "lightgreen": [144, 238, 144, 1],
  "lightgrey": [211, 211, 211, 1],
  "lightpink": [255, 182, 193, 1],
  "lightsalmon": [255, 160, 122, 1],
  "lightseagreen": [32, 178, 170, 1],
  "lightskyblue": [135, 206, 250, 1],
  "lightslategray": [119, 136, 153, 1],
  "lightslategrey": [119, 136, 153, 1],
  "lightsteelblue": [176, 196, 222, 1],
  "lightyellow": [255, 255, 224, 1],
  "lime": [0, 255, 0, 1],
  "limegreen": [50, 205, 50, 1],
  "linen": [250, 240, 230, 1],
  "magenta": [255, 0, 255, 1],
  "maroon": [128, 0, 0, 1],
  "mediumaquamarine": [102, 205, 170, 1],
  "mediumblue": [0, 0, 205, 1],
  "mediumorchid": [186, 85, 211, 1],
  "mediumpurple": [147, 112, 219, 1],
  "mediumseagreen": [60, 179, 113, 1],
  "mediumslateblue": [123, 104, 238, 1],
  "mediumspringgreen": [0, 250, 154, 1],
  "mediumturquoise": [72, 209, 204, 1],
  "mediumvioletred": [199, 21, 133, 1],
  "midnightblue": [25, 25, 112, 1],
  "mintcream": [245, 255, 250, 1],
  "mistyrose": [255, 228, 225, 1],
  "moccasin": [255, 228, 181, 1],
  "navajowhite": [255, 222, 173, 1],
  "navy": [0, 0, 128, 1],
  "oldlace": [253, 245, 230, 1],
  "olive": [128, 128, 0, 1],
  "olivedrab": [107, 142, 35, 1],
  "orange": [255, 165, 0, 1],
  "orangered": [255, 69, 0, 1],
  "orchid": [218, 112, 214, 1],
  "palegoldenrod": [238, 232, 170, 1],
  "palegreen": [152, 251, 152, 1],
  "paleturquoise": [175, 238, 238, 1],
  "palevioletred": [219, 112, 147, 1],
  "papayawhip": [255, 239, 213, 1],
  "peachpuff": [255, 218, 185, 1],
  "peru": [205, 133, 63, 1],
  "pink": [255, 192, 203, 1],
  "plum": [221, 160, 221, 1],
  "powderblue": [176, 224, 230, 1],
  "purple": [128, 0, 128, 1],
  "red": [255, 0, 0, 1],
  "rosybrown": [188, 143, 143, 1],
  "royalblue": [65, 105, 225, 1],
  "saddlebrown": [139, 69, 19, 1],
  "salmon": [250, 128, 114, 1],
  "sandybrown": [244, 164, 96, 1],
  "seagreen": [46, 139, 87, 1],
  "seashell": [255, 245, 238, 1],
  "sienna": [160, 82, 45, 1],
  "silver": [192, 192, 192, 1],
  "skyblue": [135, 206, 235, 1],
  "slateblue": [106, 90, 205, 1],
  "slategray": [112, 128, 144, 1],
  "slategrey": [112, 128, 144, 1],
  "snow": [255, 250, 250, 1],
  "springgreen": [0, 255, 127, 1],
  "steelblue": [70, 130, 180, 1],
  "tan": [210, 180, 140, 1],
  "teal": [0, 128, 128, 1],
  "thistle": [216, 191, 216, 1],
  "tomato": [255, 99, 71, 1],
  "turquoise": [64, 224, 208, 1],
  "violet": [238, 130, 238, 1],
  "wheat": [245, 222, 179, 1],
  "white": [255, 255, 255, 1],
  "whitesmoke": [245, 245, 245, 1],
  "yellow": [255, 255, 0, 1],
  "yellowgreen": [154, 205, 50, 1]
};
function clampCssByte(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clampCssAngle(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 360 ? 360 : i;
}
function clampCssFloat(f) {
  return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parseCssInt(str) {
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }
  return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(str) {
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat(parseFloat(str) / 100);
  }
  return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }
  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }
  if (h * 2 < 1) {
    return m2;
  }
  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }
  return m1;
}
function lerpNumber(a, b, p) {
  return a + (b - a) * p;
}
function setRgba(out2, r, g2, b, a) {
  out2[0] = r;
  out2[1] = g2;
  out2[2] = b;
  out2[3] = a;
  return out2;
}
function copyRgba(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
}
var colorCache = new LRUCache(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }
  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
colorUtil.parse = function(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);
  if (cached) {
    return copyRgba(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  var str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  }
  if (str.charAt(0) === "#") {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  var op = str.indexOf("("), ep = str.indexOf(")");
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(",");
    var alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        alpha = parseCssFloat(params.pop());
      case "rgb":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsla":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
};
colorUtil.parseToFloat = function(colorStr, rgbaArr) {
  rgbaArr = colorUtil.parse(colorStr, rgbaArr);
  if (!rgbaArr) {
    return;
  }
  rgbaArr[0] /= 255;
  rgbaArr[1] /= 255;
  rgbaArr[2] /= 255;
  return rgbaArr;
};
function hsla2rgba(hsla, rgba) {
  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  var s = parseCssFloat(hsla[1]);
  var l = parseCssFloat(hsla[2]);
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  }
  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B = rgba[2] / 255;
  var vMin = Math.min(R, G, B);
  var vMax = Math.max(R, G, B);
  var delta = vMax - vMin;
  var L = (vMax + vMin) / 2;
  var H;
  var S;
  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }
    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }
    if (H < 0) {
      H += 1;
    }
    if (H > 1) {
      H -= 1;
    }
  }
  var hsla = [H * 360, S, L];
  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }
  return hsla;
}
colorUtil.lift = function(color, level) {
  var colorArr = colorUtil.parse(color);
  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
    }
    return colorUtil.stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
};
colorUtil.toHex = function(color) {
  var colorArr = colorUtil.parse(color);
  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
};
colorUtil.fastLerp = function(normalizedValue, colors, out2) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  out2 = out2 || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out2;
};
colorUtil.fastMapToColor = colorUtil.fastLerp;
colorUtil.lerp = function(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colorUtil.parse(colors[leftIndex]);
  var rightColor = colorUtil.parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color = colorUtil.stringify([
    clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
    clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
    clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
    clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
  ], "rgba");
  return fullOutput ? {
    color,
    leftIndex,
    rightIndex,
    value
  } : color;
};
colorUtil.mapToColor = colorUtil.lerp;
colorUtil.modifyHSL = function(color, h, s, l) {
  color = colorUtil.parse(color);
  if (color) {
    color = rgba2hsla(color);
    h != null && (color[0] = clampCssAngle(h));
    s != null && (color[1] = parseCssFloat(s));
    l != null && (color[2] = parseCssFloat(l));
    return colorUtil.stringify(hsla2rgba(color), "rgba");
  }
};
colorUtil.modifyAlpha = function(color, alpha) {
  color = colorUtil.parse(color);
  if (color && alpha != null) {
    color[3] = clampCssFloat(alpha);
    return colorUtil.stringify(color, "rgba");
  }
};
colorUtil.stringify = function(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type === "rgba" || type === "hsva" || type === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type + "(" + colorStr + ")";
};
var colorUtil$1 = colorUtil;
var parseColor = colorUtil$1.parseToFloat;
var programKeyCache$1 = {};
function getDefineCode$1(defines) {
  var defineKeys = Object.keys(defines);
  defineKeys.sort();
  var defineStr = [];
  for (var i = 0; i < defineKeys.length; i++) {
    var key = defineKeys[i];
    var value = defines[key];
    if (value === null) {
      defineStr.push(key);
    } else {
      defineStr.push(key + " " + value.toString());
    }
  }
  return defineStr.join("\n");
}
function getProgramKey$1(vertexDefines, fragmentDefines, enabledTextures) {
  enabledTextures.sort();
  var defineStr = [];
  for (var i = 0; i < enabledTextures.length; i++) {
    var symbol = enabledTextures[i];
    defineStr.push(symbol);
  }
  var key = getDefineCode$1(vertexDefines) + "\n" + getDefineCode$1(fragmentDefines) + "\n" + defineStr.join("\n");
  if (programKeyCache$1[key]) {
    return programKeyCache$1[key];
  }
  var id = util$1.genGUID();
  programKeyCache$1[key] = id;
  return id;
}
var Material = Base$1.extend(function() {
  return {
    name: "",
    depthTest: true,
    depthMask: true,
    transparent: false,
    blend: null,
    autoUpdateTextureStatus: true,
    uniforms: {},
    vertexDefines: {},
    fragmentDefines: {},
    _textureStatus: {},
    _enabledUniforms: null
  };
}, function() {
  if (!this.name) {
    this.name = "MATERIAL_" + this.__uid__;
  }
  if (this.shader) {
    this.attachShader(this.shader, true);
  }
}, {
  precision: "highp",
  setUniform: function(symbol, value) {
    if (value === void 0) {
      console.warn('Uniform value "' + symbol + '" is undefined');
    }
    var uniform = this.uniforms[symbol];
    if (uniform) {
      if (typeof value === "string") {
        value = parseColor(value) || value;
      }
      uniform.value = value;
      if (this.autoUpdateTextureStatus && uniform.type === "t") {
        if (value) {
          this.enableTexture(symbol);
        } else {
          this.disableTexture(symbol);
        }
      }
    }
  },
  setUniforms: function(obj) {
    for (var key in obj) {
      var val = obj[key];
      this.setUniform(key, val);
    }
  },
  isUniformEnabled: function(symbol) {
    return this._enabledUniforms.indexOf(symbol) >= 0;
  },
  getEnabledUniforms: function() {
    return this._enabledUniforms;
  },
  getTextureUniforms: function() {
    return this._textureUniforms;
  },
  set: function(symbol, value) {
    if (typeof symbol === "object") {
      for (var key in symbol) {
        var val = symbol[key];
        this.setUniform(key, val);
      }
    } else {
      this.setUniform(symbol, value);
    }
  },
  get: function(symbol) {
    var uniform = this.uniforms[symbol];
    if (uniform) {
      return uniform.value;
    }
  },
  attachShader: function(shader, keepStatus) {
    var originalUniforms = this.uniforms;
    this.uniforms = shader.createUniforms();
    this.shader = shader;
    var uniforms = this.uniforms;
    this._enabledUniforms = Object.keys(uniforms);
    this._enabledUniforms.sort();
    this._textureUniforms = this._enabledUniforms.filter(function(uniformName) {
      var type = this.uniforms[uniformName].type;
      return type === "t" || type === "tv";
    }, this);
    var originalVertexDefines = this.vertexDefines;
    var originalFragmentDefines = this.fragmentDefines;
    this.vertexDefines = util$1.clone(shader.vertexDefines);
    this.fragmentDefines = util$1.clone(shader.fragmentDefines);
    if (keepStatus) {
      for (var symbol in originalUniforms) {
        if (uniforms[symbol]) {
          uniforms[symbol].value = originalUniforms[symbol].value;
        }
      }
      util$1.defaults(this.vertexDefines, originalVertexDefines);
      util$1.defaults(this.fragmentDefines, originalFragmentDefines);
    }
    var textureStatus = {};
    for (var key in shader.textures) {
      textureStatus[key] = {
        shaderType: shader.textures[key].shaderType,
        type: shader.textures[key].type,
        enabled: keepStatus && this._textureStatus[key] ? this._textureStatus[key].enabled : false
      };
    }
    this._textureStatus = textureStatus;
    this._programKey = "";
  },
  clone: function() {
    var material = new this.constructor({
      name: this.name,
      shader: this.shader
    });
    for (var symbol in this.uniforms) {
      material.uniforms[symbol].value = this.uniforms[symbol].value;
    }
    material.depthTest = this.depthTest;
    material.depthMask = this.depthMask;
    material.transparent = this.transparent;
    material.blend = this.blend;
    material.vertexDefines = util$1.clone(this.vertexDefines);
    material.fragmentDefines = util$1.clone(this.fragmentDefines);
    material.enableTexture(this.getEnabledTextures());
    material.precision = this.precision;
    return material;
  },
  define: function(shaderType, symbol, val) {
    var vertexDefines = this.vertexDefines;
    var fragmentDefines = this.fragmentDefines;
    if (shaderType !== "vertex" && shaderType !== "fragment" && shaderType !== "both" && arguments.length < 3) {
      val = symbol;
      symbol = shaderType;
      shaderType = "both";
    }
    val = val != null ? val : null;
    if (shaderType === "vertex" || shaderType === "both") {
      if (vertexDefines[symbol] !== val) {
        vertexDefines[symbol] = val;
        this._programKey = "";
      }
    }
    if (shaderType === "fragment" || shaderType === "both") {
      if (fragmentDefines[symbol] !== val) {
        fragmentDefines[symbol] = val;
        if (shaderType !== "both") {
          this._programKey = "";
        }
      }
    }
  },
  undefine: function(shaderType, symbol) {
    if (shaderType !== "vertex" && shaderType !== "fragment" && shaderType !== "both" && arguments.length < 2) {
      symbol = shaderType;
      shaderType = "both";
    }
    if (shaderType === "vertex" || shaderType === "both") {
      if (this.isDefined("vertex", symbol)) {
        delete this.vertexDefines[symbol];
        this._programKey = "";
      }
    }
    if (shaderType === "fragment" || shaderType === "both") {
      if (this.isDefined("fragment", symbol)) {
        delete this.fragmentDefines[symbol];
        if (shaderType !== "both") {
          this._programKey = "";
        }
      }
    }
  },
  isDefined: function(shaderType, symbol) {
    switch (shaderType) {
      case "vertex":
        return this.vertexDefines[symbol] !== void 0;
      case "fragment":
        return this.fragmentDefines[symbol] !== void 0;
    }
  },
  getDefine: function(shaderType, symbol) {
    switch (shaderType) {
      case "vertex":
        return this.vertexDefines[symbol];
      case "fragment":
        return this.fragmentDefines[symbol];
    }
  },
  enableTexture: function(symbol) {
    if (Array.isArray(symbol)) {
      for (var i = 0; i < symbol.length; i++) {
        this.enableTexture(symbol[i]);
      }
      return;
    }
    var status = this._textureStatus[symbol];
    if (status) {
      var isEnabled = status.enabled;
      if (!isEnabled) {
        status.enabled = true;
        this._programKey = "";
      }
    }
  },
  enableTexturesAll: function() {
    var textureStatus = this._textureStatus;
    for (var symbol in textureStatus) {
      textureStatus[symbol].enabled = true;
    }
    this._programKey = "";
  },
  disableTexture: function(symbol) {
    if (Array.isArray(symbol)) {
      for (var i = 0; i < symbol.length; i++) {
        this.disableTexture(symbol[i]);
      }
      return;
    }
    var status = this._textureStatus[symbol];
    if (status) {
      var isDisabled = !status.enabled;
      if (!isDisabled) {
        status.enabled = false;
        this._programKey = "";
      }
    }
  },
  disableTexturesAll: function() {
    var textureStatus = this._textureStatus;
    for (var symbol in textureStatus) {
      textureStatus[symbol].enabled = false;
    }
    this._programKey = "";
  },
  isTextureEnabled: function(symbol) {
    var textureStatus = this._textureStatus;
    return !!textureStatus[symbol] && textureStatus[symbol].enabled;
  },
  getEnabledTextures: function() {
    var enabledTextures = [];
    var textureStatus = this._textureStatus;
    for (var symbol in textureStatus) {
      if (textureStatus[symbol].enabled) {
        enabledTextures.push(symbol);
      }
    }
    return enabledTextures;
  },
  dirtyDefines: function() {
    this._programKey = "";
  },
  getProgramKey: function() {
    if (!this._programKey) {
      this._programKey = getProgramKey$1(this.vertexDefines, this.fragmentDefines, this.getEnabledTextures());
    }
    return this._programKey;
  }
});
var Material$1 = Material;
var GLMAT_EPSILON = 1e-6;
var GLMAT_ARRAY_TYPE = Array;
var GLMAT_RANDOM$1 = Math.random;
var vec2$3 = {};
vec2$3.create = function() {
  var out2 = new GLMAT_ARRAY_TYPE(2);
  out2[0] = 0;
  out2[1] = 0;
  return out2;
};
vec2$3.clone = function(a) {
  var out2 = new GLMAT_ARRAY_TYPE(2);
  out2[0] = a[0];
  out2[1] = a[1];
  return out2;
};
vec2$3.fromValues = function(x, y) {
  var out2 = new GLMAT_ARRAY_TYPE(2);
  out2[0] = x;
  out2[1] = y;
  return out2;
};
vec2$3.copy = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  return out2;
};
vec2$3.set = function(out2, x, y) {
  out2[0] = x;
  out2[1] = y;
  return out2;
};
vec2$3.add = function(out2, a, b) {
  out2[0] = a[0] + b[0];
  out2[1] = a[1] + b[1];
  return out2;
};
vec2$3.subtract = function(out2, a, b) {
  out2[0] = a[0] - b[0];
  out2[1] = a[1] - b[1];
  return out2;
};
vec2$3.sub = vec2$3.subtract;
vec2$3.multiply = function(out2, a, b) {
  out2[0] = a[0] * b[0];
  out2[1] = a[1] * b[1];
  return out2;
};
vec2$3.mul = vec2$3.multiply;
vec2$3.divide = function(out2, a, b) {
  out2[0] = a[0] / b[0];
  out2[1] = a[1] / b[1];
  return out2;
};
vec2$3.div = vec2$3.divide;
vec2$3.min = function(out2, a, b) {
  out2[0] = Math.min(a[0], b[0]);
  out2[1] = Math.min(a[1], b[1]);
  return out2;
};
vec2$3.max = function(out2, a, b) {
  out2[0] = Math.max(a[0], b[0]);
  out2[1] = Math.max(a[1], b[1]);
  return out2;
};
vec2$3.scale = function(out2, a, b) {
  out2[0] = a[0] * b;
  out2[1] = a[1] * b;
  return out2;
};
vec2$3.scaleAndAdd = function(out2, a, b, scale2) {
  out2[0] = a[0] + b[0] * scale2;
  out2[1] = a[1] + b[1] * scale2;
  return out2;
};
vec2$3.distance = function(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
};
vec2$3.dist = vec2$3.distance;
vec2$3.squaredDistance = function(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
};
vec2$3.sqrDist = vec2$3.squaredDistance;
vec2$3.length = function(a) {
  var x = a[0], y = a[1];
  return Math.sqrt(x * x + y * y);
};
vec2$3.len = vec2$3.length;
vec2$3.squaredLength = function(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
};
vec2$3.sqrLen = vec2$3.squaredLength;
vec2$3.negate = function(out2, a) {
  out2[0] = -a[0];
  out2[1] = -a[1];
  return out2;
};
vec2$3.inverse = function(out2, a) {
  out2[0] = 1 / a[0];
  out2[1] = 1 / a[1];
  return out2;
};
vec2$3.normalize = function(out2, a) {
  var x = a[0], y = a[1];
  var len2 = x * x + y * y;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
    out2[0] = a[0] * len2;
    out2[1] = a[1] * len2;
  }
  return out2;
};
vec2$3.dot = function(a, b) {
  return a[0] * b[0] + a[1] * b[1];
};
vec2$3.cross = function(out2, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out2[0] = out2[1] = 0;
  out2[2] = z;
  return out2;
};
vec2$3.lerp = function(out2, a, b, t) {
  var ax = a[0], ay = a[1];
  out2[0] = ax + t * (b[0] - ax);
  out2[1] = ay + t * (b[1] - ay);
  return out2;
};
vec2$3.random = function(out2, scale2) {
  scale2 = scale2 || 1;
  var r = GLMAT_RANDOM() * 2 * Math.PI;
  out2[0] = Math.cos(r) * scale2;
  out2[1] = Math.sin(r) * scale2;
  return out2;
};
vec2$3.transformMat2 = function(out2, a, m2) {
  var x = a[0], y = a[1];
  out2[0] = m2[0] * x + m2[2] * y;
  out2[1] = m2[1] * x + m2[3] * y;
  return out2;
};
vec2$3.transformMat2d = function(out2, a, m2) {
  var x = a[0], y = a[1];
  out2[0] = m2[0] * x + m2[2] * y + m2[4];
  out2[1] = m2[1] * x + m2[3] * y + m2[5];
  return out2;
};
vec2$3.transformMat3 = function(out2, a, m2) {
  var x = a[0], y = a[1];
  out2[0] = m2[0] * x + m2[3] * y + m2[6];
  out2[1] = m2[1] * x + m2[4] * y + m2[7];
  return out2;
};
vec2$3.transformMat4 = function(out2, a, m2) {
  var x = a[0], y = a[1];
  out2[0] = m2[0] * x + m2[4] * y + m2[12];
  out2[1] = m2[1] * x + m2[5] * y + m2[13];
  return out2;
};
vec2$3.forEach = function() {
  var vec = vec2$3.create();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();
var vec2$4 = vec2$3;
var Vector2 = function(x, y) {
  x = x || 0;
  y = y || 0;
  this.array = vec2$4.fromValues(x, y);
  this._dirty = true;
};
Vector2.prototype = {
  constructor: Vector2,
  add: function(b) {
    vec2$4.add(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  set: function(x, y) {
    this.array[0] = x;
    this.array[1] = y;
    this._dirty = true;
    return this;
  },
  setArray: function(arr) {
    this.array[0] = arr[0];
    this.array[1] = arr[1];
    this._dirty = true;
    return this;
  },
  clone: function() {
    return new Vector2(this.x, this.y);
  },
  copy: function(b) {
    vec2$4.copy(this.array, b.array);
    this._dirty = true;
    return this;
  },
  cross: function(out2, b) {
    vec2$4.cross(out2.array, this.array, b.array);
    out2._dirty = true;
    return this;
  },
  dist: function(b) {
    return vec2$4.dist(this.array, b.array);
  },
  distance: function(b) {
    return vec2$4.distance(this.array, b.array);
  },
  div: function(b) {
    vec2$4.div(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  divide: function(b) {
    vec2$4.divide(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  dot: function(b) {
    return vec2$4.dot(this.array, b.array);
  },
  len: function() {
    return vec2$4.len(this.array);
  },
  length: function() {
    return vec2$4.length(this.array);
  },
  lerp: function(a, b, t) {
    vec2$4.lerp(this.array, a.array, b.array, t);
    this._dirty = true;
    return this;
  },
  min: function(b) {
    vec2$4.min(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  max: function(b) {
    vec2$4.max(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  mul: function(b) {
    vec2$4.mul(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  multiply: function(b) {
    vec2$4.multiply(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  negate: function() {
    vec2$4.negate(this.array, this.array);
    this._dirty = true;
    return this;
  },
  normalize: function() {
    vec2$4.normalize(this.array, this.array);
    this._dirty = true;
    return this;
  },
  random: function(scale2) {
    vec2$4.random(this.array, scale2);
    this._dirty = true;
    return this;
  },
  scale: function(s) {
    vec2$4.scale(this.array, this.array, s);
    this._dirty = true;
    return this;
  },
  scaleAndAdd: function(b, s) {
    vec2$4.scaleAndAdd(this.array, this.array, b.array, s);
    this._dirty = true;
    return this;
  },
  sqrDist: function(b) {
    return vec2$4.sqrDist(this.array, b.array);
  },
  squaredDistance: function(b) {
    return vec2$4.squaredDistance(this.array, b.array);
  },
  sqrLen: function() {
    return vec2$4.sqrLen(this.array);
  },
  squaredLength: function() {
    return vec2$4.squaredLength(this.array);
  },
  sub: function(b) {
    vec2$4.sub(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  subtract: function(b) {
    vec2$4.subtract(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  transformMat2: function(m2) {
    vec2$4.transformMat2(this.array, this.array, m2.array);
    this._dirty = true;
    return this;
  },
  transformMat2d: function(m2) {
    vec2$4.transformMat2d(this.array, this.array, m2.array);
    this._dirty = true;
    return this;
  },
  transformMat3: function(m2) {
    vec2$4.transformMat3(this.array, this.array, m2.array);
    this._dirty = true;
    return this;
  },
  transformMat4: function(m2) {
    vec2$4.transformMat4(this.array, this.array, m2.array);
    this._dirty = true;
    return this;
  },
  toString: function() {
    return "[" + Array.prototype.join.call(this.array, ",") + "]";
  },
  toArray: function() {
    return Array.prototype.slice.call(this.array);
  }
};
if (Object.defineProperty) {
  var proto$4 = Vector2.prototype;
  Object.defineProperty(proto$4, "x", {
    get: function() {
      return this.array[0];
    },
    set: function(value) {
      this.array[0] = value;
      this._dirty = true;
    }
  });
  Object.defineProperty(proto$4, "y", {
    get: function() {
      return this.array[1];
    },
    set: function(value) {
      this.array[1] = value;
      this._dirty = true;
    }
  });
}
Vector2.add = function(out2, a, b) {
  vec2$4.add(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector2.set = function(out2, x, y) {
  vec2$4.set(out2.array, x, y);
  out2._dirty = true;
  return out2;
};
Vector2.copy = function(out2, b) {
  vec2$4.copy(out2.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector2.cross = function(out2, a, b) {
  vec2$4.cross(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector2.dist = function(a, b) {
  return vec2$4.distance(a.array, b.array);
};
Vector2.distance = Vector2.dist;
Vector2.div = function(out2, a, b) {
  vec2$4.divide(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector2.divide = Vector2.div;
Vector2.dot = function(a, b) {
  return vec2$4.dot(a.array, b.array);
};
Vector2.len = function(b) {
  return vec2$4.length(b.array);
};
Vector2.lerp = function(out2, a, b, t) {
  vec2$4.lerp(out2.array, a.array, b.array, t);
  out2._dirty = true;
  return out2;
};
Vector2.min = function(out2, a, b) {
  vec2$4.min(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector2.max = function(out2, a, b) {
  vec2$4.max(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector2.mul = function(out2, a, b) {
  vec2$4.multiply(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector2.multiply = Vector2.mul;
Vector2.negate = function(out2, a) {
  vec2$4.negate(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Vector2.normalize = function(out2, a) {
  vec2$4.normalize(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Vector2.random = function(out2, scale2) {
  vec2$4.random(out2.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector2.scale = function(out2, a, scale2) {
  vec2$4.scale(out2.array, a.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector2.scaleAndAdd = function(out2, a, b, scale2) {
  vec2$4.scaleAndAdd(out2.array, a.array, b.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector2.sqrDist = function(a, b) {
  return vec2$4.sqrDist(a.array, b.array);
};
Vector2.squaredDistance = Vector2.sqrDist;
Vector2.sqrLen = function(a) {
  return vec2$4.sqrLen(a.array);
};
Vector2.squaredLength = Vector2.sqrLen;
Vector2.sub = function(out2, a, b) {
  vec2$4.subtract(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector2.subtract = Vector2.sub;
Vector2.transformMat2 = function(out2, a, m2) {
  vec2$4.transformMat2(out2.array, a.array, m2.array);
  out2._dirty = true;
  return out2;
};
Vector2.transformMat2d = function(out2, a, m2) {
  vec2$4.transformMat2d(out2.array, a.array, m2.array);
  out2._dirty = true;
  return out2;
};
Vector2.transformMat3 = function(out2, a, m2) {
  vec2$4.transformMat3(out2.array, a.array, m2.array);
  out2._dirty = true;
  return out2;
};
Vector2.transformMat4 = function(out2, a, m2) {
  vec2$4.transformMat4(out2.array, a.array, m2.array);
  out2._dirty = true;
  return out2;
};
var Vector2$1 = Vector2;
var SHADER_STATE_TO_ENABLE = 1;
var SHADER_STATE_KEEP_ENABLE = 2;
var SHADER_STATE_PENDING = 3;
var enabledAttributeList = {};
function addLineNumbers(string) {
  var chunks = string.split("\n");
  for (var i = 0, il = chunks.length; i < il; i++) {
    chunks[i] = i + 1 + ": " + chunks[i];
  }
  return chunks.join("\n");
}
function checkShaderErrorMsg(_gl, shader, shaderString) {
  if (!_gl.getShaderParameter(shader, _gl.COMPILE_STATUS)) {
    return [_gl.getShaderInfoLog(shader), addLineNumbers(shaderString)].join("\n");
  }
}
var tmpFloat32Array16 = new vendor$1.Float32Array(16);
var GLProgram = Base$1.extend({
  uniformSemantics: {},
  attributes: {}
}, function() {
  this._locations = {};
  this._textureSlot = 0;
  this._program = null;
}, {
  bind: function(renderer) {
    this._textureSlot = 0;
    renderer.gl.useProgram(this._program);
  },
  hasUniform: function(symbol) {
    var location2 = this._locations[symbol];
    return location2 !== null && location2 !== void 0;
  },
  useTextureSlot: function(renderer, texture, slot) {
    if (texture) {
      renderer.gl.activeTexture(renderer.gl.TEXTURE0 + slot);
      if (texture.isRenderable()) {
        texture.bind(renderer);
      } else {
        texture.unbind(renderer);
      }
    }
  },
  currentTextureSlot: function() {
    return this._textureSlot;
  },
  resetTextureSlot: function(slot) {
    this._textureSlot = slot || 0;
  },
  takeCurrentTextureSlot: function(renderer, texture) {
    var textureSlot = this._textureSlot;
    this.useTextureSlot(renderer, texture, textureSlot);
    this._textureSlot++;
    return textureSlot;
  },
  setUniform: function(_gl, type, symbol, value) {
    var locationMap = this._locations;
    var location2 = locationMap[symbol];
    if (location2 === null || location2 === void 0) {
      return false;
    }
    switch (type) {
      case "m4":
        if (!(value instanceof Float32Array)) {
          for (var i = 0; i < value.length; i++) {
            tmpFloat32Array16[i] = value[i];
          }
          value = tmpFloat32Array16;
        }
        _gl.uniformMatrix4fv(location2, false, value);
        break;
      case "2i":
        _gl.uniform2i(location2, value[0], value[1]);
        break;
      case "2f":
        _gl.uniform2f(location2, value[0], value[1]);
        break;
      case "3i":
        _gl.uniform3i(location2, value[0], value[1], value[2]);
        break;
      case "3f":
        _gl.uniform3f(location2, value[0], value[1], value[2]);
        break;
      case "4i":
        _gl.uniform4i(location2, value[0], value[1], value[2], value[3]);
        break;
      case "4f":
        _gl.uniform4f(location2, value[0], value[1], value[2], value[3]);
        break;
      case "1i":
        _gl.uniform1i(location2, value);
        break;
      case "1f":
        _gl.uniform1f(location2, value);
        break;
      case "1fv":
        _gl.uniform1fv(location2, value);
        break;
      case "1iv":
        _gl.uniform1iv(location2, value);
        break;
      case "2iv":
        _gl.uniform2iv(location2, value);
        break;
      case "2fv":
        _gl.uniform2fv(location2, value);
        break;
      case "3iv":
        _gl.uniform3iv(location2, value);
        break;
      case "3fv":
        _gl.uniform3fv(location2, value);
        break;
      case "4iv":
        _gl.uniform4iv(location2, value);
        break;
      case "4fv":
        _gl.uniform4fv(location2, value);
        break;
      case "m2":
      case "m2v":
        _gl.uniformMatrix2fv(location2, false, value);
        break;
      case "m3":
      case "m3v":
        _gl.uniformMatrix3fv(location2, false, value);
        break;
      case "m4v":
        if (Array.isArray(value) && Array.isArray(value[0])) {
          var array = new vendor$1.Float32Array(value.length * 16);
          var cursor = 0;
          for (var i = 0; i < value.length; i++) {
            var item = value[i];
            for (var j = 0; j < 16; j++) {
              array[cursor++] = item[j];
            }
          }
          _gl.uniformMatrix4fv(location2, false, array);
        } else {
          _gl.uniformMatrix4fv(location2, false, value);
        }
        break;
    }
    return true;
  },
  setUniformOfSemantic: function(_gl, semantic, val) {
    var semanticInfo = this.uniformSemantics[semantic];
    if (semanticInfo) {
      return this.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, val);
    }
    return false;
  },
  enableAttributes: function(renderer, attribList, vao) {
    var _gl = renderer.gl;
    var program = this._program;
    var locationMap = this._locations;
    var enabledAttributeListInContext;
    if (vao) {
      enabledAttributeListInContext = vao.__enabledAttributeList;
    } else {
      enabledAttributeListInContext = enabledAttributeList[renderer.__uid__];
    }
    if (!enabledAttributeListInContext) {
      if (vao) {
        enabledAttributeListInContext = vao.__enabledAttributeList = [];
      } else {
        enabledAttributeListInContext = enabledAttributeList[renderer.__uid__] = [];
      }
    }
    var locationList = [];
    for (var i = 0; i < attribList.length; i++) {
      var symbol = attribList[i];
      if (!this.attributes[symbol]) {
        locationList[i] = -1;
        continue;
      }
      var location2 = locationMap[symbol];
      if (location2 == null) {
        location2 = _gl.getAttribLocation(program, symbol);
        if (location2 === -1) {
          locationList[i] = -1;
          continue;
        }
        locationMap[symbol] = location2;
      }
      locationList[i] = location2;
      if (!enabledAttributeListInContext[location2]) {
        enabledAttributeListInContext[location2] = SHADER_STATE_TO_ENABLE;
      } else {
        enabledAttributeListInContext[location2] = SHADER_STATE_KEEP_ENABLE;
      }
    }
    for (var i = 0; i < enabledAttributeListInContext.length; i++) {
      switch (enabledAttributeListInContext[i]) {
        case SHADER_STATE_TO_ENABLE:
          _gl.enableVertexAttribArray(i);
          enabledAttributeListInContext[i] = SHADER_STATE_PENDING;
          break;
        case SHADER_STATE_KEEP_ENABLE:
          enabledAttributeListInContext[i] = SHADER_STATE_PENDING;
          break;
        case SHADER_STATE_PENDING:
          _gl.disableVertexAttribArray(i);
          enabledAttributeListInContext[i] = 0;
          break;
      }
    }
    return locationList;
  },
  getAttribLocation: function(_gl, symbol) {
    var locationMap = this._locations;
    var location2 = locationMap[symbol];
    if (location2 == null) {
      location2 = _gl.getAttribLocation(this._program, symbol);
      locationMap[symbol] = location2;
    }
    return location2;
  },
  buildProgram: function(_gl, shader, vertexShaderCode, fragmentShaderCode) {
    var vertexShader = _gl.createShader(_gl.VERTEX_SHADER);
    var program = _gl.createProgram();
    _gl.shaderSource(vertexShader, vertexShaderCode);
    _gl.compileShader(vertexShader);
    var fragmentShader = _gl.createShader(_gl.FRAGMENT_SHADER);
    _gl.shaderSource(fragmentShader, fragmentShaderCode);
    _gl.compileShader(fragmentShader);
    var msg = checkShaderErrorMsg(_gl, vertexShader, vertexShaderCode);
    if (msg) {
      return msg;
    }
    msg = checkShaderErrorMsg(_gl, fragmentShader, fragmentShaderCode);
    if (msg) {
      return msg;
    }
    _gl.attachShader(program, vertexShader);
    _gl.attachShader(program, fragmentShader);
    if (shader.attributeSemantics["POSITION"]) {
      _gl.bindAttribLocation(program, 0, shader.attributeSemantics["POSITION"].symbol);
    } else {
      var keys2 = Object.keys(this.attributes);
      _gl.bindAttribLocation(program, 0, keys2[0]);
    }
    _gl.linkProgram(program);
    _gl.deleteShader(vertexShader);
    _gl.deleteShader(fragmentShader);
    this._program = program;
    this.vertexCode = vertexShaderCode;
    this.fragmentCode = fragmentShaderCode;
    if (!_gl.getProgramParameter(program, _gl.LINK_STATUS)) {
      return "Could not link program\n" + _gl.getProgramInfoLog(program);
    }
    for (var i = 0; i < shader.uniforms.length; i++) {
      var uniformSymbol = shader.uniforms[i];
      this._locations[uniformSymbol] = _gl.getUniformLocation(program, uniformSymbol);
    }
  }
});
var GLProgram$1 = GLProgram;
var loopRegex = /for\s*?\(int\s*?_idx_\s*\=\s*([\w-]+)\;\s*_idx_\s*<\s*([\w-]+);\s*_idx_\s*\+\+\s*\)\s*\{\{([\s\S]+?)(?=\}\})\}\}/g;
function unrollLoop(shaderStr, defines, lightsNumbers) {
  function replace(match, start2, end2, snippet) {
    var unroll = "";
    if (isNaN(start2)) {
      if (start2 in defines) {
        start2 = defines[start2];
      } else {
        start2 = lightNumberDefines[start2];
      }
    }
    if (isNaN(end2)) {
      if (end2 in defines) {
        end2 = defines[end2];
      } else {
        end2 = lightNumberDefines[end2];
      }
    }
    for (var idx = parseInt(start2); idx < parseInt(end2); idx++) {
      unroll += "{" + snippet.replace(/float\s*\(\s*_idx_\s*\)/g, idx.toFixed(1)).replace(/_idx_/g, idx) + "}";
    }
    return unroll;
  }
  var lightNumberDefines = {};
  for (var lightType in lightsNumbers) {
    lightNumberDefines[lightType + "_COUNT"] = lightsNumbers[lightType];
  }
  return shaderStr.replace(loopRegex, replace);
}
function getDefineCode(defines, lightsNumbers, enabledTextures) {
  var defineStr = [];
  if (lightsNumbers) {
    for (var lightType in lightsNumbers) {
      var count2 = lightsNumbers[lightType];
      if (count2 > 0) {
        defineStr.push("#define " + lightType.toUpperCase() + "_COUNT " + count2);
      }
    }
  }
  if (enabledTextures) {
    for (var i = 0; i < enabledTextures.length; i++) {
      var symbol = enabledTextures[i];
      defineStr.push("#define " + symbol.toUpperCase() + "_ENABLED");
    }
  }
  for (var symbol in defines) {
    var value = defines[symbol];
    if (value === null) {
      defineStr.push("#define " + symbol);
    } else {
      defineStr.push("#define " + symbol + " " + value.toString());
    }
  }
  return defineStr.join("\n");
}
function getExtensionCode(exts) {
  var extensionStr = [];
  for (var i = 0; i < exts.length; i++) {
    extensionStr.push("#extension GL_" + exts[i] + " : enable");
  }
  return extensionStr.join("\n");
}
function getPrecisionCode(precision) {
  return ["precision", precision, "float"].join(" ") + ";\n" + ["precision", precision, "int"].join(" ") + ";\n" + ["precision", precision, "sampler2D"].join(" ") + ";\n";
}
function ProgramManager(renderer) {
  this._renderer = renderer;
  this._cache = {};
}
ProgramManager.prototype.getProgram = function(renderable, material, scene) {
  var cache2 = this._cache;
  var isSkinnedMesh = renderable.isSkinnedMesh && renderable.isSkinnedMesh();
  var isInstancedMesh = renderable.isInstancedMesh && renderable.isInstancedMesh();
  var key = "s" + material.shader.shaderID + "m" + material.getProgramKey();
  if (scene) {
    key += "se" + scene.getProgramKey(renderable.lightGroup);
  }
  if (isSkinnedMesh) {
    key += ",sk" + renderable.joints.length;
  }
  if (isInstancedMesh) {
    key += ",is";
  }
  var program = cache2[key];
  if (program) {
    return program;
  }
  var lightsNumbers = scene ? scene.getLightsNumbers(renderable.lightGroup) : {};
  var renderer = this._renderer;
  var _gl = renderer.gl;
  var enabledTextures = material.getEnabledTextures();
  var extraDefineCode = "";
  if (isSkinnedMesh) {
    var skinDefines = {
      SKINNING: null,
      JOINT_COUNT: renderable.joints.length
    };
    if (renderable.joints.length > renderer.getMaxJointNumber()) {
      skinDefines.USE_SKIN_MATRICES_TEXTURE = null;
    }
    extraDefineCode += "\n" + getDefineCode(skinDefines) + "\n";
  }
  if (isInstancedMesh) {
    extraDefineCode += "\n#define INSTANCING\n";
  }
  var vertexDefineStr = extraDefineCode + getDefineCode(material.vertexDefines, lightsNumbers, enabledTextures);
  var fragmentDefineStr = extraDefineCode + getDefineCode(material.fragmentDefines, lightsNumbers, enabledTextures);
  var vertexCode = vertexDefineStr + "\n" + material.shader.vertex;
  var extensions2 = [
    "OES_standard_derivatives",
    "EXT_shader_texture_lod"
  ].filter(function(ext) {
    return renderer.getGLExtension(ext) != null;
  });
  if (extensions2.indexOf("EXT_shader_texture_lod") >= 0) {
    fragmentDefineStr += "\n#define SUPPORT_TEXTURE_LOD";
  }
  if (extensions2.indexOf("OES_standard_derivatives") >= 0) {
    fragmentDefineStr += "\n#define SUPPORT_STANDARD_DERIVATIVES";
  }
  var fragmentCode = getExtensionCode(extensions2) + "\n" + getPrecisionCode(material.precision) + "\n" + fragmentDefineStr + "\n" + material.shader.fragment;
  var finalVertexCode = unrollLoop(vertexCode, material.vertexDefines, lightsNumbers);
  var finalFragmentCode = unrollLoop(fragmentCode, material.fragmentDefines, lightsNumbers);
  var program = new GLProgram$1();
  program.uniformSemantics = material.shader.uniformSemantics;
  program.attributes = material.shader.attributes;
  var errorMsg = program.buildProgram(_gl, material.shader, finalVertexCode, finalFragmentCode);
  program.__error = errorMsg;
  cache2[key] = program;
  return program;
};
var uniformRegex = /uniform\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\s+([\s\S]*?);/g;
var attributeRegex = /attribute\s+(float|int|vec2|vec3|vec4)\s+([\s\S]*?);/g;
var defineRegex = /#define\s+(\w+)?(\s+[\d-.]+)?\s*;?\s*\n/g;
var uniformTypeMap = {
  "bool": "1i",
  "int": "1i",
  "sampler2D": "t",
  "samplerCube": "t",
  "float": "1f",
  "vec2": "2f",
  "vec3": "3f",
  "vec4": "4f",
  "ivec2": "2i",
  "ivec3": "3i",
  "ivec4": "4i",
  "mat2": "m2",
  "mat3": "m3",
  "mat4": "m4"
};
function createZeroArray(len2) {
  var arr = [];
  for (var i = 0; i < len2; i++) {
    arr[i] = 0;
  }
  return arr;
}
var uniformValueConstructor = {
  "bool": function() {
    return true;
  },
  "int": function() {
    return 0;
  },
  "float": function() {
    return 0;
  },
  "sampler2D": function() {
    return null;
  },
  "samplerCube": function() {
    return null;
  },
  "vec2": function() {
    return createZeroArray(2);
  },
  "vec3": function() {
    return createZeroArray(3);
  },
  "vec4": function() {
    return createZeroArray(4);
  },
  "ivec2": function() {
    return createZeroArray(2);
  },
  "ivec3": function() {
    return createZeroArray(3);
  },
  "ivec4": function() {
    return createZeroArray(4);
  },
  "mat2": function() {
    return createZeroArray(4);
  },
  "mat3": function() {
    return createZeroArray(9);
  },
  "mat4": function() {
    return createZeroArray(16);
  },
  "array": function() {
    return [];
  }
};
var attributeSemantics = [
  "POSITION",
  "NORMAL",
  "BINORMAL",
  "TANGENT",
  "TEXCOORD",
  "TEXCOORD_0",
  "TEXCOORD_1",
  "COLOR",
  "JOINT",
  "WEIGHT"
];
var uniformSemantics = [
  "SKIN_MATRIX",
  "VIEWPORT_SIZE",
  "VIEWPORT",
  "DEVICEPIXELRATIO",
  "WINDOW_SIZE",
  "NEAR",
  "FAR",
  "TIME"
];
var matrixSemantics = [
  "WORLD",
  "VIEW",
  "PROJECTION",
  "WORLDVIEW",
  "VIEWPROJECTION",
  "WORLDVIEWPROJECTION",
  "WORLDINVERSE",
  "VIEWINVERSE",
  "PROJECTIONINVERSE",
  "WORLDVIEWINVERSE",
  "VIEWPROJECTIONINVERSE",
  "WORLDVIEWPROJECTIONINVERSE",
  "WORLDTRANSPOSE",
  "VIEWTRANSPOSE",
  "PROJECTIONTRANSPOSE",
  "WORLDVIEWTRANSPOSE",
  "VIEWPROJECTIONTRANSPOSE",
  "WORLDVIEWPROJECTIONTRANSPOSE",
  "WORLDINVERSETRANSPOSE",
  "VIEWINVERSETRANSPOSE",
  "PROJECTIONINVERSETRANSPOSE",
  "WORLDVIEWINVERSETRANSPOSE",
  "VIEWPROJECTIONINVERSETRANSPOSE",
  "WORLDVIEWPROJECTIONINVERSETRANSPOSE"
];
var attributeSizeMap = {
  "vec4": 4,
  "vec3": 3,
  "vec2": 2,
  "float": 1
};
var shaderIDCache = {};
var shaderCodeCache = {};
function getShaderID(vertex, fragment) {
  var key = "vertex:" + vertex + "fragment:" + fragment;
  if (shaderIDCache[key]) {
    return shaderIDCache[key];
  }
  var id = util$1.genGUID();
  shaderIDCache[key] = id;
  shaderCodeCache[id] = {
    vertex,
    fragment
  };
  return id;
}
function removeComment(code) {
  return code.replace(/[ \t]*\/\/.*\n/g, "").replace(/[ \t]*\/\*[\s\S]*?\*\//g, "");
}
function logSyntaxError() {
  console.error("Wrong uniform/attributes syntax");
}
function parseDeclarations(type, line) {
  var speratorsRegexp = /[,=\(\):]/;
  var tokens = line.replace(/:\s*\[\s*(.*)\s*\]/g, "=" + type + "($1)").replace(/\s+/g, "").split(/(?=[,=\(\):])/g);
  var newTokens = [];
  for (var i = 0; i < tokens.length; i++) {
    if (tokens[i].match(speratorsRegexp)) {
      newTokens.push(tokens[i].charAt(0), tokens[i].slice(1));
    } else {
      newTokens.push(tokens[i]);
    }
  }
  tokens = newTokens;
  var TYPE_SYMBOL = 0;
  var TYPE_ASSIGN = 1;
  var TYPE_VEC = 2;
  var TYPE_ARR = 3;
  var TYPE_SEMANTIC = 4;
  var TYPE_NORMAL = 5;
  var opType = TYPE_SYMBOL;
  var declarations = {};
  var declarationValue = null;
  var currentDeclaration;
  addSymbol(tokens[0]);
  function addSymbol(symbol) {
    if (!symbol) {
      logSyntaxError();
    }
    var arrResult = symbol.match(/\[(.*?)\]/);
    currentDeclaration = symbol.replace(/\[(.*?)\]/, "");
    declarations[currentDeclaration] = {};
    if (arrResult) {
      declarations[currentDeclaration].isArray = true;
      declarations[currentDeclaration].arraySize = arrResult[1];
    }
  }
  for (var i = 1; i < tokens.length; i++) {
    var token2 = tokens[i];
    if (!token2) {
      continue;
    }
    if (token2 === "=") {
      if (opType !== TYPE_SYMBOL && opType !== TYPE_ARR) {
        logSyntaxError();
        break;
      }
      opType = TYPE_ASSIGN;
      continue;
    } else if (token2 === ":") {
      opType = TYPE_SEMANTIC;
      continue;
    } else if (token2 === ",") {
      if (opType === TYPE_VEC) {
        if (!(declarationValue instanceof Array)) {
          logSyntaxError();
          break;
        }
        declarationValue.push(+tokens[++i]);
      } else {
        opType = TYPE_NORMAL;
      }
      continue;
    } else if (token2 === ")") {
      declarations[currentDeclaration].value = new vendor$1.Float32Array(declarationValue);
      declarationValue = null;
      opType = TYPE_NORMAL;
      continue;
    } else if (token2 === "(") {
      if (opType !== TYPE_VEC) {
        logSyntaxError();
        break;
      }
      if (!(declarationValue instanceof Array)) {
        logSyntaxError();
        break;
      }
      declarationValue.push(+tokens[++i]);
      continue;
    } else if (token2.indexOf("vec") >= 0) {
      if (opType !== TYPE_ASSIGN && opType !== TYPE_SEMANTIC) {
        logSyntaxError();
        break;
      }
      opType = TYPE_VEC;
      declarationValue = [];
      continue;
    } else if (opType === TYPE_ASSIGN) {
      if (type === "bool") {
        declarations[currentDeclaration].value = token2 === "true";
      } else {
        declarations[currentDeclaration].value = parseFloat(token2);
      }
      declarationValue = null;
      continue;
    } else if (opType === TYPE_SEMANTIC) {
      var semantic = token2;
      if (attributeSemantics.indexOf(semantic) >= 0 || uniformSemantics.indexOf(semantic) >= 0 || matrixSemantics.indexOf(semantic) >= 0) {
        declarations[currentDeclaration].semantic = semantic;
      } else if (semantic === "ignore" || semantic === "unconfigurable") {
        declarations[currentDeclaration].ignore = true;
      } else {
        if (type === "bool") {
          declarations[currentDeclaration].value = semantic === "true";
        } else {
          declarations[currentDeclaration].value = parseFloat(semantic);
        }
      }
      continue;
    }
    addSymbol(token2);
    opType = TYPE_SYMBOL;
  }
  return declarations;
}
function Shader(vertex, fragment) {
  if (typeof vertex === "object") {
    fragment = vertex.fragment;
    vertex = vertex.vertex;
  }
  vertex = removeComment(vertex);
  fragment = removeComment(fragment);
  this._shaderID = getShaderID(vertex, fragment);
  this._vertexCode = Shader.parseImport(vertex);
  this._fragmentCode = Shader.parseImport(fragment);
  this.attributeSemantics = {};
  this.matrixSemantics = {};
  this.uniformSemantics = {};
  this.matrixSemanticKeys = [];
  this.uniformTemplates = {};
  this.attributes = {};
  this.textures = {};
  this.vertexDefines = {};
  this.fragmentDefines = {};
  this._parseAttributes();
  this._parseUniforms();
  this._parseDefines();
}
Shader.prototype = {
  constructor: Shader,
  createUniforms: function() {
    var uniforms = {};
    for (var symbol in this.uniformTemplates) {
      var uniformTpl = this.uniformTemplates[symbol];
      uniforms[symbol] = {
        type: uniformTpl.type,
        value: uniformTpl.value()
      };
    }
    return uniforms;
  },
  _parseImport: function() {
    this._vertexCode = Shader.parseImport(this.vertex);
    this._fragmentCode = Shader.parseImport(this.fragment);
  },
  _addSemanticUniform: function(symbol, uniformType, semantic) {
    if (attributeSemantics.indexOf(semantic) >= 0) {
      this.attributeSemantics[semantic] = {
        symbol,
        type: uniformType
      };
    } else if (matrixSemantics.indexOf(semantic) >= 0) {
      var isTranspose = false;
      var semanticNoTranspose = semantic;
      if (semantic.match(/TRANSPOSE$/)) {
        isTranspose = true;
        semanticNoTranspose = semantic.slice(0, -9);
      }
      this.matrixSemantics[semantic] = {
        symbol,
        type: uniformType,
        isTranspose,
        semanticNoTranspose
      };
    } else if (uniformSemantics.indexOf(semantic) >= 0) {
      this.uniformSemantics[semantic] = {
        symbol,
        type: uniformType
      };
    }
  },
  _addMaterialUniform: function(symbol, type, uniformType, defaultValueFunc, isArray2, materialUniforms) {
    materialUniforms[symbol] = {
      type: uniformType,
      value: isArray2 ? uniformValueConstructor["array"] : defaultValueFunc || uniformValueConstructor[type],
      semantic: null
    };
  },
  _parseUniforms: function() {
    var uniforms = {};
    var self2 = this;
    var shaderType = "vertex";
    this._uniformList = [];
    this._vertexCode = this._vertexCode.replace(uniformRegex, _uniformParser);
    shaderType = "fragment";
    this._fragmentCode = this._fragmentCode.replace(uniformRegex, _uniformParser);
    self2.matrixSemanticKeys = Object.keys(this.matrixSemantics);
    function makeDefaultValueFunc(value) {
      return value != null ? function() {
        return value;
      } : null;
    }
    function _uniformParser(str, type, content) {
      var declaredUniforms = parseDeclarations(type, content);
      var uniformMainStr = [];
      for (var symbol in declaredUniforms) {
        var uniformInfo = declaredUniforms[symbol];
        var semantic = uniformInfo.semantic;
        var tmpStr = symbol;
        var uniformType = uniformTypeMap[type];
        var defaultValueFunc = makeDefaultValueFunc(declaredUniforms[symbol].value);
        if (declaredUniforms[symbol].isArray) {
          tmpStr += "[" + declaredUniforms[symbol].arraySize + "]";
          uniformType += "v";
        }
        uniformMainStr.push(tmpStr);
        self2._uniformList.push(symbol);
        if (!uniformInfo.ignore) {
          if (type === "sampler2D" || type === "samplerCube") {
            self2.textures[symbol] = {
              shaderType,
              type
            };
          }
          if (semantic) {
            self2._addSemanticUniform(symbol, uniformType, semantic);
          } else {
            self2._addMaterialUniform(symbol, type, uniformType, defaultValueFunc, declaredUniforms[symbol].isArray, uniforms);
          }
        }
      }
      return uniformMainStr.length > 0 ? "uniform " + type + " " + uniformMainStr.join(",") + ";\n" : "";
    }
    this.uniformTemplates = uniforms;
  },
  _parseAttributes: function() {
    var attributes = {};
    var self2 = this;
    this._vertexCode = this._vertexCode.replace(attributeRegex, _attributeParser);
    function _attributeParser(str, type, content) {
      var declaredAttributes = parseDeclarations(type, content);
      var size = attributeSizeMap[type] || 1;
      var attributeMainStr = [];
      for (var symbol in declaredAttributes) {
        var semantic = declaredAttributes[symbol].semantic;
        attributes[symbol] = {
          type: "float",
          size,
          semantic: semantic || null
        };
        if (semantic) {
          if (attributeSemantics.indexOf(semantic) < 0) {
            throw new Error('Unkown semantic "' + semantic + '"');
          } else {
            self2.attributeSemantics[semantic] = {
              symbol,
              type
            };
          }
        }
        attributeMainStr.push(symbol);
      }
      return "attribute " + type + " " + attributeMainStr.join(",") + ";\n";
    }
    this.attributes = attributes;
  },
  _parseDefines: function() {
    var self2 = this;
    var shaderType = "vertex";
    this._vertexCode = this._vertexCode.replace(defineRegex, _defineParser);
    shaderType = "fragment";
    this._fragmentCode = this._fragmentCode.replace(defineRegex, _defineParser);
    function _defineParser(str, symbol, value) {
      var defines = shaderType === "vertex" ? self2.vertexDefines : self2.fragmentDefines;
      if (!defines[symbol]) {
        if (value === "false") {
          defines[symbol] = false;
        } else if (value === "true") {
          defines[symbol] = true;
        } else {
          defines[symbol] = value ? isNaN(parseFloat(value)) ? value.trim() : parseFloat(value) : null;
        }
      }
      return "";
    }
  },
  clone: function() {
    var code = shaderCodeCache[this._shaderID];
    var shader = new Shader(code.vertex, code.fragment);
    return shader;
  }
};
if (Object.defineProperty) {
  Object.defineProperty(Shader.prototype, "shaderID", {
    get: function() {
      return this._shaderID;
    }
  });
  Object.defineProperty(Shader.prototype, "vertex", {
    get: function() {
      return this._vertexCode;
    }
  });
  Object.defineProperty(Shader.prototype, "fragment", {
    get: function() {
      return this._fragmentCode;
    }
  });
  Object.defineProperty(Shader.prototype, "uniforms", {
    get: function() {
      return this._uniformList;
    }
  });
}
var importRegex = /(@import)\s*([0-9a-zA-Z_\-\.]*)/g;
Shader.parseImport = function(shaderStr) {
  shaderStr = shaderStr.replace(importRegex, function(str, importSymbol, importName) {
    var str = Shader.source(importName);
    if (str) {
      return Shader.parseImport(str);
    } else {
      console.error('Shader chunk "' + importName + '" not existed in library');
      return "";
    }
  });
  return shaderStr;
};
var exportRegex = /(@export)\s*([0-9a-zA-Z_\-\.]*)\s*\n([\s\S]*?)@end/g;
Shader["import"] = function(shaderStr) {
  shaderStr.replace(exportRegex, function(str, exportSymbol, exportName, code) {
    var code = code.replace(/(^[\s\t\xa0\u3000]+)|([\u3000\xa0\s\t]+\x24)/g, "");
    if (code) {
      var parts = exportName.split(".");
      var obj = Shader.codes;
      var i = 0;
      var key;
      while (i < parts.length - 1) {
        key = parts[i++];
        if (!obj[key]) {
          obj[key] = {};
        }
        obj = obj[key];
      }
      key = parts[i];
      obj[key] = code;
    }
    return code;
  });
};
Shader.codes = {};
Shader.source = function(name) {
  var parts = name.split(".");
  var obj = Shader.codes;
  var i = 0;
  while (obj && i < parts.length) {
    var key = parts[i++];
    obj = obj[key];
  }
  if (typeof obj !== "string") {
    console.error('Shader "' + name + '" not existed in library');
    return "";
  }
  return obj;
};
var prezGLSL = "@export clay.prez.vertex\nuniform mat4 WVP : WORLDVIEWPROJECTION;\nattribute vec3 pos : POSITION;\nattribute vec2 uv : TEXCOORD_0;\nuniform vec2 uvRepeat : [1.0, 1.0];\nuniform vec2 uvOffset : [0.0, 0.0];\n@import clay.chunk.skinning_header\n@import clay.chunk.instancing_header\nvarying vec2 v_Texcoord;\nvoid main()\n{\n vec4 P = vec4(pos, 1.0);\n#ifdef SKINNING\n @import clay.chunk.skin_matrix\n P = skinMatrixWS * P;\n#endif\n#ifdef INSTANCING\n @import clay.chunk.instancing_matrix\n P = instanceMat * P;\n#endif\n gl_Position = WVP * P;\n v_Texcoord = uv * uvRepeat + uvOffset;\n}\n@end\n@export clay.prez.fragment\nuniform sampler2D alphaMap;\nuniform float alphaCutoff: 0.0;\nvarying vec2 v_Texcoord;\nvoid main()\n{\n if (alphaCutoff > 0.0) {\n if (texture2D(alphaMap, v_Texcoord).a <= alphaCutoff) {\n discard;\n }\n }\n gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n}\n@end";
var mat4$2 = {};
mat4$2.create = function() {
  var out2 = new GLMAT_ARRAY_TYPE(16);
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  out2[4] = 0;
  out2[5] = 1;
  out2[6] = 0;
  out2[7] = 0;
  out2[8] = 0;
  out2[9] = 0;
  out2[10] = 1;
  out2[11] = 0;
  out2[12] = 0;
  out2[13] = 0;
  out2[14] = 0;
  out2[15] = 1;
  return out2;
};
mat4$2.clone = function(a) {
  var out2 = new GLMAT_ARRAY_TYPE(16);
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4];
  out2[5] = a[5];
  out2[6] = a[6];
  out2[7] = a[7];
  out2[8] = a[8];
  out2[9] = a[9];
  out2[10] = a[10];
  out2[11] = a[11];
  out2[12] = a[12];
  out2[13] = a[13];
  out2[14] = a[14];
  out2[15] = a[15];
  return out2;
};
mat4$2.copy = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4];
  out2[5] = a[5];
  out2[6] = a[6];
  out2[7] = a[7];
  out2[8] = a[8];
  out2[9] = a[9];
  out2[10] = a[10];
  out2[11] = a[11];
  out2[12] = a[12];
  out2[13] = a[13];
  out2[14] = a[14];
  out2[15] = a[15];
  return out2;
};
mat4$2.identity = function(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  out2[4] = 0;
  out2[5] = 1;
  out2[6] = 0;
  out2[7] = 0;
  out2[8] = 0;
  out2[9] = 0;
  out2[10] = 1;
  out2[11] = 0;
  out2[12] = 0;
  out2[13] = 0;
  out2[14] = 0;
  out2[15] = 1;
  return out2;
};
mat4$2.transpose = function(out2, a) {
  if (out2 === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3], a12 = a[6], a13 = a[7], a23 = a[11];
    out2[1] = a[4];
    out2[2] = a[8];
    out2[3] = a[12];
    out2[4] = a01;
    out2[6] = a[9];
    out2[7] = a[13];
    out2[8] = a02;
    out2[9] = a12;
    out2[11] = a[14];
    out2[12] = a03;
    out2[13] = a13;
    out2[14] = a23;
  } else {
    out2[0] = a[0];
    out2[1] = a[4];
    out2[2] = a[8];
    out2[3] = a[12];
    out2[4] = a[1];
    out2[5] = a[5];
    out2[6] = a[9];
    out2[7] = a[13];
    out2[8] = a[2];
    out2[9] = a[6];
    out2[10] = a[10];
    out2[11] = a[14];
    out2[12] = a[3];
    out2[13] = a[7];
    out2[14] = a[11];
    out2[15] = a[15];
  }
  return out2;
};
mat4$2.invert = function(out2, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out2[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out2[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out2[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out2[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out2[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out2[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out2[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out2[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out2[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out2[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out2[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out2[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out2[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out2[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out2[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out2;
};
mat4$2.adjoint = function(out2, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out2[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out2[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out2[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out2[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out2[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out2[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out2[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out2[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out2[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out2[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out2[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out2[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out2[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out2[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out2[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out2[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out2;
};
mat4$2.determinant = function(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
mat4$2.multiply = function(out2, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out2[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out2[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out2[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out2[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out2[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out2[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out2[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out2[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out2[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out2[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out2[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out2[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out2[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out2[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out2[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out2[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out2;
};
mat4$2.multiplyAffine = function(out2, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[4], a11 = a[5], a12 = a[6], a20 = a[8], a21 = a[9], a22 = a[10], a30 = a[12], a31 = a[13], a32 = a[14];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  out2[0] = b0 * a00 + b1 * a10 + b2 * a20;
  out2[1] = b0 * a01 + b1 * a11 + b2 * a21;
  out2[2] = b0 * a02 + b1 * a12 + b2 * a22;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  out2[4] = b0 * a00 + b1 * a10 + b2 * a20;
  out2[5] = b0 * a01 + b1 * a11 + b2 * a21;
  out2[6] = b0 * a02 + b1 * a12 + b2 * a22;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  out2[8] = b0 * a00 + b1 * a10 + b2 * a20;
  out2[9] = b0 * a01 + b1 * a11 + b2 * a21;
  out2[10] = b0 * a02 + b1 * a12 + b2 * a22;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  out2[12] = b0 * a00 + b1 * a10 + b2 * a20 + a30;
  out2[13] = b0 * a01 + b1 * a11 + b2 * a21 + a31;
  out2[14] = b0 * a02 + b1 * a12 + b2 * a22 + a32;
  return out2;
};
mat4$2.mul = mat4$2.multiply;
mat4$2.mulAffine = mat4$2.multiplyAffine;
mat4$2.translate = function(out2, a, v) {
  var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
  if (a === out2) {
    out2[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out2[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out2[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out2[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out2[0] = a00;
    out2[1] = a01;
    out2[2] = a02;
    out2[3] = a03;
    out2[4] = a10;
    out2[5] = a11;
    out2[6] = a12;
    out2[7] = a13;
    out2[8] = a20;
    out2[9] = a21;
    out2[10] = a22;
    out2[11] = a23;
    out2[12] = a00 * x + a10 * y + a20 * z + a[12];
    out2[13] = a01 * x + a11 * y + a21 * z + a[13];
    out2[14] = a02 * x + a12 * y + a22 * z + a[14];
    out2[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out2;
};
mat4$2.scale = function(out2, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out2[0] = a[0] * x;
  out2[1] = a[1] * x;
  out2[2] = a[2] * x;
  out2[3] = a[3] * x;
  out2[4] = a[4] * y;
  out2[5] = a[5] * y;
  out2[6] = a[6] * y;
  out2[7] = a[7] * y;
  out2[8] = a[8] * z;
  out2[9] = a[9] * z;
  out2[10] = a[10] * z;
  out2[11] = a[11] * z;
  out2[12] = a[12];
  out2[13] = a[13];
  out2[14] = a[14];
  out2[15] = a[15];
  return out2;
};
mat4$2.rotate = function(out2, a, rad2, axis) {
  var x = axis[0], y = axis[1], z = axis[2], len2 = Math.sqrt(x * x + y * y + z * z), s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, b02, b10, b11, b12, b20, b21, b22;
  if (Math.abs(len2) < GLMAT_EPSILON) {
    return null;
  }
  len2 = 1 / len2;
  x *= len2;
  y *= len2;
  z *= len2;
  s = Math.sin(rad2);
  c = Math.cos(rad2);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out2[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out2[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out2[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out2[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out2[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out2[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out2[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out2[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out2[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out2[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out2[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out2[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out2) {
    out2[12] = a[12];
    out2[13] = a[13];
    out2[14] = a[14];
    out2[15] = a[15];
  }
  return out2;
};
mat4$2.rotateX = function(out2, a, rad2) {
  var s = Math.sin(rad2), c = Math.cos(rad2), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  if (a !== out2) {
    out2[0] = a[0];
    out2[1] = a[1];
    out2[2] = a[2];
    out2[3] = a[3];
    out2[12] = a[12];
    out2[13] = a[13];
    out2[14] = a[14];
    out2[15] = a[15];
  }
  out2[4] = a10 * c + a20 * s;
  out2[5] = a11 * c + a21 * s;
  out2[6] = a12 * c + a22 * s;
  out2[7] = a13 * c + a23 * s;
  out2[8] = a20 * c - a10 * s;
  out2[9] = a21 * c - a11 * s;
  out2[10] = a22 * c - a12 * s;
  out2[11] = a23 * c - a13 * s;
  return out2;
};
mat4$2.rotateY = function(out2, a, rad2) {
  var s = Math.sin(rad2), c = Math.cos(rad2), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  if (a !== out2) {
    out2[4] = a[4];
    out2[5] = a[5];
    out2[6] = a[6];
    out2[7] = a[7];
    out2[12] = a[12];
    out2[13] = a[13];
    out2[14] = a[14];
    out2[15] = a[15];
  }
  out2[0] = a00 * c - a20 * s;
  out2[1] = a01 * c - a21 * s;
  out2[2] = a02 * c - a22 * s;
  out2[3] = a03 * c - a23 * s;
  out2[8] = a00 * s + a20 * c;
  out2[9] = a01 * s + a21 * c;
  out2[10] = a02 * s + a22 * c;
  out2[11] = a03 * s + a23 * c;
  return out2;
};
mat4$2.rotateZ = function(out2, a, rad2) {
  var s = Math.sin(rad2), c = Math.cos(rad2), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  if (a !== out2) {
    out2[8] = a[8];
    out2[9] = a[9];
    out2[10] = a[10];
    out2[11] = a[11];
    out2[12] = a[12];
    out2[13] = a[13];
    out2[14] = a[14];
    out2[15] = a[15];
  }
  out2[0] = a00 * c + a10 * s;
  out2[1] = a01 * c + a11 * s;
  out2[2] = a02 * c + a12 * s;
  out2[3] = a03 * c + a13 * s;
  out2[4] = a10 * c - a00 * s;
  out2[5] = a11 * c - a01 * s;
  out2[6] = a12 * c - a02 * s;
  out2[7] = a13 * c - a03 * s;
  return out2;
};
mat4$2.fromRotationTranslation = function(out2, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx2 = w * x2, wy = w * y2, wz = w * z2;
  out2[0] = 1 - (yy + zz);
  out2[1] = xy + wz;
  out2[2] = xz - wy;
  out2[3] = 0;
  out2[4] = xy - wz;
  out2[5] = 1 - (xx + zz);
  out2[6] = yz + wx2;
  out2[7] = 0;
  out2[8] = xz + wy;
  out2[9] = yz - wx2;
  out2[10] = 1 - (xx + yy);
  out2[11] = 0;
  out2[12] = v[0];
  out2[13] = v[1];
  out2[14] = v[2];
  out2[15] = 1;
  return out2;
};
mat4$2.fromQuat = function(out2, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx2 = w * x2, wy = w * y2, wz = w * z2;
  out2[0] = 1 - yy - zz;
  out2[1] = yx + wz;
  out2[2] = zx - wy;
  out2[3] = 0;
  out2[4] = yx - wz;
  out2[5] = 1 - xx - zz;
  out2[6] = zy + wx2;
  out2[7] = 0;
  out2[8] = zx + wy;
  out2[9] = zy - wx2;
  out2[10] = 1 - xx - yy;
  out2[11] = 0;
  out2[12] = 0;
  out2[13] = 0;
  out2[14] = 0;
  out2[15] = 1;
  return out2;
};
mat4$2.frustum = function(out2, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
  out2[0] = near * 2 * rl;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  out2[4] = 0;
  out2[5] = near * 2 * tb;
  out2[6] = 0;
  out2[7] = 0;
  out2[8] = (right + left) * rl;
  out2[9] = (top + bottom) * tb;
  out2[10] = (far + near) * nf;
  out2[11] = -1;
  out2[12] = 0;
  out2[13] = 0;
  out2[14] = far * near * 2 * nf;
  out2[15] = 0;
  return out2;
};
mat4$2.perspective = function(out2, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
  out2[0] = f / aspect;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  out2[4] = 0;
  out2[5] = f;
  out2[6] = 0;
  out2[7] = 0;
  out2[8] = 0;
  out2[9] = 0;
  out2[10] = (far + near) * nf;
  out2[11] = -1;
  out2[12] = 0;
  out2[13] = 0;
  out2[14] = 2 * far * near * nf;
  out2[15] = 0;
  return out2;
};
mat4$2.ortho = function(out2, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
  out2[0] = -2 * lr;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  out2[4] = 0;
  out2[5] = -2 * bt;
  out2[6] = 0;
  out2[7] = 0;
  out2[8] = 0;
  out2[9] = 0;
  out2[10] = 2 * nf;
  out2[11] = 0;
  out2[12] = (left + right) * lr;
  out2[13] = (top + bottom) * bt;
  out2[14] = (far + near) * nf;
  out2[15] = 1;
  return out2;
};
mat4$2.lookAt = function(out2, eye, center2, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len2, eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center2[0], centery = center2[1], centerz = center2[2];
  if (Math.abs(eyex - centerx) < GLMAT_EPSILON && Math.abs(eyey - centery) < GLMAT_EPSILON && Math.abs(eyez - centerz) < GLMAT_EPSILON) {
    return mat4$2.identity(out2);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len2 = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len2;
  z1 *= len2;
  z2 *= len2;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len2 = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len2) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len2 = 1 / len2;
    x0 *= len2;
    x1 *= len2;
    x2 *= len2;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len2 = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len2) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len2 = 1 / len2;
    y0 *= len2;
    y1 *= len2;
    y2 *= len2;
  }
  out2[0] = x0;
  out2[1] = y0;
  out2[2] = z0;
  out2[3] = 0;
  out2[4] = x1;
  out2[5] = y1;
  out2[6] = z1;
  out2[7] = 0;
  out2[8] = x2;
  out2[9] = y2;
  out2[10] = z2;
  out2[11] = 0;
  out2[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out2[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out2[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out2[15] = 1;
  return out2;
};
mat4$2.frob = function(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
};
var mat4$3 = mat4$2;
var vec3$f = {};
vec3$f.create = function() {
  var out2 = new GLMAT_ARRAY_TYPE(3);
  out2[0] = 0;
  out2[1] = 0;
  out2[2] = 0;
  return out2;
};
vec3$f.clone = function(a) {
  var out2 = new GLMAT_ARRAY_TYPE(3);
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  return out2;
};
vec3$f.fromValues = function(x, y, z) {
  var out2 = new GLMAT_ARRAY_TYPE(3);
  out2[0] = x;
  out2[1] = y;
  out2[2] = z;
  return out2;
};
vec3$f.copy = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  return out2;
};
vec3$f.set = function(out2, x, y, z) {
  out2[0] = x;
  out2[1] = y;
  out2[2] = z;
  return out2;
};
vec3$f.add = function(out2, a, b) {
  out2[0] = a[0] + b[0];
  out2[1] = a[1] + b[1];
  out2[2] = a[2] + b[2];
  return out2;
};
vec3$f.subtract = function(out2, a, b) {
  out2[0] = a[0] - b[0];
  out2[1] = a[1] - b[1];
  out2[2] = a[2] - b[2];
  return out2;
};
vec3$f.sub = vec3$f.subtract;
vec3$f.multiply = function(out2, a, b) {
  out2[0] = a[0] * b[0];
  out2[1] = a[1] * b[1];
  out2[2] = a[2] * b[2];
  return out2;
};
vec3$f.mul = vec3$f.multiply;
vec3$f.divide = function(out2, a, b) {
  out2[0] = a[0] / b[0];
  out2[1] = a[1] / b[1];
  out2[2] = a[2] / b[2];
  return out2;
};
vec3$f.div = vec3$f.divide;
vec3$f.min = function(out2, a, b) {
  out2[0] = Math.min(a[0], b[0]);
  out2[1] = Math.min(a[1], b[1]);
  out2[2] = Math.min(a[2], b[2]);
  return out2;
};
vec3$f.max = function(out2, a, b) {
  out2[0] = Math.max(a[0], b[0]);
  out2[1] = Math.max(a[1], b[1]);
  out2[2] = Math.max(a[2], b[2]);
  return out2;
};
vec3$f.scale = function(out2, a, b) {
  out2[0] = a[0] * b;
  out2[1] = a[1] * b;
  out2[2] = a[2] * b;
  return out2;
};
vec3$f.scaleAndAdd = function(out2, a, b, scale2) {
  out2[0] = a[0] + b[0] * scale2;
  out2[1] = a[1] + b[1] * scale2;
  out2[2] = a[2] + b[2] * scale2;
  return out2;
};
vec3$f.distance = function(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
};
vec3$f.dist = vec3$f.distance;
vec3$f.squaredDistance = function(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2];
  return x * x + y * y + z * z;
};
vec3$f.sqrDist = vec3$f.squaredDistance;
vec3$f.length = function(a) {
  var x = a[0], y = a[1], z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
};
vec3$f.len = vec3$f.length;
vec3$f.squaredLength = function(a) {
  var x = a[0], y = a[1], z = a[2];
  return x * x + y * y + z * z;
};
vec3$f.sqrLen = vec3$f.squaredLength;
vec3$f.negate = function(out2, a) {
  out2[0] = -a[0];
  out2[1] = -a[1];
  out2[2] = -a[2];
  return out2;
};
vec3$f.inverse = function(out2, a) {
  out2[0] = 1 / a[0];
  out2[1] = 1 / a[1];
  out2[2] = 1 / a[2];
  return out2;
};
vec3$f.normalize = function(out2, a) {
  var x = a[0], y = a[1], z = a[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
    out2[0] = a[0] * len2;
    out2[1] = a[1] * len2;
    out2[2] = a[2] * len2;
  }
  return out2;
};
vec3$f.dot = function(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};
vec3$f.cross = function(out2, a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
  out2[0] = ay * bz - az * by;
  out2[1] = az * bx - ax * bz;
  out2[2] = ax * by - ay * bx;
  return out2;
};
vec3$f.lerp = function(out2, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2];
  out2[0] = ax + t * (b[0] - ax);
  out2[1] = ay + t * (b[1] - ay);
  out2[2] = az + t * (b[2] - az);
  return out2;
};
vec3$f.random = function(out2, scale2) {
  scale2 = scale2 || 1;
  var r = GLMAT_RANDOM$1() * 2 * Math.PI;
  var z = GLMAT_RANDOM$1() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale2;
  out2[0] = Math.cos(r) * zScale;
  out2[1] = Math.sin(r) * zScale;
  out2[2] = z * scale2;
  return out2;
};
vec3$f.transformMat4 = function(out2, a, m2) {
  var x = a[0], y = a[1], z = a[2], w = m2[3] * x + m2[7] * y + m2[11] * z + m2[15];
  w = w || 1;
  out2[0] = (m2[0] * x + m2[4] * y + m2[8] * z + m2[12]) / w;
  out2[1] = (m2[1] * x + m2[5] * y + m2[9] * z + m2[13]) / w;
  out2[2] = (m2[2] * x + m2[6] * y + m2[10] * z + m2[14]) / w;
  return out2;
};
vec3$f.transformMat3 = function(out2, a, m2) {
  var x = a[0], y = a[1], z = a[2];
  out2[0] = x * m2[0] + y * m2[3] + z * m2[6];
  out2[1] = x * m2[1] + y * m2[4] + z * m2[7];
  out2[2] = x * m2[2] + y * m2[5] + z * m2[8];
  return out2;
};
vec3$f.transformQuat = function(out2, a, q) {
  var x = a[0], y = a[1], z = a[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
  out2[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out2[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out2[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out2;
};
vec3$f.rotateX = function(out2, a, b, c) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);
  out2[0] = r[0] + b[0];
  out2[1] = r[1] + b[1];
  out2[2] = r[2] + b[2];
  return out2;
};
vec3$f.rotateY = function(out2, a, b, c) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);
  out2[0] = r[0] + b[0];
  out2[1] = r[1] + b[1];
  out2[2] = r[2] + b[2];
  return out2;
};
vec3$f.rotateZ = function(out2, a, b, c) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2];
  out2[0] = r[0] + b[0];
  out2[1] = r[1] + b[1];
  out2[2] = r[2] + b[2];
  return out2;
};
vec3$f.forEach = function() {
  var vec = vec3$f.create();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();
vec3$f.angle = function(a, b) {
  var tempA = vec3$f.fromValues(a[0], a[1], a[2]);
  var tempB = vec3$f.fromValues(b[0], b[1], b[2]);
  vec3$f.normalize(tempA, tempA);
  vec3$f.normalize(tempB, tempB);
  var cosine = vec3$f.dot(tempA, tempB);
  if (cosine > 1) {
    return 0;
  } else {
    return Math.acos(cosine);
  }
};
var vec3$g = vec3$f;
Shader["import"](prezGLSL);
var mat4Create = mat4$3.create;
var errorShader = {};
function defaultGetMaterial(renderable) {
  return renderable.material;
}
function defaultGetUniform(renderable, material, symbol) {
  return material.uniforms[symbol].value;
}
function defaultIsMaterialChanged(renderabled, prevRenderable, material, prevMaterial) {
  return material !== prevMaterial;
}
function defaultIfRender(renderable) {
  return true;
}
function noop() {
}
var attributeBufferTypeMap = {
  float: glenum.FLOAT,
  byte: glenum.BYTE,
  ubyte: glenum.UNSIGNED_BYTE,
  short: glenum.SHORT,
  ushort: glenum.UNSIGNED_SHORT
};
function VertexArrayObject(availableAttributes, availableAttributeSymbols, indicesBuffer) {
  this.availableAttributes = availableAttributes;
  this.availableAttributeSymbols = availableAttributeSymbols;
  this.indicesBuffer = indicesBuffer;
  this.vao = null;
}
function PlaceHolderTexture(renderer) {
  var blankCanvas;
  var webglTexture;
  this.bind = function(renderer2) {
    if (!blankCanvas) {
      blankCanvas = vendor$1.createCanvas();
      blankCanvas.width = blankCanvas.height = 1;
      blankCanvas.getContext("2d");
    }
    var gl = renderer2.gl;
    var firstBind = !webglTexture;
    if (firstBind) {
      webglTexture = gl.createTexture();
    }
    gl.bindTexture(gl.TEXTURE_2D, webglTexture);
    if (firstBind) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, blankCanvas);
    }
  };
  this.unbind = function(renderer2) {
    renderer2.gl.bindTexture(renderer2.gl.TEXTURE_2D, null);
  };
  this.isRenderable = function() {
    return true;
  };
}
var Renderer = Base$1.extend(function() {
  return {
    canvas: null,
    _width: 100,
    _height: 100,
    devicePixelRatio: typeof window !== "undefined" && window.devicePixelRatio || 1,
    clearColor: [0, 0, 0, 0],
    clearBit: 17664,
    alpha: true,
    depth: true,
    stencil: false,
    antialias: true,
    premultipliedAlpha: true,
    preserveDrawingBuffer: false,
    throwError: true,
    gl: null,
    viewport: {},
    maxJointNumber: 20,
    __currentFrameBuffer: null,
    _viewportStack: [],
    _clearStack: [],
    _sceneRendering: null
  };
}, function() {
  if (!this.canvas) {
    this.canvas = vendor$1.createCanvas();
  }
  var canvas = this.canvas;
  try {
    var opts = {
      alpha: this.alpha,
      depth: this.depth,
      stencil: this.stencil,
      antialias: this.antialias,
      premultipliedAlpha: this.premultipliedAlpha,
      preserveDrawingBuffer: this.preserveDrawingBuffer
    };
    this.gl = canvas.getContext("webgl", opts) || canvas.getContext("experimental-webgl", opts);
    if (!this.gl) {
      throw new Error();
    }
    this._glinfo = new GLInfo(this.gl);
    if (this.gl.targetRenderer) {
      console.error("Already created a renderer");
    }
    this.gl.targetRenderer = this;
    this.resize();
  } catch (e2) {
    throw "Error creating WebGL Context " + e2;
  }
  this._programMgr = new ProgramManager(this);
  this._placeholderTexture = new PlaceHolderTexture(this);
}, {
  resize: function(width, height) {
    var canvas = this.canvas;
    var dpr2 = this.devicePixelRatio;
    if (width != null) {
      if (canvas.style) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      canvas.width = width * dpr2;
      canvas.height = height * dpr2;
      this._width = width;
      this._height = height;
    } else {
      this._width = canvas.width / dpr2;
      this._height = canvas.height / dpr2;
    }
    this.setViewport(0, 0, this._width, this._height);
  },
  getWidth: function() {
    return this._width;
  },
  getHeight: function() {
    return this._height;
  },
  getViewportAspect: function() {
    var viewport = this.viewport;
    return viewport.width / viewport.height;
  },
  setDevicePixelRatio: function(devicePixelRatio2) {
    this.devicePixelRatio = devicePixelRatio2;
    this.resize(this._width, this._height);
  },
  getDevicePixelRatio: function() {
    return this.devicePixelRatio;
  },
  getGLExtension: function(name) {
    return this._glinfo.getExtension(name);
  },
  getGLParameter: function(name) {
    return this._glinfo.getParameter(name);
  },
  setViewport: function(x, y, width, height, dpr2) {
    if (typeof x === "object") {
      var obj = x;
      x = obj.x;
      y = obj.y;
      width = obj.width;
      height = obj.height;
      dpr2 = obj.devicePixelRatio;
    }
    dpr2 = dpr2 || this.devicePixelRatio;
    this.gl.viewport(x * dpr2, y * dpr2, width * dpr2, height * dpr2);
    this.viewport = {
      x,
      y,
      width,
      height,
      devicePixelRatio: dpr2
    };
  },
  saveViewport: function() {
    this._viewportStack.push(this.viewport);
  },
  restoreViewport: function() {
    if (this._viewportStack.length > 0) {
      this.setViewport(this._viewportStack.pop());
    }
  },
  saveClear: function() {
    this._clearStack.push({
      clearBit: this.clearBit,
      clearColor: this.clearColor
    });
  },
  restoreClear: function() {
    if (this._clearStack.length > 0) {
      var opt = this._clearStack.pop();
      this.clearColor = opt.clearColor;
      this.clearBit = opt.clearBit;
    }
  },
  bindSceneRendering: function(scene) {
    this._sceneRendering = scene;
  },
  render: function(scene, camera2, notUpdateScene, preZ) {
    var _gl = this.gl;
    var clearColor = this.clearColor;
    if (this.clearBit) {
      _gl.colorMask(true, true, true, true);
      _gl.depthMask(true);
      var viewport = this.viewport;
      var needsScissor = false;
      var viewportDpr = viewport.devicePixelRatio;
      if (viewport.width !== this._width || viewport.height !== this._height || viewportDpr && viewportDpr !== this.devicePixelRatio || viewport.x || viewport.y) {
        needsScissor = true;
        _gl.enable(_gl.SCISSOR_TEST);
        _gl.scissor(viewport.x * viewportDpr, viewport.y * viewportDpr, viewport.width * viewportDpr, viewport.height * viewportDpr);
      }
      _gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
      _gl.clear(this.clearBit);
      if (needsScissor) {
        _gl.disable(_gl.SCISSOR_TEST);
      }
    }
    if (!notUpdateScene) {
      scene.update(false);
    }
    scene.updateLights();
    camera2 = camera2 || scene.getMainCamera();
    if (!camera2) {
      console.error("Can't find camera in the scene.");
      return;
    }
    camera2.update();
    var renderList = scene.updateRenderList(camera2, true);
    this._sceneRendering = scene;
    var opaqueList = renderList.opaque;
    var transparentList = renderList.transparent;
    var sceneMaterial = scene.material;
    scene.trigger("beforerender", this, scene, camera2, renderList);
    if (preZ) {
      this.renderPreZ(opaqueList, scene, camera2);
      _gl.depthFunc(_gl.LEQUAL);
    } else {
      _gl.depthFunc(_gl.LESS);
    }
    var worldViewMat = mat4Create();
    var posViewSpace = vec3$g.create();
    for (var i = 0; i < transparentList.length; i++) {
      var renderable = transparentList[i];
      mat4$3.multiplyAffine(worldViewMat, camera2.viewMatrix.array, renderable.worldTransform.array);
      vec3$g.transformMat4(posViewSpace, renderable.position.array, worldViewMat);
      renderable.__depth = posViewSpace[2];
    }
    this.renderPass(opaqueList, camera2, {
      getMaterial: function(renderable2) {
        return sceneMaterial || renderable2.material;
      },
      sortCompare: this.opaqueSortCompare
    });
    this.renderPass(transparentList, camera2, {
      getMaterial: function(renderable2) {
        return sceneMaterial || renderable2.material;
      },
      sortCompare: this.transparentSortCompare
    });
    scene.trigger("afterrender", this, scene, camera2, renderList);
    this._sceneRendering = null;
  },
  getProgram: function(renderable, renderMaterial, scene) {
    renderMaterial = renderMaterial || renderable.material;
    return this._programMgr.getProgram(renderable, renderMaterial, scene);
  },
  validateProgram: function(program) {
    if (program.__error) {
      var errorMsg = program.__error;
      if (errorShader[program.__uid__]) {
        return;
      }
      errorShader[program.__uid__] = true;
      if (this.throwError) {
        throw new Error(errorMsg);
      } else {
        this.trigger("error", errorMsg);
      }
    }
  },
  updatePrograms: function(list, scene, passConfig) {
    var getMaterial = passConfig && passConfig.getMaterial || defaultGetMaterial;
    scene = scene || null;
    for (var i = 0; i < list.length; i++) {
      var renderable = list[i];
      var renderMaterial = getMaterial.call(this, renderable);
      if (i > 0) {
        var prevRenderable = list[i - 1];
        var prevJointsLen = prevRenderable.joints ? prevRenderable.joints.length : 0;
        var jointsLen = renderable.joints ? renderable.joints.length : 0;
        if (jointsLen === prevJointsLen && renderable.material === prevRenderable.material && renderable.lightGroup === prevRenderable.lightGroup) {
          renderable.__program = prevRenderable.__program;
          continue;
        }
      }
      var program = this._programMgr.getProgram(renderable, renderMaterial, scene);
      this.validateProgram(program);
      renderable.__program = program;
    }
  },
  renderPass: function(list, camera2, passConfig) {
    this.trigger("beforerenderpass", this, list, camera2, passConfig);
    passConfig = passConfig || {};
    passConfig.getMaterial = passConfig.getMaterial || defaultGetMaterial;
    passConfig.getUniform = passConfig.getUniform || defaultGetUniform;
    passConfig.isMaterialChanged = passConfig.isMaterialChanged || defaultIsMaterialChanged;
    passConfig.beforeRender = passConfig.beforeRender || noop;
    passConfig.afterRender = passConfig.afterRender || noop;
    var ifRenderObject = passConfig.ifRender || defaultIfRender;
    this.updatePrograms(list, this._sceneRendering, passConfig);
    if (passConfig.sortCompare) {
      list.sort(passConfig.sortCompare);
    }
    var viewport = this.viewport;
    var vDpr = viewport.devicePixelRatio;
    var viewportUniform = [
      viewport.x * vDpr,
      viewport.y * vDpr,
      viewport.width * vDpr,
      viewport.height * vDpr
    ];
    var windowDpr = this.devicePixelRatio;
    var windowSizeUniform = this.__currentFrameBuffer ? [this.__currentFrameBuffer.getTextureWidth(), this.__currentFrameBuffer.getTextureHeight()] : [this._width * windowDpr, this._height * windowDpr];
    var viewportSizeUniform = [
      viewportUniform[2],
      viewportUniform[3]
    ];
    var time = Date.now();
    if (camera2) {
      mat4$3.copy(matrices.VIEW, camera2.viewMatrix.array);
      mat4$3.copy(matrices.PROJECTION, camera2.projectionMatrix.array);
      mat4$3.copy(matrices.VIEWINVERSE, camera2.worldTransform.array);
    } else {
      mat4$3.identity(matrices.VIEW);
      mat4$3.identity(matrices.PROJECTION);
      mat4$3.identity(matrices.VIEWINVERSE);
    }
    mat4$3.multiply(matrices.VIEWPROJECTION, matrices.PROJECTION, matrices.VIEW);
    mat4$3.invert(matrices.PROJECTIONINVERSE, matrices.PROJECTION);
    mat4$3.invert(matrices.VIEWPROJECTIONINVERSE, matrices.VIEWPROJECTION);
    var _gl = this.gl;
    var scene = this._sceneRendering;
    var prevMaterial;
    var prevProgram;
    var prevRenderable;
    var depthTest, depthMask;
    var culling, cullFace, frontFace;
    var transparent;
    var drawID;
    var currentVAO;
    var materialTakesTextureSlot;
    var vaoExt = null;
    for (var i = 0; i < list.length; i++) {
      var renderable = list[i];
      var isSceneNode = renderable.worldTransform != null;
      var worldM;
      if (!ifRenderObject(renderable)) {
        continue;
      }
      if (isSceneNode) {
        worldM = renderable.isSkinnedMesh && renderable.isSkinnedMesh() ? renderable.offsetMatrix ? renderable.offsetMatrix.array : matrices.IDENTITY : renderable.worldTransform.array;
      }
      var geometry = renderable.geometry;
      var material = passConfig.getMaterial.call(this, renderable);
      var program = renderable.__program;
      var shader = material.shader;
      var currentDrawID = geometry.__uid__ + "-" + program.__uid__;
      var drawIDChanged = currentDrawID !== drawID;
      drawID = currentDrawID;
      if (drawIDChanged && vaoExt) {
        vaoExt.bindVertexArrayOES(null);
      }
      if (isSceneNode) {
        mat4$3.copy(matrices.WORLD, worldM);
        mat4$3.multiply(matrices.WORLDVIEWPROJECTION, matrices.VIEWPROJECTION, worldM);
        mat4$3.multiplyAffine(matrices.WORLDVIEW, matrices.VIEW, worldM);
        if (shader.matrixSemantics.WORLDINVERSE || shader.matrixSemantics.WORLDINVERSETRANSPOSE) {
          mat4$3.invert(matrices.WORLDINVERSE, worldM);
        }
        if (shader.matrixSemantics.WORLDVIEWINVERSE || shader.matrixSemantics.WORLDVIEWINVERSETRANSPOSE) {
          mat4$3.invert(matrices.WORLDVIEWINVERSE, matrices.WORLDVIEW);
        }
        if (shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSE || shader.matrixSemantics.WORLDVIEWPROJECTIONINVERSETRANSPOSE) {
          mat4$3.invert(matrices.WORLDVIEWPROJECTIONINVERSE, matrices.WORLDVIEWPROJECTION);
        }
      }
      renderable.beforeRender && renderable.beforeRender(this);
      passConfig.beforeRender.call(this, renderable, material, prevMaterial);
      var programChanged = program !== prevProgram;
      if (programChanged) {
        program.bind(this);
        program.setUniformOfSemantic(_gl, "VIEWPORT", viewportUniform);
        program.setUniformOfSemantic(_gl, "WINDOW_SIZE", windowSizeUniform);
        if (camera2) {
          program.setUniformOfSemantic(_gl, "NEAR", camera2.near);
          program.setUniformOfSemantic(_gl, "FAR", camera2.far);
        }
        program.setUniformOfSemantic(_gl, "DEVICEPIXELRATIO", vDpr);
        program.setUniformOfSemantic(_gl, "TIME", time);
        program.setUniformOfSemantic(_gl, "VIEWPORT_SIZE", viewportSizeUniform);
        if (scene) {
          scene.setLightUniforms(program, renderable.lightGroup, this);
        }
      } else {
        program = prevProgram;
      }
      if (programChanged || passConfig.isMaterialChanged(renderable, prevRenderable, material, prevMaterial)) {
        if (material.depthTest !== depthTest) {
          material.depthTest ? _gl.enable(_gl.DEPTH_TEST) : _gl.disable(_gl.DEPTH_TEST);
          depthTest = material.depthTest;
        }
        if (material.depthMask !== depthMask) {
          _gl.depthMask(material.depthMask);
          depthMask = material.depthMask;
        }
        if (material.transparent !== transparent) {
          material.transparent ? _gl.enable(_gl.BLEND) : _gl.disable(_gl.BLEND);
          transparent = material.transparent;
        }
        if (material.transparent) {
          if (material.blend) {
            material.blend(_gl);
          } else {
            _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
            _gl.blendFuncSeparate(_gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
          }
        }
        materialTakesTextureSlot = this._bindMaterial(renderable, material, program, prevRenderable || null, prevMaterial || null, prevProgram || null, passConfig.getUniform);
        prevMaterial = material;
      }
      var matrixSemanticKeys = shader.matrixSemanticKeys;
      if (isSceneNode) {
        for (var k = 0; k < matrixSemanticKeys.length; k++) {
          var semantic = matrixSemanticKeys[k];
          var semanticInfo = shader.matrixSemantics[semantic];
          var matrix = matrices[semantic];
          if (semanticInfo.isTranspose) {
            var matrixNoTranspose = matrices[semanticInfo.semanticNoTranspose];
            mat4$3.transpose(matrix, matrixNoTranspose);
          }
          program.setUniform(_gl, semanticInfo.type, semanticInfo.symbol, matrix);
        }
      }
      if (renderable.cullFace !== cullFace) {
        cullFace = renderable.cullFace;
        _gl.cullFace(cullFace);
      }
      if (renderable.frontFace !== frontFace) {
        frontFace = renderable.frontFace;
        _gl.frontFace(frontFace);
      }
      if (renderable.culling !== culling) {
        culling = renderable.culling;
        culling ? _gl.enable(_gl.CULL_FACE) : _gl.disable(_gl.CULL_FACE);
      }
      this._updateSkeleton(renderable, program, materialTakesTextureSlot);
      if (drawIDChanged) {
        currentVAO = this._bindVAO(vaoExt, shader, geometry, program);
      }
      this._renderObject(renderable, currentVAO, program);
      passConfig.afterRender(this, renderable);
      renderable.afterRender && renderable.afterRender(this);
      prevProgram = program;
      prevRenderable = renderable;
    }
    this.trigger("afterrenderpass", this, list, camera2, passConfig);
  },
  getMaxJointNumber: function() {
    return this.maxJointNumber;
  },
  _updateSkeleton: function(object, program, slot) {
    var _gl = this.gl;
    var skeleton = object.skeleton;
    if (skeleton) {
      skeleton.update();
      if (object.joints.length > this.getMaxJointNumber()) {
        var skinMatricesTexture = skeleton.getSubSkinMatricesTexture(object.__uid__, object.joints);
        program.useTextureSlot(this, skinMatricesTexture, slot);
        program.setUniform(_gl, "1i", "skinMatricesTexture", slot);
        program.setUniform(_gl, "1f", "skinMatricesTextureSize", skinMatricesTexture.width);
      } else {
        var skinMatricesArray = skeleton.getSubSkinMatrices(object.__uid__, object.joints);
        program.setUniformOfSemantic(_gl, "SKIN_MATRIX", skinMatricesArray);
      }
    }
  },
  _renderObject: function(renderable, vao, program) {
    var _gl = this.gl;
    var geometry = renderable.geometry;
    var glDrawMode = renderable.mode;
    if (glDrawMode == null) {
      glDrawMode = 4;
    }
    var ext = null;
    var isInstanced = renderable.isInstancedMesh && renderable.isInstancedMesh();
    if (isInstanced) {
      ext = this.getGLExtension("ANGLE_instanced_arrays");
      if (!ext) {
        console.warn("Device not support ANGLE_instanced_arrays extension");
        return;
      }
    }
    var instancedAttrLocations;
    if (isInstanced) {
      instancedAttrLocations = this._bindInstancedAttributes(renderable, program, ext);
    }
    if (vao.indicesBuffer) {
      var uintExt = this.getGLExtension("OES_element_index_uint");
      var useUintExt = uintExt && geometry.indices instanceof Uint32Array;
      var indicesType = useUintExt ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;
      if (isInstanced) {
        ext.drawElementsInstancedANGLE(glDrawMode, vao.indicesBuffer.count, indicesType, 0, renderable.getInstanceCount());
      } else {
        _gl.drawElements(glDrawMode, vao.indicesBuffer.count, indicesType, 0);
      }
    } else {
      if (isInstanced) {
        ext.drawArraysInstancedANGLE(glDrawMode, 0, geometry.vertexCount, renderable.getInstanceCount());
      } else {
        _gl.drawArrays(glDrawMode, 0, geometry.vertexCount);
      }
    }
    if (isInstanced) {
      for (var i = 0; i < instancedAttrLocations.length; i++) {
        _gl.disableVertexAttribArray(instancedAttrLocations[i]);
      }
    }
  },
  _bindInstancedAttributes: function(renderable, program, ext) {
    var _gl = this.gl;
    var instancedBuffers = renderable.getInstancedAttributesBuffers(this);
    var locations = [];
    for (var i = 0; i < instancedBuffers.length; i++) {
      var bufferObj = instancedBuffers[i];
      var location2 = program.getAttribLocation(_gl, bufferObj.symbol);
      if (location2 < 0) {
        continue;
      }
      var glType = attributeBufferTypeMap[bufferObj.type] || _gl.FLOAT;
      _gl.enableVertexAttribArray(location2);
      _gl.bindBuffer(_gl.ARRAY_BUFFER, bufferObj.buffer);
      _gl.vertexAttribPointer(location2, bufferObj.size, glType, false, 0, 0);
      ext.vertexAttribDivisorANGLE(location2, bufferObj.divisor);
      locations.push(location2);
    }
    return locations;
  },
  _bindMaterial: function(renderable, material, program, prevRenderable, prevMaterial, prevProgram, getUniformValue) {
    var _gl = this.gl;
    var sameProgram = prevProgram === program;
    var currentTextureSlot = program.currentTextureSlot();
    var enabledUniforms = material.getEnabledUniforms();
    var textureUniforms = material.getTextureUniforms();
    var placeholderTexture = this._placeholderTexture;
    for (var u = 0; u < textureUniforms.length; u++) {
      var symbol = textureUniforms[u];
      var uniformValue = getUniformValue(renderable, material, symbol);
      var uniformType = material.uniforms[symbol].type;
      if (uniformType === "t" && uniformValue) {
        uniformValue.__slot = -1;
      } else if (uniformType === "tv") {
        for (var i = 0; i < uniformValue.length; i++) {
          if (uniformValue[i]) {
            uniformValue[i].__slot = -1;
          }
        }
      }
    }
    placeholderTexture.__slot = -1;
    for (var u = 0; u < enabledUniforms.length; u++) {
      var symbol = enabledUniforms[u];
      var uniform = material.uniforms[symbol];
      var uniformValue = getUniformValue(renderable, material, symbol);
      var uniformType = uniform.type;
      var isTexture = uniformType === "t";
      if (isTexture) {
        if (!uniformValue || !uniformValue.isRenderable()) {
          uniformValue = placeholderTexture;
        }
      }
      if (prevMaterial && sameProgram) {
        var prevUniformValue = getUniformValue(prevRenderable, prevMaterial, symbol);
        if (isTexture) {
          if (!prevUniformValue || !prevUniformValue.isRenderable()) {
            prevUniformValue = placeholderTexture;
          }
        }
        if (prevUniformValue === uniformValue) {
          if (isTexture) {
            program.takeCurrentTextureSlot(this, null);
          } else if (uniformType === "tv" && uniformValue) {
            for (var i = 0; i < uniformValue.length; i++) {
              program.takeCurrentTextureSlot(this, null);
            }
          }
          continue;
        }
      }
      if (uniformValue == null) {
        continue;
      } else if (isTexture) {
        if (uniformValue.__slot < 0) {
          var slot = program.currentTextureSlot();
          var res = program.setUniform(_gl, "1i", symbol, slot);
          if (res) {
            program.takeCurrentTextureSlot(this, uniformValue);
            uniformValue.__slot = slot;
          }
        } else {
          program.setUniform(_gl, "1i", symbol, uniformValue.__slot);
        }
      } else if (Array.isArray(uniformValue)) {
        if (uniformValue.length === 0) {
          continue;
        }
        if (uniformType === "tv") {
          if (!program.hasUniform(symbol)) {
            continue;
          }
          var arr = [];
          for (var i = 0; i < uniformValue.length; i++) {
            var texture = uniformValue[i];
            if (texture.__slot < 0) {
              var slot = program.currentTextureSlot();
              arr.push(slot);
              program.takeCurrentTextureSlot(this, texture);
              texture.__slot = slot;
            } else {
              arr.push(texture.__slot);
            }
          }
          program.setUniform(_gl, "1iv", symbol, arr);
        } else {
          program.setUniform(_gl, uniform.type, symbol, uniformValue);
        }
      } else {
        program.setUniform(_gl, uniform.type, symbol, uniformValue);
      }
    }
    var newSlot = program.currentTextureSlot();
    program.resetTextureSlot(currentTextureSlot);
    return newSlot;
  },
  _bindVAO: function(vaoExt, shader, geometry, program) {
    var isStatic = !geometry.dynamic;
    var _gl = this.gl;
    var vaoId = this.__uid__ + "-" + program.__uid__;
    var vao = geometry.__vaoCache[vaoId];
    if (!vao) {
      var chunks = geometry.getBufferChunks(this);
      if (!chunks || !chunks.length) {
        return;
      }
      var chunk = chunks[0];
      var attributeBuffers = chunk.attributeBuffers;
      var indicesBuffer = chunk.indicesBuffer;
      var availableAttributes = [];
      var availableAttributeSymbols = [];
      for (var a = 0; a < attributeBuffers.length; a++) {
        var attributeBufferInfo = attributeBuffers[a];
        var name = attributeBufferInfo.name;
        var semantic = attributeBufferInfo.semantic;
        var symbol;
        if (semantic) {
          var semanticInfo = shader.attributeSemantics[semantic];
          symbol = semanticInfo && semanticInfo.symbol;
        } else {
          symbol = name;
        }
        if (symbol && program.attributes[symbol]) {
          availableAttributes.push(attributeBufferInfo);
          availableAttributeSymbols.push(symbol);
        }
      }
      vao = new VertexArrayObject(availableAttributes, availableAttributeSymbols, indicesBuffer);
      if (isStatic) {
        geometry.__vaoCache[vaoId] = vao;
      }
    }
    var needsBindAttributes = true;
    if (vaoExt && isStatic) {
      if (vao.vao == null) {
        vao.vao = vaoExt.createVertexArrayOES();
      } else {
        needsBindAttributes = false;
      }
      vaoExt.bindVertexArrayOES(vao.vao);
    }
    var availableAttributes = vao.availableAttributes;
    var indicesBuffer = vao.indicesBuffer;
    if (needsBindAttributes) {
      var locationList = program.enableAttributes(this, vao.availableAttributeSymbols, vaoExt && isStatic && vao);
      for (var a = 0; a < availableAttributes.length; a++) {
        var location2 = locationList[a];
        if (location2 === -1) {
          continue;
        }
        var attributeBufferInfo = availableAttributes[a];
        var buffer = attributeBufferInfo.buffer;
        var size = attributeBufferInfo.size;
        var glType = attributeBufferTypeMap[attributeBufferInfo.type] || _gl.FLOAT;
        _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
        _gl.vertexAttribPointer(location2, size, glType, false, 0, 0);
      }
      if (geometry.isUseIndices()) {
        _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);
      }
    }
    return vao;
  },
  renderPreZ: function(list, scene, camera2) {
    var _gl = this.gl;
    var preZPassMaterial = this._prezMaterial || new Material$1({
      shader: new Shader(Shader.source("clay.prez.vertex"), Shader.source("clay.prez.fragment"))
    });
    this._prezMaterial = preZPassMaterial;
    _gl.colorMask(false, false, false, false);
    _gl.depthMask(true);
    this.renderPass(list, camera2, {
      ifRender: function(renderable) {
        return !renderable.ignorePreZ;
      },
      isMaterialChanged: function(renderable, prevRenderable) {
        var matA = renderable.material;
        var matB = prevRenderable.material;
        return matA.get("diffuseMap") !== matB.get("diffuseMap") || (matA.get("alphaCutoff") || 0) !== (matB.get("alphaCutoff") || 0);
      },
      getUniform: function(renderable, depthMaterial, symbol) {
        if (symbol === "alphaMap") {
          return renderable.material.get("diffuseMap");
        } else if (symbol === "alphaCutoff") {
          if (renderable.material.isDefined("fragment", "ALPHA_TEST") && renderable.material.get("diffuseMap")) {
            var alphaCutoff = renderable.material.get("alphaCutoff");
            return alphaCutoff || 0;
          }
          return 0;
        } else if (symbol === "uvRepeat") {
          return renderable.material.get("uvRepeat");
        } else if (symbol === "uvOffset") {
          return renderable.material.get("uvOffset");
        } else {
          return depthMaterial.get(symbol);
        }
      },
      getMaterial: function() {
        return preZPassMaterial;
      },
      sort: this.opaqueSortCompare
    });
    _gl.colorMask(true, true, true, true);
    _gl.depthMask(true);
  },
  disposeScene: function(scene) {
    this.disposeNode(scene, true, true);
    scene.dispose();
  },
  disposeNode: function(root2, disposeGeometry, disposeTexture) {
    if (root2.getParent()) {
      root2.getParent().remove(root2);
    }
    var disposedMap = {};
    root2.traverse(function(node) {
      var material = node.material;
      if (node.geometry && disposeGeometry) {
        node.geometry.dispose(this);
      }
      if (disposeTexture && material && !disposedMap[material.__uid__]) {
        var textureUniforms = material.getTextureUniforms();
        for (var u = 0; u < textureUniforms.length; u++) {
          var uniformName = textureUniforms[u];
          var val = material.uniforms[uniformName].value;
          var uniformType = material.uniforms[uniformName].type;
          if (!val) {
            continue;
          }
          if (uniformType === "t") {
            val.dispose && val.dispose(this);
          } else if (uniformType === "tv") {
            for (var k = 0; k < val.length; k++) {
              if (val[k]) {
                val[k].dispose && val[k].dispose(this);
              }
            }
          }
        }
        disposedMap[material.__uid__] = true;
      }
      if (node.dispose) {
        node.dispose(this);
      }
    }, this);
  },
  disposeGeometry: function(geometry) {
    geometry.dispose(this);
  },
  disposeTexture: function(texture) {
    texture.dispose(this);
  },
  disposeFrameBuffer: function(frameBuffer) {
    frameBuffer.dispose(this);
  },
  dispose: function() {
  },
  screenToNDC: function(x, y, out2) {
    if (!out2) {
      out2 = new Vector2$1();
    }
    y = this._height - y;
    var viewport = this.viewport;
    var arr = out2.array;
    arr[0] = (x - viewport.x) / viewport.width;
    arr[0] = arr[0] * 2 - 1;
    arr[1] = (y - viewport.y) / viewport.height;
    arr[1] = arr[1] * 2 - 1;
    return out2;
  }
});
Renderer.opaqueSortCompare = Renderer.prototype.opaqueSortCompare = function(x, y) {
  if (x.renderOrder === y.renderOrder) {
    if (x.__program === y.__program) {
      if (x.material === y.material) {
        return x.geometry.__uid__ - y.geometry.__uid__;
      }
      return x.material.__uid__ - y.material.__uid__;
    }
    if (x.__program && y.__program) {
      return x.__program.__uid__ - y.__program.__uid__;
    }
    return 0;
  }
  return x.renderOrder - y.renderOrder;
};
Renderer.transparentSortCompare = Renderer.prototype.transparentSortCompare = function(x, y) {
  if (x.renderOrder === y.renderOrder) {
    if (x.__depth === y.__depth) {
      if (x.__program === y.__program) {
        if (x.material === y.material) {
          return x.geometry.__uid__ - y.geometry.__uid__;
        }
        return x.material.__uid__ - y.material.__uid__;
      }
      if (x.__program && y.__program) {
        return x.__program.__uid__ - y.__program.__uid__;
      }
      return 0;
    }
    return x.__depth - y.__depth;
  }
  return x.renderOrder - y.renderOrder;
};
var matrices = {
  IDENTITY: mat4Create(),
  WORLD: mat4Create(),
  VIEW: mat4Create(),
  PROJECTION: mat4Create(),
  WORLDVIEW: mat4Create(),
  VIEWPROJECTION: mat4Create(),
  WORLDVIEWPROJECTION: mat4Create(),
  WORLDINVERSE: mat4Create(),
  VIEWINVERSE: mat4Create(),
  PROJECTIONINVERSE: mat4Create(),
  WORLDVIEWINVERSE: mat4Create(),
  VIEWPROJECTIONINVERSE: mat4Create(),
  WORLDVIEWPROJECTIONINVERSE: mat4Create(),
  WORLDTRANSPOSE: mat4Create(),
  VIEWTRANSPOSE: mat4Create(),
  PROJECTIONTRANSPOSE: mat4Create(),
  WORLDVIEWTRANSPOSE: mat4Create(),
  VIEWPROJECTIONTRANSPOSE: mat4Create(),
  WORLDVIEWPROJECTIONTRANSPOSE: mat4Create(),
  WORLDINVERSETRANSPOSE: mat4Create(),
  VIEWINVERSETRANSPOSE: mat4Create(),
  PROJECTIONINVERSETRANSPOSE: mat4Create(),
  WORLDVIEWINVERSETRANSPOSE: mat4Create(),
  VIEWPROJECTIONINVERSETRANSPOSE: mat4Create(),
  WORLDVIEWPROJECTIONINVERSETRANSPOSE: mat4Create()
};
Renderer.COLOR_BUFFER_BIT = glenum.COLOR_BUFFER_BIT;
Renderer.DEPTH_BUFFER_BIT = glenum.DEPTH_BUFFER_BIT;
Renderer.STENCIL_BUFFER_BIT = glenum.STENCIL_BUFFER_BIT;
var Renderer$1 = Renderer;
var Vector3 = function(x, y, z) {
  x = x || 0;
  y = y || 0;
  z = z || 0;
  this.array = vec3$g.fromValues(x, y, z);
  this._dirty = true;
};
Vector3.prototype = {
  constructor: Vector3,
  add: function(b) {
    vec3$g.add(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  set: function(x, y, z) {
    this.array[0] = x;
    this.array[1] = y;
    this.array[2] = z;
    this._dirty = true;
    return this;
  },
  setArray: function(arr) {
    this.array[0] = arr[0];
    this.array[1] = arr[1];
    this.array[2] = arr[2];
    this._dirty = true;
    return this;
  },
  clone: function() {
    return new Vector3(this.x, this.y, this.z);
  },
  copy: function(b) {
    vec3$g.copy(this.array, b.array);
    this._dirty = true;
    return this;
  },
  cross: function(a, b) {
    vec3$g.cross(this.array, a.array, b.array);
    this._dirty = true;
    return this;
  },
  dist: function(b) {
    return vec3$g.dist(this.array, b.array);
  },
  distance: function(b) {
    return vec3$g.distance(this.array, b.array);
  },
  div: function(b) {
    vec3$g.div(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  divide: function(b) {
    vec3$g.divide(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  dot: function(b) {
    return vec3$g.dot(this.array, b.array);
  },
  len: function() {
    return vec3$g.len(this.array);
  },
  length: function() {
    return vec3$g.length(this.array);
  },
  lerp: function(a, b, t) {
    vec3$g.lerp(this.array, a.array, b.array, t);
    this._dirty = true;
    return this;
  },
  min: function(b) {
    vec3$g.min(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  max: function(b) {
    vec3$g.max(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  mul: function(b) {
    vec3$g.mul(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  multiply: function(b) {
    vec3$g.multiply(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  negate: function() {
    vec3$g.negate(this.array, this.array);
    this._dirty = true;
    return this;
  },
  normalize: function() {
    vec3$g.normalize(this.array, this.array);
    this._dirty = true;
    return this;
  },
  random: function(scale2) {
    vec3$g.random(this.array, scale2);
    this._dirty = true;
    return this;
  },
  scale: function(s) {
    vec3$g.scale(this.array, this.array, s);
    this._dirty = true;
    return this;
  },
  scaleAndAdd: function(b, s) {
    vec3$g.scaleAndAdd(this.array, this.array, b.array, s);
    this._dirty = true;
    return this;
  },
  sqrDist: function(b) {
    return vec3$g.sqrDist(this.array, b.array);
  },
  squaredDistance: function(b) {
    return vec3$g.squaredDistance(this.array, b.array);
  },
  sqrLen: function() {
    return vec3$g.sqrLen(this.array);
  },
  squaredLength: function() {
    return vec3$g.squaredLength(this.array);
  },
  sub: function(b) {
    vec3$g.sub(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  subtract: function(b) {
    vec3$g.subtract(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  transformMat3: function(m2) {
    vec3$g.transformMat3(this.array, this.array, m2.array);
    this._dirty = true;
    return this;
  },
  transformMat4: function(m2) {
    vec3$g.transformMat4(this.array, this.array, m2.array);
    this._dirty = true;
    return this;
  },
  transformQuat: function(q) {
    vec3$g.transformQuat(this.array, this.array, q.array);
    this._dirty = true;
    return this;
  },
  applyProjection: function(m2) {
    var v = this.array;
    m2 = m2.array;
    if (m2[15] === 0) {
      var w = -1 / v[2];
      v[0] = m2[0] * v[0] * w;
      v[1] = m2[5] * v[1] * w;
      v[2] = (m2[10] * v[2] + m2[14]) * w;
    } else {
      v[0] = m2[0] * v[0] + m2[12];
      v[1] = m2[5] * v[1] + m2[13];
      v[2] = m2[10] * v[2] + m2[14];
    }
    this._dirty = true;
    return this;
  },
  eulerFromQuat: function(q, order) {
    Vector3.eulerFromQuat(this, q, order);
  },
  eulerFromMat3: function(m2, order) {
    Vector3.eulerFromMat3(this, m2, order);
  },
  toString: function() {
    return "[" + Array.prototype.join.call(this.array, ",") + "]";
  },
  toArray: function() {
    return Array.prototype.slice.call(this.array);
  }
};
var defineProperty$3 = Object.defineProperty;
if (defineProperty$3) {
  var proto$3 = Vector3.prototype;
  defineProperty$3(proto$3, "x", {
    get: function() {
      return this.array[0];
    },
    set: function(value) {
      this.array[0] = value;
      this._dirty = true;
    }
  });
  defineProperty$3(proto$3, "y", {
    get: function() {
      return this.array[1];
    },
    set: function(value) {
      this.array[1] = value;
      this._dirty = true;
    }
  });
  defineProperty$3(proto$3, "z", {
    get: function() {
      return this.array[2];
    },
    set: function(value) {
      this.array[2] = value;
      this._dirty = true;
    }
  });
}
Vector3.add = function(out2, a, b) {
  vec3$g.add(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector3.set = function(out2, x, y, z) {
  vec3$g.set(out2.array, x, y, z);
  out2._dirty = true;
};
Vector3.copy = function(out2, b) {
  vec3$g.copy(out2.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector3.cross = function(out2, a, b) {
  vec3$g.cross(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector3.dist = function(a, b) {
  return vec3$g.distance(a.array, b.array);
};
Vector3.distance = Vector3.dist;
Vector3.div = function(out2, a, b) {
  vec3$g.divide(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector3.divide = Vector3.div;
Vector3.dot = function(a, b) {
  return vec3$g.dot(a.array, b.array);
};
Vector3.len = function(b) {
  return vec3$g.length(b.array);
};
Vector3.lerp = function(out2, a, b, t) {
  vec3$g.lerp(out2.array, a.array, b.array, t);
  out2._dirty = true;
  return out2;
};
Vector3.min = function(out2, a, b) {
  vec3$g.min(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector3.max = function(out2, a, b) {
  vec3$g.max(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector3.mul = function(out2, a, b) {
  vec3$g.multiply(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector3.multiply = Vector3.mul;
Vector3.negate = function(out2, a) {
  vec3$g.negate(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Vector3.normalize = function(out2, a) {
  vec3$g.normalize(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Vector3.random = function(out2, scale2) {
  vec3$g.random(out2.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector3.scale = function(out2, a, scale2) {
  vec3$g.scale(out2.array, a.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector3.scaleAndAdd = function(out2, a, b, scale2) {
  vec3$g.scaleAndAdd(out2.array, a.array, b.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector3.sqrDist = function(a, b) {
  return vec3$g.sqrDist(a.array, b.array);
};
Vector3.squaredDistance = Vector3.sqrDist;
Vector3.sqrLen = function(a) {
  return vec3$g.sqrLen(a.array);
};
Vector3.squaredLength = Vector3.sqrLen;
Vector3.sub = function(out2, a, b) {
  vec3$g.subtract(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector3.subtract = Vector3.sub;
Vector3.transformMat3 = function(out2, a, m2) {
  vec3$g.transformMat3(out2.array, a.array, m2.array);
  out2._dirty = true;
  return out2;
};
Vector3.transformMat4 = function(out2, a, m2) {
  vec3$g.transformMat4(out2.array, a.array, m2.array);
  out2._dirty = true;
  return out2;
};
Vector3.transformQuat = function(out2, a, q) {
  vec3$g.transformQuat(out2.array, a.array, q.array);
  out2._dirty = true;
  return out2;
};
function clamp(val, min3, max3) {
  return val < min3 ? min3 : val > max3 ? max3 : val;
}
var atan2 = Math.atan2;
var asin$1 = Math.asin;
var abs = Math.abs;
Vector3.eulerFromQuat = function(out2, q, order) {
  out2._dirty = true;
  q = q.array;
  var target = out2.array;
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x * x;
  var y2 = y * y;
  var z2 = z * z;
  var w2 = w * w;
  var order = (order || "XYZ").toUpperCase();
  switch (order) {
    case "XYZ":
      target[0] = atan2(2 * (x * w - y * z), w2 - x2 - y2 + z2);
      target[1] = asin$1(clamp(2 * (x * z + y * w), -1, 1));
      target[2] = atan2(2 * (z * w - x * y), w2 + x2 - y2 - z2);
      break;
    case "YXZ":
      target[0] = asin$1(clamp(2 * (x * w - y * z), -1, 1));
      target[1] = atan2(2 * (x * z + y * w), w2 - x2 - y2 + z2);
      target[2] = atan2(2 * (x * y + z * w), w2 - x2 + y2 - z2);
      break;
    case "ZXY":
      target[0] = asin$1(clamp(2 * (x * w + y * z), -1, 1));
      target[1] = atan2(2 * (y * w - z * x), w2 - x2 - y2 + z2);
      target[2] = atan2(2 * (z * w - x * y), w2 - x2 + y2 - z2);
      break;
    case "ZYX":
      target[0] = atan2(2 * (x * w + z * y), w2 - x2 - y2 + z2);
      target[1] = asin$1(clamp(2 * (y * w - x * z), -1, 1));
      target[2] = atan2(2 * (x * y + z * w), w2 + x2 - y2 - z2);
      break;
    case "YZX":
      target[0] = atan2(2 * (x * w - z * y), w2 - x2 + y2 - z2);
      target[1] = atan2(2 * (y * w - x * z), w2 + x2 - y2 - z2);
      target[2] = asin$1(clamp(2 * (x * y + z * w), -1, 1));
      break;
    case "XZY":
      target[0] = atan2(2 * (x * w + y * z), w2 - x2 + y2 - z2);
      target[1] = atan2(2 * (x * z + y * w), w2 + x2 - y2 - z2);
      target[2] = asin$1(clamp(2 * (z * w - x * y), -1, 1));
      break;
    default:
      console.warn("Unkown order: " + order);
  }
  return out2;
};
Vector3.eulerFromMat3 = function(out2, m2, order) {
  var te = m2.array;
  var m11 = te[0], m12 = te[3], m13 = te[6];
  var m21 = te[1], m22 = te[4], m23 = te[7];
  var m31 = te[2], m32 = te[5], m33 = te[8];
  var target = out2.array;
  var order = (order || "XYZ").toUpperCase();
  switch (order) {
    case "XYZ":
      target[1] = asin$1(clamp(m13, -1, 1));
      if (abs(m13) < 0.99999) {
        target[0] = atan2(-m23, m33);
        target[2] = atan2(-m12, m11);
      } else {
        target[0] = atan2(m32, m22);
        target[2] = 0;
      }
      break;
    case "YXZ":
      target[0] = asin$1(-clamp(m23, -1, 1));
      if (abs(m23) < 0.99999) {
        target[1] = atan2(m13, m33);
        target[2] = atan2(m21, m22);
      } else {
        target[1] = atan2(-m31, m11);
        target[2] = 0;
      }
      break;
    case "ZXY":
      target[0] = asin$1(clamp(m32, -1, 1));
      if (abs(m32) < 0.99999) {
        target[1] = atan2(-m31, m33);
        target[2] = atan2(-m12, m22);
      } else {
        target[1] = 0;
        target[2] = atan2(m21, m11);
      }
      break;
    case "ZYX":
      target[1] = asin$1(-clamp(m31, -1, 1));
      if (abs(m31) < 0.99999) {
        target[0] = atan2(m32, m33);
        target[2] = atan2(m21, m11);
      } else {
        target[0] = 0;
        target[2] = atan2(-m12, m22);
      }
      break;
    case "YZX":
      target[2] = asin$1(clamp(m21, -1, 1));
      if (abs(m21) < 0.99999) {
        target[0] = atan2(-m23, m22);
        target[1] = atan2(-m31, m11);
      } else {
        target[0] = 0;
        target[1] = atan2(m13, m33);
      }
      break;
    case "XZY":
      target[2] = asin$1(-clamp(m12, -1, 1));
      if (abs(m12) < 0.99999) {
        target[0] = atan2(m32, m22);
        target[1] = atan2(m13, m11);
      } else {
        target[0] = atan2(-m23, m33);
        target[1] = 0;
      }
      break;
    default:
      console.warn("Unkown order: " + order);
  }
  out2._dirty = true;
  return out2;
};
Object.defineProperties(Vector3, {
  POSITIVE_X: {
    get: function() {
      return new Vector3(1, 0, 0);
    }
  },
  NEGATIVE_X: {
    get: function() {
      return new Vector3(-1, 0, 0);
    }
  },
  POSITIVE_Y: {
    get: function() {
      return new Vector3(0, 1, 0);
    }
  },
  NEGATIVE_Y: {
    get: function() {
      return new Vector3(0, -1, 0);
    }
  },
  POSITIVE_Z: {
    get: function() {
      return new Vector3(0, 0, 1);
    }
  },
  NEGATIVE_Z: {
    get: function() {
      return new Vector3(0, 0, -1);
    }
  },
  UP: {
    get: function() {
      return new Vector3(0, 1, 0);
    }
  },
  ZERO: {
    get: function() {
      return new Vector3();
    }
  }
});
var Vector3$1 = Vector3;
var EPSILON = 1e-5;
var Ray = function(origin, direction) {
  this.origin = origin || new Vector3$1();
  this.direction = direction || new Vector3$1();
};
Ray.prototype = {
  constructor: Ray,
  intersectPlane: function(plane, out2) {
    var pn = plane.normal.array;
    var d = plane.distance;
    var ro = this.origin.array;
    var rd = this.direction.array;
    var divider = vec3$g.dot(pn, rd);
    if (divider === 0) {
      return null;
    }
    if (!out2) {
      out2 = new Vector3$1();
    }
    var t = (vec3$g.dot(pn, ro) - d) / divider;
    vec3$g.scaleAndAdd(out2.array, ro, rd, -t);
    out2._dirty = true;
    return out2;
  },
  mirrorAgainstPlane: function(plane) {
    var d = vec3$g.dot(plane.normal.array, this.direction.array);
    vec3$g.scaleAndAdd(this.direction.array, this.direction.array, plane.normal.array, -d * 2);
    this.direction._dirty = true;
  },
  distanceToPoint: function() {
    var v = vec3$g.create();
    return function(point) {
      vec3$g.sub(v, point, this.origin.array);
      var b = vec3$g.dot(v, this.direction.array);
      if (b < 0) {
        return vec3$g.distance(this.origin.array, point);
      }
      var c2 = vec3$g.lenSquared(v);
      return Math.sqrt(c2 - b * b);
    };
  }(),
  intersectSphere: function() {
    var v = vec3$g.create();
    return function(center2, radius, out2) {
      var origin = this.origin.array;
      var direction = this.direction.array;
      center2 = center2.array;
      vec3$g.sub(v, center2, origin);
      var b = vec3$g.dot(v, direction);
      var c2 = vec3$g.squaredLength(v);
      var d2 = c2 - b * b;
      var r2 = radius * radius;
      if (d2 > r2) {
        return;
      }
      var a = Math.sqrt(r2 - d2);
      var t0 = b - a;
      var t1 = b + a;
      if (!out2) {
        out2 = new Vector3$1();
      }
      if (t0 < 0) {
        if (t1 < 0) {
          return null;
        } else {
          vec3$g.scaleAndAdd(out2.array, origin, direction, t1);
          return out2;
        }
      } else {
        vec3$g.scaleAndAdd(out2.array, origin, direction, t0);
        return out2;
      }
    };
  }(),
  intersectBoundingBox: function(bbox, out2) {
    var dir3 = this.direction.array;
    var origin = this.origin.array;
    var min3 = bbox.min.array;
    var max3 = bbox.max.array;
    var invdirx = 1 / dir3[0];
    var invdiry = 1 / dir3[1];
    var invdirz = 1 / dir3[2];
    var tmin, tmax, tymin, tymax, tzmin, tzmax;
    if (invdirx >= 0) {
      tmin = (min3[0] - origin[0]) * invdirx;
      tmax = (max3[0] - origin[0]) * invdirx;
    } else {
      tmax = (min3[0] - origin[0]) * invdirx;
      tmin = (max3[0] - origin[0]) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (min3[1] - origin[1]) * invdiry;
      tymax = (max3[1] - origin[1]) * invdiry;
    } else {
      tymax = (min3[1] - origin[1]) * invdiry;
      tymin = (max3[1] - origin[1]) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) {
      return null;
    }
    if (tymin > tmin || tmin !== tmin) {
      tmin = tymin;
    }
    if (tymax < tmax || tmax !== tmax) {
      tmax = tymax;
    }
    if (invdirz >= 0) {
      tzmin = (min3[2] - origin[2]) * invdirz;
      tzmax = (max3[2] - origin[2]) * invdirz;
    } else {
      tzmax = (min3[2] - origin[2]) * invdirz;
      tzmin = (max3[2] - origin[2]) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) {
      return null;
    }
    if (tzmin > tmin || tmin !== tmin) {
      tmin = tzmin;
    }
    if (tzmax < tmax || tmax !== tmax) {
      tmax = tzmax;
    }
    if (tmax < 0) {
      return null;
    }
    var t = tmin >= 0 ? tmin : tmax;
    if (!out2) {
      out2 = new Vector3$1();
    }
    vec3$g.scaleAndAdd(out2.array, origin, dir3, t);
    return out2;
  },
  intersectTriangle: function() {
    var eBA = vec3$g.create();
    var eCA = vec3$g.create();
    var AO = vec3$g.create();
    var vCross = vec3$g.create();
    return function(a, b, c, singleSided, out2, barycenteric) {
      var dir3 = this.direction.array;
      var origin = this.origin.array;
      a = a.array;
      b = b.array;
      c = c.array;
      vec3$g.sub(eBA, b, a);
      vec3$g.sub(eCA, c, a);
      vec3$g.cross(vCross, eCA, dir3);
      var det = vec3$g.dot(eBA, vCross);
      if (singleSided) {
        if (det > -EPSILON) {
          return null;
        }
      } else {
        if (det > -EPSILON && det < EPSILON) {
          return null;
        }
      }
      vec3$g.sub(AO, origin, a);
      var u = vec3$g.dot(vCross, AO) / det;
      if (u < 0 || u > 1) {
        return null;
      }
      vec3$g.cross(vCross, eBA, AO);
      var v = vec3$g.dot(dir3, vCross) / det;
      if (v < 0 || v > 1 || u + v > 1) {
        return null;
      }
      vec3$g.cross(vCross, eBA, eCA);
      var t = -vec3$g.dot(AO, vCross) / det;
      if (t < 0) {
        return null;
      }
      if (!out2) {
        out2 = new Vector3$1();
      }
      if (barycenteric) {
        Vector3$1.set(barycenteric, 1 - u - v, u, v);
      }
      vec3$g.scaleAndAdd(out2.array, origin, dir3, t);
      return out2;
    };
  }(),
  applyTransform: function(matrix) {
    Vector3$1.add(this.direction, this.direction, this.origin);
    Vector3$1.transformMat4(this.origin, this.origin, matrix);
    Vector3$1.transformMat4(this.direction, this.direction, matrix);
    Vector3$1.sub(this.direction, this.direction, this.origin);
    Vector3$1.normalize(this.direction, this.direction);
  },
  copy: function(ray) {
    Vector3$1.copy(this.origin, ray.origin);
    Vector3$1.copy(this.direction, ray.direction);
  },
  clone: function() {
    var ray = new Ray();
    ray.copy(this);
    return ray;
  }
};
var Ray$1 = Ray;
var vec4$1 = {};
vec4$1.create = function() {
  var out2 = new GLMAT_ARRAY_TYPE(4);
  out2[0] = 0;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  return out2;
};
vec4$1.clone = function(a) {
  var out2 = new GLMAT_ARRAY_TYPE(4);
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
};
vec4$1.fromValues = function(x, y, z, w) {
  var out2 = new GLMAT_ARRAY_TYPE(4);
  out2[0] = x;
  out2[1] = y;
  out2[2] = z;
  out2[3] = w;
  return out2;
};
vec4$1.copy = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
};
vec4$1.set = function(out2, x, y, z, w) {
  out2[0] = x;
  out2[1] = y;
  out2[2] = z;
  out2[3] = w;
  return out2;
};
vec4$1.add = function(out2, a, b) {
  out2[0] = a[0] + b[0];
  out2[1] = a[1] + b[1];
  out2[2] = a[2] + b[2];
  out2[3] = a[3] + b[3];
  return out2;
};
vec4$1.subtract = function(out2, a, b) {
  out2[0] = a[0] - b[0];
  out2[1] = a[1] - b[1];
  out2[2] = a[2] - b[2];
  out2[3] = a[3] - b[3];
  return out2;
};
vec4$1.sub = vec4$1.subtract;
vec4$1.multiply = function(out2, a, b) {
  out2[0] = a[0] * b[0];
  out2[1] = a[1] * b[1];
  out2[2] = a[2] * b[2];
  out2[3] = a[3] * b[3];
  return out2;
};
vec4$1.mul = vec4$1.multiply;
vec4$1.divide = function(out2, a, b) {
  out2[0] = a[0] / b[0];
  out2[1] = a[1] / b[1];
  out2[2] = a[2] / b[2];
  out2[3] = a[3] / b[3];
  return out2;
};
vec4$1.div = vec4$1.divide;
vec4$1.min = function(out2, a, b) {
  out2[0] = Math.min(a[0], b[0]);
  out2[1] = Math.min(a[1], b[1]);
  out2[2] = Math.min(a[2], b[2]);
  out2[3] = Math.min(a[3], b[3]);
  return out2;
};
vec4$1.max = function(out2, a, b) {
  out2[0] = Math.max(a[0], b[0]);
  out2[1] = Math.max(a[1], b[1]);
  out2[2] = Math.max(a[2], b[2]);
  out2[3] = Math.max(a[3], b[3]);
  return out2;
};
vec4$1.scale = function(out2, a, b) {
  out2[0] = a[0] * b;
  out2[1] = a[1] * b;
  out2[2] = a[2] * b;
  out2[3] = a[3] * b;
  return out2;
};
vec4$1.scaleAndAdd = function(out2, a, b, scale2) {
  out2[0] = a[0] + b[0] * scale2;
  out2[1] = a[1] + b[1] * scale2;
  out2[2] = a[2] + b[2] * scale2;
  out2[3] = a[3] + b[3] * scale2;
  return out2;
};
vec4$1.distance = function(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2], w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
};
vec4$1.dist = vec4$1.distance;
vec4$1.squaredDistance = function(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2], w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
};
vec4$1.sqrDist = vec4$1.squaredDistance;
vec4$1.length = function(a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
};
vec4$1.len = vec4$1.length;
vec4$1.squaredLength = function(a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  return x * x + y * y + z * z + w * w;
};
vec4$1.sqrLen = vec4$1.squaredLength;
vec4$1.negate = function(out2, a) {
  out2[0] = -a[0];
  out2[1] = -a[1];
  out2[2] = -a[2];
  out2[3] = -a[3];
  return out2;
};
vec4$1.inverse = function(out2, a) {
  out2[0] = 1 / a[0];
  out2[1] = 1 / a[1];
  out2[2] = 1 / a[2];
  out2[3] = 1 / a[3];
  return out2;
};
vec4$1.normalize = function(out2, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
    out2[0] = a[0] * len2;
    out2[1] = a[1] * len2;
    out2[2] = a[2] * len2;
    out2[3] = a[3] * len2;
  }
  return out2;
};
vec4$1.dot = function(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};
vec4$1.lerp = function(out2, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  out2[0] = ax + t * (b[0] - ax);
  out2[1] = ay + t * (b[1] - ay);
  out2[2] = az + t * (b[2] - az);
  out2[3] = aw + t * (b[3] - aw);
  return out2;
};
vec4$1.random = function(out2, scale2) {
  scale2 = scale2 || 1;
  out2[0] = GLMAT_RANDOM$1();
  out2[1] = GLMAT_RANDOM$1();
  out2[2] = GLMAT_RANDOM$1();
  out2[3] = GLMAT_RANDOM$1();
  vec4$1.normalize(out2, out2);
  vec4$1.scale(out2, out2, scale2);
  return out2;
};
vec4$1.transformMat4 = function(out2, a, m2) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out2[0] = m2[0] * x + m2[4] * y + m2[8] * z + m2[12] * w;
  out2[1] = m2[1] * x + m2[5] * y + m2[9] * z + m2[13] * w;
  out2[2] = m2[2] * x + m2[6] * y + m2[10] * z + m2[14] * w;
  out2[3] = m2[3] * x + m2[7] * y + m2[11] * z + m2[15] * w;
  return out2;
};
vec4$1.transformQuat = function(out2, a, q) {
  var x = a[0], y = a[1], z = a[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
  out2[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out2[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out2[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out2;
};
vec4$1.forEach = function() {
  var vec = vec4$1.create();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();
var vec4$2 = vec4$1;
var mat3$1 = {};
mat3$1.create = function() {
  var out2 = new GLMAT_ARRAY_TYPE(9);
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  out2[4] = 1;
  out2[5] = 0;
  out2[6] = 0;
  out2[7] = 0;
  out2[8] = 1;
  return out2;
};
mat3$1.fromMat4 = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[4];
  out2[4] = a[5];
  out2[5] = a[6];
  out2[6] = a[8];
  out2[7] = a[9];
  out2[8] = a[10];
  return out2;
};
mat3$1.clone = function(a) {
  var out2 = new GLMAT_ARRAY_TYPE(9);
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4];
  out2[5] = a[5];
  out2[6] = a[6];
  out2[7] = a[7];
  out2[8] = a[8];
  return out2;
};
mat3$1.copy = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4];
  out2[5] = a[5];
  out2[6] = a[6];
  out2[7] = a[7];
  out2[8] = a[8];
  return out2;
};
mat3$1.identity = function(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 0;
  out2[4] = 1;
  out2[5] = 0;
  out2[6] = 0;
  out2[7] = 0;
  out2[8] = 1;
  return out2;
};
mat3$1.transpose = function(out2, a) {
  if (out2 === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out2[1] = a[3];
    out2[2] = a[6];
    out2[3] = a01;
    out2[5] = a[7];
    out2[6] = a02;
    out2[7] = a12;
  } else {
    out2[0] = a[0];
    out2[1] = a[3];
    out2[2] = a[6];
    out2[3] = a[1];
    out2[4] = a[4];
    out2[5] = a[7];
    out2[6] = a[2];
    out2[7] = a[5];
    out2[8] = a[8];
  }
  return out2;
};
mat3$1.invert = function(out2, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], b01 = a22 * a11 - a12 * a21, b11 = -a22 * a10 + a12 * a20, b21 = a21 * a10 - a11 * a20, det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = b01 * det;
  out2[1] = (-a22 * a01 + a02 * a21) * det;
  out2[2] = (a12 * a01 - a02 * a11) * det;
  out2[3] = b11 * det;
  out2[4] = (a22 * a00 - a02 * a20) * det;
  out2[5] = (-a12 * a00 + a02 * a10) * det;
  out2[6] = b21 * det;
  out2[7] = (-a21 * a00 + a01 * a20) * det;
  out2[8] = (a11 * a00 - a01 * a10) * det;
  return out2;
};
mat3$1.adjoint = function(out2, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
  out2[0] = a11 * a22 - a12 * a21;
  out2[1] = a02 * a21 - a01 * a22;
  out2[2] = a01 * a12 - a02 * a11;
  out2[3] = a12 * a20 - a10 * a22;
  out2[4] = a00 * a22 - a02 * a20;
  out2[5] = a02 * a10 - a00 * a12;
  out2[6] = a10 * a21 - a11 * a20;
  out2[7] = a01 * a20 - a00 * a21;
  out2[8] = a00 * a11 - a01 * a10;
  return out2;
};
mat3$1.determinant = function(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};
mat3$1.multiply = function(out2, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
  out2[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out2[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out2[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out2[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out2[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out2[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out2[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out2[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out2[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out2;
};
mat3$1.mul = mat3$1.multiply;
mat3$1.translate = function(out2, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out2[0] = a00;
  out2[1] = a01;
  out2[2] = a02;
  out2[3] = a10;
  out2[4] = a11;
  out2[5] = a12;
  out2[6] = x * a00 + y * a10 + a20;
  out2[7] = x * a01 + y * a11 + a21;
  out2[8] = x * a02 + y * a12 + a22;
  return out2;
};
mat3$1.rotate = function(out2, a, rad2) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad2), c = Math.cos(rad2);
  out2[0] = c * a00 + s * a10;
  out2[1] = c * a01 + s * a11;
  out2[2] = c * a02 + s * a12;
  out2[3] = c * a10 - s * a00;
  out2[4] = c * a11 - s * a01;
  out2[5] = c * a12 - s * a02;
  out2[6] = a20;
  out2[7] = a21;
  out2[8] = a22;
  return out2;
};
mat3$1.scale = function(out2, a, v) {
  var x = v[0], y = v[1];
  out2[0] = x * a[0];
  out2[1] = x * a[1];
  out2[2] = x * a[2];
  out2[3] = y * a[3];
  out2[4] = y * a[4];
  out2[5] = y * a[5];
  out2[6] = a[6];
  out2[7] = a[7];
  out2[8] = a[8];
  return out2;
};
mat3$1.fromMat2d = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = 0;
  out2[3] = a[2];
  out2[4] = a[3];
  out2[5] = 0;
  out2[6] = a[4];
  out2[7] = a[5];
  out2[8] = 1;
  return out2;
};
mat3$1.fromQuat = function(out2, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx2 = w * x2, wy = w * y2, wz = w * z2;
  out2[0] = 1 - yy - zz;
  out2[3] = yx - wz;
  out2[6] = zx + wy;
  out2[1] = yx + wz;
  out2[4] = 1 - xx - zz;
  out2[7] = zy - wx2;
  out2[2] = zx - wy;
  out2[5] = zy + wx2;
  out2[8] = 1 - xx - yy;
  return out2;
};
mat3$1.normalFromMat4 = function(out2, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out2[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out2[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out2[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out2[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out2[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out2[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out2[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out2[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out2;
};
mat3$1.frob = function(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
};
var mat3$2 = mat3$1;
var quat = {};
quat.create = function() {
  var out2 = new GLMAT_ARRAY_TYPE(4);
  out2[0] = 0;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  return out2;
};
quat.rotationTo = function() {
  var tmpvec3 = vec3$g.create();
  var xUnitVec3 = vec3$g.fromValues(1, 0, 0);
  var yUnitVec3 = vec3$g.fromValues(0, 1, 0);
  return function(out2, a, b) {
    var dot = vec3$g.dot(a, b);
    if (dot < -0.999999) {
      vec3$g.cross(tmpvec3, xUnitVec3, a);
      if (vec3$g.length(tmpvec3) < 1e-6)
        vec3$g.cross(tmpvec3, yUnitVec3, a);
      vec3$g.normalize(tmpvec3, tmpvec3);
      quat.setAxisAngle(out2, tmpvec3, Math.PI);
      return out2;
    } else if (dot > 0.999999) {
      out2[0] = 0;
      out2[1] = 0;
      out2[2] = 0;
      out2[3] = 1;
      return out2;
    } else {
      vec3$g.cross(tmpvec3, a, b);
      out2[0] = tmpvec3[0];
      out2[1] = tmpvec3[1];
      out2[2] = tmpvec3[2];
      out2[3] = 1 + dot;
      return quat.normalize(out2, out2);
    }
  };
}();
quat.setAxes = function() {
  var matr = mat3$2.create();
  return function(out2, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return quat.normalize(out2, quat.fromMat3(out2, matr));
  };
}();
quat.clone = vec4$2.clone;
quat.fromValues = vec4$2.fromValues;
quat.copy = vec4$2.copy;
quat.set = vec4$2.set;
quat.identity = function(out2) {
  out2[0] = 0;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  return out2;
};
quat.setAxisAngle = function(out2, axis, rad2) {
  rad2 = rad2 * 0.5;
  var s = Math.sin(rad2);
  out2[0] = s * axis[0];
  out2[1] = s * axis[1];
  out2[2] = s * axis[2];
  out2[3] = Math.cos(rad2);
  return out2;
};
quat.add = vec4$2.add;
quat.multiply = function(out2, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out2[0] = ax * bw + aw * bx + ay * bz - az * by;
  out2[1] = ay * bw + aw * by + az * bx - ax * bz;
  out2[2] = az * bw + aw * bz + ax * by - ay * bx;
  out2[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out2;
};
quat.mul = quat.multiply;
quat.scale = vec4$2.scale;
quat.rotateX = function(out2, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = Math.sin(rad2), bw = Math.cos(rad2);
  out2[0] = ax * bw + aw * bx;
  out2[1] = ay * bw + az * bx;
  out2[2] = az * bw - ay * bx;
  out2[3] = aw * bw - ax * bx;
  return out2;
};
quat.rotateY = function(out2, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3], by = Math.sin(rad2), bw = Math.cos(rad2);
  out2[0] = ax * bw - az * by;
  out2[1] = ay * bw + aw * by;
  out2[2] = az * bw + ax * by;
  out2[3] = aw * bw - ay * by;
  return out2;
};
quat.rotateZ = function(out2, a, rad2) {
  rad2 *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3], bz = Math.sin(rad2), bw = Math.cos(rad2);
  out2[0] = ax * bw + ay * bz;
  out2[1] = ay * bw - ax * bz;
  out2[2] = az * bw + aw * bz;
  out2[3] = aw * bw - az * bz;
  return out2;
};
quat.calculateW = function(out2, a) {
  var x = a[0], y = a[1], z = a[2];
  out2[0] = x;
  out2[1] = y;
  out2[2] = z;
  out2[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out2;
};
quat.dot = vec4$2.dot;
quat.lerp = vec4$2.lerp;
quat.slerp = function(out2, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > 1e-6) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out2[0] = scale0 * ax + scale1 * bx;
  out2[1] = scale0 * ay + scale1 * by;
  out2[2] = scale0 * az + scale1 * bz;
  out2[3] = scale0 * aw + scale1 * bw;
  return out2;
};
quat.invert = function(out2, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3, invDot = dot ? 1 / dot : 0;
  out2[0] = -a0 * invDot;
  out2[1] = -a1 * invDot;
  out2[2] = -a2 * invDot;
  out2[3] = a3 * invDot;
  return out2;
};
quat.conjugate = function(out2, a) {
  out2[0] = -a[0];
  out2[1] = -a[1];
  out2[2] = -a[2];
  out2[3] = a[3];
  return out2;
};
quat.length = vec4$2.length;
quat.len = quat.length;
quat.squaredLength = vec4$2.squaredLength;
quat.sqrLen = quat.squaredLength;
quat.normalize = vec4$2.normalize;
quat.fromMat3 = function(out2, m2) {
  var fTrace = m2[0] + m2[4] + m2[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out2[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out2[0] = (m2[5] - m2[7]) * fRoot;
    out2[1] = (m2[6] - m2[2]) * fRoot;
    out2[2] = (m2[1] - m2[3]) * fRoot;
  } else {
    var i = 0;
    if (m2[4] > m2[0])
      i = 1;
    if (m2[8] > m2[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m2[i * 3 + i] - m2[j * 3 + j] - m2[k * 3 + k] + 1);
    out2[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out2[3] = (m2[j * 3 + k] - m2[k * 3 + j]) * fRoot;
    out2[j] = (m2[j * 3 + i] + m2[i * 3 + j]) * fRoot;
    out2[k] = (m2[k * 3 + i] + m2[i * 3 + k]) * fRoot;
  }
  return out2;
};
var quat$1 = quat;
var Matrix4 = function() {
  this._axisX = new Vector3$1();
  this._axisY = new Vector3$1();
  this._axisZ = new Vector3$1();
  this.array = mat4$3.create();
  this._dirty = true;
};
Matrix4.prototype = {
  constructor: Matrix4,
  setArray: function(arr) {
    for (var i = 0; i < this.array.length; i++) {
      this.array[i] = arr[i];
    }
    this._dirty = true;
    return this;
  },
  adjoint: function() {
    mat4$3.adjoint(this.array, this.array);
    this._dirty = true;
    return this;
  },
  clone: function() {
    return new Matrix4().copy(this);
  },
  copy: function(a) {
    mat4$3.copy(this.array, a.array);
    this._dirty = true;
    return this;
  },
  determinant: function() {
    return mat4$3.determinant(this.array);
  },
  fromQuat: function(q) {
    mat4$3.fromQuat(this.array, q.array);
    this._dirty = true;
    return this;
  },
  fromRotationTranslation: function(q, v) {
    mat4$3.fromRotationTranslation(this.array, q.array, v.array);
    this._dirty = true;
    return this;
  },
  fromMat2d: function(m2d) {
    Matrix4.fromMat2d(this, m2d);
    return this;
  },
  frustum: function(left, right, bottom, top, near, far) {
    mat4$3.frustum(this.array, left, right, bottom, top, near, far);
    this._dirty = true;
    return this;
  },
  identity: function() {
    mat4$3.identity(this.array);
    this._dirty = true;
    return this;
  },
  invert: function() {
    mat4$3.invert(this.array, this.array);
    this._dirty = true;
    return this;
  },
  lookAt: function(eye, center2, up) {
    mat4$3.lookAt(this.array, eye.array, center2.array, up.array);
    this._dirty = true;
    return this;
  },
  mul: function(b) {
    mat4$3.mul(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  mulLeft: function(a) {
    mat4$3.mul(this.array, a.array, this.array);
    this._dirty = true;
    return this;
  },
  multiply: function(b) {
    mat4$3.multiply(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  multiplyLeft: function(a) {
    mat4$3.multiply(this.array, a.array, this.array);
    this._dirty = true;
    return this;
  },
  ortho: function(left, right, bottom, top, near, far) {
    mat4$3.ortho(this.array, left, right, bottom, top, near, far);
    this._dirty = true;
    return this;
  },
  perspective: function(fovy, aspect, near, far) {
    mat4$3.perspective(this.array, fovy, aspect, near, far);
    this._dirty = true;
    return this;
  },
  rotate: function(rad2, axis) {
    mat4$3.rotate(this.array, this.array, rad2, axis.array);
    this._dirty = true;
    return this;
  },
  rotateX: function(rad2) {
    mat4$3.rotateX(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  rotateY: function(rad2) {
    mat4$3.rotateY(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  rotateZ: function(rad2) {
    mat4$3.rotateZ(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  scale: function(v) {
    mat4$3.scale(this.array, this.array, v.array);
    this._dirty = true;
    return this;
  },
  translate: function(v) {
    mat4$3.translate(this.array, this.array, v.array);
    this._dirty = true;
    return this;
  },
  transpose: function() {
    mat4$3.transpose(this.array, this.array);
    this._dirty = true;
    return this;
  },
  decomposeMatrix: function() {
    var x = vec3$g.create();
    var y = vec3$g.create();
    var z = vec3$g.create();
    var m3 = mat3$2.create();
    return function(scale2, rotation, position2) {
      var el = this.array;
      vec3$g.set(x, el[0], el[1], el[2]);
      vec3$g.set(y, el[4], el[5], el[6]);
      vec3$g.set(z, el[8], el[9], el[10]);
      var sx = vec3$g.length(x);
      var sy = vec3$g.length(y);
      var sz = vec3$g.length(z);
      var det = this.determinant();
      if (det < 0) {
        sx = -sx;
      }
      if (scale2) {
        scale2.set(sx, sy, sz);
      }
      position2.set(el[12], el[13], el[14]);
      mat3$2.fromMat4(m3, el);
      m3[0] /= sx;
      m3[1] /= sx;
      m3[2] /= sx;
      m3[3] /= sy;
      m3[4] /= sy;
      m3[5] /= sy;
      m3[6] /= sz;
      m3[7] /= sz;
      m3[8] /= sz;
      quat$1.fromMat3(rotation.array, m3);
      quat$1.normalize(rotation.array, rotation.array);
      rotation._dirty = true;
      position2._dirty = true;
    };
  }(),
  toString: function() {
    return "[" + Array.prototype.join.call(this.array, ",") + "]";
  },
  toArray: function() {
    return Array.prototype.slice.call(this.array);
  }
};
var defineProperty$2 = Object.defineProperty;
if (defineProperty$2) {
  var proto$2 = Matrix4.prototype;
  defineProperty$2(proto$2, "z", {
    get: function() {
      var el = this.array;
      this._axisZ.set(el[8], el[9], el[10]);
      return this._axisZ;
    },
    set: function(v) {
      var el = this.array;
      v = v.array;
      el[8] = v[0];
      el[9] = v[1];
      el[10] = v[2];
      this._dirty = true;
    }
  });
  defineProperty$2(proto$2, "y", {
    get: function() {
      var el = this.array;
      this._axisY.set(el[4], el[5], el[6]);
      return this._axisY;
    },
    set: function(v) {
      var el = this.array;
      v = v.array;
      el[4] = v[0];
      el[5] = v[1];
      el[6] = v[2];
      this._dirty = true;
    }
  });
  defineProperty$2(proto$2, "x", {
    get: function() {
      var el = this.array;
      this._axisX.set(el[0], el[1], el[2]);
      return this._axisX;
    },
    set: function(v) {
      var el = this.array;
      v = v.array;
      el[0] = v[0];
      el[1] = v[1];
      el[2] = v[2];
      this._dirty = true;
    }
  });
}
Matrix4.adjoint = function(out2, a) {
  mat4$3.adjoint(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix4.copy = function(out2, a) {
  mat4$3.copy(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix4.determinant = function(a) {
  return mat4$3.determinant(a.array);
};
Matrix4.identity = function(out2) {
  mat4$3.identity(out2.array);
  out2._dirty = true;
  return out2;
};
Matrix4.ortho = function(out2, left, right, bottom, top, near, far) {
  mat4$3.ortho(out2.array, left, right, bottom, top, near, far);
  out2._dirty = true;
  return out2;
};
Matrix4.perspective = function(out2, fovy, aspect, near, far) {
  mat4$3.perspective(out2.array, fovy, aspect, near, far);
  out2._dirty = true;
  return out2;
};
Matrix4.lookAt = function(out2, eye, center2, up) {
  mat4$3.lookAt(out2.array, eye.array, center2.array, up.array);
  out2._dirty = true;
  return out2;
};
Matrix4.invert = function(out2, a) {
  mat4$3.invert(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix4.mul = function(out2, a, b) {
  mat4$3.mul(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Matrix4.multiply = Matrix4.mul;
Matrix4.fromQuat = function(out2, q) {
  mat4$3.fromQuat(out2.array, q.array);
  out2._dirty = true;
  return out2;
};
Matrix4.fromRotationTranslation = function(out2, q, v) {
  mat4$3.fromRotationTranslation(out2.array, q.array, v.array);
  out2._dirty = true;
  return out2;
};
Matrix4.fromMat2d = function(m4, m2d) {
  m4._dirty = true;
  var m2d = m2d.array;
  var m4 = m4.array;
  m4[0] = m2d[0];
  m4[4] = m2d[2];
  m4[12] = m2d[4];
  m4[1] = m2d[1];
  m4[5] = m2d[3];
  m4[13] = m2d[5];
  return m4;
};
Matrix4.rotate = function(out2, a, rad2, axis) {
  mat4$3.rotate(out2.array, a.array, rad2, axis.array);
  out2._dirty = true;
  return out2;
};
Matrix4.rotateX = function(out2, a, rad2) {
  mat4$3.rotateX(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Matrix4.rotateY = function(out2, a, rad2) {
  mat4$3.rotateY(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Matrix4.rotateZ = function(out2, a, rad2) {
  mat4$3.rotateZ(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Matrix4.scale = function(out2, a, v) {
  mat4$3.scale(out2.array, a.array, v.array);
  out2._dirty = true;
  return out2;
};
Matrix4.transpose = function(out2, a) {
  mat4$3.transpose(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix4.translate = function(out2, a, v) {
  mat4$3.translate(out2.array, a.array, v.array);
  out2._dirty = true;
  return out2;
};
var Matrix4$1 = Matrix4;
var Quaternion = function(x, y, z, w) {
  x = x || 0;
  y = y || 0;
  z = z || 0;
  w = w === void 0 ? 1 : w;
  this.array = quat$1.fromValues(x, y, z, w);
  this._dirty = true;
};
Quaternion.prototype = {
  constructor: Quaternion,
  add: function(b) {
    quat$1.add(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  calculateW: function() {
    quat$1.calculateW(this.array, this.array);
    this._dirty = true;
    return this;
  },
  set: function(x, y, z, w) {
    this.array[0] = x;
    this.array[1] = y;
    this.array[2] = z;
    this.array[3] = w;
    this._dirty = true;
    return this;
  },
  setArray: function(arr) {
    this.array[0] = arr[0];
    this.array[1] = arr[1];
    this.array[2] = arr[2];
    this.array[3] = arr[3];
    this._dirty = true;
    return this;
  },
  clone: function() {
    return new Quaternion(this.x, this.y, this.z, this.w);
  },
  conjugate: function() {
    quat$1.conjugate(this.array, this.array);
    this._dirty = true;
    return this;
  },
  copy: function(b) {
    quat$1.copy(this.array, b.array);
    this._dirty = true;
    return this;
  },
  dot: function(b) {
    return quat$1.dot(this.array, b.array);
  },
  fromMat3: function(m2) {
    quat$1.fromMat3(this.array, m2.array);
    this._dirty = true;
    return this;
  },
  fromMat4: function() {
    var m3 = mat3$2.create();
    return function(m2) {
      mat3$2.fromMat4(m3, m2.array);
      mat3$2.transpose(m3, m3);
      quat$1.fromMat3(this.array, m3);
      this._dirty = true;
      return this;
    };
  }(),
  identity: function() {
    quat$1.identity(this.array);
    this._dirty = true;
    return this;
  },
  invert: function() {
    quat$1.invert(this.array, this.array);
    this._dirty = true;
    return this;
  },
  len: function() {
    return quat$1.len(this.array);
  },
  length: function() {
    return quat$1.length(this.array);
  },
  lerp: function(a, b, t) {
    quat$1.lerp(this.array, a.array, b.array, t);
    this._dirty = true;
    return this;
  },
  mul: function(b) {
    quat$1.mul(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  mulLeft: function(a) {
    quat$1.multiply(this.array, a.array, this.array);
    this._dirty = true;
    return this;
  },
  multiply: function(b) {
    quat$1.multiply(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  multiplyLeft: function(a) {
    quat$1.multiply(this.array, a.array, this.array);
    this._dirty = true;
    return this;
  },
  normalize: function() {
    quat$1.normalize(this.array, this.array);
    this._dirty = true;
    return this;
  },
  rotateX: function(rad2) {
    quat$1.rotateX(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  rotateY: function(rad2) {
    quat$1.rotateY(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  rotateZ: function(rad2) {
    quat$1.rotateZ(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  rotationTo: function(a, b) {
    quat$1.rotationTo(this.array, a.array, b.array);
    this._dirty = true;
    return this;
  },
  setAxes: function(view, right, up) {
    quat$1.setAxes(this.array, view.array, right.array, up.array);
    this._dirty = true;
    return this;
  },
  setAxisAngle: function(axis, rad2) {
    quat$1.setAxisAngle(this.array, axis.array, rad2);
    this._dirty = true;
    return this;
  },
  slerp: function(a, b, t) {
    quat$1.slerp(this.array, a.array, b.array, t);
    this._dirty = true;
    return this;
  },
  sqrLen: function() {
    return quat$1.sqrLen(this.array);
  },
  squaredLength: function() {
    return quat$1.squaredLength(this.array);
  },
  fromEuler: function(v, order) {
    return Quaternion.fromEuler(this, v, order);
  },
  toString: function() {
    return "[" + Array.prototype.join.call(this.array, ",") + "]";
  },
  toArray: function() {
    return Array.prototype.slice.call(this.array);
  }
};
var defineProperty$1 = Object.defineProperty;
if (defineProperty$1) {
  var proto$1 = Quaternion.prototype;
  defineProperty$1(proto$1, "x", {
    get: function() {
      return this.array[0];
    },
    set: function(value) {
      this.array[0] = value;
      this._dirty = true;
    }
  });
  defineProperty$1(proto$1, "y", {
    get: function() {
      return this.array[1];
    },
    set: function(value) {
      this.array[1] = value;
      this._dirty = true;
    }
  });
  defineProperty$1(proto$1, "z", {
    get: function() {
      return this.array[2];
    },
    set: function(value) {
      this.array[2] = value;
      this._dirty = true;
    }
  });
  defineProperty$1(proto$1, "w", {
    get: function() {
      return this.array[3];
    },
    set: function(value) {
      this.array[3] = value;
      this._dirty = true;
    }
  });
}
Quaternion.add = function(out2, a, b) {
  quat$1.add(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Quaternion.set = function(out2, x, y, z, w) {
  quat$1.set(out2.array, x, y, z, w);
  out2._dirty = true;
};
Quaternion.copy = function(out2, b) {
  quat$1.copy(out2.array, b.array);
  out2._dirty = true;
  return out2;
};
Quaternion.calculateW = function(out2, a) {
  quat$1.calculateW(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Quaternion.conjugate = function(out2, a) {
  quat$1.conjugate(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Quaternion.identity = function(out2) {
  quat$1.identity(out2.array);
  out2._dirty = true;
  return out2;
};
Quaternion.invert = function(out2, a) {
  quat$1.invert(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Quaternion.dot = function(a, b) {
  return quat$1.dot(a.array, b.array);
};
Quaternion.len = function(a) {
  return quat$1.length(a.array);
};
Quaternion.lerp = function(out2, a, b, t) {
  quat$1.lerp(out2.array, a.array, b.array, t);
  out2._dirty = true;
  return out2;
};
Quaternion.slerp = function(out2, a, b, t) {
  quat$1.slerp(out2.array, a.array, b.array, t);
  out2._dirty = true;
  return out2;
};
Quaternion.mul = function(out2, a, b) {
  quat$1.multiply(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Quaternion.multiply = Quaternion.mul;
Quaternion.rotateX = function(out2, a, rad2) {
  quat$1.rotateX(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Quaternion.rotateY = function(out2, a, rad2) {
  quat$1.rotateY(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Quaternion.rotateZ = function(out2, a, rad2) {
  quat$1.rotateZ(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Quaternion.setAxisAngle = function(out2, axis, rad2) {
  quat$1.setAxisAngle(out2.array, axis.array, rad2);
  out2._dirty = true;
  return out2;
};
Quaternion.normalize = function(out2, a) {
  quat$1.normalize(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Quaternion.sqrLen = function(a) {
  return quat$1.sqrLen(a.array);
};
Quaternion.squaredLength = Quaternion.sqrLen;
Quaternion.fromMat3 = function(out2, m2) {
  quat$1.fromMat3(out2.array, m2.array);
  out2._dirty = true;
  return out2;
};
Quaternion.setAxes = function(out2, view, right, up) {
  quat$1.setAxes(out2.array, view.array, right.array, up.array);
  out2._dirty = true;
  return out2;
};
Quaternion.rotationTo = function(out2, a, b) {
  quat$1.rotationTo(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Quaternion.fromEuler = function(out2, v, order) {
  out2._dirty = true;
  v = v.array;
  var target = out2.array;
  var c1 = Math.cos(v[0] / 2);
  var c2 = Math.cos(v[1] / 2);
  var c3 = Math.cos(v[2] / 2);
  var s1 = Math.sin(v[0] / 2);
  var s2 = Math.sin(v[1] / 2);
  var s3 = Math.sin(v[2] / 2);
  var order = (order || "XYZ").toUpperCase();
  switch (order) {
    case "XYZ":
      target[0] = s1 * c2 * c3 + c1 * s2 * s3;
      target[1] = c1 * s2 * c3 - s1 * c2 * s3;
      target[2] = c1 * c2 * s3 + s1 * s2 * c3;
      target[3] = c1 * c2 * c3 - s1 * s2 * s3;
      break;
    case "YXZ":
      target[0] = s1 * c2 * c3 + c1 * s2 * s3;
      target[1] = c1 * s2 * c3 - s1 * c2 * s3;
      target[2] = c1 * c2 * s3 - s1 * s2 * c3;
      target[3] = c1 * c2 * c3 + s1 * s2 * s3;
      break;
    case "ZXY":
      target[0] = s1 * c2 * c3 - c1 * s2 * s3;
      target[1] = c1 * s2 * c3 + s1 * c2 * s3;
      target[2] = c1 * c2 * s3 + s1 * s2 * c3;
      target[3] = c1 * c2 * c3 - s1 * s2 * s3;
      break;
    case "ZYX":
      target[0] = s1 * c2 * c3 - c1 * s2 * s3;
      target[1] = c1 * s2 * c3 + s1 * c2 * s3;
      target[2] = c1 * c2 * s3 - s1 * s2 * c3;
      target[3] = c1 * c2 * c3 + s1 * s2 * s3;
      break;
    case "YZX":
      target[0] = s1 * c2 * c3 + c1 * s2 * s3;
      target[1] = c1 * s2 * c3 + s1 * c2 * s3;
      target[2] = c1 * c2 * s3 - s1 * s2 * c3;
      target[3] = c1 * c2 * c3 - s1 * s2 * s3;
      break;
    case "XZY":
      target[0] = s1 * c2 * c3 - c1 * s2 * s3;
      target[1] = c1 * s2 * c3 - s1 * c2 * s3;
      target[2] = c1 * c2 * s3 + s1 * s2 * c3;
      target[3] = c1 * c2 * c3 + s1 * s2 * s3;
      break;
  }
};
var Quaternion$1 = Quaternion;
var vec3Set$2 = vec3$g.set;
var vec3Copy$1 = vec3$g.copy;
var BoundingBox = function(min3, max3) {
  this.min = min3 || new Vector3$1(Infinity, Infinity, Infinity);
  this.max = max3 || new Vector3$1(-Infinity, -Infinity, -Infinity);
  this.vertices = null;
};
BoundingBox.prototype = {
  constructor: BoundingBox,
  updateFromVertices: function(vertices) {
    if (vertices.length > 0) {
      var min3 = this.min;
      var max3 = this.max;
      var minArr = min3.array;
      var maxArr = max3.array;
      vec3Copy$1(minArr, vertices[0]);
      vec3Copy$1(maxArr, vertices[0]);
      for (var i = 1; i < vertices.length; i++) {
        var vertex = vertices[i];
        if (vertex[0] < minArr[0]) {
          minArr[0] = vertex[0];
        }
        if (vertex[1] < minArr[1]) {
          minArr[1] = vertex[1];
        }
        if (vertex[2] < minArr[2]) {
          minArr[2] = vertex[2];
        }
        if (vertex[0] > maxArr[0]) {
          maxArr[0] = vertex[0];
        }
        if (vertex[1] > maxArr[1]) {
          maxArr[1] = vertex[1];
        }
        if (vertex[2] > maxArr[2]) {
          maxArr[2] = vertex[2];
        }
      }
      min3._dirty = true;
      max3._dirty = true;
    }
  },
  union: function(bbox) {
    var min3 = this.min;
    var max3 = this.max;
    vec3$g.min(min3.array, min3.array, bbox.min.array);
    vec3$g.max(max3.array, max3.array, bbox.max.array);
    min3._dirty = true;
    max3._dirty = true;
    return this;
  },
  intersection: function(bbox) {
    var min3 = this.min;
    var max3 = this.max;
    vec3$g.max(min3.array, min3.array, bbox.min.array);
    vec3$g.min(max3.array, max3.array, bbox.max.array);
    min3._dirty = true;
    max3._dirty = true;
    return this;
  },
  intersectBoundingBox: function(bbox) {
    var _min = this.min.array;
    var _max = this.max.array;
    var _min2 = bbox.min.array;
    var _max2 = bbox.max.array;
    return !(_min[0] > _max2[0] || _min[1] > _max2[1] || _min[2] > _max2[2] || _max[0] < _min2[0] || _max[1] < _min2[1] || _max[2] < _min2[2]);
  },
  containBoundingBox: function(bbox) {
    var _min = this.min.array;
    var _max = this.max.array;
    var _min2 = bbox.min.array;
    var _max2 = bbox.max.array;
    return _min[0] <= _min2[0] && _min[1] <= _min2[1] && _min[2] <= _min2[2] && _max[0] >= _max2[0] && _max[1] >= _max2[1] && _max[2] >= _max2[2];
  },
  containPoint: function(p) {
    var _min = this.min.array;
    var _max = this.max.array;
    var _p = p.array;
    return _min[0] <= _p[0] && _min[1] <= _p[1] && _min[2] <= _p[2] && _max[0] >= _p[0] && _max[1] >= _p[1] && _max[2] >= _p[2];
  },
  isFinite: function() {
    var _min = this.min.array;
    var _max = this.max.array;
    return isFinite(_min[0]) && isFinite(_min[1]) && isFinite(_min[2]) && isFinite(_max[0]) && isFinite(_max[1]) && isFinite(_max[2]);
  },
  applyTransform: function(matrix) {
    this.transformFrom(this, matrix);
  },
  transformFrom: function() {
    var xa = vec3$g.create();
    var xb = vec3$g.create();
    var ya = vec3$g.create();
    var yb = vec3$g.create();
    var za = vec3$g.create();
    var zb = vec3$g.create();
    return function(source, matrix) {
      var min3 = source.min.array;
      var max3 = source.max.array;
      var m2 = matrix.array;
      xa[0] = m2[0] * min3[0];
      xa[1] = m2[1] * min3[0];
      xa[2] = m2[2] * min3[0];
      xb[0] = m2[0] * max3[0];
      xb[1] = m2[1] * max3[0];
      xb[2] = m2[2] * max3[0];
      ya[0] = m2[4] * min3[1];
      ya[1] = m2[5] * min3[1];
      ya[2] = m2[6] * min3[1];
      yb[0] = m2[4] * max3[1];
      yb[1] = m2[5] * max3[1];
      yb[2] = m2[6] * max3[1];
      za[0] = m2[8] * min3[2];
      za[1] = m2[9] * min3[2];
      za[2] = m2[10] * min3[2];
      zb[0] = m2[8] * max3[2];
      zb[1] = m2[9] * max3[2];
      zb[2] = m2[10] * max3[2];
      min3 = this.min.array;
      max3 = this.max.array;
      min3[0] = Math.min(xa[0], xb[0]) + Math.min(ya[0], yb[0]) + Math.min(za[0], zb[0]) + m2[12];
      min3[1] = Math.min(xa[1], xb[1]) + Math.min(ya[1], yb[1]) + Math.min(za[1], zb[1]) + m2[13];
      min3[2] = Math.min(xa[2], xb[2]) + Math.min(ya[2], yb[2]) + Math.min(za[2], zb[2]) + m2[14];
      max3[0] = Math.max(xa[0], xb[0]) + Math.max(ya[0], yb[0]) + Math.max(za[0], zb[0]) + m2[12];
      max3[1] = Math.max(xa[1], xb[1]) + Math.max(ya[1], yb[1]) + Math.max(za[1], zb[1]) + m2[13];
      max3[2] = Math.max(xa[2], xb[2]) + Math.max(ya[2], yb[2]) + Math.max(za[2], zb[2]) + m2[14];
      this.min._dirty = true;
      this.max._dirty = true;
      return this;
    };
  }(),
  applyProjection: function(matrix) {
    var min3 = this.min.array;
    var max3 = this.max.array;
    var m2 = matrix.array;
    var v10 = min3[0];
    var v11 = min3[1];
    var v12 = min3[2];
    var v20 = max3[0];
    var v21 = max3[1];
    var v22 = min3[2];
    var v30 = max3[0];
    var v31 = max3[1];
    var v32 = max3[2];
    if (m2[15] === 1) {
      min3[0] = m2[0] * v10 + m2[12];
      min3[1] = m2[5] * v11 + m2[13];
      max3[2] = m2[10] * v12 + m2[14];
      max3[0] = m2[0] * v30 + m2[12];
      max3[1] = m2[5] * v31 + m2[13];
      min3[2] = m2[10] * v32 + m2[14];
    } else {
      var w = -1 / v12;
      min3[0] = m2[0] * v10 * w;
      min3[1] = m2[5] * v11 * w;
      max3[2] = (m2[10] * v12 + m2[14]) * w;
      w = -1 / v22;
      max3[0] = m2[0] * v20 * w;
      max3[1] = m2[5] * v21 * w;
      w = -1 / v32;
      min3[2] = (m2[10] * v32 + m2[14]) * w;
    }
    this.min._dirty = true;
    this.max._dirty = true;
    return this;
  },
  updateVertices: function() {
    var vertices = this.vertices;
    if (!vertices) {
      vertices = [];
      for (var i = 0; i < 8; i++) {
        vertices[i] = vec3$g.fromValues(0, 0, 0);
      }
      this.vertices = vertices;
    }
    var min3 = this.min.array;
    var max3 = this.max.array;
    vec3Set$2(vertices[0], min3[0], min3[1], min3[2]);
    vec3Set$2(vertices[1], min3[0], max3[1], min3[2]);
    vec3Set$2(vertices[2], max3[0], min3[1], min3[2]);
    vec3Set$2(vertices[3], max3[0], max3[1], min3[2]);
    vec3Set$2(vertices[4], min3[0], min3[1], max3[2]);
    vec3Set$2(vertices[5], min3[0], max3[1], max3[2]);
    vec3Set$2(vertices[6], max3[0], min3[1], max3[2]);
    vec3Set$2(vertices[7], max3[0], max3[1], max3[2]);
    return this;
  },
  copy: function(bbox) {
    var min3 = this.min;
    var max3 = this.max;
    vec3Copy$1(min3.array, bbox.min.array);
    vec3Copy$1(max3.array, bbox.max.array);
    min3._dirty = true;
    max3._dirty = true;
    return this;
  },
  clone: function() {
    var boundingBox = new BoundingBox();
    boundingBox.copy(this);
    return boundingBox;
  }
};
var BoundingBox$1 = BoundingBox;
var nameId = 0;
var Node$1 = Base$1.extend({
  name: "",
  position: null,
  rotation: null,
  scale: null,
  worldTransform: null,
  localTransform: null,
  autoUpdateLocalTransform: true,
  _parent: null,
  _scene: null,
  _needsUpdateWorldTransform: true,
  _inIterating: false,
  __depth: 0
}, function() {
  if (!this.name) {
    this.name = (this.type || "NODE") + "_" + nameId++;
  }
  if (!this.position) {
    this.position = new Vector3$1();
  }
  if (!this.rotation) {
    this.rotation = new Quaternion$1();
  }
  if (!this.scale) {
    this.scale = new Vector3$1(1, 1, 1);
  }
  this.worldTransform = new Matrix4$1();
  this.localTransform = new Matrix4$1();
  this._children = [];
}, {
  target: null,
  invisible: false,
  isSkinnedMesh: function() {
    return false;
  },
  isRenderable: function() {
    return false;
  },
  setName: function(name) {
    var scene = this._scene;
    if (scene) {
      var nodeRepository = scene._nodeRepository;
      delete nodeRepository[this.name];
      nodeRepository[name] = this;
    }
    this.name = name;
  },
  add: function(node) {
    var originalParent = node._parent;
    if (originalParent === this) {
      return;
    }
    if (originalParent) {
      originalParent.remove(node);
    }
    node._parent = this;
    this._children.push(node);
    var scene = this._scene;
    if (scene && scene !== node.scene) {
      node.traverse(this._addSelfToScene, this);
    }
    node._needsUpdateWorldTransform = true;
  },
  remove: function(node) {
    var children = this._children;
    var idx = children.indexOf(node);
    if (idx < 0) {
      return;
    }
    children.splice(idx, 1);
    node._parent = null;
    if (this._scene) {
      node.traverse(this._removeSelfFromScene, this);
    }
  },
  removeAll: function() {
    var children = this._children;
    for (var idx = 0; idx < children.length; idx++) {
      children[idx]._parent = null;
      if (this._scene) {
        children[idx].traverse(this._removeSelfFromScene, this);
      }
    }
    this._children = [];
  },
  getScene: function() {
    return this._scene;
  },
  getParent: function() {
    return this._parent;
  },
  _removeSelfFromScene: function(descendant) {
    descendant._scene.removeFromScene(descendant);
    descendant._scene = null;
  },
  _addSelfToScene: function(descendant) {
    this._scene.addToScene(descendant);
    descendant._scene = this._scene;
  },
  isAncestor: function(node) {
    var parent = node._parent;
    while (parent) {
      if (parent === this) {
        return true;
      }
      parent = parent._parent;
    }
    return false;
  },
  children: function() {
    return this._children.slice();
  },
  childAt: function(idx) {
    return this._children[idx];
  },
  getChildByName: function(name) {
    var children = this._children;
    for (var i = 0; i < children.length; i++) {
      if (children[i].name === name) {
        return children[i];
      }
    }
  },
  getDescendantByName: function(name) {
    var children = this._children;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.name === name) {
        return child;
      } else {
        var res = child.getDescendantByName(name);
        if (res) {
          return res;
        }
      }
    }
  },
  queryNode: function(path) {
    if (!path) {
      return;
    }
    var pathArr = path.split("/");
    var current = this;
    for (var i = 0; i < pathArr.length; i++) {
      var name = pathArr[i];
      if (!name) {
        continue;
      }
      var found = false;
      var children = current._children;
      for (var j = 0; j < children.length; j++) {
        var child = children[j];
        if (child.name === name) {
          current = child;
          found = true;
          break;
        }
      }
      if (!found) {
        return;
      }
    }
    return current;
  },
  getPath: function(rootNode) {
    if (!this._parent) {
      return "/";
    }
    var current = this._parent;
    var path = this.name;
    while (current._parent) {
      path = current.name + "/" + path;
      if (current._parent == rootNode) {
        break;
      }
      current = current._parent;
    }
    if (!current._parent && rootNode) {
      return null;
    }
    return path;
  },
  traverse: function(callback, context) {
    callback.call(context, this);
    var _children = this._children;
    for (var i = 0, len2 = _children.length; i < len2; i++) {
      _children[i].traverse(callback, context);
    }
  },
  eachChild: function(callback, context) {
    var _children = this._children;
    for (var i = 0, len2 = _children.length; i < len2; i++) {
      var child = _children[i];
      callback.call(context, child, i);
    }
  },
  setLocalTransform: function(matrix) {
    mat4$3.copy(this.localTransform.array, matrix.array);
    this.decomposeLocalTransform();
  },
  decomposeLocalTransform: function(keepScale) {
    var scale2 = !keepScale ? this.scale : null;
    this.localTransform.decomposeMatrix(scale2, this.rotation, this.position);
  },
  setWorldTransform: function(matrix) {
    mat4$3.copy(this.worldTransform.array, matrix.array);
    this.decomposeWorldTransform();
  },
  decomposeWorldTransform: function() {
    var tmp = mat4$3.create();
    return function(keepScale) {
      var localTransform = this.localTransform;
      var worldTransform = this.worldTransform;
      if (this._parent) {
        mat4$3.invert(tmp, this._parent.worldTransform.array);
        mat4$3.multiply(localTransform.array, tmp, worldTransform.array);
      } else {
        mat4$3.copy(localTransform.array, worldTransform.array);
      }
      var scale2 = !keepScale ? this.scale : null;
      localTransform.decomposeMatrix(scale2, this.rotation, this.position);
    };
  }(),
  transformNeedsUpdate: function() {
    return this.position._dirty || this.rotation._dirty || this.scale._dirty;
  },
  updateLocalTransform: function() {
    var position2 = this.position;
    var rotation = this.rotation;
    var scale2 = this.scale;
    if (this.transformNeedsUpdate()) {
      var m2 = this.localTransform.array;
      mat4$3.fromRotationTranslation(m2, rotation.array, position2.array);
      mat4$3.scale(m2, m2, scale2.array);
      rotation._dirty = false;
      scale2._dirty = false;
      position2._dirty = false;
      this._needsUpdateWorldTransform = true;
    }
  },
  _updateWorldTransformTopDown: function() {
    var localTransform = this.localTransform.array;
    var worldTransform = this.worldTransform.array;
    if (this._parent) {
      mat4$3.multiplyAffine(worldTransform, this._parent.worldTransform.array, localTransform);
    } else {
      mat4$3.copy(worldTransform, localTransform);
    }
  },
  updateWorldTransform: function() {
    var rootNodeIsDirty = this;
    while (rootNodeIsDirty && rootNodeIsDirty.getParent() && rootNodeIsDirty.getParent().transformNeedsUpdate()) {
      rootNodeIsDirty = rootNodeIsDirty.getParent();
    }
    rootNodeIsDirty.update();
  },
  update: function(forceUpdateWorld) {
    if (this.autoUpdateLocalTransform) {
      this.updateLocalTransform();
    } else {
      forceUpdateWorld = true;
    }
    if (forceUpdateWorld || this._needsUpdateWorldTransform) {
      this._updateWorldTransformTopDown();
      forceUpdateWorld = true;
      this._needsUpdateWorldTransform = false;
    }
    var children = this._children;
    for (var i = 0, len2 = children.length; i < len2; i++) {
      children[i].update(forceUpdateWorld);
    }
  },
  getBoundingBox: function() {
    function defaultFilter(el) {
      return !el.invisible && el.geometry;
    }
    var tmpBBox = new BoundingBox$1();
    var tmpMat4 = new Matrix4$1();
    var invWorldTransform = new Matrix4$1();
    return function(filter2, out2) {
      out2 = out2 || new BoundingBox$1();
      if (this._parent) {
        Matrix4$1.invert(invWorldTransform, this._parent.worldTransform);
      } else {
        Matrix4$1.identity(invWorldTransform);
      }
      this.traverse(function(mesh2) {
        if (mesh2.geometry && mesh2.geometry.boundingBox) {
          tmpBBox.copy(mesh2.geometry.boundingBox);
          Matrix4$1.multiply(tmpMat4, invWorldTransform, mesh2.worldTransform);
          tmpBBox.applyTransform(tmpMat4);
          out2.union(tmpBBox);
        }
      }, this, defaultFilter);
      return out2;
    };
  }(),
  getWorldPosition: function(out2) {
    if (this.transformNeedsUpdate()) {
      this.updateWorldTransform();
    }
    var m2 = this.worldTransform.array;
    if (out2) {
      var arr = out2.array;
      arr[0] = m2[12];
      arr[1] = m2[13];
      arr[2] = m2[14];
      return out2;
    } else {
      return new Vector3$1(m2[12], m2[13], m2[14]);
    }
  },
  clone: function() {
    var node = new this.constructor();
    var children = this._children;
    node.setName(this.name);
    node.position.copy(this.position);
    node.rotation.copy(this.rotation);
    node.scale.copy(this.scale);
    for (var i = 0; i < children.length; i++) {
      node.add(children[i].clone());
    }
    return node;
  },
  rotateAround: function() {
    var v = new Vector3$1();
    var RTMatrix = new Matrix4$1();
    return function(point, axis, angle) {
      v.copy(this.position).subtract(point);
      var localTransform = this.localTransform;
      localTransform.identity();
      localTransform.translate(point);
      localTransform.rotate(angle, axis);
      RTMatrix.fromRotationTranslation(this.rotation, v);
      localTransform.multiply(RTMatrix);
      localTransform.scale(this.scale);
      this.decomposeLocalTransform();
      this._needsUpdateWorldTransform = true;
    };
  }(),
  lookAt: function() {
    var m2 = new Matrix4$1();
    return function(target, up) {
      m2.lookAt(this.position, target, up || this.localTransform.y).invert();
      this.setLocalTransform(m2);
      this.target = target;
    };
  }()
});
var Node3D = Node$1;
var Renderable = Node3D.extend({
  material: null,
  geometry: null,
  mode: glenum.TRIANGLES,
  _renderInfo: null
}, {
  __program: null,
  lightGroup: 0,
  renderOrder: 0,
  culling: true,
  cullFace: glenum.BACK,
  frontFace: glenum.CCW,
  frustumCulling: true,
  receiveShadow: true,
  castShadow: true,
  ignorePicking: false,
  ignorePreZ: false,
  ignoreGBuffer: false,
  isRenderable: function() {
    return this.geometry && this.material && this.material.shader && !this.invisible && this.geometry.vertexCount > 0;
  },
  beforeRender: function(_gl) {
  },
  afterRender: function(_gl, renderStat) {
  },
  getBoundingBox: function(filter2, out2) {
    out2 = Node3D.prototype.getBoundingBox.call(this, filter2, out2);
    if (this.geometry && this.geometry.boundingBox) {
      out2.union(this.geometry.boundingBox);
    }
    return out2;
  },
  clone: function() {
    var properties = [
      "castShadow",
      "receiveShadow",
      "mode",
      "culling",
      "cullFace",
      "frontFace",
      "frustumCulling",
      "renderOrder",
      "lineWidth",
      "ignorePicking",
      "ignorePreZ",
      "ignoreGBuffer"
    ];
    return function() {
      var renderable = Node3D.prototype.clone.call(this);
      renderable.geometry = this.geometry;
      renderable.material = this.material;
      for (var i = 0; i < properties.length; i++) {
        var name = properties[i];
        if (renderable[name] !== this[name]) {
          renderable[name] = this[name];
        }
      }
      return renderable;
    };
  }()
});
Renderable.POINTS = glenum.POINTS;
Renderable.LINES = glenum.LINES;
Renderable.LINE_LOOP = glenum.LINE_LOOP;
Renderable.LINE_STRIP = glenum.LINE_STRIP;
Renderable.TRIANGLES = glenum.TRIANGLES;
Renderable.TRIANGLE_STRIP = glenum.TRIANGLE_STRIP;
Renderable.TRIANGLE_FAN = glenum.TRIANGLE_FAN;
Renderable.BACK = glenum.BACK;
Renderable.FRONT = glenum.FRONT;
Renderable.FRONT_AND_BACK = glenum.FRONT_AND_BACK;
Renderable.CW = glenum.CW;
Renderable.CCW = glenum.CCW;
var Renderable$1 = Renderable;
var RayPicking = Base$1.extend({
  scene: null,
  camera: null,
  renderer: null
}, function() {
  this._ray = new Ray$1();
  this._ndc = new Vector2$1();
}, {
  pick: function(x, y, forcePickAll) {
    var out2 = this.pickAll(x, y, [], forcePickAll);
    return out2[0] || null;
  },
  pickAll: function(x, y, output, forcePickAll) {
    this.renderer.screenToNDC(x, y, this._ndc);
    this.camera.castRay(this._ndc, this._ray);
    output = output || [];
    this._intersectNode(this.scene, output, forcePickAll || false);
    output.sort(this._intersectionCompareFunc);
    return output;
  },
  _intersectNode: function(node, out2, forcePickAll) {
    if (node instanceof Renderable$1 && node.isRenderable()) {
      if ((!node.ignorePicking || forcePickAll) && (node.mode === glenum.TRIANGLES && node.geometry.isUseIndices() || node.geometry.pickByRay || node.geometry.pick)) {
        this._intersectRenderable(node, out2);
      }
    }
    for (var i = 0; i < node._children.length; i++) {
      this._intersectNode(node._children[i], out2, forcePickAll);
    }
  },
  _intersectRenderable: function() {
    var v12 = new Vector3$1();
    var v22 = new Vector3$1();
    var v32 = new Vector3$1();
    var ray = new Ray$1();
    var worldInverse = new Matrix4$1();
    return function(renderable, out2) {
      var isSkinnedMesh = renderable.isSkinnedMesh();
      ray.copy(this._ray);
      Matrix4$1.invert(worldInverse, renderable.worldTransform);
      if (!isSkinnedMesh) {
        ray.applyTransform(worldInverse);
      }
      var geometry = renderable.geometry;
      var bbox = isSkinnedMesh ? renderable.skeleton.boundingBox : geometry.boundingBox;
      if (bbox && !ray.intersectBoundingBox(bbox)) {
        return;
      }
      if (geometry.pick) {
        geometry.pick(this._ndc.x, this._ndc.y, this.renderer, this.camera, renderable, out2);
        return;
      } else if (geometry.pickByRay) {
        geometry.pickByRay(ray, renderable, out2);
        return;
      }
      var cullBack = renderable.cullFace === glenum.BACK && renderable.frontFace === glenum.CCW || renderable.cullFace === glenum.FRONT && renderable.frontFace === glenum.CW;
      var point;
      var indices = geometry.indices;
      var positionAttr = geometry.attributes.position;
      var weightAttr = geometry.attributes.weight;
      var jointAttr = geometry.attributes.joint;
      var skinMatricesArray;
      var skinMatrices = [];
      if (!positionAttr || !positionAttr.value || !indices) {
        return;
      }
      if (isSkinnedMesh) {
        skinMatricesArray = renderable.skeleton.getSubSkinMatrices(renderable.__uid__, renderable.joints);
        for (var i = 0; i < renderable.joints.length; i++) {
          skinMatrices[i] = skinMatrices[i] || [];
          for (var k = 0; k < 16; k++) {
            skinMatrices[i][k] = skinMatricesArray[i * 16 + k];
          }
        }
        var pos = [];
        var weight = [];
        var joint = [];
        var skinnedPos = [];
        var tmp = [];
        var skinnedPositionAttr = geometry.attributes.skinnedPosition;
        if (!skinnedPositionAttr || !skinnedPositionAttr.value) {
          geometry.createAttribute("skinnedPosition", "f", 3);
          skinnedPositionAttr = geometry.attributes.skinnedPosition;
          skinnedPositionAttr.init(geometry.vertexCount);
        }
        for (var i = 0; i < geometry.vertexCount; i++) {
          positionAttr.get(i, pos);
          weightAttr.get(i, weight);
          jointAttr.get(i, joint);
          weight[3] = 1 - weight[0] - weight[1] - weight[2];
          vec3$g.set(skinnedPos, 0, 0, 0);
          for (var k = 0; k < 4; k++) {
            if (joint[k] >= 0 && weight[k] > 1e-4) {
              vec3$g.transformMat4(tmp, pos, skinMatrices[joint[k]]);
              vec3$g.scaleAndAdd(skinnedPos, skinnedPos, tmp, weight[k]);
            }
          }
          skinnedPositionAttr.set(i, skinnedPos);
        }
      }
      for (var i = 0; i < indices.length; i += 3) {
        var i1 = indices[i];
        var i2 = indices[i + 1];
        var i3 = indices[i + 2];
        var finalPosAttr = isSkinnedMesh ? geometry.attributes.skinnedPosition : positionAttr;
        finalPosAttr.get(i1, v12.array);
        finalPosAttr.get(i2, v22.array);
        finalPosAttr.get(i3, v32.array);
        if (cullBack) {
          point = ray.intersectTriangle(v12, v22, v32, renderable.culling);
        } else {
          point = ray.intersectTriangle(v12, v32, v22, renderable.culling);
        }
        if (point) {
          var pointW = new Vector3$1();
          if (!isSkinnedMesh) {
            Vector3$1.transformMat4(pointW, point, renderable.worldTransform);
          } else {
            Vector3$1.copy(pointW, point);
          }
          out2.push(new RayPicking.Intersection(point, pointW, renderable, [i1, i2, i3], i / 3, Vector3$1.dist(pointW, this._ray.origin)));
        }
      }
    };
  }(),
  _intersectionCompareFunc: function(a, b) {
    return a.distance - b.distance;
  }
});
RayPicking.Intersection = function(point, pointWorld, target, triangle, triangleIndex, distance2) {
  this.point = point;
  this.pointWorld = pointWorld;
  this.target = target;
  this.triangle = triangle;
  this.triangleIndex = triangleIndex;
  this.distance = distance2;
};
var RayPicking$1 = RayPicking;
var DIRTY_PREFIX = "__dt__";
var Cache = function() {
  this._contextId = 0;
  this._caches = [];
  this._context = {};
};
Cache.prototype = {
  use: function(contextId, documentSchema) {
    var caches = this._caches;
    if (!caches[contextId]) {
      caches[contextId] = {};
      if (documentSchema) {
        caches[contextId] = documentSchema();
      }
    }
    this._contextId = contextId;
    this._context = caches[contextId];
  },
  put: function(key, value) {
    this._context[key] = value;
  },
  get: function(key) {
    return this._context[key];
  },
  dirty: function(field) {
    field = field || "";
    var key = DIRTY_PREFIX + field;
    this.put(key, true);
  },
  dirtyAll: function(field) {
    field = field || "";
    var key = DIRTY_PREFIX + field;
    var caches = this._caches;
    for (var i = 0; i < caches.length; i++) {
      if (caches[i]) {
        caches[i][key] = true;
      }
    }
  },
  fresh: function(field) {
    field = field || "";
    var key = DIRTY_PREFIX + field;
    this.put(key, false);
  },
  freshAll: function(field) {
    field = field || "";
    var key = DIRTY_PREFIX + field;
    var caches = this._caches;
    for (var i = 0; i < caches.length; i++) {
      if (caches[i]) {
        caches[i][key] = false;
      }
    }
  },
  isDirty: function(field) {
    field = field || "";
    var key = DIRTY_PREFIX + field;
    var context = this._context;
    return !context.hasOwnProperty(key) || context[key] === true;
  },
  deleteContext: function(contextId) {
    delete this._caches[contextId];
    this._context = {};
  },
  delete: function(key) {
    delete this._context[key];
  },
  clearAll: function() {
    this._caches = {};
  },
  getContext: function() {
    return this._context;
  },
  eachContext: function(cb, context) {
    var keys2 = Object.keys(this._caches);
    keys2.forEach(function(key) {
      cb && cb.call(context, key);
    });
  },
  miss: function(key) {
    return !this._context.hasOwnProperty(key);
  }
};
Cache.prototype.constructor = Cache;
var Cache$1 = Cache;
var Texture = Base$1.extend({
  width: 512,
  height: 512,
  type: glenum.UNSIGNED_BYTE,
  format: glenum.RGBA,
  wrapS: glenum.REPEAT,
  wrapT: glenum.REPEAT,
  minFilter: glenum.LINEAR_MIPMAP_LINEAR,
  magFilter: glenum.LINEAR,
  useMipmap: true,
  anisotropic: 1,
  flipY: true,
  sRGB: true,
  unpackAlignment: 4,
  premultiplyAlpha: false,
  dynamic: false,
  NPOT: false,
  __used: 0
}, function() {
  this._cache = new Cache$1();
}, {
  getWebGLTexture: function(renderer) {
    var _gl = renderer.gl;
    var cache2 = this._cache;
    cache2.use(renderer.__uid__);
    if (cache2.miss("webgl_texture")) {
      cache2.put("webgl_texture", _gl.createTexture());
    }
    if (this.dynamic) {
      this.update(renderer);
    } else if (cache2.isDirty()) {
      this.update(renderer);
      cache2.fresh();
    }
    return cache2.get("webgl_texture");
  },
  bind: function() {
  },
  unbind: function() {
  },
  dirty: function() {
    if (this._cache) {
      this._cache.dirtyAll();
    }
  },
  update: function(renderer) {
  },
  updateCommon: function(renderer) {
    var _gl = renderer.gl;
    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, this.flipY);
    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, this.unpackAlignment);
    if (this.format === glenum.DEPTH_COMPONENT) {
      this.useMipmap = false;
    }
    var sRGBExt = renderer.getGLExtension("EXT_sRGB");
    if (this.format === Texture.SRGB && !sRGBExt) {
      this.format = Texture.RGB;
    }
    if (this.format === Texture.SRGB_ALPHA && !sRGBExt) {
      this.format = Texture.RGBA;
    }
    this.NPOT = !this.isPowerOfTwo();
  },
  getAvailableWrapS: function() {
    if (this.NPOT) {
      return glenum.CLAMP_TO_EDGE;
    }
    return this.wrapS;
  },
  getAvailableWrapT: function() {
    if (this.NPOT) {
      return glenum.CLAMP_TO_EDGE;
    }
    return this.wrapT;
  },
  getAvailableMinFilter: function() {
    var minFilter = this.minFilter;
    if (this.NPOT || !this.useMipmap) {
      if (minFilter === glenum.NEAREST_MIPMAP_NEAREST || minFilter === glenum.NEAREST_MIPMAP_LINEAR) {
        return glenum.NEAREST;
      } else if (minFilter === glenum.LINEAR_MIPMAP_LINEAR || minFilter === glenum.LINEAR_MIPMAP_NEAREST) {
        return glenum.LINEAR;
      } else {
        return minFilter;
      }
    } else {
      return minFilter;
    }
  },
  getAvailableMagFilter: function() {
    return this.magFilter;
  },
  nextHighestPowerOfTwo: function(x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
      x = x | x >> i;
    }
    return x + 1;
  },
  dispose: function(renderer) {
    var cache2 = this._cache;
    cache2.use(renderer.__uid__);
    var webglTexture = cache2.get("webgl_texture");
    if (webglTexture) {
      renderer.gl.deleteTexture(webglTexture);
    }
    cache2.deleteContext(renderer.__uid__);
  },
  isRenderable: function() {
  },
  isPowerOfTwo: function() {
  }
});
Object.defineProperty(Texture.prototype, "width", {
  get: function() {
    return this._width;
  },
  set: function(value) {
    this._width = value;
  }
});
Object.defineProperty(Texture.prototype, "height", {
  get: function() {
    return this._height;
  },
  set: function(value) {
    this._height = value;
  }
});
Texture.BYTE = glenum.BYTE;
Texture.UNSIGNED_BYTE = glenum.UNSIGNED_BYTE;
Texture.SHORT = glenum.SHORT;
Texture.UNSIGNED_SHORT = glenum.UNSIGNED_SHORT;
Texture.INT = glenum.INT;
Texture.UNSIGNED_INT = glenum.UNSIGNED_INT;
Texture.FLOAT = glenum.FLOAT;
Texture.HALF_FLOAT = 36193;
Texture.UNSIGNED_INT_24_8_WEBGL = 34042;
Texture.DEPTH_COMPONENT = glenum.DEPTH_COMPONENT;
Texture.DEPTH_STENCIL = glenum.DEPTH_STENCIL;
Texture.ALPHA = glenum.ALPHA;
Texture.RGB = glenum.RGB;
Texture.RGBA = glenum.RGBA;
Texture.LUMINANCE = glenum.LUMINANCE;
Texture.LUMINANCE_ALPHA = glenum.LUMINANCE_ALPHA;
Texture.SRGB = 35904;
Texture.SRGB_ALPHA = 35906;
Texture.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
Texture.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
Texture.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
Texture.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
Texture.NEAREST = glenum.NEAREST;
Texture.LINEAR = glenum.LINEAR;
Texture.NEAREST_MIPMAP_NEAREST = glenum.NEAREST_MIPMAP_NEAREST;
Texture.LINEAR_MIPMAP_NEAREST = glenum.LINEAR_MIPMAP_NEAREST;
Texture.NEAREST_MIPMAP_LINEAR = glenum.NEAREST_MIPMAP_LINEAR;
Texture.LINEAR_MIPMAP_LINEAR = glenum.LINEAR_MIPMAP_LINEAR;
Texture.REPEAT = glenum.REPEAT;
Texture.CLAMP_TO_EDGE = glenum.CLAMP_TO_EDGE;
Texture.MIRRORED_REPEAT = glenum.MIRRORED_REPEAT;
var Texture$1 = Texture;
var Mesh = Renderable$1.extend({
  skeleton: null,
  joints: null
}, function() {
  if (!this.joints) {
    this.joints = [];
  }
}, {
  offsetMatrix: null,
  isInstancedMesh: function() {
    return false;
  },
  isSkinnedMesh: function() {
    return !!(this.skeleton && this.joints && this.joints.length > 0);
  },
  clone: function() {
    var mesh2 = Renderable$1.prototype.clone.call(this);
    mesh2.skeleton = this.skeleton;
    if (this.joints) {
      mesh2.joints = this.joints.slice();
    }
    return mesh2;
  }
});
Mesh.POINTS = glenum.POINTS;
Mesh.LINES = glenum.LINES;
Mesh.LINE_LOOP = glenum.LINE_LOOP;
Mesh.LINE_STRIP = glenum.LINE_STRIP;
Mesh.TRIANGLES = glenum.TRIANGLES;
Mesh.TRIANGLE_STRIP = glenum.TRIANGLE_STRIP;
Mesh.TRIANGLE_FAN = glenum.TRIANGLE_FAN;
Mesh.BACK = glenum.BACK;
Mesh.FRONT = glenum.FRONT;
Mesh.FRONT_AND_BACK = glenum.FRONT_AND_BACK;
Mesh.CW = glenum.CW;
Mesh.CCW = glenum.CCW;
var Mesh$1 = Mesh;
var mathUtil = {};
mathUtil.isPowerOfTwo = function(value) {
  return (value & value - 1) === 0;
};
mathUtil.nextPowerOfTwo = function(value) {
  value--;
  value |= value >> 1;
  value |= value >> 2;
  value |= value >> 4;
  value |= value >> 8;
  value |= value >> 16;
  value++;
  return value;
};
mathUtil.nearestPowerOfTwo = function(value) {
  return Math.pow(2, Math.round(Math.log(value) / Math.LN2));
};
var mathUtil$1 = mathUtil;
var isPowerOfTwo$2 = mathUtil$1.isPowerOfTwo;
function nearestPowerOfTwo$1(val) {
  return Math.pow(2, Math.round(Math.log(val) / Math.LN2));
}
function convertTextureToPowerOfTwo$1(texture, canvas) {
  var width = nearestPowerOfTwo$1(texture.width);
  var height = nearestPowerOfTwo$1(texture.height);
  canvas = canvas || document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext("2d");
  ctx.drawImage(texture.image, 0, 0, width, height);
  return canvas;
}
var Texture2D = Texture$1.extend(function() {
  return {
    image: null,
    pixels: null,
    mipmaps: [],
    convertToPOT: false
  };
}, {
  textureType: "texture2D",
  update: function(renderer) {
    var _gl = renderer.gl;
    _gl.bindTexture(_gl.TEXTURE_2D, this._cache.get("webgl_texture"));
    this.updateCommon(renderer);
    var glFormat = this.format;
    var glType = this.type;
    var convertToPOT = !!(this.convertToPOT && !this.mipmaps.length && this.image && (this.wrapS === Texture$1.REPEAT || this.wrapT === Texture$1.REPEAT) && this.NPOT);
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, convertToPOT ? this.wrapS : this.getAvailableWrapS());
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, convertToPOT ? this.wrapT : this.getAvailableWrapT());
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, convertToPOT ? this.magFilter : this.getAvailableMagFilter());
    _gl.texParameteri(_gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, convertToPOT ? this.minFilter : this.getAvailableMinFilter());
    var anisotropicExt = renderer.getGLExtension("EXT_texture_filter_anisotropic");
    if (anisotropicExt && this.anisotropic > 1) {
      _gl.texParameterf(_gl.TEXTURE_2D, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropic);
    }
    if (glType === 36193) {
      var halfFloatExt = renderer.getGLExtension("OES_texture_half_float");
      if (!halfFloatExt) {
        glType = glenum.FLOAT;
      }
    }
    if (this.mipmaps.length) {
      var width = this.width;
      var height = this.height;
      for (var i = 0; i < this.mipmaps.length; i++) {
        var mipmap = this.mipmaps[i];
        this._updateTextureData(_gl, mipmap, i, width, height, glFormat, glType, false);
        width /= 2;
        height /= 2;
      }
    } else {
      this._updateTextureData(_gl, this, 0, this.width, this.height, glFormat, glType, convertToPOT);
      if (this.useMipmap && (!this.NPOT || convertToPOT)) {
        _gl.generateMipmap(_gl.TEXTURE_2D);
      }
    }
    _gl.bindTexture(_gl.TEXTURE_2D, null);
  },
  _updateTextureData: function(_gl, data, level, width, height, glFormat, glType, convertToPOT) {
    if (data.image) {
      var imgData = data.image;
      if (convertToPOT) {
        this._potCanvas = convertTextureToPowerOfTwo$1(this, this._potCanvas);
        imgData = this._potCanvas;
      }
      _gl.texImage2D(_gl.TEXTURE_2D, level, glFormat, glFormat, glType, imgData);
    } else {
      if (glFormat <= Texture$1.COMPRESSED_RGBA_S3TC_DXT5_EXT && glFormat >= Texture$1.COMPRESSED_RGB_S3TC_DXT1_EXT) {
        _gl.compressedTexImage2D(_gl.TEXTURE_2D, level, glFormat, width, height, 0, data.pixels);
      } else {
        _gl.texImage2D(_gl.TEXTURE_2D, level, glFormat, width, height, 0, glFormat, glType, data.pixels);
      }
    }
  },
  generateMipmap: function(renderer) {
    var _gl = renderer.gl;
    if (this.useMipmap && !this.NPOT) {
      _gl.bindTexture(_gl.TEXTURE_2D, this._cache.get("webgl_texture"));
      _gl.generateMipmap(_gl.TEXTURE_2D);
    }
  },
  isPowerOfTwo: function() {
    return isPowerOfTwo$2(this.width) && isPowerOfTwo$2(this.height);
  },
  isRenderable: function() {
    if (this.image) {
      return this.image.width > 0 && this.image.height > 0;
    } else {
      return !!(this.width && this.height);
    }
  },
  bind: function(renderer) {
    renderer.gl.bindTexture(renderer.gl.TEXTURE_2D, this.getWebGLTexture(renderer));
  },
  unbind: function(renderer) {
    renderer.gl.bindTexture(renderer.gl.TEXTURE_2D, null);
  },
  load: function(src, crossOrigin) {
    var image = vendor$1.createImage();
    if (crossOrigin) {
      image.crossOrigin = crossOrigin;
    }
    var self2 = this;
    image.onload = function() {
      self2.dirty();
      self2.trigger("success", self2);
    };
    image.onerror = function() {
      self2.trigger("error", self2);
    };
    image.src = src;
    this.image = image;
    return this;
  }
});
Object.defineProperty(Texture2D.prototype, "width", {
  get: function() {
    if (this.image) {
      return this.image.width;
    }
    return this._width;
  },
  set: function(value) {
    if (this.image) {
      console.warn("Texture from image can't set width");
    } else {
      if (this._width !== value) {
        this.dirty();
      }
      this._width = value;
    }
  }
});
Object.defineProperty(Texture2D.prototype, "height", {
  get: function() {
    if (this.image) {
      return this.image.height;
    }
    return this._height;
  },
  set: function(value) {
    if (this.image) {
      console.warn("Texture from image can't set height");
    } else {
      if (this._height !== value) {
        this.dirty();
      }
      this._height = value;
    }
  }
});
var Texture2D$1 = Texture2D;
function getArrayCtorByType(type) {
  return {
    "byte": vendor$1.Int8Array,
    "ubyte": vendor$1.Uint8Array,
    "short": vendor$1.Int16Array,
    "ushort": vendor$1.Uint16Array
  }[type] || vendor$1.Float32Array;
}
function makeAttrKey(attrName) {
  return "attr_" + attrName;
}
function Attribute$1(name, type, size, semantic) {
  this.name = name;
  this.type = type;
  this.size = size;
  this.semantic = semantic || "";
  this.value = null;
  switch (size) {
    case 1:
      this.get = function(idx) {
        return this.value[idx];
      };
      this.set = function(idx, value) {
        this.value[idx] = value;
      };
      this.copy = function(target, source) {
        this.value[target] = this.value[target];
      };
      break;
    case 2:
      this.get = function(idx, out2) {
        var arr = this.value;
        out2[0] = arr[idx * 2];
        out2[1] = arr[idx * 2 + 1];
        return out2;
      };
      this.set = function(idx, val) {
        var arr = this.value;
        arr[idx * 2] = val[0];
        arr[idx * 2 + 1] = val[1];
      };
      this.copy = function(target, source) {
        var arr = this.value;
        source *= 2;
        target *= 2;
        arr[target] = arr[source];
        arr[target + 1] = arr[source + 1];
      };
      break;
    case 3:
      this.get = function(idx, out2) {
        var idx3 = idx * 3;
        var arr = this.value;
        out2[0] = arr[idx3];
        out2[1] = arr[idx3 + 1];
        out2[2] = arr[idx3 + 2];
        return out2;
      };
      this.set = function(idx, val) {
        var idx3 = idx * 3;
        var arr = this.value;
        arr[idx3] = val[0];
        arr[idx3 + 1] = val[1];
        arr[idx3 + 2] = val[2];
      };
      this.copy = function(target, source) {
        var arr = this.value;
        source *= 3;
        target *= 3;
        arr[target] = arr[source];
        arr[target + 1] = arr[source + 1];
        arr[target + 2] = arr[source + 2];
      };
      break;
    case 4:
      this.get = function(idx, out2) {
        var arr = this.value;
        var idx4 = idx * 4;
        out2[0] = arr[idx4];
        out2[1] = arr[idx4 + 1];
        out2[2] = arr[idx4 + 2];
        out2[3] = arr[idx4 + 3];
        return out2;
      };
      this.set = function(idx, val) {
        var arr = this.value;
        var idx4 = idx * 4;
        arr[idx4] = val[0];
        arr[idx4 + 1] = val[1];
        arr[idx4 + 2] = val[2];
        arr[idx4 + 3] = val[3];
      };
      this.copy = function(target, source) {
        var arr = this.value;
        source *= 4;
        target *= 4;
        arr[target] = arr[source];
        arr[target + 1] = arr[source + 1];
        arr[target + 2] = arr[source + 2];
        arr[target + 3] = arr[source + 3];
      };
  }
}
Attribute$1.prototype.init = function(nVertex) {
  if (!this.value || this.value.length !== nVertex * this.size) {
    var ArrayConstructor = getArrayCtorByType(this.type);
    this.value = new ArrayConstructor(nVertex * this.size);
  }
};
Attribute$1.prototype.fromArray = function(array) {
  var ArrayConstructor = getArrayCtorByType(this.type);
  var value;
  if (array[0] && array[0].length) {
    var n = 0;
    var size = this.size;
    value = new ArrayConstructor(array.length * size);
    for (var i = 0; i < array.length; i++) {
      for (var j = 0; j < size; j++) {
        value[n++] = array[i][j];
      }
    }
  } else {
    value = new ArrayConstructor(array);
  }
  this.value = value;
};
Attribute$1.prototype.clone = function(copyValue2) {
  var ret2 = new Attribute$1(this.name, this.type, this.size, this.semantic);
  if (copyValue2) {
    console.warn("todo");
  }
  return ret2;
};
function AttributeBuffer(name, type, buffer, size, semantic) {
  this.name = name;
  this.type = type;
  this.buffer = buffer;
  this.size = size;
  this.semantic = semantic;
  this.symbol = "";
  this.needsRemove = false;
}
function IndicesBuffer(buffer) {
  this.buffer = buffer;
  this.count = 0;
}
var GeometryBase = Base$1.extend(function() {
  return {
    attributes: {},
    indices: null,
    dynamic: true,
    _enabledAttributes: null,
    __used: 0
  };
}, function() {
  this._cache = new Cache$1();
  this._attributeList = Object.keys(this.attributes);
  this.__vaoCache = {};
}, {
  mainAttribute: "",
  pick: null,
  pickByRay: null,
  dirty: function() {
    var enabledAttributes = this.getEnabledAttributes();
    for (var i = 0; i < enabledAttributes.length; i++) {
      this.dirtyAttribute(enabledAttributes[i]);
    }
    this.dirtyIndices();
    this._enabledAttributes = null;
    this._cache.dirty("any");
  },
  dirtyIndices: function() {
    this._cache.dirtyAll("indices");
  },
  dirtyAttribute: function(attrName) {
    this._cache.dirtyAll(makeAttrKey(attrName));
    this._cache.dirtyAll("attributes");
  },
  getTriangleIndices: function(idx, out2) {
    if (idx < this.triangleCount && idx >= 0) {
      if (!out2) {
        out2 = [];
      }
      var indices = this.indices;
      out2[0] = indices[idx * 3];
      out2[1] = indices[idx * 3 + 1];
      out2[2] = indices[idx * 3 + 2];
      return out2;
    }
  },
  setTriangleIndices: function(idx, arr) {
    var indices = this.indices;
    indices[idx * 3] = arr[0];
    indices[idx * 3 + 1] = arr[1];
    indices[idx * 3 + 2] = arr[2];
  },
  isUseIndices: function() {
    return !!this.indices;
  },
  initIndicesFromArray: function(array) {
    var value;
    var ArrayConstructor = this.vertexCount > 65535 ? vendor$1.Uint32Array : vendor$1.Uint16Array;
    if (array[0] && array[0].length) {
      var n = 0;
      var size = 3;
      value = new ArrayConstructor(array.length * size);
      for (var i = 0; i < array.length; i++) {
        for (var j = 0; j < size; j++) {
          value[n++] = array[i][j];
        }
      }
    } else {
      value = new ArrayConstructor(array);
    }
    this.indices = value;
  },
  createAttribute: function(name, type, size, semantic) {
    var attrib = new Attribute$1(name, type, size, semantic);
    if (this.attributes[name]) {
      this.removeAttribute(name);
    }
    this.attributes[name] = attrib;
    this._attributeList.push(name);
    return attrib;
  },
  removeAttribute: function(name) {
    var attributeList = this._attributeList;
    var idx = attributeList.indexOf(name);
    if (idx >= 0) {
      attributeList.splice(idx, 1);
      delete this.attributes[name];
      return true;
    }
    return false;
  },
  getAttribute: function(name) {
    return this.attributes[name];
  },
  getEnabledAttributes: function() {
    var enabledAttributes = this._enabledAttributes;
    var attributeList = this._attributeList;
    if (enabledAttributes) {
      return enabledAttributes;
    }
    var result = [];
    var nVertex = this.vertexCount;
    for (var i = 0; i < attributeList.length; i++) {
      var name = attributeList[i];
      var attrib = this.attributes[name];
      if (attrib.value) {
        if (attrib.value.length === nVertex * attrib.size) {
          result.push(name);
        }
      }
    }
    this._enabledAttributes = result;
    return result;
  },
  getBufferChunks: function(renderer) {
    var cache2 = this._cache;
    cache2.use(renderer.__uid__);
    var isAttributesDirty = cache2.isDirty("attributes");
    var isIndicesDirty = cache2.isDirty("indices");
    if (isAttributesDirty || isIndicesDirty) {
      this._updateBuffer(renderer.gl, isAttributesDirty, isIndicesDirty);
      var enabledAttributes = this.getEnabledAttributes();
      for (var i = 0; i < enabledAttributes.length; i++) {
        cache2.fresh(makeAttrKey(enabledAttributes[i]));
      }
      cache2.fresh("attributes");
      cache2.fresh("indices");
    }
    cache2.fresh("any");
    return cache2.get("chunks");
  },
  _updateBuffer: function(_gl, isAttributesDirty, isIndicesDirty) {
    var cache2 = this._cache;
    var chunks = cache2.get("chunks");
    var firstUpdate = false;
    if (!chunks) {
      chunks = [];
      chunks[0] = {
        attributeBuffers: [],
        indicesBuffer: null
      };
      cache2.put("chunks", chunks);
      firstUpdate = true;
    }
    var chunk = chunks[0];
    var attributeBuffers = chunk.attributeBuffers;
    var indicesBuffer = chunk.indicesBuffer;
    if (isAttributesDirty || firstUpdate) {
      var attributeList = this.getEnabledAttributes();
      var attributeBufferMap = {};
      if (!firstUpdate) {
        for (var i = 0; i < attributeBuffers.length; i++) {
          attributeBufferMap[attributeBuffers[i].name] = attributeBuffers[i];
        }
      }
      for (var k = 0; k < attributeList.length; k++) {
        var name = attributeList[k];
        var attribute = this.attributes[name];
        var bufferInfo;
        if (!firstUpdate) {
          bufferInfo = attributeBufferMap[name];
        }
        var buffer;
        if (bufferInfo) {
          buffer = bufferInfo.buffer;
        } else {
          buffer = _gl.createBuffer();
        }
        if (cache2.isDirty(makeAttrKey(name))) {
          _gl.bindBuffer(_gl.ARRAY_BUFFER, buffer);
          _gl.bufferData(_gl.ARRAY_BUFFER, attribute.value, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
        }
        attributeBuffers[k] = new AttributeBuffer(name, attribute.type, buffer, attribute.size, attribute.semantic);
      }
      for (var i = k; i < attributeBuffers.length; i++) {
        _gl.deleteBuffer(attributeBuffers[i].buffer);
      }
      attributeBuffers.length = k;
    }
    if (this.isUseIndices() && (isIndicesDirty || firstUpdate)) {
      if (!indicesBuffer) {
        indicesBuffer = new IndicesBuffer(_gl.createBuffer());
        chunk.indicesBuffer = indicesBuffer;
      }
      indicesBuffer.count = this.indices.length;
      _gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER, indicesBuffer.buffer);
      _gl.bufferData(_gl.ELEMENT_ARRAY_BUFFER, this.indices, this.dynamic ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW);
    }
  },
  dispose: function(renderer) {
    var cache2 = this._cache;
    cache2.use(renderer.__uid__);
    var chunks = cache2.get("chunks");
    if (chunks) {
      for (var c = 0; c < chunks.length; c++) {
        var chunk = chunks[c];
        for (var k = 0; k < chunk.attributeBuffers.length; k++) {
          var attribs = chunk.attributeBuffers[k];
          renderer.gl.deleteBuffer(attribs.buffer);
        }
        if (chunk.indicesBuffer) {
          renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);
        }
      }
    }
    if (this.__vaoCache) {
      var vaoExt = renderer.getGLExtension("OES_vertex_array_object");
      for (var id in this.__vaoCache) {
        var vao = this.__vaoCache[id].vao;
        if (vao) {
          vaoExt.deleteVertexArrayOES(vao);
        }
      }
    }
    this.__vaoCache = {};
    cache2.deleteContext(renderer.__uid__);
  }
});
if (Object.defineProperty) {
  Object.defineProperty(GeometryBase.prototype, "vertexCount", {
    enumerable: false,
    get: function() {
      var mainAttribute = this.attributes[this.mainAttribute];
      if (!mainAttribute) {
        mainAttribute = this.attributes[this._attributeList[0]];
      }
      if (!mainAttribute || !mainAttribute.value) {
        return 0;
      }
      return mainAttribute.value.length / mainAttribute.size;
    }
  });
  Object.defineProperty(GeometryBase.prototype, "triangleCount", {
    enumerable: false,
    get: function() {
      var indices = this.indices;
      if (!indices) {
        return 0;
      } else {
        return indices.length / 3;
      }
    }
  });
}
GeometryBase.STATIC_DRAW = glenum.STATIC_DRAW;
GeometryBase.DYNAMIC_DRAW = glenum.DYNAMIC_DRAW;
GeometryBase.STREAM_DRAW = glenum.STREAM_DRAW;
GeometryBase.AttributeBuffer = AttributeBuffer;
GeometryBase.IndicesBuffer = IndicesBuffer;
GeometryBase.Attribute = Attribute$1;
var GeometryBase$1 = GeometryBase;
var vec3Create = vec3$g.create;
var vec3Add = vec3$g.add;
var vec3Set$1 = vec3$g.set;
var Attribute = GeometryBase$1.Attribute;
var Geometry = GeometryBase$1.extend(function() {
  return {
    attributes: {
      position: new Attribute("position", "float", 3, "POSITION"),
      texcoord0: new Attribute("texcoord0", "float", 2, "TEXCOORD_0"),
      texcoord1: new Attribute("texcoord1", "float", 2, "TEXCOORD_1"),
      normal: new Attribute("normal", "float", 3, "NORMAL"),
      tangent: new Attribute("tangent", "float", 4, "TANGENT"),
      color: new Attribute("color", "float", 4, "COLOR"),
      weight: new Attribute("weight", "float", 3, "WEIGHT"),
      joint: new Attribute("joint", "float", 4, "JOINT"),
      barycentric: new Attribute("barycentric", "float", 3, null)
    },
    boundingBox: null
  };
}, {
  mainAttribute: "position",
  updateBoundingBox: function() {
    var bbox = this.boundingBox;
    if (!bbox) {
      bbox = this.boundingBox = new BoundingBox$1();
    }
    var posArr = this.attributes.position.value;
    if (posArr && posArr.length) {
      var min3 = bbox.min;
      var max3 = bbox.max;
      var minArr = min3.array;
      var maxArr = max3.array;
      vec3$g.set(minArr, posArr[0], posArr[1], posArr[2]);
      vec3$g.set(maxArr, posArr[0], posArr[1], posArr[2]);
      for (var i = 3; i < posArr.length; ) {
        var x = posArr[i++];
        var y = posArr[i++];
        var z = posArr[i++];
        if (x < minArr[0]) {
          minArr[0] = x;
        }
        if (y < minArr[1]) {
          minArr[1] = y;
        }
        if (z < minArr[2]) {
          minArr[2] = z;
        }
        if (x > maxArr[0]) {
          maxArr[0] = x;
        }
        if (y > maxArr[1]) {
          maxArr[1] = y;
        }
        if (z > maxArr[2]) {
          maxArr[2] = z;
        }
      }
      min3._dirty = true;
      max3._dirty = true;
    }
  },
  generateVertexNormals: function() {
    if (!this.vertexCount) {
      return;
    }
    var indices = this.indices;
    var attributes = this.attributes;
    var positions = attributes.position.value;
    var normals = attributes.normal.value;
    if (!normals || normals.length !== positions.length) {
      normals = attributes.normal.value = new vendor$1.Float32Array(positions.length);
    } else {
      for (var i = 0; i < normals.length; i++) {
        normals[i] = 0;
      }
    }
    var p12 = vec3Create();
    var p22 = vec3Create();
    var p3 = vec3Create();
    var v21 = vec3Create();
    var v32 = vec3Create();
    var n = vec3Create();
    var len2 = indices ? indices.length : this.vertexCount;
    var i1, i2, i3;
    for (var f = 0; f < len2; ) {
      if (indices) {
        i1 = indices[f++];
        i2 = indices[f++];
        i3 = indices[f++];
      } else {
        i1 = f++;
        i2 = f++;
        i3 = f++;
      }
      vec3Set$1(p12, positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
      vec3Set$1(p22, positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
      vec3Set$1(p3, positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
      vec3$g.sub(v21, p12, p22);
      vec3$g.sub(v32, p22, p3);
      vec3$g.cross(n, v21, v32);
      for (var i = 0; i < 3; i++) {
        normals[i1 * 3 + i] = normals[i1 * 3 + i] + n[i];
        normals[i2 * 3 + i] = normals[i2 * 3 + i] + n[i];
        normals[i3 * 3 + i] = normals[i3 * 3 + i] + n[i];
      }
    }
    for (var i = 0; i < normals.length; ) {
      vec3Set$1(n, normals[i], normals[i + 1], normals[i + 2]);
      vec3$g.normalize(n, n);
      normals[i++] = n[0];
      normals[i++] = n[1];
      normals[i++] = n[2];
    }
    this.dirty();
  },
  generateFaceNormals: function() {
    if (!this.vertexCount) {
      return;
    }
    if (!this.isUniqueVertex()) {
      this.generateUniqueVertex();
    }
    var indices = this.indices;
    var attributes = this.attributes;
    var positions = attributes.position.value;
    var normals = attributes.normal.value;
    var p12 = vec3Create();
    var p22 = vec3Create();
    var p3 = vec3Create();
    var v21 = vec3Create();
    var v32 = vec3Create();
    var n = vec3Create();
    if (!normals) {
      normals = attributes.normal.value = new Float32Array(positions.length);
    }
    var len2 = indices ? indices.length : this.vertexCount;
    var i1, i2, i3;
    for (var f = 0; f < len2; ) {
      if (indices) {
        i1 = indices[f++];
        i2 = indices[f++];
        i3 = indices[f++];
      } else {
        i1 = f++;
        i2 = f++;
        i3 = f++;
      }
      vec3Set$1(p12, positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
      vec3Set$1(p22, positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
      vec3Set$1(p3, positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
      vec3$g.sub(v21, p12, p22);
      vec3$g.sub(v32, p22, p3);
      vec3$g.cross(n, v21, v32);
      vec3$g.normalize(n, n);
      for (var i = 0; i < 3; i++) {
        normals[i1 * 3 + i] = n[i];
        normals[i2 * 3 + i] = n[i];
        normals[i3 * 3 + i] = n[i];
      }
    }
    this.dirty();
  },
  generateTangents: function() {
    if (!this.vertexCount) {
      return;
    }
    var nVertex = this.vertexCount;
    var attributes = this.attributes;
    if (!attributes.tangent.value) {
      attributes.tangent.value = new Float32Array(nVertex * 4);
    }
    var texcoords = attributes.texcoord0.value;
    var positions = attributes.position.value;
    var tangents = attributes.tangent.value;
    var normals = attributes.normal.value;
    if (!texcoords) {
      console.warn("Geometry without texcoords can't generate tangents.");
      return;
    }
    var tan1 = [];
    var tan2 = [];
    for (var i = 0; i < nVertex; i++) {
      tan1[i] = [0, 0, 0];
      tan2[i] = [0, 0, 0];
    }
    var sdir = [0, 0, 0];
    var tdir = [0, 0, 0];
    var indices = this.indices;
    var len2 = indices ? indices.length : this.vertexCount;
    var i1, i2, i3;
    for (var i = 0; i < len2; ) {
      if (indices) {
        i1 = indices[i++];
        i2 = indices[i++];
        i3 = indices[i++];
      } else {
        i1 = i++;
        i2 = i++;
        i3 = i++;
      }
      var st1s = texcoords[i1 * 2], st2s = texcoords[i2 * 2], st3s = texcoords[i3 * 2], st1t = texcoords[i1 * 2 + 1], st2t = texcoords[i2 * 2 + 1], st3t = texcoords[i3 * 2 + 1], p1x = positions[i1 * 3], p2x = positions[i2 * 3], p3x = positions[i3 * 3], p1y = positions[i1 * 3 + 1], p2y = positions[i2 * 3 + 1], p3y = positions[i3 * 3 + 1], p1z = positions[i1 * 3 + 2], p2z = positions[i2 * 3 + 2], p3z = positions[i3 * 3 + 2];
      var x1 = p2x - p1x, x2 = p3x - p1x, y1 = p2y - p1y, y2 = p3y - p1y, z1 = p2z - p1z, z2 = p3z - p1z;
      var s1 = st2s - st1s, s2 = st3s - st1s, t1 = st2t - st1t, t2 = st3t - st1t;
      var r = 1 / (s1 * t2 - t1 * s2);
      sdir[0] = (t2 * x1 - t1 * x2) * r;
      sdir[1] = (t2 * y1 - t1 * y2) * r;
      sdir[2] = (t2 * z1 - t1 * z2) * r;
      tdir[0] = (s1 * x2 - s2 * x1) * r;
      tdir[1] = (s1 * y2 - s2 * y1) * r;
      tdir[2] = (s1 * z2 - s2 * z1) * r;
      vec3Add(tan1[i1], tan1[i1], sdir);
      vec3Add(tan1[i2], tan1[i2], sdir);
      vec3Add(tan1[i3], tan1[i3], sdir);
      vec3Add(tan2[i1], tan2[i1], tdir);
      vec3Add(tan2[i2], tan2[i2], tdir);
      vec3Add(tan2[i3], tan2[i3], tdir);
    }
    var tmp = vec3Create();
    var nCrossT = vec3Create();
    var n = vec3Create();
    for (var i = 0; i < nVertex; i++) {
      n[0] = normals[i * 3];
      n[1] = normals[i * 3 + 1];
      n[2] = normals[i * 3 + 2];
      var t = tan1[i];
      vec3$g.scale(tmp, n, vec3$g.dot(n, t));
      vec3$g.sub(tmp, t, tmp);
      vec3$g.normalize(tmp, tmp);
      vec3$g.cross(nCrossT, n, t);
      tangents[i * 4] = tmp[0];
      tangents[i * 4 + 1] = tmp[1];
      tangents[i * 4 + 2] = tmp[2];
      tangents[i * 4 + 3] = vec3$g.dot(nCrossT, tan2[i]) < 0 ? -1 : 1;
    }
    this.dirty();
  },
  isUniqueVertex: function() {
    if (this.isUseIndices()) {
      return this.vertexCount === this.indices.length;
    } else {
      return true;
    }
  },
  generateUniqueVertex: function() {
    if (!this.vertexCount || !this.indices) {
      return;
    }
    if (this.indices.length > 65535) {
      this.indices = new vendor$1.Uint32Array(this.indices);
    }
    var attributes = this.attributes;
    var indices = this.indices;
    var attributeNameList = this.getEnabledAttributes();
    var oldAttrValues = {};
    for (var a = 0; a < attributeNameList.length; a++) {
      var name = attributeNameList[a];
      oldAttrValues[name] = attributes[name].value;
      attributes[name].init(this.indices.length);
    }
    var cursor = 0;
    for (var i = 0; i < indices.length; i++) {
      var ii = indices[i];
      for (var a = 0; a < attributeNameList.length; a++) {
        var name = attributeNameList[a];
        var array = attributes[name].value;
        var size = attributes[name].size;
        for (var k = 0; k < size; k++) {
          array[cursor * size + k] = oldAttrValues[name][ii * size + k];
        }
      }
      indices[i] = cursor;
      cursor++;
    }
    this.dirty();
  },
  generateBarycentric: function() {
    if (!this.vertexCount) {
      return;
    }
    if (!this.isUniqueVertex()) {
      this.generateUniqueVertex();
    }
    var attributes = this.attributes;
    var array = attributes.barycentric.value;
    var indices = this.indices;
    if (array && array.length === indices.length * 3) {
      return;
    }
    array = attributes.barycentric.value = new Float32Array(indices.length * 3);
    for (var i = 0; i < (indices ? indices.length : this.vertexCount / 3); ) {
      for (var j = 0; j < 3; j++) {
        var ii = indices ? indices[i++] : i * 3 + j;
        array[ii * 3 + j] = 1;
      }
    }
    this.dirty();
  },
  applyTransform: function(matrix) {
    var attributes = this.attributes;
    var positions = attributes.position.value;
    var normals = attributes.normal.value;
    var tangents = attributes.tangent.value;
    matrix = matrix.array;
    var inverseTransposeMatrix = mat4$3.create();
    mat4$3.invert(inverseTransposeMatrix, matrix);
    mat4$3.transpose(inverseTransposeMatrix, inverseTransposeMatrix);
    var vec3TransformMat4 = vec3$g.transformMat4;
    var vec3ForEach = vec3$g.forEach;
    vec3ForEach(positions, 3, 0, null, vec3TransformMat4, matrix);
    if (normals) {
      vec3ForEach(normals, 3, 0, null, vec3TransformMat4, inverseTransposeMatrix);
    }
    if (tangents) {
      vec3ForEach(tangents, 4, 0, null, vec3TransformMat4, inverseTransposeMatrix);
    }
    if (this.boundingBox) {
      this.updateBoundingBox();
    }
  },
  dispose: function(renderer) {
    var cache2 = this._cache;
    cache2.use(renderer.__uid__);
    var chunks = cache2.get("chunks");
    if (chunks) {
      for (var c = 0; c < chunks.length; c++) {
        var chunk = chunks[c];
        for (var k = 0; k < chunk.attributeBuffers.length; k++) {
          var attribs = chunk.attributeBuffers[k];
          renderer.gl.deleteBuffer(attribs.buffer);
        }
        if (chunk.indicesBuffer) {
          renderer.gl.deleteBuffer(chunk.indicesBuffer.buffer);
        }
      }
    }
    if (this.__vaoCache) {
      var vaoExt = renderer.getGLExtension("OES_vertex_array_object");
      for (var id in this.__vaoCache) {
        var vao = this.__vaoCache[id].vao;
        if (vao) {
          vaoExt.deleteVertexArrayOES(vao);
        }
      }
    }
    this.__vaoCache = {};
    cache2.deleteContext(renderer.__uid__);
  }
});
Geometry.STATIC_DRAW = GeometryBase$1.STATIC_DRAW;
Geometry.DYNAMIC_DRAW = GeometryBase$1.DYNAMIC_DRAW;
Geometry.STREAM_DRAW = GeometryBase$1.STREAM_DRAW;
Geometry.AttributeBuffer = GeometryBase$1.AttributeBuffer;
Geometry.IndicesBuffer = GeometryBase$1.IndicesBuffer;
Geometry.Attribute = Attribute;
var Geometry$1 = Geometry;
var calcAmbientSHLightEssl = "vec3 calcAmbientSHLight(int idx, vec3 N) {\n int offset = 9 * idx;\n return ambientSHLightCoefficients[0]\n + ambientSHLightCoefficients[1] * N.x\n + ambientSHLightCoefficients[2] * N.y\n + ambientSHLightCoefficients[3] * N.z\n + ambientSHLightCoefficients[4] * N.x * N.z\n + ambientSHLightCoefficients[5] * N.z * N.y\n + ambientSHLightCoefficients[6] * N.y * N.x\n + ambientSHLightCoefficients[7] * (3.0 * N.z * N.z - 1.0)\n + ambientSHLightCoefficients[8] * (N.x * N.x - N.y * N.y);\n}";
var uniformVec3Prefix = "uniform vec3 ";
var uniformFloatPrefix = "uniform float ";
var exportHeaderPrefix = "@export clay.header.";
var exportEnd = "@end";
var unconfigurable = ":unconfigurable;";
var lightShader = [
  exportHeaderPrefix + "directional_light",
  uniformVec3Prefix + "directionalLightDirection[DIRECTIONAL_LIGHT_COUNT]" + unconfigurable,
  uniformVec3Prefix + "directionalLightColor[DIRECTIONAL_LIGHT_COUNT]" + unconfigurable,
  exportEnd,
  exportHeaderPrefix + "ambient_light",
  uniformVec3Prefix + "ambientLightColor[AMBIENT_LIGHT_COUNT]" + unconfigurable,
  exportEnd,
  exportHeaderPrefix + "ambient_sh_light",
  uniformVec3Prefix + "ambientSHLightColor[AMBIENT_SH_LIGHT_COUNT]" + unconfigurable,
  uniformVec3Prefix + "ambientSHLightCoefficients[AMBIENT_SH_LIGHT_COUNT * 9]" + unconfigurable,
  calcAmbientSHLightEssl,
  exportEnd,
  exportHeaderPrefix + "ambient_cubemap_light",
  uniformVec3Prefix + "ambientCubemapLightColor[AMBIENT_CUBEMAP_LIGHT_COUNT]" + unconfigurable,
  "uniform samplerCube ambientCubemapLightCubemap[AMBIENT_CUBEMAP_LIGHT_COUNT]" + unconfigurable,
  "uniform sampler2D ambientCubemapLightBRDFLookup[AMBIENT_CUBEMAP_LIGHT_COUNT]" + unconfigurable,
  exportEnd,
  exportHeaderPrefix + "point_light",
  uniformVec3Prefix + "pointLightPosition[POINT_LIGHT_COUNT]" + unconfigurable,
  uniformFloatPrefix + "pointLightRange[POINT_LIGHT_COUNT]" + unconfigurable,
  uniformVec3Prefix + "pointLightColor[POINT_LIGHT_COUNT]" + unconfigurable,
  exportEnd,
  exportHeaderPrefix + "spot_light",
  uniformVec3Prefix + "spotLightPosition[SPOT_LIGHT_COUNT]" + unconfigurable,
  uniformVec3Prefix + "spotLightDirection[SPOT_LIGHT_COUNT]" + unconfigurable,
  uniformFloatPrefix + "spotLightRange[SPOT_LIGHT_COUNT]" + unconfigurable,
  uniformFloatPrefix + "spotLightUmbraAngleCosine[SPOT_LIGHT_COUNT]" + unconfigurable,
  uniformFloatPrefix + "spotLightPenumbraAngleCosine[SPOT_LIGHT_COUNT]" + unconfigurable,
  uniformFloatPrefix + "spotLightFalloffFactor[SPOT_LIGHT_COUNT]" + unconfigurable,
  uniformVec3Prefix + "spotLightColor[SPOT_LIGHT_COUNT]" + unconfigurable,
  exportEnd
].join("\n");
Shader["import"](lightShader);
var Light = Node3D.extend(function() {
  return {
    color: [1, 1, 1],
    intensity: 1,
    castShadow: true,
    shadowResolution: 512,
    group: 0
  };
}, {
  type: "",
  clone: function() {
    var light = Node3D.prototype.clone.call(this);
    light.color = Array.prototype.slice.call(this.color);
    light.intensity = this.intensity;
    light.castShadow = this.castShadow;
    light.shadowResolution = this.shadowResolution;
    return light;
  }
});
var Light$1 = Light;
var Plane$1 = function(normal2, distance2) {
  this.normal = normal2 || new Vector3$1(0, 1, 0);
  this.distance = distance2 || 0;
};
Plane$1.prototype = {
  constructor: Plane$1,
  distanceToPoint: function(point) {
    return vec3$g.dot(point.array, this.normal.array) - this.distance;
  },
  projectPoint: function(point, out2) {
    if (!out2) {
      out2 = new Vector3$1();
    }
    var d = this.distanceToPoint(point);
    vec3$g.scaleAndAdd(out2.array, point.array, this.normal.array, -d);
    out2._dirty = true;
    return out2;
  },
  normalize: function() {
    var invLen = 1 / vec3$g.len(this.normal.array);
    vec3$g.scale(this.normal.array, invLen);
    this.distance *= invLen;
  },
  intersectFrustum: function(frustum) {
    var coords = frustum.vertices;
    var normal2 = this.normal.array;
    var onPlane = vec3$g.dot(coords[0].array, normal2) > this.distance;
    for (var i = 1; i < 8; i++) {
      if (vec3$g.dot(coords[i].array, normal2) > this.distance != onPlane) {
        return true;
      }
    }
  },
  intersectLine: function() {
    var rd = vec3$g.create();
    return function(start2, end2, out2) {
      var d0 = this.distanceToPoint(start2);
      var d1 = this.distanceToPoint(end2);
      if (d0 > 0 && d1 > 0 || d0 < 0 && d1 < 0) {
        return null;
      }
      var pn = this.normal.array;
      var d = this.distance;
      var ro = start2.array;
      vec3$g.sub(rd, end2.array, start2.array);
      vec3$g.normalize(rd, rd);
      var divider = vec3$g.dot(pn, rd);
      if (divider === 0) {
        return null;
      }
      if (!out2) {
        out2 = new Vector3$1();
      }
      var t = (vec3$g.dot(pn, ro) - d) / divider;
      vec3$g.scaleAndAdd(out2.array, ro, rd, -t);
      out2._dirty = true;
      return out2;
    };
  }(),
  applyTransform: function() {
    var inverseTranspose = mat4$3.create();
    var normalv4 = vec4$2.create();
    var pointv4 = vec4$2.create();
    pointv4[3] = 1;
    return function(m4) {
      m4 = m4.array;
      vec3$g.scale(pointv4, this.normal.array, this.distance);
      vec4$2.transformMat4(pointv4, pointv4, m4);
      this.distance = vec3$g.dot(pointv4, this.normal.array);
      mat4$3.invert(inverseTranspose, m4);
      mat4$3.transpose(inverseTranspose, inverseTranspose);
      normalv4[3] = 0;
      vec3$g.copy(normalv4, this.normal.array);
      vec4$2.transformMat4(normalv4, normalv4, inverseTranspose);
      vec3$g.copy(this.normal.array, normalv4);
    };
  }(),
  copy: function(plane) {
    vec3$g.copy(this.normal.array, plane.normal.array);
    this.normal._dirty = true;
    this.distance = plane.distance;
  },
  clone: function() {
    var plane = new Plane$1();
    plane.copy(this);
    return plane;
  }
};
var Plane$2 = Plane$1;
var vec3Set = vec3$g.set;
var vec3Copy = vec3$g.copy;
var vec3TranformMat4 = vec3$g.transformMat4;
var mathMin = Math.min;
var mathMax = Math.max;
var Frustum = function() {
  this.planes = [];
  for (var i = 0; i < 6; i++) {
    this.planes.push(new Plane$2());
  }
  this.boundingBox = new BoundingBox$1();
  this.vertices = [];
  for (var i = 0; i < 8; i++) {
    this.vertices[i] = vec3$g.fromValues(0, 0, 0);
  }
};
Frustum.prototype = {
  setFromProjection: function(projectionMatrix) {
    var planes = this.planes;
    var m2 = projectionMatrix.array;
    var m0 = m2[0], m1 = m2[1], m22 = m2[2], m3 = m2[3];
    var m4 = m2[4], m5 = m2[5], m6 = m2[6], m7 = m2[7];
    var m8 = m2[8], m9 = m2[9], m10 = m2[10], m11 = m2[11];
    var m12 = m2[12], m13 = m2[13], m14 = m2[14], m15 = m2[15];
    vec3Set(planes[0].normal.array, m3 - m0, m7 - m4, m11 - m8);
    planes[0].distance = -(m15 - m12);
    planes[0].normalize();
    vec3Set(planes[1].normal.array, m3 + m0, m7 + m4, m11 + m8);
    planes[1].distance = -(m15 + m12);
    planes[1].normalize();
    vec3Set(planes[2].normal.array, m3 + m1, m7 + m5, m11 + m9);
    planes[2].distance = -(m15 + m13);
    planes[2].normalize();
    vec3Set(planes[3].normal.array, m3 - m1, m7 - m5, m11 - m9);
    planes[3].distance = -(m15 - m13);
    planes[3].normalize();
    vec3Set(planes[4].normal.array, m3 - m22, m7 - m6, m11 - m10);
    planes[4].distance = -(m15 - m14);
    planes[4].normalize();
    vec3Set(planes[5].normal.array, m3 + m22, m7 + m6, m11 + m10);
    planes[5].distance = -(m15 + m14);
    planes[5].normalize();
    var boundingBox = this.boundingBox;
    var vertices = this.vertices;
    if (m15 === 0) {
      var aspect = m5 / m0;
      var zNear = -m14 / (m10 - 1);
      var zFar = -m14 / (m10 + 1);
      var farY = -zFar / m5;
      var nearY = -zNear / m5;
      boundingBox.min.set(-farY * aspect, -farY, zFar);
      boundingBox.max.set(farY * aspect, farY, zNear);
      vec3Set(vertices[0], -farY * aspect, -farY, zFar);
      vec3Set(vertices[1], -farY * aspect, farY, zFar);
      vec3Set(vertices[2], farY * aspect, -farY, zFar);
      vec3Set(vertices[3], farY * aspect, farY, zFar);
      vec3Set(vertices[4], -nearY * aspect, -nearY, zNear);
      vec3Set(vertices[5], -nearY * aspect, nearY, zNear);
      vec3Set(vertices[6], nearY * aspect, -nearY, zNear);
      vec3Set(vertices[7], nearY * aspect, nearY, zNear);
    } else {
      var left = (-1 - m12) / m0;
      var right = (1 - m12) / m0;
      var top = (1 - m13) / m5;
      var bottom = (-1 - m13) / m5;
      var near = (-1 - m14) / m10;
      var far = (1 - m14) / m10;
      boundingBox.min.set(Math.min(left, right), Math.min(bottom, top), Math.min(far, near));
      boundingBox.max.set(Math.max(right, left), Math.max(top, bottom), Math.max(near, far));
      var min3 = boundingBox.min.array;
      var max3 = boundingBox.max.array;
      vec3Set(vertices[0], min3[0], min3[1], min3[2]);
      vec3Set(vertices[1], min3[0], max3[1], min3[2]);
      vec3Set(vertices[2], max3[0], min3[1], min3[2]);
      vec3Set(vertices[3], max3[0], max3[1], min3[2]);
      vec3Set(vertices[4], min3[0], min3[1], max3[2]);
      vec3Set(vertices[5], min3[0], max3[1], max3[2]);
      vec3Set(vertices[6], max3[0], min3[1], max3[2]);
      vec3Set(vertices[7], max3[0], max3[1], max3[2]);
    }
  },
  getTransformedBoundingBox: function() {
    var tmpVec3 = vec3$g.create();
    return function(bbox, matrix) {
      var vertices = this.vertices;
      var m4 = matrix.array;
      var min3 = bbox.min;
      var max3 = bbox.max;
      var minArr = min3.array;
      var maxArr = max3.array;
      var v = vertices[0];
      vec3TranformMat4(tmpVec3, v, m4);
      vec3Copy(minArr, tmpVec3);
      vec3Copy(maxArr, tmpVec3);
      for (var i = 1; i < 8; i++) {
        v = vertices[i];
        vec3TranformMat4(tmpVec3, v, m4);
        minArr[0] = mathMin(tmpVec3[0], minArr[0]);
        minArr[1] = mathMin(tmpVec3[1], minArr[1]);
        minArr[2] = mathMin(tmpVec3[2], minArr[2]);
        maxArr[0] = mathMax(tmpVec3[0], maxArr[0]);
        maxArr[1] = mathMax(tmpVec3[1], maxArr[1]);
        maxArr[2] = mathMax(tmpVec3[2], maxArr[2]);
      }
      min3._dirty = true;
      max3._dirty = true;
      return bbox;
    };
  }()
};
var Frustum$1 = Frustum;
var Camera = Node3D.extend(function() {
  return {
    projectionMatrix: new Matrix4$1(),
    invProjectionMatrix: new Matrix4$1(),
    viewMatrix: new Matrix4$1(),
    frustum: new Frustum$1()
  };
}, function() {
  this.update(true);
}, {
  update: function(force) {
    Node3D.prototype.update.call(this, force);
    Matrix4$1.invert(this.viewMatrix, this.worldTransform);
    this.updateProjectionMatrix();
    Matrix4$1.invert(this.invProjectionMatrix, this.projectionMatrix);
    this.frustum.setFromProjection(this.projectionMatrix);
  },
  setViewMatrix: function(viewMatrix) {
    Matrix4$1.copy(this.viewMatrix, viewMatrix);
    Matrix4$1.invert(this.worldTransform, viewMatrix);
    this.decomposeWorldTransform();
  },
  decomposeProjectionMatrix: function() {
  },
  setProjectionMatrix: function(projectionMatrix) {
    Matrix4$1.copy(this.projectionMatrix, projectionMatrix);
    Matrix4$1.invert(this.invProjectionMatrix, projectionMatrix);
    this.decomposeProjectionMatrix();
  },
  updateProjectionMatrix: function() {
  },
  castRay: function() {
    var v4 = vec4$2.create();
    return function(ndc2, out2) {
      var ray = out2 !== void 0 ? out2 : new Ray$1();
      var x = ndc2.array[0];
      var y = ndc2.array[1];
      vec4$2.set(v4, x, y, -1, 1);
      vec4$2.transformMat4(v4, v4, this.invProjectionMatrix.array);
      vec4$2.transformMat4(v4, v4, this.worldTransform.array);
      vec3$g.scale(ray.origin.array, v4, 1 / v4[3]);
      vec4$2.set(v4, x, y, 1, 1);
      vec4$2.transformMat4(v4, v4, this.invProjectionMatrix.array);
      vec4$2.transformMat4(v4, v4, this.worldTransform.array);
      vec3$g.scale(v4, v4, 1 / v4[3]);
      vec3$g.sub(ray.direction.array, v4, ray.origin.array);
      vec3$g.normalize(ray.direction.array, ray.direction.array);
      ray.direction._dirty = true;
      ray.origin._dirty = true;
      return ray;
    };
  }()
});
var Camera$1 = Camera;
var IDENTITY = mat4$3.create();
var WORLDVIEW = mat4$3.create();
var programKeyCache = {};
function getProgramKey(lightNumbers) {
  var defineStr = [];
  var lightTypes = Object.keys(lightNumbers);
  lightTypes.sort();
  for (var i = 0; i < lightTypes.length; i++) {
    var lightType = lightTypes[i];
    defineStr.push(lightType + " " + lightNumbers[lightType]);
  }
  var key = defineStr.join("\n");
  if (programKeyCache[key]) {
    return programKeyCache[key];
  }
  var id = util$1.genGUID();
  programKeyCache[key] = id;
  return id;
}
function RenderList() {
  this.opaque = [];
  this.transparent = [];
  this._opaqueCount = 0;
  this._transparentCount = 0;
}
RenderList.prototype.startCount = function() {
  this._opaqueCount = 0;
  this._transparentCount = 0;
};
RenderList.prototype.add = function(object, isTransparent) {
  if (isTransparent) {
    this.transparent[this._transparentCount++] = object;
  } else {
    this.opaque[this._opaqueCount++] = object;
  }
};
RenderList.prototype.endCount = function() {
  this.transparent.length = this._transparentCount;
  this.opaque.length = this._opaqueCount;
};
var Scene = Node3D.extend(function() {
  return {
    material: null,
    lights: [],
    viewBoundingBoxLastFrame: new BoundingBox$1(),
    shadowUniforms: {},
    _cameraList: [],
    _lightUniforms: {},
    _previousLightNumber: {},
    _lightNumber: {},
    _lightProgramKeys: {},
    _nodeRepository: {},
    _renderLists: new LRUCache(20)
  };
}, function() {
  this._scene = this;
}, {
  addToScene: function(node) {
    if (node instanceof Camera$1) {
      if (this._cameraList.length > 0) {
        console.warn("Found multiple camera in one scene. Use the fist one.");
      }
      this._cameraList.push(node);
    } else if (node instanceof Light$1) {
      this.lights.push(node);
    }
    if (node.name) {
      this._nodeRepository[node.name] = node;
    }
  },
  removeFromScene: function(node) {
    var idx;
    if (node instanceof Camera$1) {
      idx = this._cameraList.indexOf(node);
      if (idx >= 0) {
        this._cameraList.splice(idx, 1);
      }
    } else if (node instanceof Light$1) {
      idx = this.lights.indexOf(node);
      if (idx >= 0) {
        this.lights.splice(idx, 1);
      }
    }
    if (node.name) {
      delete this._nodeRepository[node.name];
    }
  },
  getNode: function(name) {
    return this._nodeRepository[name];
  },
  setMainCamera: function(camera2) {
    var idx = this._cameraList.indexOf(camera2);
    if (idx >= 0) {
      this._cameraList.splice(idx, 1);
    }
    this._cameraList.unshift(camera2);
  },
  getMainCamera: function() {
    return this._cameraList[0];
  },
  getLights: function() {
    return this.lights;
  },
  updateLights: function() {
    var lights = this.lights;
    this._previousLightNumber = this._lightNumber;
    var lightNumber = {};
    for (var i = 0; i < lights.length; i++) {
      var light = lights[i];
      if (light.invisible) {
        continue;
      }
      var group = light.group;
      if (!lightNumber[group]) {
        lightNumber[group] = {};
      }
      lightNumber[group][light.type] = lightNumber[group][light.type] || 0;
      lightNumber[group][light.type]++;
    }
    this._lightNumber = lightNumber;
    for (var groupId in lightNumber) {
      this._lightProgramKeys[groupId] = getProgramKey(lightNumber[groupId]);
    }
    this._updateLightUniforms();
  },
  cloneNode: function(node) {
    var newNode = node.clone();
    var clonedNodesMap = {};
    function buildNodesMap(sNode, tNode) {
      clonedNodesMap[sNode.__uid__] = tNode;
      for (var i = 0; i < sNode._children.length; i++) {
        var sChild = sNode._children[i];
        var tChild = tNode._children[i];
        buildNodesMap(sChild, tChild);
      }
    }
    buildNodesMap(node, newNode);
    newNode.traverse(function(newChild) {
      if (newChild.skeleton) {
        newChild.skeleton = newChild.skeleton.clone(clonedNodesMap);
      }
      if (newChild.material) {
        newChild.material = newChild.material.clone();
      }
    });
    return newNode;
  },
  updateRenderList: function(camera2, updateSceneBoundingBox) {
    var id = camera2.__uid__;
    var renderList = this._renderLists.get(id);
    if (!renderList) {
      renderList = new RenderList();
      this._renderLists.put(id, renderList);
    }
    renderList.startCount();
    if (updateSceneBoundingBox) {
      this.viewBoundingBoxLastFrame.min.set(Infinity, Infinity, Infinity);
      this.viewBoundingBoxLastFrame.max.set(-Infinity, -Infinity, -Infinity);
    }
    var sceneMaterialTransparent = this.material && this.material.transparent || false;
    this._doUpdateRenderList(this, camera2, sceneMaterialTransparent, renderList, updateSceneBoundingBox);
    renderList.endCount();
    return renderList;
  },
  getRenderList: function(camera2) {
    return this._renderLists.get(camera2.__uid__);
  },
  _doUpdateRenderList: function(parent, camera2, sceneMaterialTransparent, renderList, updateSceneBoundingBox) {
    if (parent.invisible) {
      return;
    }
    for (var i = 0; i < parent._children.length; i++) {
      var child = parent._children[i];
      if (child.isRenderable()) {
        var worldM = child.isSkinnedMesh() ? IDENTITY : child.worldTransform.array;
        var geometry = child.geometry;
        mat4$3.multiplyAffine(WORLDVIEW, camera2.viewMatrix.array, worldM);
        if (updateSceneBoundingBox && !geometry.boundingBox || !this.isFrustumCulled(child, camera2, WORLDVIEW)) {
          renderList.add(child, child.material.transparent || sceneMaterialTransparent);
        }
      }
      if (child._children.length > 0) {
        this._doUpdateRenderList(child, camera2, sceneMaterialTransparent, renderList, updateSceneBoundingBox);
      }
    }
  },
  isFrustumCulled: function() {
    var cullingBoundingBox = new BoundingBox$1();
    var cullingMatrix = new Matrix4$1();
    return function(object, camera2, worldViewMat) {
      var geoBBox = object.boundingBox;
      if (!geoBBox) {
        if (object.skeleton && object.skeleton.boundingBox) {
          geoBBox = object.skeleton.boundingBox;
        } else {
          geoBBox = object.geometry.boundingBox;
        }
      }
      if (!geoBBox) {
        return false;
      }
      cullingMatrix.array = worldViewMat;
      cullingBoundingBox.transformFrom(geoBBox, cullingMatrix);
      if (object.castShadow) {
        this.viewBoundingBoxLastFrame.union(cullingBoundingBox);
      }
      if (object.frustumCulling) {
        if (!cullingBoundingBox.intersectBoundingBox(camera2.frustum.boundingBox)) {
          return true;
        }
        cullingMatrix.array = camera2.projectionMatrix.array;
        if (cullingBoundingBox.max.array[2] > 0 && cullingBoundingBox.min.array[2] < 0) {
          cullingBoundingBox.max.array[2] = -1e-20;
        }
        cullingBoundingBox.applyProjection(cullingMatrix);
        var min3 = cullingBoundingBox.min.array;
        var max3 = cullingBoundingBox.max.array;
        if (max3[0] < -1 || min3[0] > 1 || max3[1] < -1 || min3[1] > 1 || max3[2] < -1 || min3[2] > 1) {
          return true;
        }
      }
      return false;
    };
  }(),
  _updateLightUniforms: function() {
    var lights = this.lights;
    lights.sort(lightSortFunc);
    var lightUniforms = this._lightUniforms;
    for (var group in lightUniforms) {
      for (var symbol in lightUniforms[group]) {
        lightUniforms[group][symbol].value.length = 0;
      }
    }
    for (var i = 0; i < lights.length; i++) {
      var light = lights[i];
      if (light.invisible) {
        continue;
      }
      var group = light.group;
      for (var symbol in light.uniformTemplates) {
        var uniformTpl = light.uniformTemplates[symbol];
        var value = uniformTpl.value(light);
        if (value == null) {
          continue;
        }
        if (!lightUniforms[group]) {
          lightUniforms[group] = {};
        }
        if (!lightUniforms[group][symbol]) {
          lightUniforms[group][symbol] = {
            type: "",
            value: []
          };
        }
        var lu = lightUniforms[group][symbol];
        lu.type = uniformTpl.type + "v";
        switch (uniformTpl.type) {
          case "1i":
          case "1f":
          case "t":
            lu.value.push(value);
            break;
          case "2f":
          case "3f":
          case "4f":
            for (var j = 0; j < value.length; j++) {
              lu.value.push(value[j]);
            }
            break;
          default:
            console.error("Unkown light uniform type " + uniformTpl.type);
        }
      }
    }
  },
  getLightGroups: function() {
    var lightGroups = [];
    for (var groupId in this._lightNumber) {
      lightGroups.push(groupId);
    }
    return lightGroups;
  },
  getNumberChangedLightGroups: function() {
    var lightGroups = [];
    for (var groupId in this._lightNumber) {
      if (this.isLightNumberChanged(groupId)) {
        lightGroups.push(groupId);
      }
    }
    return lightGroups;
  },
  isLightNumberChanged: function(lightGroup) {
    var prevLightNumber = this._previousLightNumber;
    var currentLightNumber = this._lightNumber;
    for (var type in currentLightNumber[lightGroup]) {
      if (!prevLightNumber[lightGroup]) {
        return true;
      }
      if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {
        return true;
      }
    }
    for (var type in prevLightNumber[lightGroup]) {
      if (!currentLightNumber[lightGroup]) {
        return true;
      }
      if (currentLightNumber[lightGroup][type] !== prevLightNumber[lightGroup][type]) {
        return true;
      }
    }
    return false;
  },
  getLightsNumbers: function(lightGroup) {
    return this._lightNumber[lightGroup];
  },
  getProgramKey: function(lightGroup) {
    return this._lightProgramKeys[lightGroup];
  },
  setLightUniforms: function() {
    function setUniforms(uniforms, program, renderer) {
      for (var symbol in uniforms) {
        var lu = uniforms[symbol];
        if (lu.type === "tv") {
          if (!program.hasUniform(symbol)) {
            continue;
          }
          var texSlots = [];
          for (var i = 0; i < lu.value.length; i++) {
            var texture = lu.value[i];
            var slot = program.takeCurrentTextureSlot(renderer, texture);
            texSlots.push(slot);
          }
          program.setUniform(renderer.gl, "1iv", symbol, texSlots);
        } else {
          program.setUniform(renderer.gl, lu.type, symbol, lu.value);
        }
      }
    }
    return function(program, lightGroup, renderer) {
      setUniforms(this._lightUniforms[lightGroup], program, renderer);
      setUniforms(this.shadowUniforms, program, renderer);
    };
  }(),
  dispose: function() {
    this.material = null;
    this._opaqueList = [];
    this._transparentList = [];
    this.lights = [];
    this._lightUniforms = {};
    this._lightNumber = {};
    this._nodeRepository = {};
  }
});
function lightSortFunc(a, b) {
  if (b.castShadow && !a.castShadow) {
    return true;
  }
}
var Scene$1 = Scene;
var isPowerOfTwo$1 = mathUtil$1.isPowerOfTwo;
var targetList = ["px", "nx", "py", "ny", "pz", "nz"];
var TextureCube = Texture$1.extend(function() {
  return {
    image: {
      px: null,
      nx: null,
      py: null,
      ny: null,
      pz: null,
      nz: null
    },
    pixels: {
      px: null,
      nx: null,
      py: null,
      ny: null,
      pz: null,
      nz: null
    },
    mipmaps: []
  };
}, {
  textureType: "textureCube",
  update: function(renderer) {
    var _gl = renderer.gl;
    _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, this._cache.get("webgl_texture"));
    this.updateCommon(renderer);
    var glFormat = this.format;
    var glType = this.type;
    _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_S, this.getAvailableWrapS());
    _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_WRAP_T, this.getAvailableWrapT());
    _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MAG_FILTER, this.getAvailableMagFilter());
    _gl.texParameteri(_gl.TEXTURE_CUBE_MAP, _gl.TEXTURE_MIN_FILTER, this.getAvailableMinFilter());
    var anisotropicExt = renderer.getGLExtension("EXT_texture_filter_anisotropic");
    if (anisotropicExt && this.anisotropic > 1) {
      _gl.texParameterf(_gl.TEXTURE_CUBE_MAP, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropic);
    }
    if (glType === 36193) {
      var halfFloatExt = renderer.getGLExtension("OES_texture_half_float");
      if (!halfFloatExt) {
        glType = glenum.FLOAT;
      }
    }
    if (this.mipmaps.length) {
      var width = this.width;
      var height = this.height;
      for (var i = 0; i < this.mipmaps.length; i++) {
        var mipmap = this.mipmaps[i];
        this._updateTextureData(_gl, mipmap, i, width, height, glFormat, glType);
        width /= 2;
        height /= 2;
      }
    } else {
      this._updateTextureData(_gl, this, 0, this.width, this.height, glFormat, glType);
      if (!this.NPOT && this.useMipmap) {
        _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
    }
    _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
  },
  _updateTextureData: function(_gl, data, level, width, height, glFormat, glType) {
    for (var i = 0; i < 6; i++) {
      var target = targetList[i];
      var img = data.image && data.image[target];
      if (img) {
        _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, glFormat, glFormat, glType, img);
      } else {
        _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, glFormat, width, height, 0, glFormat, glType, data.pixels && data.pixels[target]);
      }
    }
  },
  generateMipmap: function(renderer) {
    var _gl = renderer.gl;
    if (this.useMipmap && !this.NPOT) {
      _gl.bindTexture(_gl.TEXTURE_CUBE_MAP, this._cache.get("webgl_texture"));
      _gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);
    }
  },
  bind: function(renderer) {
    renderer.gl.bindTexture(renderer.gl.TEXTURE_CUBE_MAP, this.getWebGLTexture(renderer));
  },
  unbind: function(renderer) {
    renderer.gl.bindTexture(renderer.gl.TEXTURE_CUBE_MAP, null);
  },
  isPowerOfTwo: function() {
    if (this.image.px) {
      return isPowerOfTwo$1(this.image.px.width) && isPowerOfTwo$1(this.image.px.height);
    } else {
      return isPowerOfTwo$1(this.width) && isPowerOfTwo$1(this.height);
    }
  },
  isRenderable: function() {
    if (this.image.px) {
      return isImageRenderable(this.image.px) && isImageRenderable(this.image.nx) && isImageRenderable(this.image.py) && isImageRenderable(this.image.ny) && isImageRenderable(this.image.pz) && isImageRenderable(this.image.nz);
    } else {
      return !!(this.width && this.height);
    }
  },
  load: function(imageList, crossOrigin) {
    var loading = 0;
    var self2 = this;
    util$1.each(imageList, function(src, target) {
      var image = vendor$1.createImage();
      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }
      image.onload = function() {
        loading--;
        if (loading === 0) {
          self2.dirty();
          self2.trigger("success", self2);
        }
      };
      image.onerror = function() {
        loading--;
      };
      loading++;
      image.src = src;
      self2.image[target] = image;
    });
    return this;
  }
});
Object.defineProperty(TextureCube.prototype, "width", {
  get: function() {
    if (this.image && this.image.px) {
      return this.image.px.width;
    }
    return this._width;
  },
  set: function(value) {
    if (this.image && this.image.px) {
      console.warn("Texture from image can't set width");
    } else {
      if (this._width !== value) {
        this.dirty();
      }
      this._width = value;
    }
  }
});
Object.defineProperty(TextureCube.prototype, "height", {
  get: function() {
    if (this.image && this.image.px) {
      return this.image.px.height;
    }
    return this._height;
  },
  set: function(value) {
    if (this.image && this.image.px) {
      console.warn("Texture from image can't set height");
    } else {
      if (this._height !== value) {
        this.dirty();
      }
      this._height = value;
    }
  }
});
function isImageRenderable(image) {
  return image.width > 0 && image.height > 0;
}
var TextureCube$1 = TextureCube;
var Perspective = Camera$1.extend({
  fov: 50,
  aspect: 1,
  near: 0.1,
  far: 2e3
}, {
  updateProjectionMatrix: function() {
    var rad2 = this.fov / 180 * Math.PI;
    this.projectionMatrix.perspective(rad2, this.aspect, this.near, this.far);
  },
  decomposeProjectionMatrix: function() {
    var m2 = this.projectionMatrix.array;
    var rad2 = Math.atan(1 / m2[5]) * 2;
    this.fov = rad2 / Math.PI * 180;
    this.aspect = m2[5] / m2[0];
    this.near = m2[14] / (m2[10] - 1);
    this.far = m2[14] / (m2[10] + 1);
  },
  clone: function() {
    var camera2 = Camera$1.prototype.clone.call(this);
    camera2.fov = this.fov;
    camera2.aspect = this.aspect;
    camera2.near = this.near;
    camera2.far = this.far;
    return camera2;
  }
});
var PerspectiveCamera = Perspective;
var KEY_FRAMEBUFFER = "framebuffer";
var KEY_RENDERBUFFER = "renderbuffer";
var KEY_RENDERBUFFER_WIDTH = KEY_RENDERBUFFER + "_width";
var KEY_RENDERBUFFER_HEIGHT = KEY_RENDERBUFFER + "_height";
var KEY_RENDERBUFFER_ATTACHED = KEY_RENDERBUFFER + "_attached";
var KEY_DEPTHTEXTURE_ATTACHED = "depthtexture_attached";
var GL_FRAMEBUFFER = glenum.FRAMEBUFFER;
var GL_RENDERBUFFER = glenum.RENDERBUFFER;
var GL_DEPTH_ATTACHMENT = glenum.DEPTH_ATTACHMENT;
var GL_COLOR_ATTACHMENT0 = glenum.COLOR_ATTACHMENT0;
var FrameBuffer = Base$1.extend({
  depthBuffer: true,
  viewport: null,
  _width: 0,
  _height: 0,
  _textures: null,
  _boundRenderer: null
}, function() {
  this._cache = new Cache$1();
  this._textures = {};
}, {
  getTextureWidth: function() {
    return this._width;
  },
  getTextureHeight: function() {
    return this._height;
  },
  bind: function(renderer) {
    if (renderer.__currentFrameBuffer) {
      if (renderer.__currentFrameBuffer === this) {
        return;
      }
      console.warn("Renderer already bound with another framebuffer. Unbind it first");
    }
    renderer.__currentFrameBuffer = this;
    var _gl = renderer.gl;
    _gl.bindFramebuffer(GL_FRAMEBUFFER, this._getFrameBufferGL(renderer));
    this._boundRenderer = renderer;
    var cache2 = this._cache;
    cache2.put("viewport", renderer.viewport);
    var hasTextureAttached = false;
    var width;
    var height;
    for (var attachment in this._textures) {
      hasTextureAttached = true;
      var obj = this._textures[attachment];
      if (obj) {
        width = obj.texture.width;
        height = obj.texture.height;
        this._doAttach(renderer, obj.texture, attachment, obj.target);
      }
    }
    this._width = width;
    this._height = height;
    if (!hasTextureAttached && this.depthBuffer) {
      console.error("Must attach texture before bind, or renderbuffer may have incorrect width and height.");
    }
    if (this.viewport) {
      renderer.setViewport(this.viewport);
    } else {
      renderer.setViewport(0, 0, width, height, 1);
    }
    var attachedTextures = cache2.get("attached_textures");
    if (attachedTextures) {
      for (var attachment in attachedTextures) {
        if (!this._textures[attachment]) {
          var target = attachedTextures[attachment];
          this._doDetach(_gl, attachment, target);
        }
      }
    }
    if (!cache2.get(KEY_DEPTHTEXTURE_ATTACHED) && this.depthBuffer) {
      if (cache2.miss(KEY_RENDERBUFFER)) {
        cache2.put(KEY_RENDERBUFFER, _gl.createRenderbuffer());
      }
      var renderbuffer = cache2.get(KEY_RENDERBUFFER);
      if (width !== cache2.get(KEY_RENDERBUFFER_WIDTH) || height !== cache2.get(KEY_RENDERBUFFER_HEIGHT)) {
        _gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer);
        _gl.renderbufferStorage(GL_RENDERBUFFER, _gl.DEPTH_COMPONENT16, width, height);
        cache2.put(KEY_RENDERBUFFER_WIDTH, width);
        cache2.put(KEY_RENDERBUFFER_HEIGHT, height);
        _gl.bindRenderbuffer(GL_RENDERBUFFER, null);
      }
      if (!cache2.get(KEY_RENDERBUFFER_ATTACHED)) {
        _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, renderbuffer);
        cache2.put(KEY_RENDERBUFFER_ATTACHED, true);
      }
    }
  },
  unbind: function(renderer) {
    renderer.__currentFrameBuffer = null;
    var _gl = renderer.gl;
    _gl.bindFramebuffer(GL_FRAMEBUFFER, null);
    this._boundRenderer = null;
    this._cache.use(renderer.__uid__);
    var viewport = this._cache.get("viewport");
    if (viewport) {
      renderer.setViewport(viewport);
    }
    this.updateMipmap(renderer);
  },
  updateMipmap: function(renderer) {
    var _gl = renderer.gl;
    for (var attachment in this._textures) {
      var obj = this._textures[attachment];
      if (obj) {
        var texture = obj.texture;
        if (!texture.NPOT && texture.useMipmap && texture.minFilter === Texture$1.LINEAR_MIPMAP_LINEAR) {
          var target = texture.textureType === "textureCube" ? glenum.TEXTURE_CUBE_MAP : glenum.TEXTURE_2D;
          _gl.bindTexture(target, texture.getWebGLTexture(renderer));
          _gl.generateMipmap(target);
          _gl.bindTexture(target, null);
        }
      }
    }
  },
  checkStatus: function(_gl) {
    return _gl.checkFramebufferStatus(GL_FRAMEBUFFER);
  },
  _getFrameBufferGL: function(renderer) {
    var cache2 = this._cache;
    cache2.use(renderer.__uid__);
    if (cache2.miss(KEY_FRAMEBUFFER)) {
      cache2.put(KEY_FRAMEBUFFER, renderer.gl.createFramebuffer());
    }
    return cache2.get(KEY_FRAMEBUFFER);
  },
  attach: function(texture, attachment, target) {
    if (!texture.width) {
      throw new Error("The texture attached to color buffer is not a valid.");
    }
    attachment = attachment || GL_COLOR_ATTACHMENT0;
    target = target || glenum.TEXTURE_2D;
    var boundRenderer = this._boundRenderer;
    var _gl = boundRenderer && boundRenderer.gl;
    var attachedTextures;
    if (_gl) {
      var cache2 = this._cache;
      cache2.use(boundRenderer.__uid__);
      attachedTextures = cache2.get("attached_textures");
    }
    var previous = this._textures[attachment];
    if (previous && previous.target === target && previous.texture === texture && (attachedTextures && attachedTextures[attachment] != null)) {
      return;
    }
    var canAttach = true;
    if (boundRenderer) {
      canAttach = this._doAttach(boundRenderer, texture, attachment, target);
      if (!this.viewport) {
        boundRenderer.setViewport(0, 0, texture.width, texture.height, 1);
      }
    }
    if (canAttach) {
      this._textures[attachment] = this._textures[attachment] || {};
      this._textures[attachment].texture = texture;
      this._textures[attachment].target = target;
    }
  },
  _doAttach: function(renderer, texture, attachment, target) {
    var _gl = renderer.gl;
    var webglTexture = texture.getWebGLTexture(renderer);
    var attachedTextures = this._cache.get("attached_textures");
    if (attachedTextures && attachedTextures[attachment]) {
      var obj = attachedTextures[attachment];
      if (obj.texture === texture && obj.target === target) {
        return;
      }
    }
    attachment = +attachment;
    var canAttach = true;
    if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {
      var extension = renderer.getGLExtension("WEBGL_depth_texture");
      if (!extension) {
        console.error("Depth texture is not supported by the browser");
        canAttach = false;
      }
      if (texture.format !== glenum.DEPTH_COMPONENT && texture.format !== glenum.DEPTH_STENCIL) {
        console.error("The texture attached to depth buffer is not a valid.");
        canAttach = false;
      }
      if (canAttach) {
        var renderbuffer = this._cache.get(KEY_RENDERBUFFER);
        if (renderbuffer) {
          _gl.framebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, null);
          _gl.deleteRenderbuffer(renderbuffer);
          this._cache.put(KEY_RENDERBUFFER, false);
        }
        this._cache.put(KEY_RENDERBUFFER_ATTACHED, false);
        this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, true);
      }
    }
    _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, webglTexture, 0);
    if (!attachedTextures) {
      attachedTextures = {};
      this._cache.put("attached_textures", attachedTextures);
    }
    attachedTextures[attachment] = attachedTextures[attachment] || {};
    attachedTextures[attachment].texture = texture;
    attachedTextures[attachment].target = target;
    return canAttach;
  },
  _doDetach: function(_gl, attachment, target) {
    _gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, target, null, 0);
    var attachedTextures = this._cache.get("attached_textures");
    if (attachedTextures && attachedTextures[attachment]) {
      attachedTextures[attachment] = null;
    }
    if (attachment === GL_DEPTH_ATTACHMENT || attachment === glenum.DEPTH_STENCIL_ATTACHMENT) {
      this._cache.put(KEY_DEPTHTEXTURE_ATTACHED, false);
    }
  },
  detach: function(attachment, target) {
    this._textures[attachment] = null;
    if (this._boundRenderer) {
      var cache2 = this._cache;
      cache2.use(this._boundRenderer.__uid__);
      this._doDetach(this._boundRenderer.gl, attachment, target);
    }
  },
  dispose: function(renderer) {
    var _gl = renderer.gl;
    var cache2 = this._cache;
    cache2.use(renderer.__uid__);
    var renderBuffer = cache2.get(KEY_RENDERBUFFER);
    if (renderBuffer) {
      _gl.deleteRenderbuffer(renderBuffer);
    }
    var frameBuffer = cache2.get(KEY_FRAMEBUFFER);
    if (frameBuffer) {
      _gl.deleteFramebuffer(frameBuffer);
    }
    cache2.deleteContext(renderer.__uid__);
    this._textures = {};
  }
});
FrameBuffer.DEPTH_ATTACHMENT = GL_DEPTH_ATTACHMENT;
FrameBuffer.COLOR_ATTACHMENT0 = GL_COLOR_ATTACHMENT0;
FrameBuffer.STENCIL_ATTACHMENT = glenum.STENCIL_ATTACHMENT;
FrameBuffer.DEPTH_STENCIL_ATTACHMENT = glenum.DEPTH_STENCIL_ATTACHMENT;
var FrameBuffer$1 = FrameBuffer;
var targets$3 = ["px", "nx", "py", "ny", "pz", "nz"];
var EnvironmentMapPass = Base$1.extend(function() {
  var ret2 = {
    position: new Vector3$1(),
    far: 1e3,
    near: 0.1,
    texture: null,
    shadowMapPass: null
  };
  var cameras = ret2._cameras = {
    px: new PerspectiveCamera({ fov: 90 }),
    nx: new PerspectiveCamera({ fov: 90 }),
    py: new PerspectiveCamera({ fov: 90 }),
    ny: new PerspectiveCamera({ fov: 90 }),
    pz: new PerspectiveCamera({ fov: 90 }),
    nz: new PerspectiveCamera({ fov: 90 })
  };
  cameras.px.lookAt(Vector3$1.POSITIVE_X, Vector3$1.NEGATIVE_Y);
  cameras.nx.lookAt(Vector3$1.NEGATIVE_X, Vector3$1.NEGATIVE_Y);
  cameras.py.lookAt(Vector3$1.POSITIVE_Y, Vector3$1.POSITIVE_Z);
  cameras.ny.lookAt(Vector3$1.NEGATIVE_Y, Vector3$1.NEGATIVE_Z);
  cameras.pz.lookAt(Vector3$1.POSITIVE_Z, Vector3$1.NEGATIVE_Y);
  cameras.nz.lookAt(Vector3$1.NEGATIVE_Z, Vector3$1.NEGATIVE_Y);
  ret2._frameBuffer = new FrameBuffer$1();
  return ret2;
}, {
  getCamera: function(target) {
    return this._cameras[target];
  },
  render: function(renderer, scene, notUpdateScene) {
    var _gl = renderer.gl;
    if (!notUpdateScene) {
      scene.update();
    }
    var n = this.texture.width;
    var fov = 2 * Math.atan(n / (n - 0.5)) / Math.PI * 180;
    for (var i = 0; i < 6; i++) {
      var target = targets$3[i];
      var camera2 = this._cameras[target];
      Vector3$1.copy(camera2.position, this.position);
      camera2.far = this.far;
      camera2.near = this.near;
      camera2.fov = fov;
      if (this.shadowMapPass) {
        camera2.update();
        var bbox = scene.getBoundingBox();
        bbox.applyTransform(camera2.viewMatrix);
        scene.viewBoundingBoxLastFrame.copy(bbox);
        this.shadowMapPass.render(renderer, scene, camera2, true);
      }
      this._frameBuffer.attach(this.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
      this._frameBuffer.bind(renderer);
      renderer.render(scene, camera2, true);
      this._frameBuffer.unbind(renderer);
    }
  },
  dispose: function(renderer) {
    this._frameBuffer.dispose(renderer);
  }
});
var EnvironmentMapPass$1 = EnvironmentMapPass;
var Plane = Geometry$1.extend({
  dynamic: false,
  widthSegments: 1,
  heightSegments: 1
}, function() {
  this.build();
}, {
  build: function() {
    var heightSegments = this.heightSegments;
    var widthSegments = this.widthSegments;
    var attributes = this.attributes;
    var positions = [];
    var texcoords = [];
    var normals = [];
    var faces = [];
    for (var y = 0; y <= heightSegments; y++) {
      var t = y / heightSegments;
      for (var x = 0; x <= widthSegments; x++) {
        var s = x / widthSegments;
        positions.push([2 * s - 1, 2 * t - 1, 0]);
        if (texcoords) {
          texcoords.push([s, t]);
        }
        if (normals) {
          normals.push([0, 0, 1]);
        }
        if (x < widthSegments && y < heightSegments) {
          var i = x + y * (widthSegments + 1);
          faces.push([i, i + 1, i + widthSegments + 1]);
          faces.push([i + widthSegments + 1, i + 1, i + widthSegments + 2]);
        }
      }
    }
    attributes.position.fromArray(positions);
    attributes.texcoord0.fromArray(texcoords);
    attributes.normal.fromArray(normals);
    this.initIndicesFromArray(faces);
    this.boundingBox = new BoundingBox$1();
    this.boundingBox.min.set(-1, -1, 0);
    this.boundingBox.max.set(1, 1, 0);
  }
});
var PlaneGeometry = Plane;
var planeMatrix = new Matrix4$1();
var Cube = Geometry$1.extend({
  dynamic: false,
  widthSegments: 1,
  heightSegments: 1,
  depthSegments: 1,
  inside: false
}, function() {
  this.build();
}, {
  build: function() {
    var planes = {
      "px": createPlane("px", this.depthSegments, this.heightSegments),
      "nx": createPlane("nx", this.depthSegments, this.heightSegments),
      "py": createPlane("py", this.widthSegments, this.depthSegments),
      "ny": createPlane("ny", this.widthSegments, this.depthSegments),
      "pz": createPlane("pz", this.widthSegments, this.heightSegments),
      "nz": createPlane("nz", this.widthSegments, this.heightSegments)
    };
    var attrList = ["position", "texcoord0", "normal"];
    var vertexNumber = 0;
    var faceNumber = 0;
    for (var pos in planes) {
      vertexNumber += planes[pos].vertexCount;
      faceNumber += planes[pos].indices.length;
    }
    for (var k = 0; k < attrList.length; k++) {
      this.attributes[attrList[k]].init(vertexNumber);
    }
    this.indices = new vendor$1.Uint16Array(faceNumber);
    var faceOffset = 0;
    var vertexOffset = 0;
    for (var pos in planes) {
      var plane = planes[pos];
      for (var k = 0; k < attrList.length; k++) {
        var attrName = attrList[k];
        var attrArray = plane.attributes[attrName].value;
        var attrSize = plane.attributes[attrName].size;
        var isNormal = attrName === "normal";
        for (var i = 0; i < attrArray.length; i++) {
          var value = attrArray[i];
          if (this.inside && isNormal) {
            value = -value;
          }
          this.attributes[attrName].value[i + attrSize * vertexOffset] = value;
        }
      }
      var len2 = plane.indices.length;
      for (var i = 0; i < plane.indices.length; i++) {
        this.indices[i + faceOffset] = vertexOffset + plane.indices[this.inside ? len2 - i - 1 : i];
      }
      faceOffset += plane.indices.length;
      vertexOffset += plane.vertexCount;
    }
    this.boundingBox = new BoundingBox$1();
    this.boundingBox.max.set(1, 1, 1);
    this.boundingBox.min.set(-1, -1, -1);
  }
});
function createPlane(pos, widthSegments, heightSegments) {
  planeMatrix.identity();
  var plane = new PlaneGeometry({
    widthSegments,
    heightSegments
  });
  switch (pos) {
    case "px":
      Matrix4$1.translate(planeMatrix, planeMatrix, Vector3$1.POSITIVE_X);
      Matrix4$1.rotateY(planeMatrix, planeMatrix, Math.PI / 2);
      break;
    case "nx":
      Matrix4$1.translate(planeMatrix, planeMatrix, Vector3$1.NEGATIVE_X);
      Matrix4$1.rotateY(planeMatrix, planeMatrix, -Math.PI / 2);
      break;
    case "py":
      Matrix4$1.translate(planeMatrix, planeMatrix, Vector3$1.POSITIVE_Y);
      Matrix4$1.rotateX(planeMatrix, planeMatrix, -Math.PI / 2);
      break;
    case "ny":
      Matrix4$1.translate(planeMatrix, planeMatrix, Vector3$1.NEGATIVE_Y);
      Matrix4$1.rotateX(planeMatrix, planeMatrix, Math.PI / 2);
      break;
    case "pz":
      Matrix4$1.translate(planeMatrix, planeMatrix, Vector3$1.POSITIVE_Z);
      break;
    case "nz":
      Matrix4$1.translate(planeMatrix, planeMatrix, Vector3$1.NEGATIVE_Z);
      Matrix4$1.rotateY(planeMatrix, planeMatrix, Math.PI);
      break;
  }
  plane.applyTransform(planeMatrix);
  return plane;
}
var CubeGeometry = Cube;
var skyboxEssl = "@export clay.skybox.vertex\n#define SHADER_NAME skybox\nuniform mat4 world : WORLD;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nattribute vec3 position : POSITION;\nvarying vec3 v_WorldPosition;\nvoid main()\n{\n v_WorldPosition = (world * vec4(position, 1.0)).xyz;\n gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n@end\n@export clay.skybox.fragment\n#define PI 3.1415926\nuniform mat4 viewInverse : VIEWINVERSE;\n#ifdef EQUIRECTANGULAR\nuniform sampler2D environmentMap;\n#else\nuniform samplerCube environmentMap;\n#endif\nuniform float lod: 0.0;\nvarying vec3 v_WorldPosition;\n@import clay.util.rgbm\n@import clay.util.srgb\n@import clay.util.ACES\nvoid main()\n{\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(v_WorldPosition - eyePos);\n#ifdef EQUIRECTANGULAR\n float phi = acos(V.y);\n float theta = atan(-V.x, V.z) + PI * 0.5;\n vec2 uv = vec2(theta / 2.0 / PI, phi / PI);\n vec4 texel = decodeHDR(texture2D(environmentMap, fract(uv)));\n#else\n #if defined(LOD) || defined(SUPPORT_TEXTURE_LOD)\n vec4 texel = decodeHDR(textureCubeLodEXT(environmentMap, V, lod));\n #else\n vec4 texel = decodeHDR(textureCube(environmentMap, V));\n #endif\n#endif\n#ifdef SRGB_DECODE\n texel = sRGBToLinear(texel);\n#endif\n#ifdef TONEMAPPING\n texel.rgb = ACESToneMapping(texel.rgb);\n#endif\n#ifdef SRGB_ENCODE\n texel = linearTosRGB(texel);\n#endif\n gl_FragColor = encodeHDR(vec4(texel.rgb, 1.0));\n}\n@end";
Shader.import(skyboxEssl);
var Skybox = Mesh$1.extend(function() {
  var skyboxShader = new Shader({
    vertex: Shader.source("clay.skybox.vertex"),
    fragment: Shader.source("clay.skybox.fragment")
  });
  var material = new Material$1({
    shader: skyboxShader,
    depthMask: false
  });
  return {
    scene: null,
    geometry: new CubeGeometry(),
    material,
    environmentMap: null,
    culling: false,
    _dummyCamera: new PerspectiveCamera()
  };
}, function() {
  var scene = this.scene;
  if (scene) {
    this.attachScene(scene);
  }
  if (this.environmentMap) {
    this.setEnvironmentMap(this.environmentMap);
  }
}, {
  attachScene: function(scene) {
    if (this.scene) {
      this.detachScene();
    }
    scene.skybox = this;
    this.scene = scene;
    scene.on("beforerender", this._beforeRenderScene, this);
  },
  detachScene: function() {
    if (this.scene) {
      this.scene.off("beforerender", this._beforeRenderScene);
      this.scene.skybox = null;
    }
    this.scene = null;
  },
  dispose: function(renderer) {
    this.detachScene();
    this.geometry.dispose(renderer);
  },
  setEnvironmentMap: function(envMap) {
    if (envMap.textureType === "texture2D") {
      this.material.define("EQUIRECTANGULAR");
      envMap.minFilter = Texture$1.LINEAR;
    } else {
      this.material.undefine("EQUIRECTANGULAR");
    }
    this.material.set("environmentMap", envMap);
  },
  getEnvironmentMap: function() {
    return this.material.get("environmentMap");
  },
  _beforeRenderScene: function(renderer, scene, camera2) {
    this.renderSkybox(renderer, camera2);
  },
  renderSkybox: function(renderer, camera2) {
    var dummyCamera = this._dummyCamera;
    dummyCamera.aspect = renderer.getViewportAspect();
    dummyCamera.fov = camera2.fov || 50;
    dummyCamera.updateProjectionMatrix();
    Matrix4$1.invert(dummyCamera.invProjectionMatrix, dummyCamera.projectionMatrix);
    dummyCamera.worldTransform.copy(camera2.worldTransform);
    dummyCamera.viewMatrix.copy(camera2.viewMatrix);
    this.position.copy(camera2.getWorldPosition());
    this.update();
    renderer.gl.disable(renderer.gl.BLEND);
    if (this.material.get("lod") > 0) {
      this.material.define("fragment", "LOD");
    } else {
      this.material.undefine("fragment", "LOD");
    }
    renderer.renderPass([this], dummyCamera);
  }
});
var Skybox$1 = Skybox;
var DDS_MAGIC = 542327876;
var DDSD_MIPMAPCOUNT = 131072;
var DDSCAPS2_CUBEMAP = 512;
var DDPF_FOURCC = 4;
function fourCCToInt32(value) {
  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
var headerLengthInt = 31;
var FOURCC_DXT1 = fourCCToInt32("DXT1");
var FOURCC_DXT3 = fourCCToInt32("DXT3");
var FOURCC_DXT5 = fourCCToInt32("DXT5");
var off_magic = 0;
var off_size = 1;
var off_flags = 2;
var off_height = 3;
var off_width = 4;
var off_mipmapCount = 7;
var off_pfFlags = 20;
var off_pfFourCC = 21;
var off_caps2 = 28;
var ret$1 = {
  parse: function(arrayBuffer, out2) {
    var header = new Int32Array(arrayBuffer, 0, headerLengthInt);
    if (header[off_magic] !== DDS_MAGIC) {
      return null;
    }
    if (!header(off_pfFlags) & DDPF_FOURCC) {
      return null;
    }
    var fourCC = header(off_pfFourCC);
    var width = header[off_width];
    var height = header[off_height];
    var isCubeMap = header[off_caps2] & DDSCAPS2_CUBEMAP;
    var hasMipmap = header[off_flags] & DDSD_MIPMAPCOUNT;
    var blockBytes, internalFormat;
    switch (fourCC) {
      case FOURCC_DXT1:
        blockBytes = 8;
        internalFormat = Texture$1.COMPRESSED_RGB_S3TC_DXT1_EXT;
        break;
      case FOURCC_DXT3:
        blockBytes = 16;
        internalFormat = Texture$1.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        break;
      case FOURCC_DXT5:
        blockBytes = 16;
        internalFormat = Texture$1.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        break;
      default:
        return null;
    }
    var dataOffset = header[off_size] + 4;
    var faceNumber = isCubeMap ? 6 : 1;
    var mipmapCount = 1;
    if (hasMipmap) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    var textures = [];
    for (var f = 0; f < faceNumber; f++) {
      var _width = width;
      var _height = height;
      textures[f] = new Texture2D$1({
        width: _width,
        height: _height,
        format: internalFormat
      });
      var mipmaps = [];
      for (var i = 0; i < mipmapCount; i++) {
        var dataLength = Math.max(4, _width) / 4 * Math.max(4, _height) / 4 * blockBytes;
        var byteArray = new Uint8Array(arrayBuffer, dataOffset, dataLength);
        dataOffset += dataLength;
        _width *= 0.5;
        _height *= 0.5;
        mipmaps[i] = byteArray;
      }
      textures[f].pixels = mipmaps[0];
      if (hasMipmap) {
        textures[f].mipmaps = mipmaps;
      }
    }
    if (out2) {
      out2.width = textures[0].width;
      out2.height = textures[0].height;
      out2.format = textures[0].format;
      out2.pixels = textures[0].pixels;
      out2.mipmaps = textures[0].mipmaps;
    } else {
      return textures[0];
    }
  }
};
var dds = ret$1;
var toChar = String.fromCharCode;
var MINELEN = 8;
var MAXELEN = 32767;
function rgbe2float(rgbe, buffer, offset, exposure) {
  if (rgbe[3] > 0) {
    var f = Math.pow(2, rgbe[3] - 128 - 8 + exposure);
    buffer[offset + 0] = rgbe[0] * f;
    buffer[offset + 1] = rgbe[1] * f;
    buffer[offset + 2] = rgbe[2] * f;
  } else {
    buffer[offset + 0] = 0;
    buffer[offset + 1] = 0;
    buffer[offset + 2] = 0;
  }
  buffer[offset + 3] = 1;
  return buffer;
}
function uint82string(array, offset, size) {
  var str = "";
  for (var i = offset; i < size; i++) {
    str += toChar(array[i]);
  }
  return str;
}
function copyrgbe(s, t) {
  t[0] = s[0];
  t[1] = s[1];
  t[2] = s[2];
  t[3] = s[3];
}
function oldReadColors(scan, buffer, offset, xmax) {
  var rshift = 0, x = 0, len2 = xmax;
  while (len2 > 0) {
    scan[x][0] = buffer[offset++];
    scan[x][1] = buffer[offset++];
    scan[x][2] = buffer[offset++];
    scan[x][3] = buffer[offset++];
    if (scan[x][0] === 1 && scan[x][1] === 1 && scan[x][2] === 1) {
      for (var i = scan[x][3] << rshift >>> 0; i > 0; i--) {
        copyrgbe(scan[x - 1], scan[x]);
        x++;
        len2--;
      }
      rshift += 8;
    } else {
      x++;
      len2--;
      rshift = 0;
    }
  }
  return offset;
}
function readColors(scan, buffer, offset, xmax) {
  if (xmax < MINELEN | xmax > MAXELEN) {
    return oldReadColors(scan, buffer, offset, xmax);
  }
  var i = buffer[offset++];
  if (i != 2) {
    return oldReadColors(scan, buffer, offset - 1, xmax);
  }
  scan[0][1] = buffer[offset++];
  scan[0][2] = buffer[offset++];
  i = buffer[offset++];
  if ((scan[0][2] << 8 >>> 0 | i) >>> 0 !== xmax) {
    return null;
  }
  for (var i = 0; i < 4; i++) {
    for (var x = 0; x < xmax; ) {
      var code = buffer[offset++];
      if (code > 128) {
        code = (code & 127) >>> 0;
        var val = buffer[offset++];
        while (code--) {
          scan[x++][i] = val;
        }
      } else {
        while (code--) {
          scan[x++][i] = buffer[offset++];
        }
      }
    }
  }
  return offset;
}
var ret = {
  parseRGBE: function(arrayBuffer, texture, exposure) {
    if (exposure == null) {
      exposure = 0;
    }
    var data = new Uint8Array(arrayBuffer);
    var size = data.length;
    if (uint82string(data, 0, 2) !== "#?") {
      return;
    }
    for (var i = 2; i < size; i++) {
      if (toChar(data[i]) === "\n" && toChar(data[i + 1]) === "\n") {
        break;
      }
    }
    if (i >= size) {
      return;
    }
    i += 2;
    var str = "";
    for (; i < size; i++) {
      var _char = toChar(data[i]);
      if (_char === "\n") {
        break;
      }
      str += _char;
    }
    var tmp = str.split(" ");
    var height = parseInt(tmp[1]);
    var width = parseInt(tmp[3]);
    if (!width || !height) {
      return;
    }
    var offset = i + 1;
    var scanline = [];
    for (var x = 0; x < width; x++) {
      scanline[x] = [];
      for (var j = 0; j < 4; j++) {
        scanline[x][j] = 0;
      }
    }
    var pixels = new Float32Array(width * height * 4);
    var offset2 = 0;
    for (var y = 0; y < height; y++) {
      var offset = readColors(scanline, data, offset, width);
      if (!offset) {
        return null;
      }
      for (var x = 0; x < width; x++) {
        rgbe2float(scanline[x], pixels, offset2, exposure);
        offset2 += 4;
      }
    }
    if (!texture) {
      texture = new Texture2D$1();
    }
    texture.width = width;
    texture.height = height;
    texture.pixels = pixels;
    texture.type = Texture$1.FLOAT;
    return texture;
  },
  parseRGBEFromPNG: function(png) {
  }
};
var hdr = ret;
var textureUtil = {
  loadTexture: function(path, option, onsuccess, onerror) {
    var texture;
    if (typeof option === "function") {
      onsuccess = option;
      onerror = onsuccess;
      option = {};
    } else {
      option = option || {};
    }
    if (typeof path === "string") {
      if (path.match(/.hdr$/) || option.fileType === "hdr") {
        texture = new Texture2D$1({
          width: 0,
          height: 0,
          sRGB: false
        });
        textureUtil._fetchTexture(path, function(data) {
          hdr.parseRGBE(data, texture, option.exposure);
          texture.dirty();
          onsuccess && onsuccess(texture);
        }, onerror);
        return texture;
      } else if (path.match(/.dds$/) || option.fileType === "dds") {
        texture = new Texture2D$1({
          width: 0,
          height: 0
        });
        textureUtil._fetchTexture(path, function(data) {
          dds.parse(data, texture);
          texture.dirty();
          onsuccess && onsuccess(texture);
        }, onerror);
      } else {
        texture = new Texture2D$1();
        texture.load(path);
        texture.success(onsuccess);
        texture.error(onerror);
      }
    } else if (typeof path === "object" && typeof path.px !== "undefined") {
      texture = new TextureCube$1();
      texture.load(path);
      texture.success(onsuccess);
      texture.error(onerror);
    }
    return texture;
  },
  loadPanorama: function(renderer, path, cubeMap, option, onsuccess, onerror) {
    var self2 = this;
    if (typeof option === "function") {
      onsuccess = option;
      onerror = onsuccess;
      option = {};
    } else {
      option = option || {};
    }
    textureUtil.loadTexture(path, option, function(texture) {
      texture.flipY = option.flipY || false;
      self2.panoramaToCubeMap(renderer, texture, cubeMap, option);
      texture.dispose(renderer);
      onsuccess && onsuccess(cubeMap);
    }, onerror);
  },
  panoramaToCubeMap: function(renderer, panoramaMap, cubeMap, option) {
    var environmentMapPass = new EnvironmentMapPass$1();
    var skydome = new Skybox$1({
      scene: new Scene$1()
    });
    skydome.setEnvironmentMap(panoramaMap);
    option = option || {};
    if (option.encodeRGBM) {
      skydome.material.define("fragment", "RGBM_ENCODE");
    }
    cubeMap.sRGB = panoramaMap.sRGB;
    environmentMapPass.texture = cubeMap;
    environmentMapPass.render(renderer, skydome.scene);
    environmentMapPass.texture = null;
    environmentMapPass.dispose(renderer);
    return cubeMap;
  },
  heightToNormal: function(image, checkBump) {
    var canvas = document.createElement("canvas");
    var width = canvas.width = image.width;
    var height = canvas.height = image.height;
    var ctx = canvas.getContext("2d");
    ctx.drawImage(image, 0, 0, width, height);
    checkBump = checkBump || false;
    var srcData = ctx.getImageData(0, 0, width, height);
    var dstData = ctx.createImageData(width, height);
    for (var i = 0; i < srcData.data.length; i += 4) {
      if (checkBump) {
        var r = srcData.data[i];
        var g2 = srcData.data[i + 1];
        var b = srcData.data[i + 2];
        var diff = Math.abs(r - g2) + Math.abs(g2 - b);
        if (diff > 20) {
          console.warn("Given image is not a height map");
          return image;
        }
      }
      var x1, y1, x2, y2;
      if (i % (width * 4) === 0) {
        x1 = srcData.data[i];
        x2 = srcData.data[i + 4];
      } else if (i % (width * 4) === (width - 1) * 4) {
        x1 = srcData.data[i - 4];
        x2 = srcData.data[i];
      } else {
        x1 = srcData.data[i - 4];
        x2 = srcData.data[i + 4];
      }
      if (i < width * 4) {
        y1 = srcData.data[i];
        y2 = srcData.data[i + width * 4];
      } else if (i > width * (height - 1) * 4) {
        y1 = srcData.data[i - width * 4];
        y2 = srcData.data[i];
      } else {
        y1 = srcData.data[i - width * 4];
        y2 = srcData.data[i + width * 4];
      }
      dstData.data[i] = x1 - x2 + 127;
      dstData.data[i + 1] = y1 - y2 + 127;
      dstData.data[i + 2] = 255;
      dstData.data[i + 3] = 255;
    }
    ctx.putImageData(dstData, 0, 0);
    return canvas;
  },
  isHeightImage: function(img, downScaleSize, threshold) {
    if (!img || !img.width || !img.height) {
      return false;
    }
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    var size = downScaleSize || 32;
    threshold = threshold || 20;
    canvas.width = canvas.height = size;
    ctx.drawImage(img, 0, 0, size, size);
    var srcData = ctx.getImageData(0, 0, size, size);
    for (var i = 0; i < srcData.data.length; i += 4) {
      var r = srcData.data[i];
      var g2 = srcData.data[i + 1];
      var b = srcData.data[i + 2];
      var diff = Math.abs(r - g2) + Math.abs(g2 - b);
      if (diff > threshold) {
        return false;
      }
    }
    return true;
  },
  _fetchTexture: function(path, onsuccess, onerror) {
    vendor$1.request.get({
      url: path,
      responseType: "arraybuffer",
      onload: onsuccess,
      onerror
    });
  },
  createChessboard: function(size, unitSize, color1, color2) {
    size = size || 512;
    unitSize = unitSize || 64;
    color1 = color1 || "black";
    color2 = color2 || "white";
    var repeat = Math.ceil(size / unitSize);
    var canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = color2;
    ctx.fillRect(0, 0, size, size);
    ctx.fillStyle = color1;
    for (var i = 0; i < repeat; i++) {
      for (var j = 0; j < repeat; j++) {
        var isFill = j % 2 ? i % 2 : i % 2 - 1;
        if (isFill) {
          ctx.fillRect(i * unitSize, j * unitSize, unitSize, unitSize);
        }
      }
    }
    var texture = new Texture2D$1({
      image: canvas,
      anisotropic: 8
    });
    return texture;
  },
  createBlank: function(color) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = color;
    ctx.fillRect(0, 0, 1, 1);
    var texture = new Texture2D$1({
      image: canvas
    });
    return texture;
  }
};
var textureUtil$1 = textureUtil;
var events = ["mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "click", "dblclick", "contextmenu"];
function makeHandlerName(eventName) {
  return "_on" + eventName;
}
var EChartsSurface = function(chart) {
  var self2 = this;
  this._texture = new Texture2D$1({
    anisotropic: 32,
    flipY: false,
    surface: this,
    dispose: function(renderer) {
      self2.dispose();
      Texture2D$1.prototype.dispose.call(this, renderer);
    }
  });
  events.forEach(function(eventName) {
    this[makeHandlerName(eventName)] = function(eveObj) {
      if (!eveObj.triangle) {
        return;
      }
      this._meshes.forEach(function(mesh2) {
        this.dispatchEvent(eventName, mesh2, eveObj.triangle, eveObj.point);
      }, this);
    };
  }, this);
  this._meshes = [];
  if (chart) {
    this.setECharts(chart);
  }
  this.onupdate = null;
};
EChartsSurface.prototype = {
  constructor: EChartsSurface,
  getTexture: function() {
    return this._texture;
  },
  setECharts: function(chart) {
    this._chart = chart;
    var canvas = chart.getDom();
    if (!(canvas instanceof HTMLCanvasElement)) {
      console.error("ECharts must init on canvas if it is used as texture.");
      canvas = document.createElement("canvas");
    } else {
      var self2 = this;
      var zr = chart.getZr();
      var oldRefreshImmediately = zr.__oldRefreshImmediately || zr.refreshImmediately;
      zr.refreshImmediately = function() {
        oldRefreshImmediately.call(this);
        self2._texture.dirty();
        self2.onupdate && self2.onupdate();
      };
      zr.__oldRefreshImmediately = oldRefreshImmediately;
    }
    this._texture.image = canvas;
    this._texture.dirty();
    this.onupdate && this.onupdate();
  },
  dispatchEvent: function() {
    var p02 = new Vector3$1();
    var p12 = new Vector3$1();
    var p22 = new Vector3$1();
    var uv0 = new Vector2$1();
    var uv1 = new Vector2$1();
    var uv2 = new Vector2$1();
    var uv = new Vector2$1();
    var vCross = new Vector3$1();
    return function(eventName, attachedMesh, triangle, point) {
      var geo = attachedMesh.geometry;
      var position2 = geo.attributes.position;
      var texcoord = geo.attributes.texcoord0;
      var dot = Vector3$1.dot;
      var cross2 = Vector3$1.cross;
      position2.get(triangle[0], p02.array);
      position2.get(triangle[1], p12.array);
      position2.get(triangle[2], p22.array);
      texcoord.get(triangle[0], uv0.array);
      texcoord.get(triangle[1], uv1.array);
      texcoord.get(triangle[2], uv2.array);
      cross2(vCross, p12, p22);
      var det = dot(p02, vCross);
      var t = dot(point, vCross) / det;
      cross2(vCross, p22, p02);
      var u = dot(point, vCross) / det;
      cross2(vCross, p02, p12);
      var v = dot(point, vCross) / det;
      Vector2$1.scale(uv, uv0, t);
      Vector2$1.scaleAndAdd(uv, uv, uv1, u);
      Vector2$1.scaleAndAdd(uv, uv, uv2, v);
      var x = uv.x * this._chart.getWidth();
      var y = uv.y * this._chart.getHeight();
      this._chart.getZr().handler.dispatch(eventName, {
        zrX: x,
        zrY: y
      });
    };
  }(),
  attachToMesh: function(mesh2) {
    if (this._meshes.indexOf(mesh2) >= 0) {
      return;
    }
    events.forEach(function(eventName) {
      mesh2.on(eventName, this[makeHandlerName(eventName)], this);
    }, this);
    this._meshes.push(mesh2);
  },
  detachFromMesh: function(mesh2) {
    var idx = this._meshes.indexOf(mesh2);
    if (idx >= 0) {
      this._meshes.splice(idx, 1);
    }
    events.forEach(function(eventName) {
      mesh2.off(eventName, this[makeHandlerName(eventName)]);
    }, this);
  },
  dispose: function() {
    this._meshes.forEach(function(mesh2) {
      this.detachFromMesh(mesh2);
    }, this);
  }
};
var EChartsSurface$1 = EChartsSurface;
var Orthographic = Camera$1.extend({
  left: -1,
  right: 1,
  near: -1,
  far: 1,
  top: 1,
  bottom: -1
}, {
  updateProjectionMatrix: function() {
    this.projectionMatrix.ortho(this.left, this.right, this.bottom, this.top, this.near, this.far);
  },
  decomposeProjectionMatrix: function() {
    var m2 = this.projectionMatrix.array;
    this.left = (-1 - m2[12]) / m2[0];
    this.right = (1 - m2[12]) / m2[0];
    this.top = (1 - m2[13]) / m2[5];
    this.bottom = (-1 - m2[13]) / m2[5];
    this.near = -(-1 - m2[14]) / m2[10];
    this.far = -(1 - m2[14]) / m2[10];
  },
  clone: function() {
    var camera2 = Camera$1.prototype.clone.call(this);
    camera2.left = this.left;
    camera2.right = this.right;
    camera2.near = this.near;
    camera2.far = this.far;
    camera2.top = this.top;
    camera2.bottom = this.bottom;
    return camera2;
  }
});
var OrthoCamera = Orthographic;
var vertexGlsl = "\n@export clay.compositor.vertex\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nvarying vec2 v_Texcoord;\nvoid main()\n{\n v_Texcoord = texcoord;\n gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n@end";
Shader["import"](vertexGlsl);
var planeGeo = new PlaneGeometry();
var mesh = new Mesh$1({
  geometry: planeGeo,
  frustumCulling: false
});
var camera = new OrthoCamera();
var Pass = Base$1.extend(function() {
  return {
    fragment: "",
    outputs: null,
    material: null,
    blendWithPrevious: false,
    clearColor: false,
    clearDepth: true
  };
}, function() {
  var shader = new Shader(Shader.source("clay.compositor.vertex"), this.fragment);
  var material = new Material$1({
    shader
  });
  material.enableTexturesAll();
  this.material = material;
}, {
  setUniform: function(name, value) {
    this.material.setUniform(name, value);
  },
  getUniform: function(name) {
    var uniform = this.material.uniforms[name];
    if (uniform) {
      return uniform.value;
    }
  },
  attachOutput: function(texture, attachment) {
    if (!this.outputs) {
      this.outputs = {};
    }
    attachment = attachment || glenum.COLOR_ATTACHMENT0;
    this.outputs[attachment] = texture;
  },
  detachOutput: function(texture) {
    for (var attachment in this.outputs) {
      if (this.outputs[attachment] === texture) {
        this.outputs[attachment] = null;
      }
    }
  },
  bind: function(renderer, frameBuffer) {
    if (this.outputs) {
      for (var attachment in this.outputs) {
        var texture = this.outputs[attachment];
        if (texture) {
          frameBuffer.attach(texture, attachment);
        }
      }
    }
    if (frameBuffer) {
      frameBuffer.bind(renderer);
    }
  },
  unbind: function(renderer, frameBuffer) {
    frameBuffer.unbind(renderer);
  },
  render: function(renderer, frameBuffer) {
    var _gl = renderer.gl;
    if (frameBuffer) {
      this.bind(renderer, frameBuffer);
      var ext = renderer.getGLExtension("EXT_draw_buffers");
      if (ext && this.outputs) {
        var bufs = [];
        for (var attachment in this.outputs) {
          attachment = +attachment;
          if (attachment >= _gl.COLOR_ATTACHMENT0 && attachment <= _gl.COLOR_ATTACHMENT0 + 8) {
            bufs.push(attachment);
          }
        }
        ext.drawBuffersEXT(bufs);
      }
    }
    this.trigger("beforerender", this, renderer);
    var clearBit = this.clearDepth ? _gl.DEPTH_BUFFER_BIT : 0;
    _gl.depthMask(true);
    if (this.clearColor) {
      clearBit = clearBit | _gl.COLOR_BUFFER_BIT;
      _gl.colorMask(true, true, true, true);
      var cc = this.clearColor;
      if (Array.isArray(cc)) {
        _gl.clearColor(cc[0], cc[1], cc[2], cc[3]);
      }
    }
    _gl.clear(clearBit);
    if (this.blendWithPrevious) {
      _gl.enable(_gl.BLEND);
      this.material.transparent = true;
    } else {
      _gl.disable(_gl.BLEND);
      this.material.transparent = false;
    }
    this.renderQuad(renderer);
    this.trigger("afterrender", this, renderer);
    if (frameBuffer) {
      this.unbind(renderer, frameBuffer);
    }
  },
  renderQuad: function(renderer) {
    mesh.material = this.material;
    renderer.renderPass([mesh], camera);
  },
  dispose: function(renderer) {
  }
});
var Pass$1 = Pass;
var integrateBRDFShaderCode = "#define SAMPLE_NUMBER 1024\n#define PI 3.14159265358979\nuniform sampler2D normalDistribution;\nuniform vec2 viewportSize : [512, 256];\nconst vec3 N = vec3(0.0, 0.0, 1.0);\nconst float fSampleNumber = float(SAMPLE_NUMBER);\nvec3 importanceSampleNormal(float i, float roughness, vec3 N) {\n vec3 H = texture2D(normalDistribution, vec2(roughness, i)).rgb;\n vec3 upVector = abs(N.y) > 0.999 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n vec3 tangentX = normalize(cross(N, upVector));\n vec3 tangentZ = cross(N, tangentX);\n return normalize(tangentX * H.x + N * H.y + tangentZ * H.z);\n}\nfloat G_Smith(float roughness, float NoV, float NoL) {\n float k = roughness * roughness / 2.0;\n float G1V = NoV / (NoV * (1.0 - k) + k);\n float G1L = NoL / (NoL * (1.0 - k) + k);\n return G1L * G1V;\n}\nvoid main() {\n vec2 uv = gl_FragCoord.xy / viewportSize;\n float NoV = uv.x;\n float roughness = uv.y;\n vec3 V;\n V.x = sqrt(1.0 - NoV * NoV);\n V.y = 0.0;\n V.z = NoV;\n float A = 0.0;\n float B = 0.0;\n for (int i = 0; i < SAMPLE_NUMBER; i++) {\n vec3 H = importanceSampleNormal(float(i) / fSampleNumber, roughness, N);\n vec3 L = reflect(-V, H);\n float NoL = clamp(L.z, 0.0, 1.0);\n float NoH = clamp(H.z, 0.0, 1.0);\n float VoH = clamp(dot(V, H), 0.0, 1.0);\n if (NoL > 0.0) {\n float G = G_Smith(roughness, NoV, NoL);\n float G_Vis = G * VoH / (NoH * NoV);\n float Fc = pow(1.0 - VoH, 5.0);\n A += (1.0 - Fc) * G_Vis;\n B += Fc * G_Vis;\n }\n }\n gl_FragColor = vec4(vec2(A, B) / fSampleNumber, 0.0, 1.0);\n}\n";
var prefilterFragCode = "#define SHADER_NAME prefilter\n#define SAMPLE_NUMBER 1024\n#define PI 3.14159265358979\nuniform mat4 viewInverse : VIEWINVERSE;\nuniform samplerCube environmentMap;\nuniform sampler2D normalDistribution;\nuniform float roughness : 0.5;\nvarying vec2 v_Texcoord;\nvarying vec3 v_WorldPosition;\n@import clay.util.rgbm\nvec3 importanceSampleNormal(float i, float roughness, vec3 N) {\n vec3 H = texture2D(normalDistribution, vec2(roughness, i)).rgb;\n vec3 upVector = abs(N.y) > 0.999 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n vec3 tangentX = normalize(cross(N, upVector));\n vec3 tangentZ = cross(N, tangentX);\n return normalize(tangentX * H.x + N * H.y + tangentZ * H.z);\n}\nvoid main() {\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(v_WorldPosition - eyePos);\n vec3 N = V;\n vec3 prefilteredColor = vec3(0.0);\n float totalWeight = 0.0;\n float fMaxSampleNumber = float(SAMPLE_NUMBER);\n for (int i = 0; i < SAMPLE_NUMBER; i++) {\n vec3 H = importanceSampleNormal(float(i) / fMaxSampleNumber, roughness, N);\n vec3 L = reflect(-V, H);\n float NoL = clamp(dot(N, L), 0.0, 1.0);\n if (NoL > 0.0) {\n prefilteredColor += decodeHDR(textureCube(environmentMap, L)).rgb * NoL;\n totalWeight += NoL;\n }\n }\n gl_FragColor = encodeHDR(vec4(prefilteredColor / totalWeight, 1.0));\n}\n";
var cubemapUtil = {};
var targets$2 = ["px", "nx", "py", "ny", "pz", "nz"];
cubemapUtil.prefilterEnvironmentMap = function(renderer, envMap, textureOpts, normalDistribution, brdfLookup) {
  if (!brdfLookup || !normalDistribution) {
    normalDistribution = cubemapUtil.generateNormalDistribution();
    brdfLookup = cubemapUtil.integrateBRDF(renderer, normalDistribution);
  }
  textureOpts = textureOpts || {};
  var width = textureOpts.width || 64;
  var height = textureOpts.height || 64;
  var textureType = textureOpts.type || envMap.type;
  var prefilteredCubeMap = new TextureCube$1({
    width,
    height,
    type: textureType,
    flipY: false,
    mipmaps: []
  });
  if (!prefilteredCubeMap.isPowerOfTwo()) {
    console.warn("Width and height must be power of two to enable mipmap.");
  }
  var size = Math.min(width, height);
  var mipmapNum = Math.log(size) / Math.log(2) + 1;
  var prefilterMaterial = new Material$1({
    shader: new Shader({
      vertex: Shader.source("clay.skybox.vertex"),
      fragment: prefilterFragCode
    })
  });
  prefilterMaterial.set("normalDistribution", normalDistribution);
  textureOpts.encodeRGBM && prefilterMaterial.define("fragment", "RGBM_ENCODE");
  textureOpts.decodeRGBM && prefilterMaterial.define("fragment", "RGBM_DECODE");
  var dummyScene = new Scene$1();
  var skyEnv;
  if (envMap.textureType === "texture2D") {
    var envCubemap = new TextureCube$1({
      width,
      height,
      type: textureType === Texture$1.FLOAT ? Texture$1.HALF_FLOAT : textureType
    });
    textureUtil$1.panoramaToCubeMap(renderer, envMap, envCubemap, {
      encodeRGBM: textureOpts.decodeRGBM
    });
    envMap = envCubemap;
  }
  skyEnv = new Skybox$1({
    scene: dummyScene,
    material: prefilterMaterial
  });
  skyEnv.material.set("environmentMap", envMap);
  var envMapPass = new EnvironmentMapPass$1({
    texture: prefilteredCubeMap
  });
  if (textureOpts.encodeRGBM) {
    textureType = prefilteredCubeMap.type = Texture$1.UNSIGNED_BYTE;
  }
  var renderTargetTmp = new Texture2D$1({
    width,
    height,
    type: textureType
  });
  var frameBuffer = new FrameBuffer$1({
    depthBuffer: false
  });
  var ArrayCtor = vendor$1[textureType === Texture$1.UNSIGNED_BYTE ? "Uint8Array" : "Float32Array"];
  for (var i = 0; i < mipmapNum; i++) {
    prefilteredCubeMap.mipmaps[i] = {
      pixels: {}
    };
    skyEnv.material.set("roughness", i / (mipmapNum - 1));
    var n = renderTargetTmp.width;
    var fov = 2 * Math.atan(n / (n - 0.5)) / Math.PI * 180;
    for (var j = 0; j < targets$2.length; j++) {
      var pixels = new ArrayCtor(renderTargetTmp.width * renderTargetTmp.height * 4);
      frameBuffer.attach(renderTargetTmp);
      frameBuffer.bind(renderer);
      var camera2 = envMapPass.getCamera(targets$2[j]);
      camera2.fov = fov;
      renderer.render(dummyScene, camera2);
      renderer.gl.readPixels(0, 0, renderTargetTmp.width, renderTargetTmp.height, Texture$1.RGBA, textureType, pixels);
      frameBuffer.unbind(renderer);
      prefilteredCubeMap.mipmaps[i].pixels[targets$2[j]] = pixels;
    }
    renderTargetTmp.width /= 2;
    renderTargetTmp.height /= 2;
    renderTargetTmp.dirty();
  }
  frameBuffer.dispose(renderer);
  renderTargetTmp.dispose(renderer);
  skyEnv.dispose(renderer);
  normalDistribution.dispose(renderer);
  return {
    environmentMap: prefilteredCubeMap,
    brdfLookup,
    normalDistribution,
    maxMipmapLevel: mipmapNum
  };
};
cubemapUtil.integrateBRDF = function(renderer, normalDistribution) {
  normalDistribution = normalDistribution || cubemapUtil.generateNormalDistribution();
  var framebuffer = new FrameBuffer$1({
    depthBuffer: false
  });
  var pass = new Pass$1({
    fragment: integrateBRDFShaderCode
  });
  var texture = new Texture2D$1({
    width: 512,
    height: 256,
    type: Texture$1.HALF_FLOAT,
    wrapS: Texture$1.CLAMP_TO_EDGE,
    wrapT: Texture$1.CLAMP_TO_EDGE,
    minFilter: Texture$1.NEAREST,
    magFilter: Texture$1.NEAREST,
    useMipmap: false
  });
  pass.setUniform("normalDistribution", normalDistribution);
  pass.setUniform("viewportSize", [512, 256]);
  pass.attachOutput(texture);
  pass.render(renderer, framebuffer);
  framebuffer.dispose(renderer);
  return texture;
};
cubemapUtil.generateNormalDistribution = function(roughnessLevels, sampleSize) {
  var roughnessLevels = roughnessLevels || 256;
  var sampleSize = sampleSize || 1024;
  var normalDistribution = new Texture2D$1({
    width: roughnessLevels,
    height: sampleSize,
    type: Texture$1.FLOAT,
    minFilter: Texture$1.NEAREST,
    magFilter: Texture$1.NEAREST,
    wrapS: Texture$1.CLAMP_TO_EDGE,
    wrapT: Texture$1.CLAMP_TO_EDGE,
    useMipmap: false
  });
  var pixels = new Float32Array(sampleSize * roughnessLevels * 4);
  var tmp = [];
  for (var j = 0; j < roughnessLevels; j++) {
    var roughness = j / roughnessLevels;
    var a = roughness * roughness;
    for (var i = 0; i < sampleSize; i++) {
      var y = (i << 16 | i >>> 16) >>> 0;
      y = ((y & 1431655765) << 1 | (y & 2863311530) >>> 1) >>> 0;
      y = ((y & 858993459) << 2 | (y & 3435973836) >>> 2) >>> 0;
      y = ((y & 252645135) << 4 | (y & 4042322160) >>> 4) >>> 0;
      y = (((y & 16711935) << 8 | (y & 4278255360) >>> 8) >>> 0) / 4294967296;
      var cosTheta = Math.sqrt((1 - y) / (1 + (a * a - 1) * y));
      tmp[i] = cosTheta;
    }
    for (var i = 0; i < sampleSize; i++) {
      var offset = (i * roughnessLevels + j) * 4;
      var cosTheta = tmp[i];
      var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
      var x = i / sampleSize;
      var phi = 2 * Math.PI * x;
      pixels[offset] = sinTheta * Math.cos(phi);
      pixels[offset + 1] = cosTheta;
      pixels[offset + 2] = sinTheta * Math.sin(phi);
      pixels[offset + 3] = 1;
    }
  }
  normalDistribution.pixels = pixels;
  return normalDistribution;
};
var cubemapUtil$1 = cubemapUtil;
var AmbientCubemapLight = Light$1.extend({
  cubemap: null,
  castShadow: false,
  _normalDistribution: null,
  _brdfLookup: null
}, {
  type: "AMBIENT_CUBEMAP_LIGHT",
  prefilter: function(renderer, size) {
    if (!renderer.getGLExtension("EXT_shader_texture_lod")) {
      console.warn("Device not support textureCubeLodEXT");
      return;
    }
    if (!this._brdfLookup) {
      this._normalDistribution = cubemapUtil$1.generateNormalDistribution();
      this._brdfLookup = cubemapUtil$1.integrateBRDF(renderer, this._normalDistribution);
    }
    var cubemap = this.cubemap;
    if (cubemap.__prefiltered) {
      return;
    }
    var result = cubemapUtil$1.prefilterEnvironmentMap(renderer, cubemap, {
      encodeRGBM: true,
      width: size,
      height: size
    }, this._normalDistribution, this._brdfLookup);
    this.cubemap = result.environmentMap;
    this.cubemap.__prefiltered = true;
    cubemap.dispose(renderer);
  },
  getBRDFLookup: function() {
    return this._brdfLookup;
  },
  uniformTemplates: {
    ambientCubemapLightColor: {
      type: "3f",
      value: function(instance) {
        var color = instance.color;
        var intensity = instance.intensity;
        return [color[0] * intensity, color[1] * intensity, color[2] * intensity];
      }
    },
    ambientCubemapLightCubemap: {
      type: "t",
      value: function(instance) {
        return instance.cubemap;
      }
    },
    ambientCubemapLightBRDFLookup: {
      type: "t",
      value: function(instance) {
        return instance._brdfLookup;
      }
    }
  }
});
var AmbientCubemapLight$1 = AmbientCubemapLight;
var AmbientSHLight = Light$1.extend({
  castShadow: false,
  coefficients: []
}, function() {
  this._coefficientsTmpArr = new vendor$1.Float32Array(9 * 3);
}, {
  type: "AMBIENT_SH_LIGHT",
  uniformTemplates: {
    ambientSHLightColor: {
      type: "3f",
      value: function(instance) {
        var color = instance.color;
        var intensity = instance.intensity;
        return [color[0] * intensity, color[1] * intensity, color[2] * intensity];
      }
    },
    ambientSHLightCoefficients: {
      type: "3f",
      value: function(instance) {
        var coefficientsTmpArr = instance._coefficientsTmpArr;
        for (var i = 0; i < instance.coefficients.length; i++) {
          coefficientsTmpArr[i] = instance.coefficients[i];
        }
        return coefficientsTmpArr;
      }
    }
  }
});
var AmbientSHLight$1 = AmbientSHLight;
var sh = {};
var targets$1 = ["px", "nx", "py", "ny", "pz", "nz"];
function harmonics(normal2, index) {
  var x = normal2[0];
  var y = normal2[1];
  var z = normal2[2];
  if (index === 0) {
    return 1;
  } else if (index === 1) {
    return x;
  } else if (index === 2) {
    return y;
  } else if (index === 3) {
    return z;
  } else if (index === 4) {
    return x * z;
  } else if (index === 5) {
    return y * z;
  } else if (index === 6) {
    return x * y;
  } else if (index === 7) {
    return 3 * z * z - 1;
  } else {
    return x * x - y * y;
  }
}
var normalTransform = {
  px: [2, 1, 0, -1, -1, 1],
  nx: [2, 1, 0, 1, -1, -1],
  py: [0, 2, 1, 1, -1, -1],
  ny: [0, 2, 1, 1, 1, 1],
  pz: [0, 1, 2, -1, -1, -1],
  nz: [0, 1, 2, 1, -1, 1]
};
function projectEnvironmentMapCPU(renderer, cubePixels, width, height) {
  var coeff = new vendor$1.Float32Array(9 * 3);
  var normal2 = vec3$g.create();
  var texel = vec3$g.create();
  var fetchNormal = vec3$g.create();
  for (var m2 = 0; m2 < 9; m2++) {
    var result = vec3$g.create();
    for (var k = 0; k < targets$1.length; k++) {
      var pixels = cubePixels[targets$1[k]];
      var sideResult = vec3$g.create();
      var divider = 0;
      var i = 0;
      var transform2 = normalTransform[targets$1[k]];
      for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
          normal2[0] = x / (width - 1) * 2 - 1;
          normal2[1] = y / (height - 1) * 2 - 1;
          normal2[2] = -1;
          vec3$g.normalize(normal2, normal2);
          fetchNormal[0] = normal2[transform2[0]] * transform2[3];
          fetchNormal[1] = normal2[transform2[1]] * transform2[4];
          fetchNormal[2] = normal2[transform2[2]] * transform2[5];
          texel[0] = pixels[i++] / 255;
          texel[1] = pixels[i++] / 255;
          texel[2] = pixels[i++] / 255;
          var scale2 = pixels[i++] / 255 * 8.12;
          texel[0] *= scale2;
          texel[1] *= scale2;
          texel[2] *= scale2;
          vec3$g.scaleAndAdd(sideResult, sideResult, texel, harmonics(fetchNormal, m2) * -normal2[2]);
          divider += -normal2[2];
        }
      }
      vec3$g.scaleAndAdd(result, result, sideResult, 1 / divider);
    }
    coeff[m2 * 3] = result[0] / 6;
    coeff[m2 * 3 + 1] = result[1] / 6;
    coeff[m2 * 3 + 2] = result[2] / 6;
  }
  return coeff;
}
sh.projectEnvironmentMap = function(renderer, envMap, opts) {
  opts = opts || {};
  opts.lod = opts.lod || 0;
  var skybox;
  var dummyScene = new Scene$1();
  var size = 64;
  if (envMap.textureType === "texture2D") {
    skybox = new Skybox$1({
      scene: dummyScene,
      environmentMap: envMap
    });
  } else {
    size = envMap.image && envMap.image.px ? envMap.image.px.width : envMap.width;
    skybox = new Skybox$1({
      scene: dummyScene,
      environmentMap: envMap
    });
  }
  var width = Math.ceil(size / Math.pow(2, opts.lod));
  var height = Math.ceil(size / Math.pow(2, opts.lod));
  var rgbmTexture = new Texture2D$1({
    width,
    height
  });
  var framebuffer = new FrameBuffer$1();
  skybox.material.define("fragment", "RGBM_ENCODE");
  if (opts.decodeRGBM) {
    skybox.material.define("fragment", "RGBM_DECODE");
  }
  skybox.material.set("lod", opts.lod);
  var envMapPass = new EnvironmentMapPass$1({
    texture: rgbmTexture
  });
  var cubePixels = {};
  for (var i = 0; i < targets$1.length; i++) {
    cubePixels[targets$1[i]] = new Uint8Array(width * height * 4);
    var camera2 = envMapPass.getCamera(targets$1[i]);
    camera2.fov = 90;
    framebuffer.attach(rgbmTexture);
    framebuffer.bind(renderer);
    renderer.render(dummyScene, camera2);
    renderer.gl.readPixels(0, 0, width, height, Texture$1.RGBA, Texture$1.UNSIGNED_BYTE, cubePixels[targets$1[i]]);
    framebuffer.unbind(renderer);
  }
  skybox.dispose(renderer);
  framebuffer.dispose(renderer);
  rgbmTexture.dispose(renderer);
  return projectEnvironmentMapCPU(renderer, cubePixels, width, height);
};
var shUtil = sh;
var retrieve = {
  firstNotNull: function() {
    for (var i = 0, len2 = arguments.length; i < len2; i++) {
      if (arguments[i] != null) {
        return arguments[i];
      }
    }
  },
  queryDataIndex: function(data, payload) {
    if (payload.dataIndexInside != null) {
      return payload.dataIndexInside;
    } else if (payload.dataIndex != null) {
      return isArray$1(payload.dataIndex) ? map$1(payload.dataIndex, function(value) {
        return data.indexOfRawIndex(value);
      }) : data.indexOfRawIndex(payload.dataIndex);
    } else if (payload.name != null) {
      return isArray$1(payload.name) ? map$1(payload.name, function(value) {
        return data.indexOfName(value);
      }) : data.indexOfName(payload.name);
    }
  }
};
var retrieve$1 = retrieve;
var Sphere = Geometry$1.extend({
  dynamic: false,
  widthSegments: 40,
  heightSegments: 20,
  phiStart: 0,
  phiLength: Math.PI * 2,
  thetaStart: 0,
  thetaLength: Math.PI,
  radius: 1
}, function() {
  this.build();
}, {
  build: function() {
    var heightSegments = this.heightSegments;
    var widthSegments = this.widthSegments;
    var positionAttr = this.attributes.position;
    var texcoordAttr = this.attributes.texcoord0;
    var normalAttr = this.attributes.normal;
    var vertexCount = (widthSegments + 1) * (heightSegments + 1);
    positionAttr.init(vertexCount);
    texcoordAttr.init(vertexCount);
    normalAttr.init(vertexCount);
    var IndicesCtor = vertexCount > 65535 ? Uint32Array : Uint16Array;
    var indices = this.indices = new IndicesCtor(widthSegments * heightSegments * 6);
    var x, y, z, u, v, i, j;
    var radius = this.radius;
    var phiStart = this.phiStart;
    var phiLength = this.phiLength;
    var thetaStart = this.thetaStart;
    var thetaLength = this.thetaLength;
    var radius = this.radius;
    var pos = [];
    var uv = [];
    var offset = 0;
    var divider = 1 / radius;
    for (j = 0; j <= heightSegments; j++) {
      for (i = 0; i <= widthSegments; i++) {
        u = i / widthSegments;
        v = j / heightSegments;
        x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        y = radius * Math.cos(thetaStart + v * thetaLength);
        z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        pos[0] = x;
        pos[1] = y;
        pos[2] = z;
        uv[0] = u;
        uv[1] = v;
        positionAttr.set(offset, pos);
        texcoordAttr.set(offset, uv);
        pos[0] *= divider;
        pos[1] *= divider;
        pos[2] *= divider;
        normalAttr.set(offset, pos);
        offset++;
      }
    }
    var i1, i2, i3, i4;
    var len2 = widthSegments + 1;
    var n = 0;
    for (j = 0; j < heightSegments; j++) {
      for (i = 0; i < widthSegments; i++) {
        i2 = j * len2 + i;
        i1 = j * len2 + i + 1;
        i4 = (j + 1) * len2 + i + 1;
        i3 = (j + 1) * len2 + i;
        indices[n++] = i1;
        indices[n++] = i2;
        indices[n++] = i4;
        indices[n++] = i2;
        indices[n++] = i3;
        indices[n++] = i4;
      }
    }
    this.boundingBox = new BoundingBox$1();
    this.boundingBox.max.set(radius, radius, radius);
    this.boundingBox.min.set(-radius, -radius, -radius);
  }
});
var SphereGeometry = Sphere;
var AmbientLight = Light$1.extend({
  castShadow: false
}, {
  type: "AMBIENT_LIGHT",
  uniformTemplates: {
    ambientLightColor: {
      type: "3f",
      value: function(instance) {
        var color = instance.color;
        var intensity = instance.intensity;
        return [color[0] * intensity, color[1] * intensity, color[2] * intensity];
      }
    }
  }
});
var AmbientLight$1 = AmbientLight;
var DirectionalLight = Light$1.extend({
  shadowBias: 1e-3,
  shadowSlopeScale: 2,
  shadowCascade: 1,
  cascadeSplitLogFactor: 0.2
}, {
  type: "DIRECTIONAL_LIGHT",
  uniformTemplates: {
    directionalLightDirection: {
      type: "3f",
      value: function(instance) {
        instance.__dir = instance.__dir || new Vector3$1();
        return instance.__dir.copy(instance.worldTransform.z).normalize().negate().array;
      }
    },
    directionalLightColor: {
      type: "3f",
      value: function(instance) {
        var color = instance.color;
        var intensity = instance.intensity;
        return [color[0] * intensity, color[1] * intensity, color[2] * intensity];
      }
    }
  },
  clone: function() {
    var light = Light$1.prototype.clone.call(this);
    light.shadowBias = this.shadowBias;
    light.shadowSlopeScale = this.shadowSlopeScale;
    return light;
  }
});
var DirectionalLight$1 = DirectionalLight;
var PointLight = Light$1.extend({
  range: 100,
  castShadow: false
}, {
  type: "POINT_LIGHT",
  uniformTemplates: {
    pointLightPosition: {
      type: "3f",
      value: function(instance) {
        return instance.getWorldPosition().array;
      }
    },
    pointLightRange: {
      type: "1f",
      value: function(instance) {
        return instance.range;
      }
    },
    pointLightColor: {
      type: "3f",
      value: function(instance) {
        var color = instance.color;
        var intensity = instance.intensity;
        return [color[0] * intensity, color[1] * intensity, color[2] * intensity];
      }
    }
  },
  clone: function() {
    var light = Light$1.prototype.clone.call(this);
    light.range = this.range;
    return light;
  }
});
var PointLight$1 = PointLight;
var SpotLight = Light$1.extend({
  range: 20,
  umbraAngle: 30,
  penumbraAngle: 45,
  falloffFactor: 2,
  shadowBias: 1e-3,
  shadowSlopeScale: 2
}, {
  type: "SPOT_LIGHT",
  uniformTemplates: {
    spotLightPosition: {
      type: "3f",
      value: function(instance) {
        return instance.getWorldPosition().array;
      }
    },
    spotLightRange: {
      type: "1f",
      value: function(instance) {
        return instance.range;
      }
    },
    spotLightUmbraAngleCosine: {
      type: "1f",
      value: function(instance) {
        return Math.cos(instance.umbraAngle * Math.PI / 180);
      }
    },
    spotLightPenumbraAngleCosine: {
      type: "1f",
      value: function(instance) {
        return Math.cos(instance.penumbraAngle * Math.PI / 180);
      }
    },
    spotLightFalloffFactor: {
      type: "1f",
      value: function(instance) {
        return instance.falloffFactor;
      }
    },
    spotLightDirection: {
      type: "3f",
      value: function(instance) {
        instance.__dir = instance.__dir || new Vector3$1();
        return instance.__dir.copy(instance.worldTransform.z).negate().array;
      }
    },
    spotLightColor: {
      type: "3f",
      value: function(instance) {
        var color = instance.color;
        var intensity = instance.intensity;
        return [color[0] * intensity, color[1] * intensity, color[2] * intensity];
      }
    }
  },
  clone: function() {
    var light = Light$1.prototype.clone.call(this);
    light.range = this.range;
    light.umbraAngle = this.umbraAngle;
    light.penumbraAngle = this.penumbraAngle;
    light.falloffFactor = this.falloffFactor;
    light.shadowBias = this.shadowBias;
    light.shadowSlopeScale = this.shadowSlopeScale;
    return light;
  }
});
var SpotLight$1 = SpotLight;
var Vector4 = function(x, y, z, w) {
  x = x || 0;
  y = y || 0;
  z = z || 0;
  w = w || 0;
  this.array = vec4$2.fromValues(x, y, z, w);
  this._dirty = true;
};
Vector4.prototype = {
  constructor: Vector4,
  add: function(b) {
    vec4$2.add(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  set: function(x, y, z, w) {
    this.array[0] = x;
    this.array[1] = y;
    this.array[2] = z;
    this.array[3] = w;
    this._dirty = true;
    return this;
  },
  setArray: function(arr) {
    this.array[0] = arr[0];
    this.array[1] = arr[1];
    this.array[2] = arr[2];
    this.array[3] = arr[3];
    this._dirty = true;
    return this;
  },
  clone: function() {
    return new Vector4(this.x, this.y, this.z, this.w);
  },
  copy: function(b) {
    vec4$2.copy(this.array, b.array);
    this._dirty = true;
    return this;
  },
  dist: function(b) {
    return vec4$2.dist(this.array, b.array);
  },
  distance: function(b) {
    return vec4$2.distance(this.array, b.array);
  },
  div: function(b) {
    vec4$2.div(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  divide: function(b) {
    vec4$2.divide(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  dot: function(b) {
    return vec4$2.dot(this.array, b.array);
  },
  len: function() {
    return vec4$2.len(this.array);
  },
  length: function() {
    return vec4$2.length(this.array);
  },
  lerp: function(a, b, t) {
    vec4$2.lerp(this.array, a.array, b.array, t);
    this._dirty = true;
    return this;
  },
  min: function(b) {
    vec4$2.min(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  max: function(b) {
    vec4$2.max(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  mul: function(b) {
    vec4$2.mul(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  multiply: function(b) {
    vec4$2.multiply(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  negate: function() {
    vec4$2.negate(this.array, this.array);
    this._dirty = true;
    return this;
  },
  normalize: function() {
    vec4$2.normalize(this.array, this.array);
    this._dirty = true;
    return this;
  },
  random: function(scale2) {
    vec4$2.random(this.array, scale2);
    this._dirty = true;
    return this;
  },
  scale: function(s) {
    vec4$2.scale(this.array, this.array, s);
    this._dirty = true;
    return this;
  },
  scaleAndAdd: function(b, s) {
    vec4$2.scaleAndAdd(this.array, this.array, b.array, s);
    this._dirty = true;
    return this;
  },
  sqrDist: function(b) {
    return vec4$2.sqrDist(this.array, b.array);
  },
  squaredDistance: function(b) {
    return vec4$2.squaredDistance(this.array, b.array);
  },
  sqrLen: function() {
    return vec4$2.sqrLen(this.array);
  },
  squaredLength: function() {
    return vec4$2.squaredLength(this.array);
  },
  sub: function(b) {
    vec4$2.sub(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  subtract: function(b) {
    vec4$2.subtract(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  transformMat4: function(m2) {
    vec4$2.transformMat4(this.array, this.array, m2.array);
    this._dirty = true;
    return this;
  },
  transformQuat: function(q) {
    vec4$2.transformQuat(this.array, this.array, q.array);
    this._dirty = true;
    return this;
  },
  toString: function() {
    return "[" + Array.prototype.join.call(this.array, ",") + "]";
  },
  toArray: function() {
    return Array.prototype.slice.call(this.array);
  }
};
var defineProperty = Object.defineProperty;
if (defineProperty) {
  var proto = Vector4.prototype;
  defineProperty(proto, "x", {
    get: function() {
      return this.array[0];
    },
    set: function(value) {
      this.array[0] = value;
      this._dirty = true;
    }
  });
  defineProperty(proto, "y", {
    get: function() {
      return this.array[1];
    },
    set: function(value) {
      this.array[1] = value;
      this._dirty = true;
    }
  });
  defineProperty(proto, "z", {
    get: function() {
      return this.array[2];
    },
    set: function(value) {
      this.array[2] = value;
      this._dirty = true;
    }
  });
  defineProperty(proto, "w", {
    get: function() {
      return this.array[3];
    },
    set: function(value) {
      this.array[3] = value;
      this._dirty = true;
    }
  });
}
Vector4.add = function(out2, a, b) {
  vec4$2.add(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector4.set = function(out2, x, y, z, w) {
  vec4$2.set(out2.array, x, y, z, w);
  out2._dirty = true;
};
Vector4.copy = function(out2, b) {
  vec4$2.copy(out2.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector4.dist = function(a, b) {
  return vec4$2.distance(a.array, b.array);
};
Vector4.distance = Vector4.dist;
Vector4.div = function(out2, a, b) {
  vec4$2.divide(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector4.divide = Vector4.div;
Vector4.dot = function(a, b) {
  return vec4$2.dot(a.array, b.array);
};
Vector4.len = function(b) {
  return vec4$2.length(b.array);
};
Vector4.lerp = function(out2, a, b, t) {
  vec4$2.lerp(out2.array, a.array, b.array, t);
  out2._dirty = true;
  return out2;
};
Vector4.min = function(out2, a, b) {
  vec4$2.min(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector4.max = function(out2, a, b) {
  vec4$2.max(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector4.mul = function(out2, a, b) {
  vec4$2.multiply(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector4.multiply = Vector4.mul;
Vector4.negate = function(out2, a) {
  vec4$2.negate(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Vector4.normalize = function(out2, a) {
  vec4$2.normalize(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Vector4.random = function(out2, scale2) {
  vec4$2.random(out2.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector4.scale = function(out2, a, scale2) {
  vec4$2.scale(out2.array, a.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector4.scaleAndAdd = function(out2, a, b, scale2) {
  vec4$2.scaleAndAdd(out2.array, a.array, b.array, scale2);
  out2._dirty = true;
  return out2;
};
Vector4.sqrDist = function(a, b) {
  return vec4$2.sqrDist(a.array, b.array);
};
Vector4.squaredDistance = Vector4.sqrDist;
Vector4.sqrLen = function(a) {
  return vec4$2.sqrLen(a.array);
};
Vector4.squaredLength = Vector4.sqrLen;
Vector4.sub = function(out2, a, b) {
  vec4$2.subtract(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Vector4.subtract = Vector4.sub;
Vector4.transformMat4 = function(out2, a, m2) {
  vec4$2.transformMat4(out2.array, a.array, m2.array);
  out2._dirty = true;
  return out2;
};
Vector4.transformQuat = function(out2, a, q) {
  vec4$2.transformQuat(out2.array, a.array, q.array);
  out2._dirty = true;
  return out2;
};
var Vector4$1 = Vector4;
var mat2 = {};
mat2.create = function() {
  var out2 = new GLMAT_ARRAY_TYPE(4);
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  return out2;
};
mat2.clone = function(a) {
  var out2 = new GLMAT_ARRAY_TYPE(4);
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
};
mat2.copy = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
};
mat2.identity = function(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  return out2;
};
mat2.transpose = function(out2, a) {
  if (out2 === a) {
    var a1 = a[1];
    out2[1] = a[2];
    out2[2] = a1;
  } else {
    out2[0] = a[0];
    out2[1] = a[2];
    out2[2] = a[1];
    out2[3] = a[3];
  }
  return out2;
};
mat2.invert = function(out2, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], det = a0 * a3 - a2 * a1;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = a3 * det;
  out2[1] = -a1 * det;
  out2[2] = -a2 * det;
  out2[3] = a0 * det;
  return out2;
};
mat2.adjoint = function(out2, a) {
  var a0 = a[0];
  out2[0] = a[3];
  out2[1] = -a[1];
  out2[2] = -a[2];
  out2[3] = a0;
  return out2;
};
mat2.determinant = function(a) {
  return a[0] * a[3] - a[2] * a[1];
};
mat2.multiply = function(out2, a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out2[0] = a0 * b0 + a2 * b1;
  out2[1] = a1 * b0 + a3 * b1;
  out2[2] = a0 * b2 + a2 * b3;
  out2[3] = a1 * b2 + a3 * b3;
  return out2;
};
mat2.mul = mat2.multiply;
mat2.rotate = function(out2, a, rad2) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], s = Math.sin(rad2), c = Math.cos(rad2);
  out2[0] = a0 * c + a2 * s;
  out2[1] = a1 * c + a3 * s;
  out2[2] = a0 * -s + a2 * c;
  out2[3] = a1 * -s + a3 * c;
  return out2;
};
mat2.scale = function(out2, a, v) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], v0 = v[0], v12 = v[1];
  out2[0] = a0 * v0;
  out2[1] = a1 * v0;
  out2[2] = a2 * v12;
  out2[3] = a3 * v12;
  return out2;
};
mat2.frob = function(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
};
mat2.LDU = function(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
};
var mat2$1 = mat2;
var Matrix2 = function() {
  this.array = mat2$1.create();
  this._dirty = true;
};
Matrix2.prototype = {
  constructor: Matrix2,
  setArray: function(arr) {
    for (var i = 0; i < this.array.length; i++) {
      this.array[i] = arr[i];
    }
    this._dirty = true;
    return this;
  },
  clone: function() {
    return new Matrix2().copy(this);
  },
  copy: function(b) {
    mat2$1.copy(this.array, b.array);
    this._dirty = true;
    return this;
  },
  adjoint: function() {
    mat2$1.adjoint(this.array, this.array);
    this._dirty = true;
    return this;
  },
  determinant: function() {
    return mat2$1.determinant(this.array);
  },
  identity: function() {
    mat2$1.identity(this.array);
    this._dirty = true;
    return this;
  },
  invert: function() {
    mat2$1.invert(this.array, this.array);
    this._dirty = true;
    return this;
  },
  mul: function(b) {
    mat2$1.mul(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  mulLeft: function(a) {
    mat2$1.mul(this.array, a.array, this.array);
    this._dirty = true;
    return this;
  },
  multiply: function(b) {
    mat2$1.multiply(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  multiplyLeft: function(a) {
    mat2$1.multiply(this.array, a.array, this.array);
    this._dirty = true;
    return this;
  },
  rotate: function(rad2) {
    mat2$1.rotate(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  scale: function(v) {
    mat2$1.scale(this.array, this.array, v.array);
    this._dirty = true;
    return this;
  },
  transpose: function() {
    mat2$1.transpose(this.array, this.array);
    this._dirty = true;
    return this;
  },
  toString: function() {
    return "[" + Array.prototype.join.call(this.array, ",") + "]";
  },
  toArray: function() {
    return Array.prototype.slice.call(this.array);
  }
};
Matrix2.adjoint = function(out2, a) {
  mat2$1.adjoint(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix2.copy = function(out2, a) {
  mat2$1.copy(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix2.determinant = function(a) {
  return mat2$1.determinant(a.array);
};
Matrix2.identity = function(out2) {
  mat2$1.identity(out2.array);
  out2._dirty = true;
  return out2;
};
Matrix2.invert = function(out2, a) {
  mat2$1.invert(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix2.mul = function(out2, a, b) {
  mat2$1.mul(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Matrix2.multiply = Matrix2.mul;
Matrix2.rotate = function(out2, a, rad2) {
  mat2$1.rotate(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Matrix2.scale = function(out2, a, v) {
  mat2$1.scale(out2.array, a.array, v.array);
  out2._dirty = true;
  return out2;
};
Matrix2.transpose = function(out2, a) {
  mat2$1.transpose(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
var Matrix2$1 = Matrix2;
var mat2d = {};
mat2d.create = function() {
  var out2 = new GLMAT_ARRAY_TYPE(6);
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  out2[4] = 0;
  out2[5] = 0;
  return out2;
};
mat2d.clone = function(a) {
  var out2 = new GLMAT_ARRAY_TYPE(6);
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4];
  out2[5] = a[5];
  return out2;
};
mat2d.copy = function(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4];
  out2[5] = a[5];
  return out2;
};
mat2d.identity = function(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  out2[4] = 0;
  out2[5] = 0;
  return out2;
};
mat2d.invert = function(out2, a) {
  var aa = a[0], ab = a[1], ac = a[2], ad = a[3], atx = a[4], aty = a[5];
  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = ad * det;
  out2[1] = -ab * det;
  out2[2] = -ac * det;
  out2[3] = aa * det;
  out2[4] = (ac * aty - ad * atx) * det;
  out2[5] = (ab * atx - aa * aty) * det;
  return out2;
};
mat2d.determinant = function(a) {
  return a[0] * a[3] - a[1] * a[2];
};
mat2d.multiply = function(out2, a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
  out2[0] = a0 * b0 + a2 * b1;
  out2[1] = a1 * b0 + a3 * b1;
  out2[2] = a0 * b2 + a2 * b3;
  out2[3] = a1 * b2 + a3 * b3;
  out2[4] = a0 * b4 + a2 * b5 + a4;
  out2[5] = a1 * b4 + a3 * b5 + a5;
  return out2;
};
mat2d.mul = mat2d.multiply;
mat2d.rotate = function(out2, a, rad2) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], s = Math.sin(rad2), c = Math.cos(rad2);
  out2[0] = a0 * c + a2 * s;
  out2[1] = a1 * c + a3 * s;
  out2[2] = a0 * -s + a2 * c;
  out2[3] = a1 * -s + a3 * c;
  out2[4] = a4;
  out2[5] = a5;
  return out2;
};
mat2d.scale = function(out2, a, v) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], v0 = v[0], v12 = v[1];
  out2[0] = a0 * v0;
  out2[1] = a1 * v0;
  out2[2] = a2 * v12;
  out2[3] = a3 * v12;
  out2[4] = a4;
  out2[5] = a5;
  return out2;
};
mat2d.translate = function(out2, a, v) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], v0 = v[0], v12 = v[1];
  out2[0] = a0;
  out2[1] = a1;
  out2[2] = a2;
  out2[3] = a3;
  out2[4] = a0 * v0 + a2 * v12 + a4;
  out2[5] = a1 * v0 + a3 * v12 + a5;
  return out2;
};
mat2d.frob = function(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
};
var mat2d$1 = mat2d;
var Matrix2d = function() {
  this.array = mat2d$1.create();
  this._dirty = true;
};
Matrix2d.prototype = {
  constructor: Matrix2d,
  setArray: function(arr) {
    for (var i = 0; i < this.array.length; i++) {
      this.array[i] = arr[i];
    }
    this._dirty = true;
    return this;
  },
  clone: function() {
    return new Matrix2d().copy(this);
  },
  copy: function(b) {
    mat2d$1.copy(this.array, b.array);
    this._dirty = true;
    return this;
  },
  determinant: function() {
    return mat2d$1.determinant(this.array);
  },
  identity: function() {
    mat2d$1.identity(this.array);
    this._dirty = true;
    return this;
  },
  invert: function() {
    mat2d$1.invert(this.array, this.array);
    this._dirty = true;
    return this;
  },
  mul: function(b) {
    mat2d$1.mul(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  mulLeft: function(b) {
    mat2d$1.mul(this.array, b.array, this.array);
    this._dirty = true;
    return this;
  },
  multiply: function(b) {
    mat2d$1.multiply(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  multiplyLeft: function(b) {
    mat2d$1.multiply(this.array, b.array, this.array);
    this._dirty = true;
    return this;
  },
  rotate: function(rad2) {
    mat2d$1.rotate(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  scale: function(s) {
    mat2d$1.scale(this.array, this.array, s.array);
    this._dirty = true;
    return this;
  },
  translate: function(v) {
    mat2d$1.translate(this.array, this.array, v.array);
    this._dirty = true;
    return this;
  },
  toString: function() {
    return "[" + Array.prototype.join.call(this.array, ",") + "]";
  },
  toArray: function() {
    return Array.prototype.slice.call(this.array);
  }
};
Matrix2d.copy = function(out2, a) {
  mat2d$1.copy(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix2d.determinant = function(a) {
  return mat2d$1.determinant(a.array);
};
Matrix2d.identity = function(out2) {
  mat2d$1.identity(out2.array);
  out2._dirty = true;
  return out2;
};
Matrix2d.invert = function(out2, a) {
  mat2d$1.invert(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix2d.mul = function(out2, a, b) {
  mat2d$1.mul(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Matrix2d.multiply = Matrix2d.mul;
Matrix2d.rotate = function(out2, a, rad2) {
  mat2d$1.rotate(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Matrix2d.scale = function(out2, a, v) {
  mat2d$1.scale(out2.array, a.array, v.array);
  out2._dirty = true;
  return out2;
};
Matrix2d.translate = function(out2, a, v) {
  mat2d$1.translate(out2.array, a.array, v.array);
  out2._dirty = true;
  return out2;
};
var Matrix2d$1 = Matrix2d;
var Matrix3 = function() {
  this.array = mat3$2.create();
  this._dirty = true;
};
Matrix3.prototype = {
  constructor: Matrix3,
  setArray: function(arr) {
    for (var i = 0; i < this.array.length; i++) {
      this.array[i] = arr[i];
    }
    this._dirty = true;
    return this;
  },
  adjoint: function() {
    mat3$2.adjoint(this.array, this.array);
    this._dirty = true;
    return this;
  },
  clone: function() {
    return new Matrix3().copy(this);
  },
  copy: function(b) {
    mat3$2.copy(this.array, b.array);
    this._dirty = true;
    return this;
  },
  determinant: function() {
    return mat3$2.determinant(this.array);
  },
  fromMat2d: function(a) {
    mat3$2.fromMat2d(this.array, a.array);
    this._dirty = true;
    return this;
  },
  fromMat4: function(a) {
    mat3$2.fromMat4(this.array, a.array);
    this._dirty = true;
    return this;
  },
  fromQuat: function(q) {
    mat3$2.fromQuat(this.array, q.array);
    this._dirty = true;
    return this;
  },
  identity: function() {
    mat3$2.identity(this.array);
    this._dirty = true;
    return this;
  },
  invert: function() {
    mat3$2.invert(this.array, this.array);
    this._dirty = true;
    return this;
  },
  mul: function(b) {
    mat3$2.mul(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  mulLeft: function(a) {
    mat3$2.mul(this.array, a.array, this.array);
    this._dirty = true;
    return this;
  },
  multiply: function(b) {
    mat3$2.multiply(this.array, this.array, b.array);
    this._dirty = true;
    return this;
  },
  multiplyLeft: function(a) {
    mat3$2.multiply(this.array, a.array, this.array);
    this._dirty = true;
    return this;
  },
  rotate: function(rad2) {
    mat3$2.rotate(this.array, this.array, rad2);
    this._dirty = true;
    return this;
  },
  scale: function(v) {
    mat3$2.scale(this.array, this.array, v.array);
    this._dirty = true;
    return this;
  },
  translate: function(v) {
    mat3$2.translate(this.array, this.array, v.array);
    this._dirty = true;
    return this;
  },
  normalFromMat4: function(a) {
    mat3$2.normalFromMat4(this.array, a.array);
    this._dirty = true;
    return this;
  },
  transpose: function() {
    mat3$2.transpose(this.array, this.array);
    this._dirty = true;
    return this;
  },
  toString: function() {
    return "[" + Array.prototype.join.call(this.array, ",") + "]";
  },
  toArray: function() {
    return Array.prototype.slice.call(this.array);
  }
};
Matrix3.adjoint = function(out2, a) {
  mat3$2.adjoint(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix3.copy = function(out2, a) {
  mat3$2.copy(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix3.determinant = function(a) {
  return mat3$2.determinant(a.array);
};
Matrix3.identity = function(out2) {
  mat3$2.identity(out2.array);
  out2._dirty = true;
  return out2;
};
Matrix3.invert = function(out2, a) {
  mat3$2.invert(out2.array, a.array);
  return out2;
};
Matrix3.mul = function(out2, a, b) {
  mat3$2.mul(out2.array, a.array, b.array);
  out2._dirty = true;
  return out2;
};
Matrix3.multiply = Matrix3.mul;
Matrix3.fromMat2d = function(out2, a) {
  mat3$2.fromMat2d(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix3.fromMat4 = function(out2, a) {
  mat3$2.fromMat4(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix3.fromQuat = function(out2, q) {
  mat3$2.fromQuat(out2.array, q.array);
  out2._dirty = true;
  return out2;
};
Matrix3.normalFromMat4 = function(out2, a) {
  mat3$2.normalFromMat4(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix3.rotate = function(out2, a, rad2) {
  mat3$2.rotate(out2.array, a.array, rad2);
  out2._dirty = true;
  return out2;
};
Matrix3.scale = function(out2, a, v) {
  mat3$2.scale(out2.array, a.array, v.array);
  out2._dirty = true;
  return out2;
};
Matrix3.transpose = function(out2, a) {
  mat3$2.transpose(out2.array, a.array);
  out2._dirty = true;
  return out2;
};
Matrix3.translate = function(out2, a, v) {
  mat3$2.translate(out2.array, a.array, v.array);
  out2._dirty = true;
  return out2;
};
var Matrix3$1 = Matrix3;
var animatableMixin = {
  _animators: null,
  getAnimators: function() {
    this._animators = this._animators || [];
    return this._animators;
  },
  animate: function(path, opts) {
    this._animators = this._animators || [];
    var el = this;
    var target;
    if (path) {
      var pathSplitted = path.split(".");
      var prop = el;
      for (var i = 0, l = pathSplitted.length; i < l; i++) {
        if (!prop) {
          continue;
        }
        prop = prop[pathSplitted[i]];
      }
      if (prop) {
        target = prop;
      }
    } else {
      target = el;
    }
    if (target == null) {
      throw new Error("Target " + path + " not exists");
    }
    var animators = this._animators;
    var animator = new Animator$1(target, opts);
    var self2 = this;
    animator.during(function() {
      if (self2.__zr) {
        self2.__zr.refresh();
      }
    }).done(function() {
      var idx = animators.indexOf(animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    animators.push(animator);
    if (this.__zr) {
      this.__zr.animation.addAnimator(animator);
    }
    return animator;
  },
  stopAnimation: function(forwardToLast) {
    this._animators = this._animators || [];
    var animators = this._animators;
    var len2 = animators.length;
    for (var i = 0; i < len2; i++) {
      animators[i].stop(forwardToLast);
    }
    animators.length = 0;
    return this;
  },
  addAnimatorsToZr: function(zr) {
    if (this._animators) {
      for (var i = 0; i < this._animators.length; i++) {
        zr.animation.addAnimator(this._animators[i]);
      }
    }
  },
  removeAnimatorsFromZr: function(zr) {
    if (this._animators) {
      for (var i = 0; i < this._animators.length; i++) {
        zr.animation.removeAnimator(this._animators[i]);
      }
    }
  }
};
var animatableMixin$1 = animatableMixin;
var utilShaderCode = "\n@export clay.util.rand\nhighp float rand(vec2 uv) {\n const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n highp float dt = dot(uv.xy, vec2(a,b)), sn = mod(dt, 3.141592653589793);\n return fract(sin(sn) * c);\n}\n@end\n@export clay.util.calculate_attenuation\nuniform float attenuationFactor : 5.0;\nfloat lightAttenuation(float dist, float range)\n{\n float attenuation = 1.0;\n attenuation = dist*dist/(range*range+1.0);\n float att_s = attenuationFactor;\n attenuation = 1.0/(attenuation*att_s+1.0);\n att_s = 1.0/(att_s+1.0);\n attenuation = attenuation - att_s;\n attenuation /= 1.0 - att_s;\n return clamp(attenuation, 0.0, 1.0);\n}\n@end\n@export clay.util.edge_factor\n#ifdef SUPPORT_STANDARD_DERIVATIVES\nfloat edgeFactor(float width)\n{\n vec3 d = fwidth(v_Barycentric);\n vec3 a3 = smoothstep(vec3(0.0), d * width, v_Barycentric);\n return min(min(a3.x, a3.y), a3.z);\n}\n#else\nfloat edgeFactor(float width)\n{\n return 1.0;\n}\n#endif\n@end\n@export clay.util.encode_float\nvec4 encodeFloat(const in float depth)\n{\n const vec4 bitShifts = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n const vec4 bit_mask = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n vec4 res = fract(depth * bitShifts);\n res -= res.xxyz * bit_mask;\n return res;\n}\n@end\n@export clay.util.decode_float\nfloat decodeFloat(const in vec4 color)\n{\n const vec4 bitShifts = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n return dot(color, bitShifts);\n}\n@end\n@export clay.util.float\n@import clay.util.encode_float\n@import clay.util.decode_float\n@end\n@export clay.util.rgbm_decode\nvec3 RGBMDecode(vec4 rgbm, float range) {\n return range * rgbm.rgb * rgbm.a;\n}\n@end\n@export clay.util.rgbm_encode\nvec4 RGBMEncode(vec3 color, float range) {\n if (dot(color, color) == 0.0) {\n return vec4(0.0);\n }\n vec4 rgbm;\n color /= range;\n rgbm.a = clamp(max(max(color.r, color.g), max(color.b, 1e-6)), 0.0, 1.0);\n rgbm.a = ceil(rgbm.a * 255.0) / 255.0;\n rgbm.rgb = color / rgbm.a;\n return rgbm;\n}\n@end\n@export clay.util.rgbm\n@import clay.util.rgbm_decode\n@import clay.util.rgbm_encode\nvec4 decodeHDR(vec4 color)\n{\n#if defined(RGBM_DECODE) || defined(RGBM)\n return vec4(RGBMDecode(color, 8.12), 1.0);\n#else\n return color;\n#endif\n}\nvec4 encodeHDR(vec4 color)\n{\n#if defined(RGBM_ENCODE) || defined(RGBM)\n return RGBMEncode(color.xyz, 8.12);\n#else\n return color;\n#endif\n}\n@end\n@export clay.util.srgb\nvec4 sRGBToLinear(in vec4 value) {\n return vec4(mix(pow(value.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), value.rgb * 0.0773993808, vec3(lessThanEqual(value.rgb, vec3(0.04045)))), value.w);\n}\nvec4 linearTosRGB(in vec4 value) {\n return vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.w);\n}\n@end\n@export clay.chunk.skinning_header\n#ifdef SKINNING\nattribute vec3 weight : WEIGHT;\nattribute vec4 joint : JOINT;\n#ifdef USE_SKIN_MATRICES_TEXTURE\nuniform sampler2D skinMatricesTexture : ignore;\nuniform float skinMatricesTextureSize: ignore;\nmat4 getSkinMatrix(sampler2D tex, float idx) {\n float j = idx * 4.0;\n float x = mod(j, skinMatricesTextureSize);\n float y = floor(j / skinMatricesTextureSize) + 0.5;\n vec2 scale = vec2(skinMatricesTextureSize);\n return mat4(\n texture2D(tex, vec2(x + 0.5, y) / scale),\n texture2D(tex, vec2(x + 1.5, y) / scale),\n texture2D(tex, vec2(x + 2.5, y) / scale),\n texture2D(tex, vec2(x + 3.5, y) / scale)\n );\n}\nmat4 getSkinMatrix(float idx) {\n return getSkinMatrix(skinMatricesTexture, idx);\n}\n#else\nuniform mat4 skinMatrix[JOINT_COUNT] : SKIN_MATRIX;\nmat4 getSkinMatrix(float idx) {\n return skinMatrix[int(idx)];\n}\n#endif\n#endif\n@end\n@export clay.chunk.skin_matrix\nmat4 skinMatrixWS = getSkinMatrix(joint.x) * weight.x;\nif (weight.y > 1e-4)\n{\n skinMatrixWS += getSkinMatrix(joint.y) * weight.y;\n}\nif (weight.z > 1e-4)\n{\n skinMatrixWS += getSkinMatrix(joint.z) * weight.z;\n}\nfloat weightW = 1.0-weight.x-weight.y-weight.z;\nif (weightW > 1e-4)\n{\n skinMatrixWS += getSkinMatrix(joint.w) * weightW;\n}\n@end\n@export clay.chunk.instancing_header\n#ifdef INSTANCING\nattribute vec4 instanceMat1;\nattribute vec4 instanceMat2;\nattribute vec4 instanceMat3;\n#endif\n@end\n@export clay.chunk.instancing_matrix\nmat4 instanceMat = mat4(\n vec4(instanceMat1.xyz, 0.0),\n vec4(instanceMat2.xyz, 0.0),\n vec4(instanceMat3.xyz, 0.0),\n vec4(instanceMat1.w, instanceMat2.w, instanceMat3.w, 1.0)\n);\n@end\n@export clay.util.parallax_correct\nvec3 parallaxCorrect(in vec3 dir, in vec3 pos, in vec3 boxMin, in vec3 boxMax) {\n vec3 first = (boxMax - pos) / dir;\n vec3 second = (boxMin - pos) / dir;\n vec3 further = max(first, second);\n float dist = min(further.x, min(further.y, further.z));\n vec3 fixedPos = pos + dir * dist;\n vec3 boxCenter = (boxMax + boxMin) * 0.5;\n return normalize(fixedPos - boxCenter);\n}\n@end\n@export clay.util.clamp_sample\nvec4 clampSample(const in sampler2D texture, const in vec2 coord)\n{\n#ifdef STEREO\n float eye = step(0.5, coord.x) * 0.5;\n vec2 coordClamped = clamp(coord, vec2(eye, 0.0), vec2(0.5 + eye, 1.0));\n#else\n vec2 coordClamped = clamp(coord, vec2(0.0), vec2(1.0));\n#endif\n return texture2D(texture, coordClamped);\n}\n@end\n@export clay.util.ACES\nvec3 ACESToneMapping(vec3 color)\n{\n const float A = 2.51;\n const float B = 0.03;\n const float C = 2.43;\n const float D = 0.59;\n const float E = 0.14;\n return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n@end";
var commonGLSL = "\n@export ecgl.common.transformUniforms\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nuniform mat4 world : WORLD;\n@end\n\n@export ecgl.common.attributes\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 normal : NORMAL;\n@end\n\n@export ecgl.common.uv.header\nuniform vec2 uvRepeat : [1.0, 1.0];\nuniform vec2 uvOffset : [0.0, 0.0];\nuniform vec2 detailUvRepeat : [1.0, 1.0];\nuniform vec2 detailUvOffset : [0.0, 0.0];\n\nvarying vec2 v_Texcoord;\nvarying vec2 v_DetailTexcoord;\n@end\n\n@export ecgl.common.uv.main\nv_Texcoord = texcoord * uvRepeat + uvOffset;\nv_DetailTexcoord = texcoord * detailUvRepeat + detailUvOffset;\n@end\n\n@export ecgl.common.uv.fragmentHeader\nvarying vec2 v_Texcoord;\nvarying vec2 v_DetailTexcoord;\n@end\n\n\n@export ecgl.common.albedo.main\n\n vec4 albedoTexel = vec4(1.0);\n#ifdef DIFFUSEMAP_ENABLED\n albedoTexel = texture2D(diffuseMap, v_Texcoord);\n #ifdef SRGB_DECODE\n albedoTexel = sRGBToLinear(albedoTexel);\n #endif\n#endif\n\n#ifdef DETAILMAP_ENABLED\n vec4 detailTexel = texture2D(detailMap, v_DetailTexcoord);\n #ifdef SRGB_DECODE\n detailTexel = sRGBToLinear(detailTexel);\n #endif\n albedoTexel.rgb = mix(albedoTexel.rgb, detailTexel.rgb, detailTexel.a);\n albedoTexel.a = detailTexel.a + (1.0 - detailTexel.a) * albedoTexel.a;\n#endif\n\n@end\n\n@export ecgl.common.wireframe.vertexHeader\n\n#ifdef WIREFRAME_QUAD\nattribute vec4 barycentric;\nvarying vec4 v_Barycentric;\n#elif defined(WIREFRAME_TRIANGLE)\nattribute vec3 barycentric;\nvarying vec3 v_Barycentric;\n#endif\n\n@end\n\n@export ecgl.common.wireframe.vertexMain\n\n#if defined(WIREFRAME_QUAD) || defined(WIREFRAME_TRIANGLE)\n v_Barycentric = barycentric;\n#endif\n\n@end\n\n\n@export ecgl.common.wireframe.fragmentHeader\n\nuniform float wireframeLineWidth : 1;\nuniform vec4 wireframeLineColor: [0, 0, 0, 0.5];\n\n#ifdef WIREFRAME_QUAD\nvarying vec4 v_Barycentric;\nfloat edgeFactor () {\n vec4 d = fwidth(v_Barycentric);\n vec4 a4 = smoothstep(vec4(0.0), d * wireframeLineWidth, v_Barycentric);\n return min(min(min(a4.x, a4.y), a4.z), a4.w);\n}\n#elif defined(WIREFRAME_TRIANGLE)\nvarying vec3 v_Barycentric;\nfloat edgeFactor () {\n vec3 d = fwidth(v_Barycentric);\n vec3 a3 = smoothstep(vec3(0.0), d * wireframeLineWidth, v_Barycentric);\n return min(min(a3.x, a3.y), a3.z);\n}\n#endif\n\n@end\n\n\n@export ecgl.common.wireframe.fragmentMain\n\n#if defined(WIREFRAME_QUAD) || defined(WIREFRAME_TRIANGLE)\n if (wireframeLineWidth > 0.) {\n vec4 lineColor = wireframeLineColor;\n#ifdef SRGB_DECODE\n lineColor = sRGBToLinear(lineColor);\n#endif\n\n gl_FragColor.rgb = mix(gl_FragColor.rgb, lineColor.rgb, (1.0 - edgeFactor()) * lineColor.a);\n }\n#endif\n@end\n\n\n\n\n@export ecgl.common.bumpMap.header\n\n#ifdef BUMPMAP_ENABLED\nuniform sampler2D bumpMap;\nuniform float bumpScale : 1.0;\n\n\nvec3 bumpNormal(vec3 surfPos, vec3 surfNormal, vec3 baseNormal)\n{\n vec2 dSTdx = dFdx(v_Texcoord);\n vec2 dSTdy = dFdy(v_Texcoord);\n\n float Hll = bumpScale * texture2D(bumpMap, v_Texcoord).x;\n float dHx = bumpScale * texture2D(bumpMap, v_Texcoord + dSTdx).x - Hll;\n float dHy = bumpScale * texture2D(bumpMap, v_Texcoord + dSTdy).x - Hll;\n\n vec3 vSigmaX = dFdx(surfPos);\n vec3 vSigmaY = dFdy(surfPos);\n vec3 vN = surfNormal;\n\n vec3 R1 = cross(vSigmaY, vN);\n vec3 R2 = cross(vN, vSigmaX);\n\n float fDet = dot(vSigmaX, R1);\n\n vec3 vGrad = sign(fDet) * (dHx * R1 + dHy * R2);\n return normalize(abs(fDet) * baseNormal - vGrad);\n\n}\n#endif\n\n@end\n\n@export ecgl.common.normalMap.vertexHeader\n\n#ifdef NORMALMAP_ENABLED\nattribute vec4 tangent : TANGENT;\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\n@end\n\n@export ecgl.common.normalMap.vertexMain\n\n#ifdef NORMALMAP_ENABLED\n if (dot(tangent, tangent) > 0.0) {\n v_Tangent = normalize((worldInverseTranspose * vec4(tangent.xyz, 0.0)).xyz);\n v_Bitangent = normalize(cross(v_Normal, v_Tangent) * tangent.w);\n }\n#endif\n\n@end\n\n\n@export ecgl.common.normalMap.fragmentHeader\n\n#ifdef NORMALMAP_ENABLED\nuniform sampler2D normalMap;\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\n@end\n\n@export ecgl.common.normalMap.fragmentMain\n#ifdef NORMALMAP_ENABLED\n if (dot(v_Tangent, v_Tangent) > 0.0) {\n vec3 normalTexel = texture2D(normalMap, v_DetailTexcoord).xyz;\n if (dot(normalTexel, normalTexel) > 0.0) { N = normalTexel * 2.0 - 1.0;\n mat3 tbn = mat3(v_Tangent, v_Bitangent, v_Normal);\n N = normalize(tbn * N);\n }\n }\n#endif\n@end\n\n\n\n@export ecgl.common.vertexAnimation.header\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nattribute vec3 prevNormal;\nuniform float percent;\n#endif\n\n@end\n\n@export ecgl.common.vertexAnimation.main\n\n#ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n vec3 norm = mix(prevNormal, normal, percent);\n#else\n vec3 pos = position;\n vec3 norm = normal;\n#endif\n\n@end\n\n\n@export ecgl.common.ssaoMap.header\n#ifdef SSAOMAP_ENABLED\nuniform sampler2D ssaoMap;\nuniform vec4 viewport : VIEWPORT;\n#endif\n@end\n\n@export ecgl.common.ssaoMap.main\n float ao = 1.0;\n#ifdef SSAOMAP_ENABLED\n ao = texture2D(ssaoMap, (gl_FragCoord.xy - viewport.xy) / viewport.zw).r;\n#endif\n@end\n\n\n\n\n@export ecgl.common.diffuseLayer.header\n\n#if (LAYER_DIFFUSEMAP_COUNT > 0)\nuniform float layerDiffuseIntensity[LAYER_DIFFUSEMAP_COUNT];\nuniform sampler2D layerDiffuseMap[LAYER_DIFFUSEMAP_COUNT];\n#endif\n\n@end\n\n@export ecgl.common.emissiveLayer.header\n\n#if (LAYER_EMISSIVEMAP_COUNT > 0)\nuniform float layerEmissionIntensity[LAYER_EMISSIVEMAP_COUNT];\nuniform sampler2D layerEmissiveMap[LAYER_EMISSIVEMAP_COUNT];\n#endif\n\n@end\n\n@export ecgl.common.layers.header\n@import ecgl.common.diffuseLayer.header\n@import ecgl.common.emissiveLayer.header\n@end\n\n@export ecgl.common.diffuseLayer.main\n\n#if (LAYER_DIFFUSEMAP_COUNT > 0)\n for (int _idx_ = 0; _idx_ < LAYER_DIFFUSEMAP_COUNT; _idx_++) {{\n float intensity = layerDiffuseIntensity[_idx_];\n vec4 texel2 = texture2D(layerDiffuseMap[_idx_], v_Texcoord);\n #ifdef SRGB_DECODE\n texel2 = sRGBToLinear(texel2);\n #endif\n albedoTexel.rgb = mix(albedoTexel.rgb, texel2.rgb * intensity, texel2.a);\n albedoTexel.a = texel2.a + (1.0 - texel2.a) * albedoTexel.a;\n }}\n#endif\n\n@end\n\n@export ecgl.common.emissiveLayer.main\n\n#if (LAYER_EMISSIVEMAP_COUNT > 0)\n for (int _idx_ = 0; _idx_ < LAYER_EMISSIVEMAP_COUNT; _idx_++)\n {{\n vec4 texel2 = texture2D(layerEmissiveMap[_idx_], v_Texcoord) * layerEmissionIntensity[_idx_];\n #ifdef SRGB_DECODE\n texel2 = sRGBToLinear(texel2);\n #endif\n float intensity = layerEmissionIntensity[_idx_];\n gl_FragColor.rgb += texel2.rgb * texel2.a * intensity;\n }}\n#endif\n\n@end\n";
var colorGLSL = "@export ecgl.color.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\n@import ecgl.common.uv.header\n\nattribute vec2 texcoord : TEXCOORD_0;\nattribute vec3 position: POSITION;\n\n@import ecgl.common.wireframe.vertexHeader\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n#endif\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nuniform float percent : 1.0;\n#endif\n\n#ifdef ATMOSPHERE_ENABLED\nattribute vec3 normal: NORMAL;\nuniform mat4 worldInverseTranspose : WORLDINVERSETRANSPOSE;\nvarying vec3 v_Normal;\n#endif\n\nvoid main()\n{\n#ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n#else\n vec3 pos = position;\n#endif\n\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n\n @import ecgl.common.uv.main\n\n#ifdef VERTEX_COLOR\n v_Color = a_Color;\n#endif\n\n#ifdef ATMOSPHERE_ENABLED\n v_Normal = normalize((worldInverseTranspose * vec4(normal, 0.0)).xyz);\n#endif\n\n @import ecgl.common.wireframe.vertexMain\n\n}\n\n@end\n\n@export ecgl.color.fragment\n\n#define LAYER_DIFFUSEMAP_COUNT 0\n#define LAYER_EMISSIVEMAP_COUNT 0\n\nuniform sampler2D diffuseMap;\nuniform sampler2D detailMap;\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\n#ifdef ATMOSPHERE_ENABLED\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform vec3 glowColor;\nuniform float glowPower;\nvarying vec3 v_Normal;\n#endif\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\n@import ecgl.common.layers.header\n\n@import ecgl.common.uv.fragmentHeader\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.util.srgb\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color);\n#else\n gl_FragColor = color;\n#endif\n\n#ifdef VERTEX_COLOR\n gl_FragColor *= v_Color;\n#endif\n\n @import ecgl.common.albedo.main\n\n @import ecgl.common.diffuseLayer.main\n\n gl_FragColor *= albedoTexel;\n\n#ifdef ATMOSPHERE_ENABLED\n float atmoIntensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor.rgb += glowColor * atmoIntensity;\n#endif\n\n @import ecgl.common.emissiveLayer.main\n\n @import ecgl.common.wireframe.fragmentMain\n\n}\n@end";
var lambertGLSL = "/**\n * http: */\n\n@export ecgl.lambert.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n\n@import ecgl.common.attributes\n\n@import ecgl.common.wireframe.vertexHeader\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n#endif\n\n\n@import ecgl.common.vertexAnimation.header\n\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nvoid main()\n{\n @import ecgl.common.uv.main\n\n @import ecgl.common.vertexAnimation.main\n\n\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n\n v_Normal = normalize((worldInverseTranspose * vec4(norm, 0.0)).xyz);\n v_WorldPosition = (world * vec4(pos, 1.0)).xyz;\n\n#ifdef VERTEX_COLOR\n v_Color = a_Color;\n#endif\n\n @import ecgl.common.wireframe.vertexMain\n}\n\n@end\n\n\n@export ecgl.lambert.fragment\n\n#define LAYER_DIFFUSEMAP_COUNT 0\n#define LAYER_EMISSIVEMAP_COUNT 0\n\n#define NORMAL_UP_AXIS 1\n#define NORMAL_FRONT_AXIS 2\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform sampler2D diffuseMap;\nuniform sampler2D detailMap;\n\n@import ecgl.common.layers.header\n\nuniform float emissionIntensity: 1.0;\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\n#ifdef ATMOSPHERE_ENABLED\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform vec3 glowColor;\nuniform float glowPower;\n#endif\n\n#ifdef AMBIENT_LIGHT_COUNT\n@import clay.header.ambient_light\n#endif\n#ifdef AMBIENT_SH_LIGHT_COUNT\n@import clay.header.ambient_sh_light\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\n\n@import ecgl.common.ssaoMap.header\n\n@import ecgl.common.bumpMap.header\n\n@import clay.util.srgb\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.plugin.compute_shadow_map\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color);\n#else\n gl_FragColor = color;\n#endif\n\n#ifdef VERTEX_COLOR\n #ifdef SRGB_DECODE\n gl_FragColor *= sRGBToLinear(v_Color);\n #else\n gl_FragColor *= v_Color;\n #endif\n#endif\n\n @import ecgl.common.albedo.main\n\n @import ecgl.common.diffuseLayer.main\n\n gl_FragColor *= albedoTexel;\n\n vec3 N = v_Normal;\n#ifdef DOUBLE_SIDED\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(eyePos - v_WorldPosition);\n\n if (dot(N, V) < 0.0) {\n N = -N;\n }\n#endif\n\n float ambientFactor = 1.0;\n\n#ifdef BUMPMAP_ENABLED\n N = bumpNormal(v_WorldPosition, v_Normal, N);\n ambientFactor = dot(v_Normal, N);\n#endif\n\n vec3 N2 = vec3(N.x, N[NORMAL_UP_AXIS], N[NORMAL_FRONT_AXIS]);\n\n vec3 diffuseColor = vec3(0.0, 0.0, 0.0);\n\n @import ecgl.common.ssaoMap.main\n\n#ifdef AMBIENT_LIGHT_COUNT\n for(int i = 0; i < AMBIENT_LIGHT_COUNT; i++)\n {\n diffuseColor += ambientLightColor[i] * ambientFactor * ao;\n }\n#endif\n#ifdef AMBIENT_SH_LIGHT_COUNT\n for(int _idx_ = 0; _idx_ < AMBIENT_SH_LIGHT_COUNT; _idx_++)\n {{\n diffuseColor += calcAmbientSHLight(_idx_, N2) * ambientSHLightColor[_idx_] * ao;\n }}\n#endif\n#ifdef DIRECTIONAL_LIGHT_COUNT\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n#endif\n for(int i = 0; i < DIRECTIONAL_LIGHT_COUNT; i++)\n {\n vec3 lightDirection = -directionalLightDirection[i];\n vec3 lightColor = directionalLightColor[i];\n\n float shadowContrib = 1.0;\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n if (shadowEnabled)\n {\n shadowContrib = shadowContribsDir[i];\n }\n#endif\n\n float ndl = dot(N, normalize(lightDirection)) * shadowContrib;\n\n diffuseColor += lightColor * clamp(ndl, 0.0, 1.0);\n }\n#endif\n\n gl_FragColor.rgb *= diffuseColor;\n\n#ifdef ATMOSPHERE_ENABLED\n float atmoIntensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor.rgb += glowColor * atmoIntensity;\n#endif\n\n @import ecgl.common.emissiveLayer.main\n\n @import ecgl.common.wireframe.fragmentMain\n}\n\n@end";
var realisticGLSL = "@export ecgl.realistic.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n@import ecgl.common.attributes\n\n\n@import ecgl.common.wireframe.vertexHeader\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n#endif\n\n#ifdef NORMALMAP_ENABLED\nattribute vec4 tangent : TANGENT;\nvarying vec3 v_Tangent;\nvarying vec3 v_Bitangent;\n#endif\n\n@import ecgl.common.vertexAnimation.header\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nvoid main()\n{\n\n @import ecgl.common.uv.main\n\n @import ecgl.common.vertexAnimation.main\n\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n\n v_Normal = normalize((worldInverseTranspose * vec4(norm, 0.0)).xyz);\n v_WorldPosition = (world * vec4(pos, 1.0)).xyz;\n\n#ifdef VERTEX_COLOR\n v_Color = a_Color;\n#endif\n\n#ifdef NORMALMAP_ENABLED\n v_Tangent = normalize((worldInverseTranspose * vec4(tangent.xyz, 0.0)).xyz);\n v_Bitangent = normalize(cross(v_Normal, v_Tangent) * tangent.w);\n#endif\n\n @import ecgl.common.wireframe.vertexMain\n\n}\n\n@end\n\n\n\n@export ecgl.realistic.fragment\n\n#define LAYER_DIFFUSEMAP_COUNT 0\n#define LAYER_EMISSIVEMAP_COUNT 0\n#define PI 3.14159265358979\n#define ROUGHNESS_CHANEL 0\n#define METALNESS_CHANEL 1\n\n#define NORMAL_UP_AXIS 1\n#define NORMAL_FRONT_AXIS 2\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform sampler2D diffuseMap;\n\nuniform sampler2D detailMap;\nuniform sampler2D metalnessMap;\nuniform sampler2D roughnessMap;\n\n@import ecgl.common.layers.header\n\nuniform float emissionIntensity: 1.0;\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nuniform float metalness : 0.0;\nuniform float roughness : 0.5;\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\n#ifdef ATMOSPHERE_ENABLED\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform vec3 glowColor;\nuniform float glowPower;\n#endif\n\n#ifdef AMBIENT_LIGHT_COUNT\n@import clay.header.ambient_light\n#endif\n\n#ifdef AMBIENT_SH_LIGHT_COUNT\n@import clay.header.ambient_sh_light\n#endif\n\n#ifdef AMBIENT_CUBEMAP_LIGHT_COUNT\n@import clay.header.ambient_cubemap_light\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n@import ecgl.common.normalMap.fragmentHeader\n\n@import ecgl.common.ssaoMap.header\n\n@import ecgl.common.bumpMap.header\n\n@import clay.util.srgb\n\n@import clay.util.rgbm\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.plugin.compute_shadow_map\n\nvec3 F_Schlick(float ndv, vec3 spec) {\n return spec + (1.0 - spec) * pow(1.0 - ndv, 5.0);\n}\n\nfloat D_Phong(float g, float ndh) {\n float a = pow(8192.0, g);\n return (a + 2.0) / 8.0 * pow(ndh, a);\n}\n\nvoid main()\n{\n vec4 albedoColor = color;\n\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(eyePos - v_WorldPosition);\n#ifdef VERTEX_COLOR\n #ifdef SRGB_DECODE\n albedoColor *= sRGBToLinear(v_Color);\n #else\n albedoColor *= v_Color;\n #endif\n#endif\n\n @import ecgl.common.albedo.main\n\n @import ecgl.common.diffuseLayer.main\n\n albedoColor *= albedoTexel;\n\n float m = metalness;\n\n#ifdef METALNESSMAP_ENABLED\n float m2 = texture2D(metalnessMap, v_DetailTexcoord)[METALNESS_CHANEL];\n m = clamp(m2 + (m - 0.5) * 2.0, 0.0, 1.0);\n#endif\n\n vec3 baseColor = albedoColor.rgb;\n albedoColor.rgb = baseColor * (1.0 - m);\n vec3 specFactor = mix(vec3(0.04), baseColor, m);\n\n float g = 1.0 - roughness;\n\n#ifdef ROUGHNESSMAP_ENABLED\n float g2 = 1.0 - texture2D(roughnessMap, v_DetailTexcoord)[ROUGHNESS_CHANEL];\n g = clamp(g2 + (g - 0.5) * 2.0, 0.0, 1.0);\n#endif\n\n vec3 N = v_Normal;\n\n#ifdef DOUBLE_SIDED\n if (dot(N, V) < 0.0) {\n N = -N;\n }\n#endif\n\n float ambientFactor = 1.0;\n\n#ifdef BUMPMAP_ENABLED\n N = bumpNormal(v_WorldPosition, v_Normal, N);\n ambientFactor = dot(v_Normal, N);\n#endif\n\n@import ecgl.common.normalMap.fragmentMain\n\n vec3 N2 = vec3(N.x, N[NORMAL_UP_AXIS], N[NORMAL_FRONT_AXIS]);\n\n vec3 diffuseTerm = vec3(0.0);\n vec3 specularTerm = vec3(0.0);\n\n float ndv = clamp(dot(N, V), 0.0, 1.0);\n vec3 fresnelTerm = F_Schlick(ndv, specFactor);\n\n @import ecgl.common.ssaoMap.main\n\n#ifdef AMBIENT_LIGHT_COUNT\n for(int _idx_ = 0; _idx_ < AMBIENT_LIGHT_COUNT; _idx_++)\n {{\n diffuseTerm += ambientLightColor[_idx_] * ambientFactor * ao;\n }}\n#endif\n\n#ifdef AMBIENT_SH_LIGHT_COUNT\n for(int _idx_ = 0; _idx_ < AMBIENT_SH_LIGHT_COUNT; _idx_++)\n {{\n diffuseTerm += calcAmbientSHLight(_idx_, N2) * ambientSHLightColor[_idx_] * ao;\n }}\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n#endif\n for(int _idx_ = 0; _idx_ < DIRECTIONAL_LIGHT_COUNT; _idx_++)\n {{\n vec3 L = -directionalLightDirection[_idx_];\n vec3 lc = directionalLightColor[_idx_];\n\n vec3 H = normalize(L + V);\n float ndl = clamp(dot(N, normalize(L)), 0.0, 1.0);\n float ndh = clamp(dot(N, H), 0.0, 1.0);\n\n float shadowContrib = 1.0;\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n if (shadowEnabled)\n {\n shadowContrib = shadowContribsDir[_idx_];\n }\n#endif\n\n vec3 li = lc * ndl * shadowContrib;\n\n diffuseTerm += li;\n specularTerm += li * fresnelTerm * D_Phong(g, ndh);\n }}\n#endif\n\n\n#ifdef AMBIENT_CUBEMAP_LIGHT_COUNT\n vec3 L = reflect(-V, N);\n L = vec3(L.x, L[NORMAL_UP_AXIS], L[NORMAL_FRONT_AXIS]);\n float rough2 = clamp(1.0 - g, 0.0, 1.0);\n float bias2 = rough2 * 5.0;\n vec2 brdfParam2 = texture2D(ambientCubemapLightBRDFLookup[0], vec2(rough2, ndv)).xy;\n vec3 envWeight2 = specFactor * brdfParam2.x + brdfParam2.y;\n vec3 envTexel2;\n for(int _idx_ = 0; _idx_ < AMBIENT_CUBEMAP_LIGHT_COUNT; _idx_++)\n {{\n envTexel2 = RGBMDecode(textureCubeLodEXT(ambientCubemapLightCubemap[_idx_], L, bias2), 8.12);\n specularTerm += ambientCubemapLightColor[_idx_] * envTexel2 * envWeight2 * ao;\n }}\n#endif\n\n gl_FragColor.rgb = albedoColor.rgb * diffuseTerm + specularTerm;\n gl_FragColor.a = albedoColor.a;\n\n#ifdef ATMOSPHERE_ENABLED\n float atmoIntensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor.rgb += glowColor * atmoIntensity;\n#endif\n\n#ifdef SRGB_ENCODE\n gl_FragColor = linearTosRGB(gl_FragColor);\n#endif\n\n @import ecgl.common.emissiveLayer.main\n\n @import ecgl.common.wireframe.fragmentMain\n}\n\n@end";
var hatchingGLSL = "@export ecgl.hatching.vertex\n\n@import ecgl.realistic.vertex\n\n@end\n\n\n@export ecgl.hatching.fragment\n\n#define NORMAL_UP_AXIS 1\n#define NORMAL_FRONT_AXIS 2\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform vec4 color : [0.0, 0.0, 0.0, 1.0];\nuniform vec4 paperColor : [1.0, 1.0, 1.0, 1.0];\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\n#ifdef AMBIENT_LIGHT_COUNT\n@import clay.header.ambient_light\n#endif\n#ifdef AMBIENT_SH_LIGHT_COUNT\n@import clay.header.ambient_sh_light\n#endif\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\n\n@import ecgl.common.ssaoMap.header\n\n@import ecgl.common.bumpMap.header\n\n@import clay.util.srgb\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.plugin.compute_shadow_map\n\nuniform sampler2D hatch1;\nuniform sampler2D hatch2;\nuniform sampler2D hatch3;\nuniform sampler2D hatch4;\nuniform sampler2D hatch5;\nuniform sampler2D hatch6;\n\nfloat shade(in float tone) {\n vec4 c = vec4(1. ,1., 1., 1.);\n float step = 1. / 6.;\n vec2 uv = v_DetailTexcoord;\n if (tone <= step / 2.0) {\n c = mix(vec4(0.), texture2D(hatch6, uv), 12. * tone);\n }\n else if (tone <= step) {\n c = mix(texture2D(hatch6, uv), texture2D(hatch5, uv), 6. * tone);\n }\n if(tone > step && tone <= 2. * step){\n c = mix(texture2D(hatch5, uv), texture2D(hatch4, uv) , 6. * (tone - step));\n }\n if(tone > 2. * step && tone <= 3. * step){\n c = mix(texture2D(hatch4, uv), texture2D(hatch3, uv), 6. * (tone - 2. * step));\n }\n if(tone > 3. * step && tone <= 4. * step){\n c = mix(texture2D(hatch3, uv), texture2D(hatch2, uv), 6. * (tone - 3. * step));\n }\n if(tone > 4. * step && tone <= 5. * step){\n c = mix(texture2D(hatch2, uv), texture2D(hatch1, uv), 6. * (tone - 4. * step));\n }\n if(tone > 5. * step){\n c = mix(texture2D(hatch1, uv), vec4(1.), 6. * (tone - 5. * step));\n }\n\n return c.r;\n}\n\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n vec4 inkColor = sRGBToLinear(color);\n#else\n vec4 inkColor = color;\n#endif\n\n#ifdef VERTEX_COLOR\n #ifdef SRGB_DECODE\n inkColor *= sRGBToLinear(v_Color);\n #else\n inkColor *= v_Color;\n #endif\n#endif\n\n vec3 N = v_Normal;\n#ifdef DOUBLE_SIDED\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(eyePos - v_WorldPosition);\n\n if (dot(N, V) < 0.0) {\n N = -N;\n }\n#endif\n\n float tone = 0.0;\n\n float ambientFactor = 1.0;\n\n#ifdef BUMPMAP_ENABLED\n N = bumpNormal(v_WorldPosition, v_Normal, N);\n ambientFactor = dot(v_Normal, N);\n#endif\n\n vec3 N2 = vec3(N.x, N[NORMAL_UP_AXIS], N[NORMAL_FRONT_AXIS]);\n\n @import ecgl.common.ssaoMap.main\n\n#ifdef AMBIENT_LIGHT_COUNT\n for(int i = 0; i < AMBIENT_LIGHT_COUNT; i++)\n {\n tone += dot(ambientLightColor[i], w) * ambientFactor * ao;\n }\n#endif\n#ifdef AMBIENT_SH_LIGHT_COUNT\n for(int _idx_ = 0; _idx_ < AMBIENT_SH_LIGHT_COUNT; _idx_++)\n {{\n tone += dot(calcAmbientSHLight(_idx_, N2) * ambientSHLightColor[_idx_], w) * ao;\n }}\n#endif\n#ifdef DIRECTIONAL_LIGHT_COUNT\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n#endif\n for(int i = 0; i < DIRECTIONAL_LIGHT_COUNT; i++)\n {\n vec3 lightDirection = -directionalLightDirection[i];\n float lightTone = dot(directionalLightColor[i], w);\n\n float shadowContrib = 1.0;\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n if (shadowEnabled)\n {\n shadowContrib = shadowContribsDir[i];\n }\n#endif\n\n float ndl = dot(N, normalize(lightDirection)) * shadowContrib;\n\n tone += lightTone * clamp(ndl, 0.0, 1.0);\n }\n#endif\n\n gl_FragColor = mix(inkColor, paperColor, shade(clamp(tone, 0.0, 1.0)));\n }\n@end\n";
var shadowGLSL = "@export ecgl.sm.depth.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nuniform float percent : 1.0;\n#endif\n\nvarying vec4 v_ViewPosition;\nvarying vec2 v_Texcoord;\n\nvoid main(){\n\n#ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n#else\n vec3 pos = position;\n#endif\n\n v_ViewPosition = worldViewProjection * vec4(pos, 1.0);\n gl_Position = v_ViewPosition;\n\n v_Texcoord = texcoord;\n\n}\n@end\n\n\n\n@export ecgl.sm.depth.fragment\n\n@import clay.sm.depth.fragment\n\n@end";
Object.assign(Node3D.prototype, animatableMixin$1);
Shader.import(utilShaderCode);
Shader.import(prezGLSL);
Shader.import(commonGLSL);
Shader.import(colorGLSL);
Shader.import(lambertGLSL);
Shader.import(realisticGLSL);
Shader.import(hatchingGLSL);
Shader.import(shadowGLSL);
function isValueNone(value) {
  return !value || value === "none";
}
function isValueImage(value) {
  return value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof Image;
}
function isECharts(value) {
  return value.getZr && value.setOption;
}
var oldAddToScene = Scene$1.prototype.addToScene;
var oldRemoveFromScene = Scene$1.prototype.removeFromScene;
Scene$1.prototype.addToScene = function(node) {
  oldAddToScene.call(this, node);
  if (this.__zr) {
    var zr = this.__zr;
    node.traverse(function(child) {
      child.__zr = zr;
      if (child.addAnimatorsToZr) {
        child.addAnimatorsToZr(zr);
      }
    });
  }
};
Scene$1.prototype.removeFromScene = function(node) {
  oldRemoveFromScene.call(this, node);
  node.traverse(function(child) {
    var zr = child.__zr;
    child.__zr = null;
    if (zr && child.removeAnimatorsFromZr) {
      child.removeAnimatorsFromZr(zr);
    }
  });
};
Material$1.prototype.setTextureImage = function(textureName, imgValue, api, textureOpts) {
  if (!this.shader) {
    return;
  }
  var zr = api.getZr();
  var material = this;
  var texture;
  material.autoUpdateTextureStatus = false;
  material.disableTexture(textureName);
  if (!isValueNone(imgValue)) {
    texture = graphicGL.loadTexture(imgValue, api, textureOpts, function(texture2) {
      material.enableTexture(textureName);
      zr && zr.refresh();
    });
    material.set(textureName, texture);
  }
  return texture;
};
var graphicGL = {};
graphicGL.Renderer = Renderer$1;
graphicGL.Node = Node3D;
graphicGL.Mesh = Mesh$1;
graphicGL.Shader = Shader;
graphicGL.Material = Material$1;
graphicGL.Texture = Texture$1;
graphicGL.Texture2D = Texture2D$1;
graphicGL.Geometry = Geometry$1;
graphicGL.SphereGeometry = SphereGeometry;
graphicGL.PlaneGeometry = PlaneGeometry;
graphicGL.CubeGeometry = CubeGeometry;
graphicGL.AmbientLight = AmbientLight$1;
graphicGL.DirectionalLight = DirectionalLight$1;
graphicGL.PointLight = PointLight$1;
graphicGL.SpotLight = SpotLight$1;
graphicGL.PerspectiveCamera = PerspectiveCamera;
graphicGL.OrthographicCamera = OrthoCamera;
graphicGL.Vector2 = Vector2$1;
graphicGL.Vector3 = Vector3$1;
graphicGL.Vector4 = Vector4$1;
graphicGL.Quaternion = Quaternion$1;
graphicGL.Matrix2 = Matrix2$1;
graphicGL.Matrix2d = Matrix2d$1;
graphicGL.Matrix3 = Matrix3$1;
graphicGL.Matrix4 = Matrix4$1;
graphicGL.Plane = Plane$2;
graphicGL.Ray = Ray$1;
graphicGL.BoundingBox = BoundingBox$1;
graphicGL.Frustum = Frustum$1;
var blankImage = null;
function getBlankImage() {
  if (blankImage !== null) {
    return blankImage;
  }
  blankImage = textureUtil$1.createBlank("rgba(255,255,255,0)").image;
  return blankImage;
}
function nearestPowerOfTwo(val) {
  return Math.pow(2, Math.round(Math.log(val) / Math.LN2));
}
function convertTextureToPowerOfTwo(texture) {
  if ((texture.wrapS === Texture$1.REPEAT || texture.wrapT === Texture$1.REPEAT) && texture.image) {
    var width = nearestPowerOfTwo(texture.width);
    var height = nearestPowerOfTwo(texture.height);
    if (width !== texture.width || height !== texture.height) {
      var canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
      var ctx = canvas.getContext("2d");
      ctx.drawImage(texture.image, 0, 0, width, height);
      texture.image = canvas;
    }
  }
}
graphicGL.loadTexture = function(imgValue, api, textureOpts, cb) {
  if (typeof textureOpts === "function") {
    cb = textureOpts;
    textureOpts = {};
  }
  textureOpts = textureOpts || {};
  var keys2 = Object.keys(textureOpts).sort();
  var prefix = "";
  for (var i = 0; i < keys2.length; i++) {
    prefix += keys2[i] + "_" + textureOpts[keys2[i]] + "_";
  }
  var textureCache = api.__textureCache = api.__textureCache || new LRUCache$1(20);
  if (isECharts(imgValue)) {
    var id = imgValue.__textureid__;
    var textureObj = textureCache.get(prefix + id);
    if (!textureObj) {
      var surface = new EChartsSurface$1(imgValue);
      surface.onupdate = function() {
        api.getZr().refresh();
      };
      textureObj = {
        texture: surface.getTexture()
      };
      for (var i = 0; i < keys2.length; i++) {
        textureObj.texture[keys2[i]] = textureOpts[keys2[i]];
      }
      id = imgValue.__textureid__ || "__ecgl_ec__" + textureObj.texture.__uid__;
      imgValue.__textureid__ = id;
      textureCache.put(prefix + id, textureObj);
      cb && cb(textureObj.texture);
    } else {
      textureObj.texture.surface.setECharts(imgValue);
      cb && cb(textureObj.texture);
    }
    return textureObj.texture;
  } else if (isValueImage(imgValue)) {
    var id = imgValue.__textureid__;
    var textureObj = textureCache.get(prefix + id);
    if (!textureObj) {
      textureObj = {
        texture: new graphicGL.Texture2D({
          image: imgValue
        })
      };
      for (var i = 0; i < keys2.length; i++) {
        textureObj.texture[keys2[i]] = textureOpts[keys2[i]];
      }
      id = imgValue.__textureid__ || "__ecgl_image__" + textureObj.texture.__uid__;
      imgValue.__textureid__ = id;
      textureCache.put(prefix + id, textureObj);
      convertTextureToPowerOfTwo(textureObj.texture);
      cb && cb(textureObj.texture);
    }
    return textureObj.texture;
  } else {
    var textureObj = textureCache.get(prefix + imgValue);
    if (textureObj) {
      if (textureObj.callbacks) {
        textureObj.callbacks.push(cb);
      } else {
        cb && cb(textureObj.texture);
      }
    } else {
      if (imgValue.match(/.hdr$|^data:application\/octet-stream/)) {
        textureObj = {
          callbacks: [cb]
        };
        var texture = textureUtil$1.loadTexture(imgValue, {
          exposure: textureOpts.exposure,
          fileType: "hdr"
        }, function() {
          texture.dirty();
          textureObj.callbacks.forEach(function(cb2) {
            cb2 && cb2(texture);
          });
          textureObj.callbacks = null;
        });
        textureObj.texture = texture;
        textureCache.put(prefix + imgValue, textureObj);
      } else {
        var texture = new graphicGL.Texture2D({
          image: new Image()
        });
        for (var i = 0; i < keys2.length; i++) {
          texture[keys2[i]] = textureOpts[keys2[i]];
        }
        textureObj = {
          texture,
          callbacks: [cb]
        };
        var originalImage = texture.image;
        originalImage.onload = function() {
          texture.image = originalImage;
          convertTextureToPowerOfTwo(texture);
          texture.dirty();
          textureObj.callbacks.forEach(function(cb2) {
            cb2 && cb2(texture);
          });
          textureObj.callbacks = null;
        };
        originalImage.crossOrigin = "Anonymous";
        originalImage.src = imgValue;
        texture.image = getBlankImage();
        textureCache.put(prefix + imgValue, textureObj);
      }
    }
    return textureObj.texture;
  }
};
graphicGL.createAmbientCubemap = function(opt, renderer, api, cb) {
  opt = opt || {};
  var textureUrl = opt.texture;
  var exposure = retrieve$1.firstNotNull(opt.exposure, 1);
  var ambientCubemap = new AmbientCubemapLight$1({
    intensity: retrieve$1.firstNotNull(opt.specularIntensity, 1)
  });
  var ambientSH = new AmbientSHLight$1({
    intensity: retrieve$1.firstNotNull(opt.diffuseIntensity, 1),
    coefficients: [0.844, 0.712, 0.691, -0.037, 0.083, 0.167, 0.343, 0.288, 0.299, -0.041, -0.021, -9e-3, -3e-3, -0.041, -0.064, -0.011, -7e-3, -4e-3, -0.031, 0.034, 0.081, -0.06, -0.049, -0.06, 0.046, 0.056, 0.05]
  });
  ambientCubemap.cubemap = graphicGL.loadTexture(textureUrl, api, {
    exposure
  }, function() {
    ambientCubemap.cubemap.flipY = false;
    ambientCubemap.prefilter(renderer, 32);
    ambientSH.coefficients = shUtil.projectEnvironmentMap(renderer, ambientCubemap.cubemap, {
      lod: 1
    });
    cb && cb();
  });
  return {
    specular: ambientCubemap,
    diffuse: ambientSH
  };
};
graphicGL.createBlankTexture = textureUtil$1.createBlank;
graphicGL.isImage = isValueImage;
graphicGL.additiveBlend = function(gl) {
  gl.blendEquation(gl.FUNC_ADD);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
};
graphicGL.parseColor = function(colorStr, rgba) {
  if (colorStr instanceof Array) {
    if (!rgba) {
      rgba = [];
    }
    rgba[0] = colorStr[0];
    rgba[1] = colorStr[1];
    rgba[2] = colorStr[2];
    if (colorStr.length > 3) {
      rgba[3] = colorStr[3];
    } else {
      rgba[3] = 1;
    }
    return rgba;
  }
  rgba = parse(colorStr || "#000", rgba) || [0, 0, 0, 0];
  rgba[0] /= 255;
  rgba[1] /= 255;
  rgba[2] /= 255;
  return rgba;
};
graphicGL.directionFromAlphaBeta = function(alpha, beta) {
  var theta = alpha / 180 * Math.PI + Math.PI / 2;
  var phi = -beta / 180 * Math.PI + Math.PI / 2;
  var dir3 = [];
  var r = Math.sin(theta);
  dir3[0] = r * Math.cos(phi);
  dir3[1] = -Math.cos(theta);
  dir3[2] = r * Math.sin(phi);
  return dir3;
};
graphicGL.getShadowResolution = function(shadowQuality) {
  var shadowResolution = 1024;
  switch (shadowQuality) {
    case "low":
      shadowResolution = 512;
      break;
    case "medium":
      break;
    case "high":
      shadowResolution = 2048;
      break;
    case "ultra":
      shadowResolution = 4096;
      break;
  }
  return shadowResolution;
};
graphicGL.COMMON_SHADERS = ["lambert", "color", "realistic", "hatching", "shadow"];
graphicGL.createShader = function(prefix) {
  if (prefix === "ecgl.shadow") {
    prefix = "ecgl.displayShadow";
  }
  var vertexShaderStr = Shader.source(prefix + ".vertex");
  var fragmentShaderStr = Shader.source(prefix + ".fragment");
  if (!vertexShaderStr) {
    console.error("Vertex shader of '%s' not exits", prefix);
  }
  if (!fragmentShaderStr) {
    console.error("Fragment shader of '%s' not exits", prefix);
  }
  var shader = new Shader(vertexShaderStr, fragmentShaderStr);
  shader.name = prefix;
  return shader;
};
graphicGL.createMaterial = function(prefix, defines) {
  if (!(defines instanceof Array)) {
    defines = [defines];
  }
  var shader = graphicGL.createShader(prefix);
  var material = new Material$1({
    shader
  });
  defines.forEach(function(defineName) {
    if (typeof defineName === "string") {
      material.define(defineName);
    }
  });
  return material;
};
graphicGL.setMaterialFromModel = function(shading, material, model, api) {
  material.autoUpdateTextureStatus = false;
  var materialModel = model.getModel(shading + "Material");
  var detailTexture = materialModel.get("detailTexture");
  var uvRepeat = retrieve$1.firstNotNull(materialModel.get("textureTiling"), 1);
  var uvOffset = retrieve$1.firstNotNull(materialModel.get("textureOffset"), 0);
  if (typeof uvRepeat === "number") {
    uvRepeat = [uvRepeat, uvRepeat];
  }
  if (typeof uvOffset === "number") {
    uvOffset = [uvOffset, uvOffset];
  }
  var repeatParam = uvRepeat[0] > 1 || uvRepeat[1] > 1 ? graphicGL.Texture.REPEAT : graphicGL.Texture.CLAMP_TO_EDGE;
  var textureOpt = {
    anisotropic: 8,
    wrapS: repeatParam,
    wrapT: repeatParam
  };
  if (shading === "realistic") {
    var roughness = materialModel.get("roughness");
    var metalness = materialModel.get("metalness");
    if (metalness != null) {
      if (isNaN(metalness)) {
        material.setTextureImage("metalnessMap", metalness, api, textureOpt);
        metalness = retrieve$1.firstNotNull(materialModel.get("metalnessAdjust"), 0.5);
      }
    } else {
      metalness = 0;
    }
    if (roughness != null) {
      if (isNaN(roughness)) {
        material.setTextureImage("roughnessMap", roughness, api, textureOpt);
        roughness = retrieve$1.firstNotNull(materialModel.get("roughnessAdjust"), 0.5);
      }
    } else {
      roughness = 0.5;
    }
    var normalTextureVal = materialModel.get("normalTexture");
    material.setTextureImage("detailMap", detailTexture, api, textureOpt);
    material.setTextureImage("normalMap", normalTextureVal, api, textureOpt);
    material.set({
      roughness,
      metalness,
      detailUvRepeat: uvRepeat,
      detailUvOffset: uvOffset
    });
  } else if (shading === "lambert") {
    material.setTextureImage("detailMap", detailTexture, api, textureOpt);
    material.set({
      detailUvRepeat: uvRepeat,
      detailUvOffset: uvOffset
    });
  } else if (shading === "color") {
    material.setTextureImage("detailMap", detailTexture, api, textureOpt);
    material.set({
      detailUvRepeat: uvRepeat,
      detailUvOffset: uvOffset
    });
  } else if (shading === "hatching") {
    var tams = materialModel.get("hatchingTextures") || [];
    if (tams.length < 6)
      ;
    for (var i = 0; i < 6; i++) {
      material.setTextureImage("hatch" + (i + 1), tams[i], api, {
        anisotropic: 8,
        wrapS: graphicGL.Texture.REPEAT,
        wrapT: graphicGL.Texture.REPEAT
      });
    }
    material.set({
      detailUvRepeat: uvRepeat,
      detailUvOffset: uvOffset
    });
  }
};
graphicGL.updateVertexAnimation = function(mappingAttributes, previousMesh, currentMesh, seriesModel) {
  var enableAnimation = seriesModel.get("animation");
  var duration = seriesModel.get("animationDurationUpdate");
  var easing = seriesModel.get("animationEasingUpdate");
  var shadowDepthMaterial = currentMesh.shadowDepthMaterial;
  if (enableAnimation && previousMesh && duration > 0 && previousMesh.geometry.vertexCount === currentMesh.geometry.vertexCount) {
    currentMesh.material.define("vertex", "VERTEX_ANIMATION");
    currentMesh.ignorePreZ = true;
    if (shadowDepthMaterial) {
      shadowDepthMaterial.define("vertex", "VERTEX_ANIMATION");
    }
    for (var i = 0; i < mappingAttributes.length; i++) {
      currentMesh.geometry.attributes[mappingAttributes[i][0]].value = previousMesh.geometry.attributes[mappingAttributes[i][1]].value;
    }
    currentMesh.geometry.dirty();
    currentMesh.__percent = 0;
    currentMesh.material.set("percent", 0);
    currentMesh.stopAnimation();
    currentMesh.animate().when(duration, {
      __percent: 1
    }).during(function() {
      currentMesh.material.set("percent", currentMesh.__percent);
      if (shadowDepthMaterial) {
        shadowDepthMaterial.set("percent", currentMesh.__percent);
      }
    }).done(function() {
      currentMesh.ignorePreZ = false;
      currentMesh.material.undefine("vertex", "VERTEX_ANIMATION");
      if (shadowDepthMaterial) {
        shadowDepthMaterial.undefine("vertex", "VERTEX_ANIMATION");
      }
    }).start(easing);
  } else {
    currentMesh.material.undefine("vertex", "VERTEX_ANIMATION");
    if (shadowDepthMaterial) {
      shadowDepthMaterial.undefine("vertex", "VERTEX_ANIMATION");
    }
  }
};
var graphicGL$1 = graphicGL;
var LayerGL = function(id, zr) {
  this.id = id;
  this.zr = zr;
  try {
    this.renderer = new Renderer$1({
      clearBit: 0,
      devicePixelRatio: zr.painter.dpr,
      preserveDrawingBuffer: true,
      premultipliedAlpha: true
    });
    this.renderer.resize(zr.painter.getWidth(), zr.painter.getHeight());
  } catch (e2) {
    this.renderer = null;
    this.dom = document.createElement("div");
    this.dom.style.cssText = "position:absolute; left: 0; top: 0; right: 0; bottom: 0;";
    this.dom.className = "ecgl-nowebgl";
    this.dom.innerHTML = "Sorry, your browser does not support WebGL";
    console.error(e2);
    return;
  }
  this.onglobalout = this.onglobalout.bind(this);
  zr.on("globalout", this.onglobalout);
  this.dom = this.renderer.canvas;
  var style = this.dom.style;
  style.position = "absolute";
  style.left = "0";
  style.top = "0";
  this.views = [];
  this._picking = new RayPicking$1({
    renderer: this.renderer
  });
  this._viewsToDispose = [];
  this._accumulatingId = 0;
  this._zrEventProxy = new Rect$3({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    },
    __isGLToZRProxy: true
  });
  this._backgroundColor = null;
  this._disposed = false;
};
LayerGL.prototype.setUnpainted = function() {
};
LayerGL.prototype.addView = function(view) {
  if (view.layer === this) {
    return;
  }
  var idx = this._viewsToDispose.indexOf(view);
  if (idx >= 0) {
    this._viewsToDispose.splice(idx, 1);
  }
  this.views.push(view);
  view.layer = this;
  var zr = this.zr;
  view.scene.traverse(function(node) {
    node.__zr = zr;
    if (node.addAnimatorsToZr) {
      node.addAnimatorsToZr(zr);
    }
  });
};
function removeFromZr(node) {
  var zr = node.__zr;
  node.__zr = null;
  if (zr && node.removeAnimatorsFromZr) {
    node.removeAnimatorsFromZr(zr);
  }
}
LayerGL.prototype.removeView = function(view) {
  if (view.layer !== this) {
    return;
  }
  var idx = this.views.indexOf(view);
  if (idx >= 0) {
    this.views.splice(idx, 1);
    view.scene.traverse(removeFromZr, this);
    view.layer = null;
    this._viewsToDispose.push(view);
  }
};
LayerGL.prototype.removeViewsAll = function() {
  this.views.forEach(function(view) {
    view.scene.traverse(removeFromZr, this);
    view.layer = null;
    this._viewsToDispose.push(view);
  }, this);
  this.views.length = 0;
};
LayerGL.prototype.resize = function(width, height) {
  var renderer = this.renderer;
  renderer.resize(width, height);
};
LayerGL.prototype.clear = function() {
  var gl = this.renderer.gl;
  var clearColor = this._backgroundColor || [0, 0, 0, 0];
  gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
  gl.depthMask(true);
  gl.colorMask(true, true, true, true);
  gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
};
LayerGL.prototype.clearDepth = function() {
  var gl = this.renderer.gl;
  gl.clear(gl.DEPTH_BUFFER_BIT);
};
LayerGL.prototype.clearColor = function() {
  var gl = this.renderer.gl;
  gl.clearColor(0, 0, 0, 0);
  gl.clear(gl.COLOR_BUFFER_BIT);
};
LayerGL.prototype.needsRefresh = function() {
  this.zr.refresh();
};
LayerGL.prototype.refresh = function(bgColor) {
  this._backgroundColor = bgColor ? graphicGL$1.parseColor(bgColor) : [0, 0, 0, 0];
  this.renderer.clearColor = this._backgroundColor;
  for (var i = 0; i < this.views.length; i++) {
    this.views[i].prepareRender(this.renderer);
  }
  this._doRender(false);
  this._trackAndClean();
  for (var i = 0; i < this._viewsToDispose.length; i++) {
    this._viewsToDispose[i].dispose(this.renderer);
  }
  this._viewsToDispose.length = 0;
  this._startAccumulating();
};
LayerGL.prototype.renderToCanvas = function(ctx) {
  this._startAccumulating(true);
  ctx.drawImage(this.dom, 0, 0, ctx.canvas.width, ctx.canvas.height);
};
LayerGL.prototype._doRender = function(accumulating) {
  this.clear();
  this.renderer.saveViewport();
  for (var i = 0; i < this.views.length; i++) {
    this.views[i].render(this.renderer, accumulating);
  }
  this.renderer.restoreViewport();
};
LayerGL.prototype._stopAccumulating = function() {
  this._accumulatingId = 0;
  clearTimeout(this._accumulatingTimeout);
};
var accumulatingId = 1;
LayerGL.prototype._startAccumulating = function(immediate) {
  var self2 = this;
  this._stopAccumulating();
  var needsAccumulate = false;
  for (var i = 0; i < this.views.length; i++) {
    needsAccumulate = this.views[i].needsAccumulate() || needsAccumulate;
  }
  if (!needsAccumulate) {
    return;
  }
  function accumulate(id) {
    if (!self2._accumulatingId || id !== self2._accumulatingId) {
      return;
    }
    var isFinished = true;
    for (var i2 = 0; i2 < self2.views.length; i2++) {
      isFinished = self2.views[i2].isAccumulateFinished() && needsAccumulate;
    }
    if (!isFinished) {
      self2._doRender(true);
      if (immediate) {
        accumulate(id);
      } else {
        requestAnimationFrame$2(function() {
          accumulate(id);
        });
      }
    }
  }
  this._accumulatingId = accumulatingId++;
  if (immediate) {
    accumulate(self2._accumulatingId);
  } else {
    this._accumulatingTimeout = setTimeout(function() {
      accumulate(self2._accumulatingId);
    }, 50);
  }
};
LayerGL.prototype._trackAndClean = function() {
  var textureList = [];
  var geometriesList = [];
  if (this._textureList) {
    markUnused(this._textureList);
    markUnused(this._geometriesList);
  }
  for (var i = 0; i < this.views.length; i++) {
    collectResources(this.views[i].scene, textureList, geometriesList);
  }
  if (this._textureList) {
    checkAndDispose(this.renderer, this._textureList);
    checkAndDispose(this.renderer, this._geometriesList);
  }
  this._textureList = textureList;
  this._geometriesList = geometriesList;
};
function markUnused(resourceList) {
  for (var i = 0; i < resourceList.length; i++) {
    resourceList[i].__used__ = 0;
  }
}
function checkAndDispose(renderer, resourceList) {
  for (var i = 0; i < resourceList.length; i++) {
    if (!resourceList[i].__used__) {
      resourceList[i].dispose(renderer);
    }
  }
}
function updateUsed(resource, list) {
  resource.__used__ = resource.__used__ || 0;
  resource.__used__++;
  if (resource.__used__ === 1) {
    list.push(resource);
  }
}
function collectResources(scene, textureResourceList, geometryResourceList) {
  var prevMaterial;
  var prevGeometry;
  scene.traverse(function(renderable) {
    if (renderable.isRenderable()) {
      var geometry = renderable.geometry;
      var material = renderable.material;
      if (material !== prevMaterial) {
        var textureUniforms = material.getTextureUniforms();
        for (var u = 0; u < textureUniforms.length; u++) {
          var uniformName = textureUniforms[u];
          var val = material.uniforms[uniformName].value;
          if (!val) {
            continue;
          }
          if (val instanceof Texture$1) {
            updateUsed(val, textureResourceList);
          } else if (val instanceof Array) {
            for (var k2 = 0; k2 < val.length; k2++) {
              if (val[k2] instanceof Texture$1) {
                updateUsed(val[k2], textureResourceList);
              }
            }
          }
        }
      }
      if (geometry !== prevGeometry) {
        updateUsed(geometry, geometryResourceList);
      }
      prevMaterial = material;
      prevGeometry = geometry;
    }
  });
  for (var k = 0; k < scene.lights.length; k++) {
    if (scene.lights[k].cubemap) {
      updateUsed(scene.lights[k].cubemap, textureResourceList);
    }
  }
}
LayerGL.prototype.dispose = function() {
  if (this._disposed) {
    return;
  }
  this._stopAccumulating();
  if (this._textureList) {
    markUnused(this._textureList);
    markUnused(this._geometriesList);
    checkAndDispose(this.renderer, this._textureList);
    checkAndDispose(this.renderer, this._geometriesList);
  }
  this.zr.off("globalout", this.onglobalout);
  this._disposed = true;
};
LayerGL.prototype.onmousedown = function(e2) {
  if (e2.target && e2.target.__isGLToZRProxy) {
    return;
  }
  e2 = e2.event;
  var obj = this.pickObject(e2.offsetX, e2.offsetY);
  if (obj) {
    this._dispatchEvent("mousedown", e2, obj);
    this._dispatchDataEvent("mousedown", e2, obj);
  }
  this._downX = e2.offsetX;
  this._downY = e2.offsetY;
};
LayerGL.prototype.onmousemove = function(e2) {
  if (e2.target && e2.target.__isGLToZRProxy) {
    return;
  }
  e2 = e2.event;
  var obj = this.pickObject(e2.offsetX, e2.offsetY);
  var target = obj && obj.target;
  var lastHovered = this._hovered;
  this._hovered = obj;
  if (lastHovered && target !== lastHovered.target) {
    lastHovered.relatedTarget = target;
    this._dispatchEvent("mouseout", e2, lastHovered);
    this.zr.setCursorStyle("default");
  }
  this._dispatchEvent("mousemove", e2, obj);
  if (obj) {
    this.zr.setCursorStyle("pointer");
    if (!lastHovered || target !== lastHovered.target) {
      this._dispatchEvent("mouseover", e2, obj);
    }
  }
  this._dispatchDataEvent("mousemove", e2, obj);
};
LayerGL.prototype.onmouseup = function(e2) {
  if (e2.target && e2.target.__isGLToZRProxy) {
    return;
  }
  e2 = e2.event;
  var obj = this.pickObject(e2.offsetX, e2.offsetY);
  if (obj) {
    this._dispatchEvent("mouseup", e2, obj);
    this._dispatchDataEvent("mouseup", e2, obj);
  }
  this._upX = e2.offsetX;
  this._upY = e2.offsetY;
};
LayerGL.prototype.onclick = LayerGL.prototype.dblclick = function(e2) {
  if (e2.target && e2.target.__isGLToZRProxy) {
    return;
  }
  var dx = this._upX - this._downX;
  var dy = this._upY - this._downY;
  if (Math.sqrt(dx * dx + dy * dy) > 20) {
    return;
  }
  e2 = e2.event;
  var obj = this.pickObject(e2.offsetX, e2.offsetY);
  if (obj) {
    this._dispatchEvent(e2.type, e2, obj);
    this._dispatchDataEvent(e2.type, e2, obj);
  }
  var result = this._clickToSetFocusPoint(e2);
  if (result) {
    var success = result.view.setDOFFocusOnPoint(result.distance);
    if (success) {
      this.zr.refresh();
    }
  }
};
LayerGL.prototype._clickToSetFocusPoint = function(e2) {
  var renderer = this.renderer;
  var oldViewport = renderer.viewport;
  for (var i = this.views.length - 1; i >= 0; i--) {
    var viewGL = this.views[i];
    if (viewGL.hasDOF() && viewGL.containPoint(e2.offsetX, e2.offsetY)) {
      this._picking.scene = viewGL.scene;
      this._picking.camera = viewGL.camera;
      renderer.viewport = viewGL.viewport;
      var result = this._picking.pick(e2.offsetX, e2.offsetY, true);
      if (result) {
        result.view = viewGL;
        return result;
      }
    }
  }
  renderer.viewport = oldViewport;
};
LayerGL.prototype.onglobalout = function(e2) {
  var lastHovered = this._hovered;
  if (lastHovered) {
    this._dispatchEvent("mouseout", e2, {
      target: lastHovered.target
    });
  }
};
LayerGL.prototype.pickObject = function(x, y) {
  var output = [];
  var renderer = this.renderer;
  var oldViewport = renderer.viewport;
  for (var i = 0; i < this.views.length; i++) {
    var viewGL = this.views[i];
    if (viewGL.containPoint(x, y)) {
      this._picking.scene = viewGL.scene;
      this._picking.camera = viewGL.camera;
      renderer.viewport = viewGL.viewport;
      this._picking.pickAll(x, y, output);
    }
  }
  renderer.viewport = oldViewport;
  output.sort(function(a, b) {
    return a.distance - b.distance;
  });
  return output[0];
};
LayerGL.prototype._dispatchEvent = function(eveName, originalEvent, newEvent) {
  if (!newEvent) {
    newEvent = {};
  }
  var current = newEvent.target;
  newEvent.cancelBubble = false;
  newEvent.event = originalEvent;
  newEvent.type = eveName;
  newEvent.offsetX = originalEvent.offsetX;
  newEvent.offsetY = originalEvent.offsetY;
  while (current) {
    current.trigger(eveName, newEvent);
    current = current.getParent();
    if (newEvent.cancelBubble) {
      break;
    }
  }
  this._dispatchToView(eveName, newEvent);
};
LayerGL.prototype._dispatchDataEvent = function(eveName, originalEvent, newEvent) {
  var mesh2 = newEvent && newEvent.target;
  var dataIndex = mesh2 && mesh2.dataIndex;
  var seriesIndex = mesh2 && mesh2.seriesIndex;
  var eventData = mesh2 && mesh2.eventData;
  var elChangedInMouseMove = false;
  var eventProxy = this._zrEventProxy;
  eventProxy.x = originalEvent.offsetX;
  eventProxy.y = originalEvent.offsetY;
  eventProxy.update();
  var targetInfo = {
    target: eventProxy
  };
  const ecData = getECData(eventProxy);
  if (eveName === "mousemove") {
    if (dataIndex != null) {
      if (dataIndex !== this._lastDataIndex) {
        if (parseInt(this._lastDataIndex, 10) >= 0) {
          ecData.dataIndex = this._lastDataIndex;
          ecData.seriesIndex = this._lastSeriesIndex;
          this.zr.handler.dispatchToElement(targetInfo, "mouseout", originalEvent);
        }
        elChangedInMouseMove = true;
      }
    } else if (eventData != null) {
      if (eventData !== this._lastEventData) {
        if (this._lastEventData != null) {
          ecData.eventData = this._lastEventData;
          this.zr.handler.dispatchToElement(targetInfo, "mouseout", originalEvent);
        }
        elChangedInMouseMove = true;
      }
    }
    this._lastEventData = eventData;
    this._lastDataIndex = dataIndex;
    this._lastSeriesIndex = seriesIndex;
  }
  ecData.eventData = eventData;
  ecData.dataIndex = dataIndex;
  ecData.seriesIndex = seriesIndex;
  if (eventData != null || parseInt(dataIndex, 10) >= 0 && parseInt(seriesIndex, 10) >= 0) {
    this.zr.handler.dispatchToElement(targetInfo, eveName, originalEvent);
    if (elChangedInMouseMove) {
      this.zr.handler.dispatchToElement(targetInfo, "mouseover", originalEvent);
    }
  }
};
LayerGL.prototype._dispatchToView = function(eventName, e2) {
  for (var i = 0; i < this.views.length; i++) {
    if (this.views[i].containPoint(e2.offsetX, e2.offsetY)) {
      this.views[i].trigger(eventName, e2);
    }
  }
};
Object.assign(LayerGL.prototype, notifier$1);
var LayerGL$1 = LayerGL;
var GL_SERIES = ["bar3D", "line3D", "map3D", "scatter3D", "surface", "lines3D", "scatterGL", "scatter3D"];
function convertNormalEmphasis(option, optType) {
  if (option && option[optType] && (option[optType].normal || option[optType].emphasis)) {
    var normalOpt = option[optType].normal;
    var emphasisOpt = option[optType].emphasis;
    if (normalOpt) {
      option[optType] = normalOpt;
    }
    if (emphasisOpt) {
      option.emphasis = option.emphasis || {};
      option.emphasis[optType] = emphasisOpt;
    }
  }
}
function convertNormalEmphasisForEach(option) {
  convertNormalEmphasis(option, "itemStyle");
  convertNormalEmphasis(option, "lineStyle");
  convertNormalEmphasis(option, "areaStyle");
  convertNormalEmphasis(option, "label");
}
function removeTextStyleInAxis(axesOpt) {
  if (!axesOpt) {
    return;
  }
  if (!(axesOpt instanceof Array)) {
    axesOpt = [axesOpt];
  }
  each$f(axesOpt, function(axisOpt) {
    if (axisOpt.axisLabel) {
      var labelOpt = axisOpt.axisLabel;
      Object.assign(labelOpt, labelOpt.textStyle);
      labelOpt.textStyle = null;
    }
  });
}
function backwardCompat(option) {
  each$f(option.series, function(series) {
    if (indexOf(GL_SERIES, series.type) >= 0) {
      convertNormalEmphasisForEach(series);
      if (series.coordinateSystem === "mapbox") {
        series.coordinateSystem = "mapbox3D";
        option.mapbox3D = option.mapbox;
      }
    }
  });
  removeTextStyleInAxis(option.xAxis3D);
  removeTextStyleInAxis(option.yAxis3D);
  removeTextStyleInAxis(option.zAxis3D);
  removeTextStyleInAxis(option.grid3D);
  convertNormalEmphasis(option.geo3D);
}
function EChartsGL(zr) {
  this._layers = {};
  this._zr = zr;
}
EChartsGL.prototype.update = function(ecModel, api) {
  var self2 = this;
  var zr = api.getZr();
  if (!zr.getWidth() || !zr.getHeight()) {
    console.warn("Dom has no width or height");
    return;
  }
  function getLayerGL(model) {
    zr.setSleepAfterStill(0);
    var zlevel2;
    if (model.coordinateSystem && model.coordinateSystem.model) {
      zlevel2 = model.get("zlevel");
    } else {
      zlevel2 = model.get("zlevel");
    }
    var layers = self2._layers;
    var layerGL = layers[zlevel2];
    if (!layerGL) {
      layerGL = layers[zlevel2] = new LayerGL$1("gl-" + zlevel2, zr);
      if (zr.painter.isSingleCanvas()) {
        layerGL.virtual = true;
        var img = new ZRImage$1({
          z: 1e4,
          style: {
            image: layerGL.renderer.canvas
          },
          silent: true
        });
        layerGL.__hostImage = img;
        zr.add(img);
      }
      zr.painter.insertLayer(zlevel2, layerGL);
    }
    if (layerGL.__hostImage) {
      layerGL.__hostImage.setStyle({
        width: layerGL.renderer.getWidth(),
        height: layerGL.renderer.getHeight()
      });
    }
    return layerGL;
  }
  function setSilent2(groupGL, silent) {
    if (groupGL) {
      groupGL.traverse(function(mesh2) {
        if (mesh2.isRenderable && mesh2.isRenderable()) {
          mesh2.ignorePicking = mesh2.$ignorePicking != null ? mesh2.$ignorePicking : silent;
        }
      });
    }
  }
  for (var zlevel in this._layers) {
    this._layers[zlevel].removeViewsAll();
  }
  ecModel.eachComponent(function(componentType, componentModel) {
    if (componentType !== "series") {
      var view = api.getViewOfComponentModel(componentModel);
      var coordSys = componentModel.coordinateSystem;
      if (view.__ecgl__) {
        var viewGL;
        if (coordSys) {
          if (!coordSys.viewGL) {
            console.error("Can't find viewGL in coordinateSystem of component " + componentModel.id);
            return;
          }
          viewGL = coordSys.viewGL;
        } else {
          if (!componentModel.viewGL) {
            console.error("Can't find viewGL of component " + componentModel.id);
            return;
          }
          viewGL = coordSys.viewGL;
        }
        var viewGL = coordSys.viewGL;
        var layerGL = getLayerGL(componentModel);
        layerGL.addView(viewGL);
        view.afterRender && view.afterRender(componentModel, ecModel, api, layerGL);
        setSilent2(view.groupGL, componentModel.get("silent"));
      }
    }
  });
  ecModel.eachSeries(function(seriesModel) {
    var chartView = api.getViewOfSeriesModel(seriesModel);
    var coordSys = seriesModel.coordinateSystem;
    if (chartView.__ecgl__) {
      if (coordSys && !coordSys.viewGL && !chartView.viewGL) {
        console.error("Can't find viewGL of series " + chartView.id);
        return;
      }
      var viewGL = coordSys && coordSys.viewGL || chartView.viewGL;
      var layerGL = getLayerGL(seriesModel);
      layerGL.addView(viewGL);
      chartView.afterRender && chartView.afterRender(seriesModel, ecModel, api, layerGL);
      setSilent2(chartView.groupGL, seriesModel.get("silent"));
    }
  });
};
registerPostInit(function(chart) {
  var zr = chart.getZr();
  var oldDispose = zr.painter.dispose;
  zr.painter.dispose = function() {
    this.eachOtherLayer(function(layer) {
      if (layer instanceof LayerGL$1) {
        layer.dispose();
      }
    });
    oldDispose.call(this);
  };
  zr.painter.getRenderedCanvas = function(opts) {
    opts = opts || {};
    if (this._singleCanvas) {
      return this._layers[0].dom;
    }
    var canvas = document.createElement("canvas");
    var dpr2 = opts.pixelRatio || this.dpr;
    canvas.width = this.getWidth() * dpr2;
    canvas.height = this.getHeight() * dpr2;
    var ctx = canvas.getContext("2d");
    ctx.dpr = dpr2;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (opts.backgroundColor) {
      ctx.fillStyle = opts.backgroundColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    var displayList = this.storage.getDisplayList(true);
    var scope = {};
    var zlevel;
    var self2 = this;
    function findAndDrawOtherLayer(smaller, larger) {
      var zlevelList = self2._zlevelList;
      if (smaller == null) {
        smaller = -Infinity;
      }
      var intermediateLayer;
      for (var i2 = 0; i2 < zlevelList.length; i2++) {
        var z = zlevelList[i2];
        var layer2 = self2._layers[z];
        if (!layer2.__builtin__ && z > smaller && z < larger) {
          intermediateLayer = layer2;
          break;
        }
      }
      if (intermediateLayer && intermediateLayer.renderToCanvas) {
        ctx.save();
        intermediateLayer.renderToCanvas(ctx);
        ctx.restore();
      }
    }
    var layer = {
      ctx
    };
    for (var i = 0; i < displayList.length; i++) {
      var el = displayList[i];
      if (el.zlevel !== zlevel) {
        findAndDrawOtherLayer(zlevel, el.zlevel);
        zlevel = el.zlevel;
      }
      this._doPaintEl(el, layer, true, null, scope);
    }
    findAndDrawOtherLayer(zlevel, Infinity);
    return canvas;
  };
});
registerPostUpdate(function(ecModel, api) {
  var zr = api.getZr();
  var egl = zr.__egl = zr.__egl || new EChartsGL(zr);
  egl.update(ecModel, api);
});
registerPreprocessor(backwardCompat);
var componentViewControlMixin = {
  defaultOption: {
    viewControl: {
      projection: "perspective",
      autoRotate: false,
      autoRotateDirection: "cw",
      autoRotateSpeed: 10,
      autoRotateAfterStill: 3,
      damping: 0.8,
      rotateSensitivity: 1,
      zoomSensitivity: 1,
      panSensitivity: 1,
      panMouseButton: "middle",
      rotateMouseButton: "left",
      distance: 150,
      minDistance: 40,
      maxDistance: 400,
      orthographicSize: 150,
      maxOrthographicSize: 400,
      minOrthographicSize: 20,
      center: [0, 0, 0],
      alpha: 0,
      beta: 0,
      minAlpha: -90,
      maxAlpha: 90
    }
  },
  setView: function(opts) {
    opts = opts || {};
    this.option.viewControl = this.option.viewControl || {};
    if (opts.alpha != null) {
      this.option.viewControl.alpha = opts.alpha;
    }
    if (opts.beta != null) {
      this.option.viewControl.beta = opts.beta;
    }
    if (opts.distance != null) {
      this.option.viewControl.distance = opts.distance;
    }
    if (opts.center != null) {
      this.option.viewControl.center = opts.center;
    }
  }
};
var componentPostEffectMixin = {
  defaultOption: {
    postEffect: {
      enable: false,
      bloom: {
        enable: true,
        intensity: 0.1
      },
      depthOfField: {
        enable: false,
        focalRange: 20,
        focalDistance: 50,
        blurRadius: 10,
        fstop: 2.8,
        quality: "medium"
      },
      screenSpaceAmbientOcclusion: {
        enable: false,
        radius: 2,
        quality: "medium",
        intensity: 1
      },
      screenSpaceReflection: {
        enable: false,
        quality: "medium",
        maxRoughness: 0.8
      },
      colorCorrection: {
        enable: true,
        exposure: 0,
        brightness: 0,
        contrast: 1,
        saturation: 1,
        lookupTexture: ""
      },
      edge: {
        enable: false
      },
      FXAA: {
        enable: false
      }
    },
    temporalSuperSampling: {
      enable: "auto"
    }
  }
};
var componentLightMixin = {
  defaultOption: {
    light: {
      main: {
        shadow: false,
        shadowQuality: "high",
        color: "#fff",
        intensity: 1,
        alpha: 0,
        beta: 0
      },
      ambient: {
        color: "#fff",
        intensity: 0.2
      },
      ambientCubemap: {
        texture: null,
        exposure: 1,
        diffuseIntensity: 0.5,
        specularIntensity: 0.5
      }
    }
  }
};
var Grid3DModel = ComponentModel$1.extend({
  type: "grid3D",
  dependencies: ["xAxis3D", "yAxis3D", "zAxis3D"],
  defaultOption: {
    show: true,
    zlevel: -10,
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    environment: "auto",
    boxWidth: 100,
    boxHeight: 100,
    boxDepth: 100,
    axisPointer: {
      show: true,
      lineStyle: {
        color: "rgba(0, 0, 0, 0.8)",
        width: 1
      },
      label: {
        show: true,
        formatter: null,
        margin: 8,
        textStyle: {
          fontSize: 14,
          color: "#fff",
          backgroundColor: "rgba(0,0,0,0.5)",
          padding: 3,
          borderRadius: 3
        }
      }
    },
    axisLine: {
      show: true,
      lineStyle: {
        color: "#333",
        width: 2,
        type: "solid"
      }
    },
    axisTick: {
      show: true,
      inside: false,
      length: 3,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      inside: false,
      rotate: 0,
      margin: 8,
      textStyle: {
        fontSize: 12
      }
    },
    splitLine: {
      show: true,
      lineStyle: {
        color: ["#ccc"],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
      }
    },
    light: {
      main: {
        alpha: 30,
        beta: 40
      },
      ambient: {
        intensity: 0.4
      }
    },
    viewControl: {
      alpha: 20,
      beta: 40,
      autoRotate: false,
      distance: 200,
      minDistance: 40,
      maxDistance: 400
    }
  }
});
merge(Grid3DModel.prototype, componentViewControlMixin);
merge(Grid3DModel.prototype, componentPostEffectMixin);
merge(Grid3DModel.prototype, componentLightMixin);
var Grid3DModel$1 = Grid3DModel;
var firstNotNull$3 = retrieve$1.firstNotNull;
var MOUSE_BUTTON_KEY_MAP = {
  left: 0,
  middle: 1,
  right: 2
};
function convertToArray(val) {
  if (!(val instanceof Array)) {
    val = [val, val];
  }
  return val;
}
var OrbitControl = Base$1.extend(function() {
  return {
    zr: null,
    viewGL: null,
    _center: new Vector3$1(),
    minDistance: 0.5,
    maxDistance: 1.5,
    maxOrthographicSize: 300,
    minOrthographicSize: 30,
    minAlpha: -90,
    maxAlpha: 90,
    minBeta: -Infinity,
    maxBeta: Infinity,
    autoRotateAfterStill: 0,
    autoRotateDirection: "cw",
    autoRotateSpeed: 60,
    damping: 0.8,
    rotateSensitivity: 1,
    zoomSensitivity: 1,
    panSensitivity: 1,
    panMouseButton: "middle",
    rotateMouseButton: "left",
    _mode: "rotate",
    _camera: null,
    _needsUpdate: false,
    _rotating: false,
    _phi: 0,
    _theta: 0,
    _mouseX: 0,
    _mouseY: 0,
    _rotateVelocity: new Vector2$1(),
    _panVelocity: new Vector2$1(),
    _distance: 500,
    _zoomSpeed: 0,
    _stillTimeout: 0,
    _animators: []
  };
}, function() {
  ["_mouseDownHandler", "_mouseWheelHandler", "_mouseMoveHandler", "_mouseUpHandler", "_pinchHandler", "_contextMenuHandler", "_update"].forEach(function(hdlName) {
    this[hdlName] = this[hdlName].bind(this);
  }, this);
}, {
  init: function() {
    var zr = this.zr;
    if (zr) {
      zr.on("mousedown", this._mouseDownHandler);
      zr.on("globalout", this._mouseUpHandler);
      zr.on("mousewheel", this._mouseWheelHandler);
      zr.on("pinch", this._pinchHandler);
      zr.animation.on("frame", this._update);
      zr.dom.addEventListener("contextmenu", this._contextMenuHandler);
    }
  },
  dispose: function() {
    var zr = this.zr;
    if (zr) {
      zr.off("mousedown", this._mouseDownHandler);
      zr.off("mousemove", this._mouseMoveHandler);
      zr.off("mouseup", this._mouseUpHandler);
      zr.off("mousewheel", this._mouseWheelHandler);
      zr.off("pinch", this._pinchHandler);
      zr.off("globalout", this._mouseUpHandler);
      zr.dom.removeEventListener("contextmenu", this._contextMenuHandler);
      zr.animation.off("frame", this._update);
    }
    this.stopAllAnimation();
  },
  getDistance: function() {
    return this._distance;
  },
  setDistance: function(distance2) {
    this._distance = distance2;
    this._needsUpdate = true;
  },
  getOrthographicSize: function() {
    return this._orthoSize;
  },
  setOrthographicSize: function(size) {
    this._orthoSize = size;
    this._needsUpdate = true;
  },
  getAlpha: function() {
    return this._theta / Math.PI * 180;
  },
  getBeta: function() {
    return -this._phi / Math.PI * 180;
  },
  getCenter: function() {
    return this._center.toArray();
  },
  setAlpha: function(alpha) {
    alpha = Math.max(Math.min(this.maxAlpha, alpha), this.minAlpha);
    this._theta = alpha / 180 * Math.PI;
    this._needsUpdate = true;
  },
  setBeta: function(beta) {
    beta = Math.max(Math.min(this.maxBeta, beta), this.minBeta);
    this._phi = -beta / 180 * Math.PI;
    this._needsUpdate = true;
  },
  setCenter: function(centerArr) {
    this._center.setArray(centerArr);
  },
  setViewGL: function(viewGL) {
    this.viewGL = viewGL;
  },
  getCamera: function() {
    return this.viewGL.camera;
  },
  setFromViewControlModel: function(viewControlModel, extraOpts) {
    extraOpts = extraOpts || {};
    var baseDistance = extraOpts.baseDistance || 0;
    var baseOrthoSize = extraOpts.baseOrthoSize || 1;
    var projection = viewControlModel.get("projection");
    if (projection !== "perspective" && projection !== "orthographic" && projection !== "isometric") {
      projection = "perspective";
    }
    this._projection = projection;
    this.viewGL.setProjection(projection);
    var targetDistance = viewControlModel.get("distance") + baseDistance;
    var targetOrthographicSize = viewControlModel.get("orthographicSize") + baseOrthoSize;
    [["damping", 0.8], ["autoRotate", false], ["autoRotateAfterStill", 3], ["autoRotateDirection", "cw"], ["autoRotateSpeed", 10], ["minDistance", 30], ["maxDistance", 400], ["minOrthographicSize", 30], ["maxOrthographicSize", 300], ["minAlpha", -90], ["maxAlpha", 90], ["minBeta", -Infinity], ["maxBeta", Infinity], ["rotateSensitivity", 1], ["zoomSensitivity", 1], ["panSensitivity", 1], ["panMouseButton", "left"], ["rotateMouseButton", "middle"]].forEach(function(prop) {
      this[prop[0]] = firstNotNull$3(viewControlModel.get(prop[0]), prop[1]);
    }, this);
    this.minDistance += baseDistance;
    this.maxDistance += baseDistance;
    this.minOrthographicSize += baseOrthoSize, this.maxOrthographicSize += baseOrthoSize;
    var ecModel = viewControlModel.ecModel;
    var animationOpts = {};
    ["animation", "animationDurationUpdate", "animationEasingUpdate"].forEach(function(key) {
      animationOpts[key] = firstNotNull$3(viewControlModel.get(key), ecModel && ecModel.get(key));
    });
    var alpha = firstNotNull$3(extraOpts.alpha, viewControlModel.get("alpha")) || 0;
    var beta = firstNotNull$3(extraOpts.beta, viewControlModel.get("beta")) || 0;
    var center2 = firstNotNull$3(extraOpts.center, viewControlModel.get("center")) || [0, 0, 0];
    if (animationOpts.animation && animationOpts.animationDurationUpdate > 0 && this._notFirst) {
      this.animateTo({
        alpha,
        beta,
        center: center2,
        distance: targetDistance,
        orthographicSize: targetOrthographicSize,
        easing: animationOpts.animationEasingUpdate,
        duration: animationOpts.animationDurationUpdate
      });
    } else {
      this.setDistance(targetDistance);
      this.setAlpha(alpha);
      this.setBeta(beta);
      this.setCenter(center2);
      this.setOrthographicSize(targetOrthographicSize);
    }
    this._notFirst = true;
    this._validateProperties();
  },
  _validateProperties: function() {
  },
  animateTo: function(opts) {
    var zr = this.zr;
    var self2 = this;
    var obj = {};
    var target = {};
    if (opts.distance != null) {
      obj.distance = this.getDistance();
      target.distance = opts.distance;
    }
    if (opts.orthographicSize != null) {
      obj.orthographicSize = this.getOrthographicSize();
      target.orthographicSize = opts.orthographicSize;
    }
    if (opts.alpha != null) {
      obj.alpha = this.getAlpha();
      target.alpha = opts.alpha;
    }
    if (opts.beta != null) {
      obj.beta = this.getBeta();
      target.beta = opts.beta;
    }
    if (opts.center != null) {
      obj.center = this.getCenter();
      target.center = opts.center;
    }
    return this._addAnimator(zr.animation.animate(obj).when(opts.duration || 1e3, target).during(function() {
      if (obj.alpha != null) {
        self2.setAlpha(obj.alpha);
      }
      if (obj.beta != null) {
        self2.setBeta(obj.beta);
      }
      if (obj.distance != null) {
        self2.setDistance(obj.distance);
      }
      if (obj.center != null) {
        self2.setCenter(obj.center);
      }
      if (obj.orthographicSize != null) {
        self2.setOrthographicSize(obj.orthographicSize);
      }
      self2._needsUpdate = true;
    })).start(opts.easing || "linear");
  },
  stopAllAnimation: function() {
    for (var i = 0; i < this._animators.length; i++) {
      this._animators[i].stop();
    }
    this._animators.length = 0;
  },
  update: function() {
    this._needsUpdate = true;
    this._update(20);
  },
  _isAnimating: function() {
    return this._animators.length > 0;
  },
  _update: function(deltaTime) {
    if (this._rotating) {
      var radian = (this.autoRotateDirection === "cw" ? 1 : -1) * this.autoRotateSpeed / 180 * Math.PI;
      this._phi -= radian * deltaTime / 1e3;
      this._needsUpdate = true;
    } else if (this._rotateVelocity.len() > 0) {
      this._needsUpdate = true;
    }
    if (Math.abs(this._zoomSpeed) > 0.1 || this._panVelocity.len() > 0) {
      this._needsUpdate = true;
    }
    if (!this._needsUpdate) {
      return;
    }
    deltaTime = Math.min(deltaTime, 50);
    this._updateDistanceOrSize(deltaTime);
    this._updatePan(deltaTime);
    this._updateRotate(deltaTime);
    this._updateTransform();
    this.getCamera().update();
    this.zr && this.zr.refresh();
    this.trigger("update");
    this._needsUpdate = false;
  },
  _updateRotate: function(deltaTime) {
    var velocity = this._rotateVelocity;
    this._phi = velocity.y * deltaTime / 20 + this._phi;
    this._theta = velocity.x * deltaTime / 20 + this._theta;
    this.setAlpha(this.getAlpha());
    this.setBeta(this.getBeta());
    this._vectorDamping(velocity, Math.pow(this.damping, deltaTime / 16));
  },
  _updateDistanceOrSize: function(deltaTime) {
    if (this._projection === "perspective") {
      this._setDistance(this._distance + this._zoomSpeed * deltaTime / 20);
    } else {
      this._setOrthoSize(this._orthoSize + this._zoomSpeed * deltaTime / 20);
    }
    this._zoomSpeed *= Math.pow(this.damping, deltaTime / 16);
  },
  _setDistance: function(distance2) {
    this._distance = Math.max(Math.min(distance2, this.maxDistance), this.minDistance);
  },
  _setOrthoSize: function(size) {
    this._orthoSize = Math.max(Math.min(size, this.maxOrthographicSize), this.minOrthographicSize);
    var camera2 = this.getCamera();
    var cameraHeight = this._orthoSize;
    var cameraWidth = cameraHeight / this.viewGL.viewport.height * this.viewGL.viewport.width;
    camera2.left = -cameraWidth / 2;
    camera2.right = cameraWidth / 2;
    camera2.top = cameraHeight / 2;
    camera2.bottom = -cameraHeight / 2;
  },
  _updatePan: function(deltaTime) {
    var velocity = this._panVelocity;
    var len2 = this._distance;
    var target = this.getCamera();
    var yAxis = target.worldTransform.y;
    var xAxis = target.worldTransform.x;
    this._center.scaleAndAdd(xAxis, -velocity.x * len2 / 200).scaleAndAdd(yAxis, -velocity.y * len2 / 200);
    this._vectorDamping(velocity, 0);
  },
  _updateTransform: function() {
    var camera2 = this.getCamera();
    var dir3 = new Vector3$1();
    var theta = this._theta + Math.PI / 2;
    var phi = this._phi + Math.PI / 2;
    var r = Math.sin(theta);
    dir3.x = r * Math.cos(phi);
    dir3.y = -Math.cos(theta);
    dir3.z = r * Math.sin(phi);
    camera2.position.copy(this._center).scaleAndAdd(dir3, this._distance);
    camera2.rotation.identity().rotateY(-this._phi).rotateX(-this._theta);
  },
  _startCountingStill: function() {
    clearTimeout(this._stillTimeout);
    var time = this.autoRotateAfterStill;
    var self2 = this;
    if (!isNaN(time) && time > 0) {
      this._stillTimeout = setTimeout(function() {
        self2._rotating = true;
      }, time * 1e3);
    }
  },
  _vectorDamping: function(v, damping) {
    var speed = v.len();
    speed = speed * damping;
    if (speed < 1e-4) {
      speed = 0;
    }
    v.normalize().scale(speed);
  },
  _decomposeTransform: function() {
    if (!this.getCamera()) {
      return;
    }
    this.getCamera().updateWorldTransform();
    var forward = this.getCamera().worldTransform.z;
    var alpha = Math.asin(forward.y);
    var beta = Math.atan2(forward.x, forward.z);
    this._theta = alpha;
    this._phi = -beta;
    this.setBeta(this.getBeta());
    this.setAlpha(this.getAlpha());
    if (this.getCamera().aspect) {
      this._setDistance(this.getCamera().position.dist(this._center));
    } else {
      this._setOrthoSize(this.getCamera().top - this.getCamera().bottom);
    }
  },
  _mouseDownHandler: function(e2) {
    if (e2.target) {
      return;
    }
    if (this._isAnimating()) {
      return;
    }
    var x = e2.offsetX;
    var y = e2.offsetY;
    if (this.viewGL && !this.viewGL.containPoint(x, y)) {
      return;
    }
    this.zr.on("mousemove", this._mouseMoveHandler);
    this.zr.on("mouseup", this._mouseUpHandler);
    if (e2.event.targetTouches) {
      if (e2.event.targetTouches.length === 1) {
        this._mode = "rotate";
      }
    } else {
      if (e2.event.button === MOUSE_BUTTON_KEY_MAP[this.rotateMouseButton]) {
        this._mode = "rotate";
      } else if (e2.event.button === MOUSE_BUTTON_KEY_MAP[this.panMouseButton]) {
        this._mode = "pan";
      } else {
        this._mode = "";
      }
    }
    this._rotateVelocity.set(0, 0);
    this._rotating = false;
    if (this.autoRotate) {
      this._startCountingStill();
    }
    this._mouseX = e2.offsetX;
    this._mouseY = e2.offsetY;
  },
  _mouseMoveHandler: function(e2) {
    if (e2.target && e2.target.__isGLToZRProxy) {
      return;
    }
    if (this._isAnimating()) {
      return;
    }
    var panSensitivity = convertToArray(this.panSensitivity);
    var rotateSensitivity = convertToArray(this.rotateSensitivity);
    if (this._mode === "rotate") {
      this._rotateVelocity.y = (e2.offsetX - this._mouseX) / this.zr.getHeight() * 2 * rotateSensitivity[0];
      this._rotateVelocity.x = (e2.offsetY - this._mouseY) / this.zr.getWidth() * 2 * rotateSensitivity[1];
    } else if (this._mode === "pan") {
      this._panVelocity.x = (e2.offsetX - this._mouseX) / this.zr.getWidth() * panSensitivity[0] * 400;
      this._panVelocity.y = (-e2.offsetY + this._mouseY) / this.zr.getHeight() * panSensitivity[1] * 400;
    }
    this._mouseX = e2.offsetX;
    this._mouseY = e2.offsetY;
    e2.event.preventDefault();
  },
  _mouseWheelHandler: function(e2) {
    if (this._isAnimating()) {
      return;
    }
    var delta = e2.event.wheelDelta || -e2.event.detail;
    this._zoomHandler(e2, delta);
  },
  _pinchHandler: function(e2) {
    if (this._isAnimating()) {
      return;
    }
    this._zoomHandler(e2, e2.pinchScale > 1 ? 1 : -1);
    this._mode = "";
  },
  _zoomHandler: function(e2, delta) {
    if (delta === 0) {
      return;
    }
    var x = e2.offsetX;
    var y = e2.offsetY;
    if (this.viewGL && !this.viewGL.containPoint(x, y)) {
      return;
    }
    var speed;
    if (this._projection === "perspective") {
      speed = Math.max(Math.max(Math.min(this._distance - this.minDistance, this.maxDistance - this._distance)) / 20, 0.5);
    } else {
      speed = Math.max(Math.max(Math.min(this._orthoSize - this.minOrthographicSize, this.maxOrthographicSize - this._orthoSize)) / 20, 0.5);
    }
    this._zoomSpeed = (delta > 0 ? -1 : 1) * speed * this.zoomSensitivity;
    this._rotating = false;
    if (this.autoRotate && this._mode === "rotate") {
      this._startCountingStill();
    }
    e2.event.preventDefault();
  },
  _mouseUpHandler: function() {
    this.zr.off("mousemove", this._mouseMoveHandler);
    this.zr.off("mouseup", this._mouseUpHandler);
  },
  _isRightMouseButtonUsed: function() {
    return this.rotateMouseButton === "right" || this.panMouseButton === "right";
  },
  _contextMenuHandler: function(e2) {
    if (this._isRightMouseButtonUsed()) {
      e2.preventDefault();
    }
  },
  _addAnimator: function(animator) {
    var animators = this._animators;
    animators.push(animator);
    animator.done(function() {
      var idx = animators.indexOf(animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    return animator;
  }
});
Object.defineProperty(OrbitControl.prototype, "autoRotate", {
  get: function(val) {
    return this._autoRotate;
  },
  set: function(val) {
    this._autoRotate = val;
    this._rotating = val;
  }
});
var OrbitControl$1 = OrbitControl;
var dynamicConvertMixin = {
  convertToDynamicArray: function(clear2) {
    if (clear2) {
      this.resetOffset();
    }
    var attributes = this.attributes;
    for (var name in attributes) {
      if (clear2 || !attributes[name].value) {
        attributes[name].value = [];
      } else {
        attributes[name].value = Array.prototype.slice.call(attributes[name].value);
      }
    }
    if (clear2 || !this.indices) {
      this.indices = [];
    } else {
      this.indices = Array.prototype.slice.call(this.indices);
    }
  },
  convertToTypedArray: function() {
    var attributes = this.attributes;
    for (var name in attributes) {
      if (attributes[name].value && attributes[name].value.length > 0) {
        attributes[name].value = new Float32Array(attributes[name].value);
      } else {
        attributes[name].value = null;
      }
    }
    if (this.indices && this.indices.length > 0) {
      this.indices = this.vertexCount > 65535 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
    }
    this.dirty();
  }
};
var glmatrix = {
  vec2: vec2$4,
  vec3: vec3$g,
  vec4: vec4$2,
  mat2: mat2$1,
  mat2d: mat2d$1,
  mat3: mat3$2,
  mat4: mat4$3,
  quat: quat$1
};
var vec3$e = glmatrix.vec3;
var sampleLinePoints$1 = [[0, 0], [1, 1]];
var LinesGeometry$2 = Geometry$1.extend(function() {
  return {
    segmentScale: 1,
    dynamic: true,
    useNativeLine: true,
    attributes: {
      position: new Geometry$1.Attribute("position", "float", 3, "POSITION"),
      positionPrev: new Geometry$1.Attribute("positionPrev", "float", 3),
      positionNext: new Geometry$1.Attribute("positionNext", "float", 3),
      prevPositionPrev: new Geometry$1.Attribute("prevPositionPrev", "float", 3),
      prevPosition: new Geometry$1.Attribute("prevPosition", "float", 3),
      prevPositionNext: new Geometry$1.Attribute("prevPositionNext", "float", 3),
      offset: new Geometry$1.Attribute("offset", "float", 1),
      color: new Geometry$1.Attribute("color", "float", 4, "COLOR")
    }
  };
}, {
  resetOffset: function() {
    this._vertexOffset = 0;
    this._triangleOffset = 0;
    this._itemVertexOffsets = [];
  },
  setVertexCount: function(nVertex) {
    var attributes = this.attributes;
    if (this.vertexCount !== nVertex) {
      attributes.position.init(nVertex);
      attributes.color.init(nVertex);
      if (!this.useNativeLine) {
        attributes.positionPrev.init(nVertex);
        attributes.positionNext.init(nVertex);
        attributes.offset.init(nVertex);
      }
      if (nVertex > 65535) {
        if (this.indices instanceof Uint16Array) {
          this.indices = new Uint32Array(this.indices);
        }
      } else {
        if (this.indices instanceof Uint32Array) {
          this.indices = new Uint16Array(this.indices);
        }
      }
    }
  },
  setTriangleCount: function(nTriangle) {
    if (this.triangleCount !== nTriangle) {
      if (nTriangle === 0) {
        this.indices = null;
      } else {
        this.indices = this.vertexCount > 65535 ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);
      }
    }
  },
  _getCubicCurveApproxStep: function(p02, p12, p22, p3) {
    var len2 = vec3$e.dist(p02, p12) + vec3$e.dist(p22, p12) + vec3$e.dist(p3, p22);
    var step = 1 / (len2 + 1) * this.segmentScale;
    return step;
  },
  getCubicCurveVertexCount: function(p02, p12, p22, p3) {
    var step = this._getCubicCurveApproxStep(p02, p12, p22, p3);
    var segCount = Math.ceil(1 / step);
    if (!this.useNativeLine) {
      return segCount * 2 + 2;
    } else {
      return segCount * 2;
    }
  },
  getCubicCurveTriangleCount: function(p02, p12, p22, p3) {
    var step = this._getCubicCurveApproxStep(p02, p12, p22, p3);
    var segCount = Math.ceil(1 / step);
    if (!this.useNativeLine) {
      return segCount * 2;
    } else {
      return 0;
    }
  },
  getLineVertexCount: function() {
    return this.getPolylineVertexCount(sampleLinePoints$1);
  },
  getLineTriangleCount: function() {
    return this.getPolylineTriangleCount(sampleLinePoints$1);
  },
  getPolylineVertexCount: function(points2) {
    var pointsLen;
    if (typeof points2 === "number") {
      pointsLen = points2;
    } else {
      var is2DArray2 = typeof points2[0] !== "number";
      pointsLen = is2DArray2 ? points2.length : points2.length / 3;
    }
    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;
  },
  getPolylineTriangleCount: function(points2) {
    var pointsLen;
    if (typeof points2 === "number") {
      pointsLen = points2;
    } else {
      var is2DArray2 = typeof points2[0] !== "number";
      pointsLen = is2DArray2 ? points2.length : points2.length / 3;
    }
    return !this.useNativeLine ? Math.max(pointsLen - 1, 0) * 2 : 0;
  },
  addCubicCurve: function(p02, p12, p22, p3, color, lineWidth) {
    if (lineWidth == null) {
      lineWidth = 1;
    }
    var x0 = p02[0], y0 = p02[1], z0 = p02[2];
    var x1 = p12[0], y1 = p12[1], z1 = p12[2];
    var x2 = p22[0], y2 = p22[1], z2 = p22[2];
    var x3 = p3[0], y3 = p3[1], z3 = p3[2];
    var step = this._getCubicCurveApproxStep(p02, p12, p22, p3);
    var step2 = step * step;
    var step3 = step2 * step;
    var pre1 = 3 * step;
    var pre2 = 3 * step2;
    var pre4 = 6 * step2;
    var pre5 = 6 * step3;
    var tmp1x = x0 - x1 * 2 + x2;
    var tmp1y = y0 - y1 * 2 + y2;
    var tmp1z = z0 - z1 * 2 + z2;
    var tmp2x = (x1 - x2) * 3 - x0 + x3;
    var tmp2y = (y1 - y2) * 3 - y0 + y3;
    var tmp2z = (z1 - z2) * 3 - z0 + z3;
    var fx = x0;
    var fy = y0;
    var fz = z0;
    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;
    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;
    var dfz = (z1 - z0) * pre1 + tmp1z * pre2 + tmp2z * step3;
    var ddfx = tmp1x * pre4 + tmp2x * pre5;
    var ddfy = tmp1y * pre4 + tmp2y * pre5;
    var ddfz = tmp1z * pre4 + tmp2z * pre5;
    var dddfx = tmp2x * pre5;
    var dddfy = tmp2y * pre5;
    var dddfz = tmp2z * pre5;
    var t = 0;
    var k = 0;
    var segCount = Math.ceil(1 / step);
    var points2 = new Float32Array((segCount + 1) * 3);
    var points2 = [];
    var offset = 0;
    for (var k = 0; k < segCount + 1; k++) {
      points2[offset++] = fx;
      points2[offset++] = fy;
      points2[offset++] = fz;
      fx += dfx;
      fy += dfy;
      fz += dfz;
      dfx += ddfx;
      dfy += ddfy;
      dfz += ddfz;
      ddfx += dddfx;
      ddfy += dddfy;
      ddfz += dddfz;
      t += step;
      if (t > 1) {
        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);
        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);
        fz = dfz > 0 ? Math.min(fz, z3) : Math.max(fz, z3);
      }
    }
    return this.addPolyline(points2, color, lineWidth);
  },
  addLine: function(p02, p12, color, lineWidth) {
    return this.addPolyline([p02, p12], color, lineWidth);
  },
  addPolyline: function(points2, color, lineWidth, startOffset, pointsCount) {
    if (!points2.length) {
      return;
    }
    var is2DArray2 = typeof points2[0] !== "number";
    if (pointsCount == null) {
      pointsCount = is2DArray2 ? points2.length : points2.length / 3;
    }
    if (pointsCount < 2) {
      return;
    }
    if (startOffset == null) {
      startOffset = 0;
    }
    if (lineWidth == null) {
      lineWidth = 1;
    }
    this._itemVertexOffsets.push(this._vertexOffset);
    var is2DArray2 = typeof points2[0] !== "number";
    var notSharingColor = is2DArray2 ? typeof color[0] !== "number" : color.length / 4 === pointsCount;
    var positionAttr = this.attributes.position;
    var positionPrevAttr = this.attributes.positionPrev;
    var positionNextAttr = this.attributes.positionNext;
    var colorAttr = this.attributes.color;
    var offsetAttr = this.attributes.offset;
    var indices = this.indices;
    var vertexOffset = this._vertexOffset;
    var point;
    var pointColor;
    lineWidth = Math.max(lineWidth, 0.01);
    for (var k = startOffset; k < pointsCount; k++) {
      if (is2DArray2) {
        point = points2[k];
        if (notSharingColor) {
          pointColor = color[k];
        } else {
          pointColor = color;
        }
      } else {
        var k3 = k * 3;
        point = point || [];
        point[0] = points2[k3];
        point[1] = points2[k3 + 1];
        point[2] = points2[k3 + 2];
        if (notSharingColor) {
          var k4 = k * 4;
          pointColor = pointColor || [];
          pointColor[0] = color[k4];
          pointColor[1] = color[k4 + 1];
          pointColor[2] = color[k4 + 2];
          pointColor[3] = color[k4 + 3];
        } else {
          pointColor = color;
        }
      }
      if (!this.useNativeLine) {
        if (k < pointsCount - 1) {
          positionPrevAttr.set(vertexOffset + 2, point);
          positionPrevAttr.set(vertexOffset + 3, point);
        }
        if (k > 0) {
          positionNextAttr.set(vertexOffset - 2, point);
          positionNextAttr.set(vertexOffset - 1, point);
        }
        positionAttr.set(vertexOffset, point);
        positionAttr.set(vertexOffset + 1, point);
        colorAttr.set(vertexOffset, pointColor);
        colorAttr.set(vertexOffset + 1, pointColor);
        offsetAttr.set(vertexOffset, lineWidth / 2);
        offsetAttr.set(vertexOffset + 1, -lineWidth / 2);
        vertexOffset += 2;
      } else {
        if (k > 1) {
          positionAttr.copy(vertexOffset, vertexOffset - 1);
          colorAttr.copy(vertexOffset, vertexOffset - 1);
          vertexOffset++;
        }
      }
      if (!this.useNativeLine) {
        if (k > 0) {
          var idx3 = this._triangleOffset * 3;
          var indices = this.indices;
          indices[idx3] = vertexOffset - 4;
          indices[idx3 + 1] = vertexOffset - 3;
          indices[idx3 + 2] = vertexOffset - 2;
          indices[idx3 + 3] = vertexOffset - 3;
          indices[idx3 + 4] = vertexOffset - 1;
          indices[idx3 + 5] = vertexOffset - 2;
          this._triangleOffset += 2;
        }
      } else {
        colorAttr.set(vertexOffset, pointColor);
        positionAttr.set(vertexOffset, point);
        vertexOffset++;
      }
    }
    if (!this.useNativeLine) {
      var start2 = this._vertexOffset;
      var end2 = this._vertexOffset + pointsCount * 2;
      positionPrevAttr.copy(start2, start2 + 2);
      positionPrevAttr.copy(start2 + 1, start2 + 3);
      positionNextAttr.copy(end2 - 1, end2 - 3);
      positionNextAttr.copy(end2 - 2, end2 - 4);
    }
    this._vertexOffset = vertexOffset;
    return this._vertexOffset;
  },
  setItemColor: function(idx, color) {
    var startOffset = this._itemVertexOffsets[idx];
    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;
    for (var i = startOffset; i < endOffset; i++) {
      this.attributes.color.set(i, color);
    }
    this.dirty("color");
  },
  currentTriangleOffset: function() {
    return this._triangleOffset;
  },
  currentVertexOffset: function() {
    return this._vertexOffset;
  }
});
defaults(LinesGeometry$2.prototype, dynamicConvertMixin);
var LinesGeometry$3 = LinesGeometry$2;
function ZRTextureAtlasSurfaceNode(zr, offsetX, offsetY, width, height, gap, dpr2) {
  this._zr = zr;
  this._x = 0;
  this._y = 0;
  this._rowHeight = 0;
  this.width = width;
  this.height = height;
  this.offsetX = offsetX;
  this.offsetY = offsetY;
  this.dpr = dpr2;
  this.gap = gap;
}
ZRTextureAtlasSurfaceNode.prototype = {
  constructor: ZRTextureAtlasSurfaceNode,
  clear: function() {
    this._x = 0;
    this._y = 0;
    this._rowHeight = 0;
  },
  add: function(el, width, height) {
    var rect = el.getBoundingRect();
    if (width == null) {
      width = rect.width;
    }
    if (height == null) {
      height = rect.height;
    }
    width *= this.dpr;
    height *= this.dpr;
    this._fitElement(el, width, height);
    var x = this._x;
    var y = this._y;
    var canvasWidth = this.width * this.dpr;
    var canvasHeight = this.height * this.dpr;
    var gap = this.gap;
    if (x + width + gap > canvasWidth) {
      x = this._x = 0;
      y += this._rowHeight + gap;
      this._y = y;
      this._rowHeight = 0;
    }
    this._x += width + gap;
    this._rowHeight = Math.max(this._rowHeight, height);
    if (y + height + gap > canvasHeight) {
      return null;
    }
    el.x += this.offsetX * this.dpr + x;
    el.y += this.offsetY * this.dpr + y;
    this._zr.add(el);
    var coordsOffset = [this.offsetX / this.width, this.offsetY / this.height];
    var coords = [[x / canvasWidth + coordsOffset[0], y / canvasHeight + coordsOffset[1]], [(x + width) / canvasWidth + coordsOffset[0], (y + height) / canvasHeight + coordsOffset[1]]];
    return coords;
  },
  _fitElement: function(el, spriteWidth, spriteHeight) {
    var rect = el.getBoundingRect();
    var scaleX = spriteWidth / rect.width;
    var scaleY = spriteHeight / rect.height;
    el.x = -rect.x * scaleX;
    el.y = -rect.y * scaleY;
    el.scaleX = scaleX;
    el.scaleY = scaleY;
    el.update();
  }
};
function ZRTextureAtlasSurface(opt) {
  opt = opt || {};
  opt.width = opt.width || 512;
  opt.height = opt.height || 512;
  opt.devicePixelRatio = opt.devicePixelRatio || 1;
  opt.gap = opt.gap == null ? 2 : opt.gap;
  var canvas = document.createElement("canvas");
  canvas.width = opt.width * opt.devicePixelRatio;
  canvas.height = opt.height * opt.devicePixelRatio;
  this._canvas = canvas;
  this._texture = new Texture2D$1({
    image: canvas,
    flipY: false
  });
  var self2 = this;
  this._zr = init$2(canvas);
  var oldRefreshImmediately = this._zr.refreshImmediately;
  this._zr.refreshImmediately = function() {
    oldRefreshImmediately.call(this);
    self2._texture.dirty();
    self2.onupdate && self2.onupdate();
  };
  this._dpr = opt.devicePixelRatio;
  this._coords = {};
  this.onupdate = opt.onupdate;
  this._gap = opt.gap;
  this._textureAtlasNodes = [new ZRTextureAtlasSurfaceNode(this._zr, 0, 0, opt.width, opt.height, this._gap, this._dpr)];
  this._nodeWidth = opt.width;
  this._nodeHeight = opt.height;
  this._currentNodeIdx = 0;
}
ZRTextureAtlasSurface.prototype = {
  clear: function() {
    for (var i = 0; i < this._textureAtlasNodes.length; i++) {
      this._textureAtlasNodes[i].clear();
    }
    this._currentNodeIdx = 0;
    this._zr.clear();
    this._coords = {};
  },
  getWidth: function() {
    return this._width;
  },
  getHeight: function() {
    return this._height;
  },
  getTexture: function() {
    return this._texture;
  },
  getDevicePixelRatio: function() {
    return this._dpr;
  },
  getZr: function() {
    return this._zr;
  },
  _getCurrentNode: function() {
    return this._textureAtlasNodes[this._currentNodeIdx];
  },
  _expand: function() {
    this._currentNodeIdx++;
    if (this._textureAtlasNodes[this._currentNodeIdx]) {
      return this._textureAtlasNodes[this._currentNodeIdx];
    }
    var maxSize = 4096 / this._dpr;
    var textureAtlasNodes = this._textureAtlasNodes;
    var nodeLen = textureAtlasNodes.length;
    var offsetX = nodeLen * this._nodeWidth % maxSize;
    var offsetY = Math.floor(nodeLen * this._nodeWidth / maxSize) * this._nodeHeight;
    if (offsetY >= maxSize) {
      return;
    }
    var width = (offsetX + this._nodeWidth) * this._dpr;
    var height = (offsetY + this._nodeHeight) * this._dpr;
    try {
      this._zr.resize({
        width,
        height
      });
    } catch (e2) {
      this._canvas.width = width;
      this._canvas.height = height;
    }
    var newNode = new ZRTextureAtlasSurfaceNode(this._zr, offsetX, offsetY, this._nodeWidth, this._nodeHeight, this._gap, this._dpr);
    this._textureAtlasNodes.push(newNode);
    return newNode;
  },
  add: function(el, width, height) {
    if (this._coords[el.id]) {
      return this._coords[el.id];
    }
    var coords = this._getCurrentNode().add(el, width, height);
    if (!coords) {
      var newNode = this._expand();
      if (!newNode) {
        return;
      }
      coords = newNode.add(el, width, height);
    }
    this._coords[el.id] = coords;
    return coords;
  },
  getCoordsScale: function() {
    var dpr2 = this._dpr;
    return [this._nodeWidth / this._canvas.width * dpr2, this._nodeHeight / this._canvas.height * dpr2];
  },
  getCoords: function(id) {
    return this._coords[id];
  },
  dispose: function() {
    this._zr.dispose();
  }
};
function SceneHelper() {
}
SceneHelper.prototype = {
  constructor: SceneHelper,
  setScene: function(scene) {
    this._scene = scene;
    if (this._skybox) {
      this._skybox.attachScene(this._scene);
    }
  },
  initLight: function(rootNode) {
    this._lightRoot = rootNode;
    this.mainLight = new graphicGL$1.DirectionalLight({
      shadowBias: 5e-3
    });
    this.ambientLight = new graphicGL$1.AmbientLight();
    rootNode.add(this.mainLight);
    rootNode.add(this.ambientLight);
  },
  dispose: function() {
    if (this._lightRoot) {
      this._lightRoot.remove(this.mainLight);
      this._lightRoot.remove(this.ambientLight);
    }
  },
  updateLight: function(componentModel) {
    var mainLight = this.mainLight;
    var ambientLight = this.ambientLight;
    var lightModel = componentModel.getModel("light");
    var mainLightModel = lightModel.getModel("main");
    var ambientLightModel = lightModel.getModel("ambient");
    mainLight.intensity = mainLightModel.get("intensity");
    ambientLight.intensity = ambientLightModel.get("intensity");
    mainLight.color = graphicGL$1.parseColor(mainLightModel.get("color")).slice(0, 3);
    ambientLight.color = graphicGL$1.parseColor(ambientLightModel.get("color")).slice(0, 3);
    var alpha = mainLightModel.get("alpha") || 0;
    var beta = mainLightModel.get("beta") || 0;
    mainLight.position.setArray(graphicGL$1.directionFromAlphaBeta(alpha, beta));
    mainLight.lookAt(graphicGL$1.Vector3.ZERO);
    mainLight.castShadow = mainLightModel.get("shadow");
    mainLight.shadowResolution = graphicGL$1.getShadowResolution(mainLightModel.get("shadowQuality"));
  },
  updateAmbientCubemap: function(renderer, componentModel, api) {
    var ambientCubemapModel = componentModel.getModel("light.ambientCubemap");
    var textureUrl = ambientCubemapModel.get("texture");
    if (textureUrl) {
      this._cubemapLightsCache = this._cubemapLightsCache || {};
      var lights = this._cubemapLightsCache[textureUrl];
      if (!lights) {
        var self2 = this;
        lights = this._cubemapLightsCache[textureUrl] = graphicGL$1.createAmbientCubemap(ambientCubemapModel.option, renderer, api, function() {
          if (self2._isSkyboxFromAmbientCubemap) {
            self2._skybox.setEnvironmentMap(lights.specular.cubemap);
          }
          api.getZr().refresh();
        });
      }
      this._lightRoot.add(lights.diffuse);
      this._lightRoot.add(lights.specular);
      this._currentCubemapLights = lights;
    } else if (this._currentCubemapLights) {
      this._lightRoot.remove(this._currentCubemapLights.diffuse);
      this._lightRoot.remove(this._currentCubemapLights.specular);
      this._currentCubemapLights = null;
    }
  },
  updateSkybox: function(renderer, componentModel, api) {
    var environmentUrl = componentModel.get("environment");
    var self2 = this;
    function getSkybox() {
      self2._skybox = self2._skybox || new Skybox$1();
      return self2._skybox;
    }
    var skybox = getSkybox();
    if (environmentUrl && environmentUrl !== "none") {
      if (environmentUrl === "auto") {
        this._isSkyboxFromAmbientCubemap = true;
        if (this._currentCubemapLights) {
          var cubemap = this._currentCubemapLights.specular.cubemap;
          skybox.setEnvironmentMap(cubemap);
          if (this._scene) {
            skybox.attachScene(this._scene);
          }
          skybox.material.set("lod", 3);
        } else if (this._skybox) {
          this._skybox.detachScene();
        }
      } else if (typeof environmentUrl === "object" && environmentUrl.colorStops || typeof environmentUrl === "string" && parse(environmentUrl)) {
        this._isSkyboxFromAmbientCubemap = false;
        var texture = new graphicGL$1.Texture2D({
          anisotropic: 8,
          flipY: false
        });
        skybox.setEnvironmentMap(texture);
        var canvas = texture.image = document.createElement("canvas");
        canvas.width = canvas.height = 16;
        var ctx = canvas.getContext("2d");
        var rect = new Rect$3({
          shape: {
            x: 0,
            y: 0,
            width: 16,
            height: 16
          },
          style: {
            fill: environmentUrl
          }
        });
        brushSingle(ctx, rect);
        skybox.attachScene(this._scene);
      } else {
        this._isSkyboxFromAmbientCubemap = false;
        var texture = graphicGL$1.loadTexture(environmentUrl, api, {
          anisotropic: 8,
          flipY: false
        });
        skybox.setEnvironmentMap(texture);
        skybox.attachScene(this._scene);
      }
    } else {
      if (this._skybox) {
        this._skybox.detachScene(this._scene);
      }
      this._skybox = null;
    }
    var coordSys = componentModel.coordinateSystem;
    if (this._skybox) {
      if (coordSys && coordSys.viewGL && environmentUrl !== "auto" && !(environmentUrl.match && environmentUrl.match(/.hdr$/))) {
        var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
        this._skybox.material[srgbDefineMethod]("fragment", "SRGB_DECODE");
      } else {
        this._skybox.material.undefine("fragment", "SRGB_DECODE");
      }
    }
  }
};
var vec3$d = glmatrix.vec3;
var QuadsGeometry = Geometry$1.extend(function() {
  return {
    segmentScale: 1,
    useNativeLine: true,
    attributes: {
      position: new Geometry$1.Attribute("position", "float", 3, "POSITION"),
      normal: new Geometry$1.Attribute("normal", "float", 3, "NORMAL"),
      color: new Geometry$1.Attribute("color", "float", 4, "COLOR")
    }
  };
}, {
  resetOffset: function() {
    this._vertexOffset = 0;
    this._faceOffset = 0;
  },
  setQuadCount: function(nQuad) {
    var attributes = this.attributes;
    var vertexCount = this.getQuadVertexCount() * nQuad;
    var triangleCount = this.getQuadTriangleCount() * nQuad;
    if (this.vertexCount !== vertexCount) {
      attributes.position.init(vertexCount);
      attributes.normal.init(vertexCount);
      attributes.color.init(vertexCount);
    }
    if (this.triangleCount !== triangleCount) {
      this.indices = vertexCount > 65535 ? new Uint32Array(triangleCount * 3) : new Uint16Array(triangleCount * 3);
    }
  },
  getQuadVertexCount: function() {
    return 4;
  },
  getQuadTriangleCount: function() {
    return 2;
  },
  addQuad: function() {
    var a = vec3$d.create();
    var b = vec3$d.create();
    var normal2 = vec3$d.create();
    var indices = [0, 3, 1, 3, 2, 1];
    return function(coords, color) {
      var positionAttr = this.attributes.position;
      var normalAttr = this.attributes.normal;
      var colorAttr = this.attributes.color;
      vec3$d.sub(a, coords[1], coords[0]);
      vec3$d.sub(b, coords[2], coords[1]);
      vec3$d.cross(normal2, a, b);
      vec3$d.normalize(normal2, normal2);
      for (var i = 0; i < 4; i++) {
        positionAttr.set(this._vertexOffset + i, coords[i]);
        colorAttr.set(this._vertexOffset + i, color);
        normalAttr.set(this._vertexOffset + i, normal2);
      }
      var idx = this._faceOffset * 3;
      for (var i = 0; i < 6; i++) {
        this.indices[idx + i] = indices[i] + this._vertexOffset;
      }
      this._vertexOffset += 4;
      this._faceOffset += 2;
    };
  }()
});
defaults(QuadsGeometry.prototype, dynamicConvertMixin);
var QuadsGeometry$1 = QuadsGeometry;
var firstNotNull$2 = retrieve$1.firstNotNull;
var dimIndicesMap$2 = {
  x: 0,
  y: 2,
  z: 1
};
function updateFacePlane(node, plane, otherAxis, dir3) {
  var coord = [0, 0, 0];
  var distance2 = dir3 < 0 ? otherAxis.getExtentMin() : otherAxis.getExtentMax();
  coord[dimIndicesMap$2[otherAxis.dim]] = distance2;
  node.position.setArray(coord);
  node.rotation.identity();
  plane.distance = -Math.abs(distance2);
  plane.normal.set(0, 0, 0);
  if (otherAxis.dim === "x") {
    node.rotation.rotateY(dir3 * Math.PI / 2);
    plane.normal.x = -dir3;
  } else if (otherAxis.dim === "z") {
    node.rotation.rotateX(-dir3 * Math.PI / 2);
    plane.normal.y = -dir3;
  } else {
    if (dir3 > 0) {
      node.rotation.rotateY(Math.PI);
    }
    plane.normal.z = -dir3;
  }
}
function Grid3DFace(faceInfo, linesMaterial, quadsMaterial) {
  this.rootNode = new graphicGL$1.Node();
  var linesMesh = new graphicGL$1.Mesh({
    geometry: new LinesGeometry$3({
      useNativeLine: false
    }),
    material: linesMaterial,
    castShadow: false,
    ignorePicking: true,
    $ignorePicking: true,
    renderOrder: 1
  });
  var quadsMesh = new graphicGL$1.Mesh({
    geometry: new QuadsGeometry$1(),
    material: quadsMaterial,
    castShadow: false,
    culling: false,
    ignorePicking: true,
    $ignorePicking: true,
    renderOrder: 0
  });
  this.rootNode.add(quadsMesh);
  this.rootNode.add(linesMesh);
  this.faceInfo = faceInfo;
  this.plane = new graphicGL$1.Plane();
  this.linesMesh = linesMesh;
  this.quadsMesh = quadsMesh;
}
Grid3DFace.prototype.update = function(grid3DModel, ecModel, api) {
  var cartesian = grid3DModel.coordinateSystem;
  var axes = [cartesian.getAxis(this.faceInfo[0]), cartesian.getAxis(this.faceInfo[1])];
  var lineGeometry = this.linesMesh.geometry;
  var quadsGeometry = this.quadsMesh.geometry;
  lineGeometry.convertToDynamicArray(true);
  quadsGeometry.convertToDynamicArray(true);
  this._updateSplitLines(lineGeometry, axes, grid3DModel, api);
  this._udpateSplitAreas(quadsGeometry, axes, grid3DModel, api);
  lineGeometry.convertToTypedArray();
  quadsGeometry.convertToTypedArray();
  var otherAxis = cartesian.getAxis(this.faceInfo[2]);
  updateFacePlane(this.rootNode, this.plane, otherAxis, this.faceInfo[3]);
};
Grid3DFace.prototype._updateSplitLines = function(geometry, axes, grid3DModel, api) {
  var dpr2 = api.getDevicePixelRatio();
  axes.forEach(function(axis, idx) {
    var axisModel = axis.model;
    var otherExtent = axes[1 - idx].getExtent();
    if (axis.scale.isBlank()) {
      return;
    }
    var splitLineModel = axisModel.getModel("splitLine", grid3DModel.getModel("splitLine"));
    if (splitLineModel.get("show")) {
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      var opacity = firstNotNull$2(lineStyleModel.get("opacity"), 1);
      var lineWidth = firstNotNull$2(lineStyleModel.get("width"), 1);
      lineColors = isArray$1(lineColors) ? lineColors : [lineColors];
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel
      });
      var count2 = 0;
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = ticksCoords[i].coord;
        var lineColor = graphicGL$1.parseColor(lineColors[count2 % lineColors.length]);
        lineColor[3] *= opacity;
        var p02 = [0, 0, 0];
        var p12 = [0, 0, 0];
        p02[idx] = p12[idx] = tickCoord;
        p02[1 - idx] = otherExtent[0];
        p12[1 - idx] = otherExtent[1];
        geometry.addLine(p02, p12, lineColor, lineWidth * dpr2);
        count2++;
      }
    }
  });
};
Grid3DFace.prototype._udpateSplitAreas = function(geometry, axes, grid3DModel, api) {
  axes.forEach(function(axis, idx) {
    var axisModel = axis.model;
    var otherExtent = axes[1 - idx].getExtent();
    if (axis.scale.isBlank()) {
      return;
    }
    var splitAreaModel = axisModel.getModel("splitArea", grid3DModel.getModel("splitArea"));
    if (splitAreaModel.get("show")) {
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var colors = areaStyleModel.get("color");
      var opacity = firstNotNull$2(areaStyleModel.get("opacity"), 1);
      colors = isArray$1(colors) ? colors : [colors];
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitAreaModel,
        clamp: true
      });
      var count2 = 0;
      var prevP0 = [0, 0, 0];
      var prevP1 = [0, 0, 0];
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = ticksCoords[i].coord;
        var p02 = [0, 0, 0];
        var p12 = [0, 0, 0];
        p02[idx] = p12[idx] = tickCoord;
        p02[1 - idx] = otherExtent[0];
        p12[1 - idx] = otherExtent[1];
        if (i === 0) {
          prevP0 = p02;
          prevP1 = p12;
          continue;
        }
        var color = graphicGL$1.parseColor(colors[count2 % colors.length]);
        color[3] *= opacity;
        geometry.addQuad([prevP0, p02, p12, prevP1], color);
        prevP0 = p02;
        prevP1 = p12;
        count2++;
      }
    }
  });
};
var squareTriangles = [0, 1, 2, 0, 2, 3];
var SpritesGeometry = Geometry$1.extend(function() {
  return {
    attributes: {
      position: new Geometry$1.Attribute("position", "float", 3, "POSITION"),
      texcoord: new Geometry$1.Attribute("texcoord", "float", 2, "TEXCOORD_0"),
      offset: new Geometry$1.Attribute("offset", "float", 2),
      color: new Geometry$1.Attribute("color", "float", 4, "COLOR")
    }
  };
}, {
  resetOffset: function() {
    this._vertexOffset = 0;
    this._faceOffset = 0;
  },
  setSpriteCount: function(spriteCount) {
    this._spriteCount = spriteCount;
    var vertexCount = spriteCount * 4;
    var triangleCount = spriteCount * 2;
    if (this.vertexCount !== vertexCount) {
      this.attributes.position.init(vertexCount);
      this.attributes.offset.init(vertexCount);
      this.attributes.color.init(vertexCount);
    }
    if (this.triangleCount !== triangleCount) {
      this.indices = vertexCount > 65535 ? new Uint32Array(triangleCount * 3) : new Uint16Array(triangleCount * 3);
    }
  },
  setSpriteAlign: function(spriteOffset, size, align, verticalAlign, margin) {
    if (align == null) {
      align = "left";
    }
    if (verticalAlign == null) {
      verticalAlign = "top";
    }
    var leftOffset, topOffset, rightOffset, bottomOffset;
    margin = margin || 0;
    switch (align) {
      case "left":
        leftOffset = margin;
        rightOffset = size[0] + margin;
        break;
      case "center":
      case "middle":
        leftOffset = -size[0] / 2;
        rightOffset = size[0] / 2;
        break;
      case "right":
        leftOffset = -size[0] - margin;
        rightOffset = -margin;
        break;
    }
    switch (verticalAlign) {
      case "bottom":
        topOffset = margin;
        bottomOffset = size[1] + margin;
        break;
      case "middle":
        topOffset = -size[1] / 2;
        bottomOffset = size[1] / 2;
        break;
      case "top":
        topOffset = -size[1] - margin;
        bottomOffset = -margin;
        break;
    }
    var vertexOffset = spriteOffset * 4;
    var offsetAttr = this.attributes.offset;
    offsetAttr.set(vertexOffset, [leftOffset, bottomOffset]);
    offsetAttr.set(vertexOffset + 1, [rightOffset, bottomOffset]);
    offsetAttr.set(vertexOffset + 2, [rightOffset, topOffset]);
    offsetAttr.set(vertexOffset + 3, [leftOffset, topOffset]);
  },
  addSprite: function(position2, size, coords, align, verticalAlign, screenMargin) {
    var vertexOffset = this._vertexOffset;
    this.setSprite(this._vertexOffset / 4, position2, size, coords, align, verticalAlign, screenMargin);
    for (var i = 0; i < squareTriangles.length; i++) {
      this.indices[this._faceOffset * 3 + i] = squareTriangles[i] + vertexOffset;
    }
    this._faceOffset += 2;
    this._vertexOffset += 4;
    return vertexOffset / 4;
  },
  setSprite: function(spriteOffset, position2, size, coords, align, verticalAlign, screenMargin) {
    var vertexOffset = spriteOffset * 4;
    var attributes = this.attributes;
    for (var i = 0; i < 4; i++) {
      attributes.position.set(vertexOffset + i, position2);
    }
    var texcoordAttr = attributes.texcoord;
    texcoordAttr.set(vertexOffset, [coords[0][0], coords[0][1]]);
    texcoordAttr.set(vertexOffset + 1, [coords[1][0], coords[0][1]]);
    texcoordAttr.set(vertexOffset + 2, [coords[1][0], coords[1][1]]);
    texcoordAttr.set(vertexOffset + 3, [coords[0][0], coords[1][1]]);
    this.setSpriteAlign(spriteOffset, size, align, verticalAlign, screenMargin);
  }
});
defaults(SpritesGeometry.prototype, dynamicConvertMixin);
var SpritesGeometry$1 = SpritesGeometry;
var labelsGLSL = "@export ecgl.labels.vertex\n\nattribute vec3 position: POSITION;\nattribute vec2 texcoord: TEXCOORD_0;\nattribute vec2 offset;\n#ifdef VERTEX_COLOR\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n#endif\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\n\nvarying vec2 v_Texcoord;\n\nvoid main()\n{\n vec4 proj = worldViewProjection * vec4(position, 1.0);\n\n vec2 screen = (proj.xy / abs(proj.w) + 1.0) * 0.5 * viewport.zw;\n\n screen += offset;\n\n proj.xy = (screen / viewport.zw - 0.5) * 2.0 * abs(proj.w);\n gl_Position = proj;\n#ifdef VERTEX_COLOR\n v_Color = a_Color;\n#endif\n v_Texcoord = texcoord;\n}\n@end\n\n\n@export ecgl.labels.fragment\n\nuniform vec3 color : [1.0, 1.0, 1.0];\nuniform float alpha : 1.0;\nuniform sampler2D textureAtlas;\nuniform vec2 uvScale: [1.0, 1.0];\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\nvarying float v_Miter;\n\nvarying vec2 v_Texcoord;\n\nvoid main()\n{\n gl_FragColor = vec4(color, alpha) * texture2D(textureAtlas, v_Texcoord * uvScale);\n#ifdef VERTEX_COLOR\n gl_FragColor *= v_Color;\n#endif\n}\n\n@end";
graphicGL$1.Shader.import(labelsGLSL);
var LabelsMesh = graphicGL$1.Mesh.extend(function() {
  var geometry = new SpritesGeometry$1({
    dynamic: true
  });
  var material = new graphicGL$1.Material({
    shader: graphicGL$1.createShader("ecgl.labels"),
    transparent: true,
    depthMask: false
  });
  return {
    geometry,
    material,
    culling: false,
    castShadow: false,
    ignorePicking: true
  };
});
var firstNotNull$1 = retrieve$1.firstNotNull;
var dimIndicesMap$1 = {
  x: 0,
  y: 2,
  z: 1
};
function Grid3DAxis(dim, linesMaterial) {
  var linesMesh = new graphicGL$1.Mesh({
    geometry: new LinesGeometry$3({
      useNativeLine: false
    }),
    material: linesMaterial,
    castShadow: false,
    ignorePicking: true,
    renderOrder: 2
  });
  var axisLabelsMesh = new LabelsMesh();
  axisLabelsMesh.material.depthMask = false;
  var rootNode = new graphicGL$1.Node();
  rootNode.add(linesMesh);
  rootNode.add(axisLabelsMesh);
  this.rootNode = rootNode;
  this.dim = dim;
  this.linesMesh = linesMesh;
  this.labelsMesh = axisLabelsMesh;
  this.axisLineCoords = null;
  this.labelElements = [];
}
var otherDim = {
  x: "y",
  y: "x",
  z: "y"
};
Grid3DAxis.prototype.update = function(grid3DModel, axisLabelSurface, api) {
  var cartesian = grid3DModel.coordinateSystem;
  var axis = cartesian.getAxis(this.dim);
  var linesGeo = this.linesMesh.geometry;
  var labelsGeo = this.labelsMesh.geometry;
  linesGeo.convertToDynamicArray(true);
  labelsGeo.convertToDynamicArray(true);
  var axisModel = axis.model;
  var extent3 = axis.getExtent();
  var dpr2 = api.getDevicePixelRatio();
  var axisLineModel = axisModel.getModel("axisLine", grid3DModel.getModel("axisLine"));
  var axisTickModel = axisModel.getModel("axisTick", grid3DModel.getModel("axisTick"));
  var axisLabelModel = axisModel.getModel("axisLabel", grid3DModel.getModel("axisLabel"));
  var axisLineColor = axisLineModel.get("lineStyle.color");
  if (axisLineModel.get("show")) {
    var axisLineStyleModel = axisLineModel.getModel("lineStyle");
    var p02 = [0, 0, 0];
    var p12 = [0, 0, 0];
    var idx = dimIndicesMap$1[axis.dim];
    p02[idx] = extent3[0];
    p12[idx] = extent3[1];
    this.axisLineCoords = [p02, p12];
    var color = graphicGL$1.parseColor(axisLineColor);
    var lineWidth = firstNotNull$1(axisLineStyleModel.get("width"), 1);
    var opacity = firstNotNull$1(axisLineStyleModel.get("opacity"), 1);
    color[3] *= opacity;
    linesGeo.addLine(p02, p12, color, lineWidth * dpr2);
  }
  if (axisTickModel.get("show")) {
    var lineStyleModel = axisTickModel.getModel("lineStyle");
    var lineColor = graphicGL$1.parseColor(firstNotNull$1(lineStyleModel.get("color"), axisLineColor));
    var lineWidth = firstNotNull$1(lineStyleModel.get("width"), 1);
    lineColor[3] *= firstNotNull$1(lineStyleModel.get("opacity"), 1);
    var ticksCoords = axis.getTicksCoords();
    var tickLength = axisTickModel.get("length");
    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = ticksCoords[i].coord;
      var p02 = [0, 0, 0];
      var p12 = [0, 0, 0];
      var idx = dimIndicesMap$1[axis.dim];
      var otherIdx = dimIndicesMap$1[otherDim[axis.dim]];
      p02[idx] = p12[idx] = tickCoord;
      p12[otherIdx] = tickLength;
      linesGeo.addLine(p02, p12, lineColor, lineWidth * dpr2);
    }
  }
  this.labelElements = [];
  var dpr2 = api.getDevicePixelRatio();
  if (axisLabelModel.get("show")) {
    var ticksCoords = axis.getTicksCoords();
    var categoryData = axisModel.get("data");
    var labelMargin = axisLabelModel.get("margin");
    var labels = axis.getViewLabels();
    for (var i = 0; i < labels.length; i++) {
      var tickValue = labels[i].tickValue;
      var formattedLabel = labels[i].formattedLabel;
      var rawLabel = labels[i].rawLabel;
      var tickCoord = axis.dataToCoord(tickValue);
      var p = [0, 0, 0];
      var idx = dimIndicesMap$1[axis.dim];
      var otherIdx = dimIndicesMap$1[otherDim[axis.dim]];
      p[idx] = p[idx] = tickCoord;
      p[otherIdx] = labelMargin;
      var itemTextStyleModel = axisLabelModel;
      if (categoryData && categoryData[tickValue] && categoryData[tickValue].textStyle) {
        itemTextStyleModel = new Model$1(categoryData[tickValue].textStyle, axisLabelModel, axisModel.ecModel);
      }
      var textColor = firstNotNull$1(itemTextStyleModel.get("color"), axisLineColor);
      var textEl = new ZRText$1({
        style: createTextStyle$1(itemTextStyleModel, {
          text: formattedLabel,
          fill: typeof textColor === "function" ? textColor(axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue, i) : textColor,
          verticalAlign: "top",
          align: "left"
        })
      });
      var coords = axisLabelSurface.add(textEl);
      var rect = textEl.getBoundingRect();
      labelsGeo.addSprite(p, [rect.width * dpr2, rect.height * dpr2], coords);
      this.labelElements.push(textEl);
    }
  }
  if (axisModel.get("name")) {
    var nameTextStyleModel = axisModel.getModel("nameTextStyle");
    var p = [0, 0, 0];
    var idx = dimIndicesMap$1[axis.dim];
    var otherIdx = dimIndicesMap$1[otherDim[axis.dim]];
    var labelColor = firstNotNull$1(nameTextStyleModel.get("color"), axisLineColor);
    var strokeColor = nameTextStyleModel.get("borderColor");
    var lineWidth = nameTextStyleModel.get("borderWidth");
    p[idx] = p[idx] = (extent3[0] + extent3[1]) / 2;
    p[otherIdx] = axisModel.get("nameGap");
    var textEl = new ZRText$1({
      style: createTextStyle$1(nameTextStyleModel, {
        text: axisModel.get("name"),
        fill: labelColor,
        stroke: strokeColor,
        lineWidth
      })
    });
    var coords = axisLabelSurface.add(textEl);
    var rect = textEl.getBoundingRect();
    labelsGeo.addSprite(p, [rect.width * dpr2, rect.height * dpr2], coords);
    textEl.__idx = this.labelElements.length;
    this.nameLabelElement = textEl;
  }
  this.labelsMesh.material.set("textureAtlas", axisLabelSurface.getTexture());
  this.labelsMesh.material.set("uvScale", axisLabelSurface.getCoordsScale());
  linesGeo.convertToTypedArray();
  labelsGeo.convertToTypedArray();
};
Grid3DAxis.prototype.setSpriteAlign = function(textAlign, textVerticalAlign, api) {
  var dpr2 = api.getDevicePixelRatio();
  var labelGeo = this.labelsMesh.geometry;
  for (var i = 0; i < this.labelElements.length; i++) {
    var labelEl = this.labelElements[i];
    var rect = labelEl.getBoundingRect();
    labelGeo.setSpriteAlign(i, [rect.width * dpr2, rect.height * dpr2], textAlign, textVerticalAlign);
  }
  var nameLabelEl = this.nameLabelElement;
  if (nameLabelEl) {
    var rect = nameLabelEl.getBoundingRect();
    labelGeo.setSpriteAlign(nameLabelEl.__idx, [rect.width * dpr2, rect.height * dpr2], textAlign, textVerticalAlign);
    labelGeo.dirty();
  }
  this.textAlign = textAlign;
  this.textVerticalAlign = textVerticalAlign;
};
var lines3DGLSL = "@export ecgl.lines3D.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec3 position: POSITION;\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n\nvoid main()\n{\n gl_Position = worldViewProjection * vec4(position, 1.0);\n v_Color = a_Color;\n}\n\n@end\n\n@export ecgl.lines3D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\n\n@import clay.util.srgb\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color * v_Color);\n#else\n gl_FragColor = color * v_Color;\n#endif\n}\n@end\n\n\n\n@export ecgl.lines3D.clipNear\n\nvec4 clipNear(vec4 p1, vec4 p2) {\n float n = (p1.w - near) / (p1.w - p2.w);\n return vec4(mix(p1.xy, p2.xy, n), -near, near);\n}\n\n@end\n\n@export ecgl.lines3D.expandLine\n#ifdef VERTEX_ANIMATION\n vec4 prevProj = worldViewProjection * vec4(mix(prevPositionPrev, positionPrev, percent), 1.0);\n vec4 currProj = worldViewProjection * vec4(mix(prevPosition, position, percent), 1.0);\n vec4 nextProj = worldViewProjection * vec4(mix(prevPositionNext, positionNext, percent), 1.0);\n#else\n vec4 prevProj = worldViewProjection * vec4(positionPrev, 1.0);\n vec4 currProj = worldViewProjection * vec4(position, 1.0);\n vec4 nextProj = worldViewProjection * vec4(positionNext, 1.0);\n#endif\n\n if (currProj.w < 0.0) {\n if (nextProj.w > 0.0) {\n currProj = clipNear(currProj, nextProj);\n }\n else if (prevProj.w > 0.0) {\n currProj = clipNear(currProj, prevProj);\n }\n }\n\n vec2 prevScreen = (prevProj.xy / abs(prevProj.w) + 1.0) * 0.5 * viewport.zw;\n vec2 currScreen = (currProj.xy / abs(currProj.w) + 1.0) * 0.5 * viewport.zw;\n vec2 nextScreen = (nextProj.xy / abs(nextProj.w) + 1.0) * 0.5 * viewport.zw;\n\n vec2 dir;\n float len = offset;\n if (position == positionPrev) {\n dir = normalize(nextScreen - currScreen);\n }\n else if (position == positionNext) {\n dir = normalize(currScreen - prevScreen);\n }\n else {\n vec2 dirA = normalize(currScreen - prevScreen);\n vec2 dirB = normalize(nextScreen - currScreen);\n\n vec2 tanget = normalize(dirA + dirB);\n\n float miter = 1.0 / max(dot(tanget, dirA), 0.5);\n len *= miter;\n dir = tanget;\n }\n\n dir = vec2(-dir.y, dir.x) * len;\n currScreen += dir;\n\n currProj.xy = (currScreen / viewport.zw - 0.5) * 2.0 * abs(currProj.w);\n@end\n\n\n@export ecgl.meshLines3D.vertex\n\nattribute vec3 position: POSITION;\nattribute vec3 positionPrev;\nattribute vec3 positionNext;\nattribute float offset;\nattribute vec4 a_Color : COLOR;\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nattribute vec3 prevPositionPrev;\nattribute vec3 prevPositionNext;\nuniform float percent : 1.0;\n#endif\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\nuniform float near : NEAR;\n\nvarying vec4 v_Color;\n\n@import ecgl.common.wireframe.vertexHeader\n\n@import ecgl.lines3D.clipNear\n\nvoid main()\n{\n @import ecgl.lines3D.expandLine\n\n gl_Position = currProj;\n\n v_Color = a_Color;\n\n @import ecgl.common.wireframe.vertexMain\n}\n@end\n\n\n@export ecgl.meshLines3D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.util.srgb\n\nvoid main()\n{\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color * v_Color);\n#else\n gl_FragColor = color * v_Color;\n#endif\n\n @import ecgl.common.wireframe.fragmentMain\n}\n\n@end";
var firstNotNull = retrieve$1.firstNotNull;
graphicGL$1.Shader.import(lines3DGLSL);
var dimIndicesMap = {
  x: 0,
  y: 2,
  z: 1
};
var Grid3DView = ComponentView$1.extend({
  type: "grid3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    var FACES = [
      ["y", "z", "x", -1, "left"],
      ["y", "z", "x", 1, "right"],
      ["x", "y", "z", -1, "bottom"],
      ["x", "y", "z", 1, "top"],
      ["x", "z", "y", -1, "far"],
      ["x", "z", "y", 1, "near"]
    ];
    var DIMS = ["x", "y", "z"];
    var quadsMaterial = new graphicGL$1.Material({
      shader: graphicGL$1.createShader("ecgl.color"),
      depthMask: false,
      transparent: true
    });
    var linesMaterial = new graphicGL$1.Material({
      shader: graphicGL$1.createShader("ecgl.meshLines3D"),
      depthMask: false,
      transparent: true
    });
    quadsMaterial.define("fragment", "DOUBLE_SIDED");
    quadsMaterial.define("both", "VERTEX_COLOR");
    this.groupGL = new graphicGL$1.Node();
    this._control = new OrbitControl$1({
      zr: api.getZr()
    });
    this._control.init();
    this._faces = FACES.map(function(faceInfo) {
      var face = new Grid3DFace(faceInfo, linesMaterial, quadsMaterial);
      this.groupGL.add(face.rootNode);
      return face;
    }, this);
    this._axes = DIMS.map(function(dim) {
      var axis = new Grid3DAxis(dim, linesMaterial);
      this.groupGL.add(axis.rootNode);
      return axis;
    }, this);
    var dpr2 = api.getDevicePixelRatio();
    this._axisLabelSurface = new ZRTextureAtlasSurface({
      width: 256,
      height: 256,
      devicePixelRatio: dpr2
    });
    this._axisLabelSurface.onupdate = function() {
      api.getZr().refresh();
    };
    this._axisPointerLineMesh = new graphicGL$1.Mesh({
      geometry: new LinesGeometry$3({
        useNativeLine: false
      }),
      material: linesMaterial,
      castShadow: false,
      ignorePicking: true,
      renderOrder: 3
    });
    this.groupGL.add(this._axisPointerLineMesh);
    this._axisPointerLabelsSurface = new ZRTextureAtlasSurface({
      width: 128,
      height: 128,
      devicePixelRatio: dpr2
    });
    this._axisPointerLabelsMesh = new LabelsMesh({
      ignorePicking: true,
      renderOrder: 4,
      castShadow: false
    });
    this._axisPointerLabelsMesh.material.set("textureAtlas", this._axisPointerLabelsSurface.getTexture());
    this.groupGL.add(this._axisPointerLabelsMesh);
    this._lightRoot = new graphicGL$1.Node();
    this._sceneHelper = new SceneHelper();
    this._sceneHelper.initLight(this._lightRoot);
  },
  render: function(grid3DModel, ecModel, api) {
    this._model = grid3DModel;
    this._api = api;
    var cartesian = grid3DModel.coordinateSystem;
    cartesian.viewGL.add(this._lightRoot);
    if (grid3DModel.get("show")) {
      cartesian.viewGL.add(this.groupGL);
    } else {
      cartesian.viewGL.remove(this.groupGL);
    }
    var control = this._control;
    control.setViewGL(cartesian.viewGL);
    var viewControlModel = grid3DModel.getModel("viewControl");
    control.setFromViewControlModel(viewControlModel, 0);
    this._axisLabelSurface.clear();
    control.off("update");
    if (grid3DModel.get("show")) {
      this._faces.forEach(function(face) {
        face.update(grid3DModel, ecModel, api);
      }, this);
      this._axes.forEach(function(axis) {
        axis.update(grid3DModel, this._axisLabelSurface, api);
      }, this);
    }
    control.on("update", this._onCameraChange.bind(this, grid3DModel, api), this);
    this._sceneHelper.setScene(cartesian.viewGL.scene);
    this._sceneHelper.updateLight(grid3DModel);
    cartesian.viewGL.setPostEffect(grid3DModel.getModel("postEffect"), api);
    cartesian.viewGL.setTemporalSuperSampling(grid3DModel.getModel("temporalSuperSampling"));
    this._initMouseHandler(grid3DModel);
  },
  afterRender: function(grid3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, grid3DModel, api);
    this._sceneHelper.updateSkybox(renderer, grid3DModel, api);
  },
  showAxisPointer: function(grid3dModel, ecModel, api, payload) {
    this._doShowAxisPointer();
    this._updateAxisPointer(payload.value);
  },
  hideAxisPointer: function(grid3dModel, ecModel, api, payload) {
    this._doHideAxisPointer();
  },
  _initMouseHandler: function(grid3DModel) {
    var cartesian = grid3DModel.coordinateSystem;
    var viewGL = cartesian.viewGL;
    if (grid3DModel.get("show") && grid3DModel.get("axisPointer.show")) {
      viewGL.on("mousemove", this._updateAxisPointerOnMousePosition, this);
    } else {
      viewGL.off("mousemove", this._updateAxisPointerOnMousePosition);
    }
  },
  _updateAxisPointerOnMousePosition: function(e2) {
    if (e2.target) {
      return;
    }
    var grid3DModel = this._model;
    var cartesian = grid3DModel.coordinateSystem;
    var viewGL = cartesian.viewGL;
    var ray = viewGL.castRay(e2.offsetX, e2.offsetY, new graphicGL$1.Ray());
    var nearestIntersectPoint;
    for (var i = 0; i < this._faces.length; i++) {
      var face = this._faces[i];
      if (face.rootNode.invisible) {
        continue;
      }
      if (face.plane.normal.dot(viewGL.camera.worldTransform.z) < 0) {
        face.plane.normal.negate();
      }
      var point = ray.intersectPlane(face.plane);
      if (!point) {
        continue;
      }
      var axis0 = cartesian.getAxis(face.faceInfo[0]);
      var axis1 = cartesian.getAxis(face.faceInfo[1]);
      var idx0 = dimIndicesMap[face.faceInfo[0]];
      var idx1 = dimIndicesMap[face.faceInfo[1]];
      if (axis0.contain(point.array[idx0]) && axis1.contain(point.array[idx1])) {
        nearestIntersectPoint = point;
      }
    }
    if (nearestIntersectPoint) {
      var data = cartesian.pointToData(nearestIntersectPoint.array, [], true);
      this._updateAxisPointer(data);
      this._doShowAxisPointer();
    } else {
      this._doHideAxisPointer();
    }
  },
  _onCameraChange: function(grid3DModel, api) {
    if (grid3DModel.get("show")) {
      this._updateFaceVisibility();
      this._updateAxisLinePosition();
    }
    var control = this._control;
    api.dispatchAction({
      type: "grid3DChangeCamera",
      alpha: control.getAlpha(),
      beta: control.getBeta(),
      distance: control.getDistance(),
      center: control.getCenter(),
      from: this.uid,
      grid3DId: grid3DModel.id
    });
  },
  _updateFaceVisibility: function() {
    var camera2 = this._control.getCamera();
    var viewSpacePos = new graphicGL$1.Vector3();
    camera2.update();
    for (var idx = 0; idx < this._faces.length / 2; idx++) {
      var depths = [];
      for (var k = 0; k < 2; k++) {
        var face = this._faces[idx * 2 + k];
        face.rootNode.getWorldPosition(viewSpacePos);
        viewSpacePos.transformMat4(camera2.viewMatrix);
        depths[k] = viewSpacePos.z;
      }
      var frontIndex = depths[0] > depths[1] ? 0 : 1;
      var frontFace = this._faces[idx * 2 + frontIndex];
      var backFace = this._faces[idx * 2 + 1 - frontIndex];
      frontFace.rootNode.invisible = true;
      backFace.rootNode.invisible = false;
    }
  },
  _updateAxisLinePosition: function() {
    var cartesian = this._model.coordinateSystem;
    var xAxis = cartesian.getAxis("x");
    var yAxis = cartesian.getAxis("y");
    var zAxis = cartesian.getAxis("z");
    var top = zAxis.getExtentMax();
    var bottom = zAxis.getExtentMin();
    var left = xAxis.getExtentMin();
    var right = xAxis.getExtentMax();
    var near = yAxis.getExtentMax();
    var far = yAxis.getExtentMin();
    var xAxisNode = this._axes[0].rootNode;
    var yAxisNode = this._axes[1].rootNode;
    var zAxisNode = this._axes[2].rootNode;
    var faces = this._faces;
    var xAxisZOffset = faces[4].rootNode.invisible ? far : near;
    var xAxisYOffset = faces[2].rootNode.invisible ? top : bottom;
    var yAxisXOffset = faces[0].rootNode.invisible ? left : right;
    var yAxisYOffset = faces[2].rootNode.invisible ? top : bottom;
    var zAxisXOffset = faces[0].rootNode.invisible ? right : left;
    var zAxisZOffset = faces[4].rootNode.invisible ? far : near;
    xAxisNode.rotation.identity();
    yAxisNode.rotation.identity();
    zAxisNode.rotation.identity();
    if (faces[4].rootNode.invisible) {
      this._axes[0].flipped = true;
      xAxisNode.rotation.rotateX(Math.PI);
    }
    if (faces[0].rootNode.invisible) {
      this._axes[1].flipped = true;
      yAxisNode.rotation.rotateZ(Math.PI);
    }
    if (faces[4].rootNode.invisible) {
      this._axes[2].flipped = true;
      zAxisNode.rotation.rotateY(Math.PI);
    }
    xAxisNode.position.set(0, xAxisYOffset, xAxisZOffset);
    yAxisNode.position.set(yAxisXOffset, yAxisYOffset, 0);
    zAxisNode.position.set(zAxisXOffset, 0, zAxisZOffset);
    xAxisNode.update();
    yAxisNode.update();
    zAxisNode.update();
    this._updateAxisLabelAlign();
  },
  _updateAxisLabelAlign: function() {
    var camera2 = this._control.getCamera();
    var coords = [new graphicGL$1.Vector4(), new graphicGL$1.Vector4()];
    var center2 = new graphicGL$1.Vector4();
    this.groupGL.getWorldPosition(center2);
    center2.w = 1;
    center2.transformMat4(camera2.viewMatrix).transformMat4(camera2.projectionMatrix);
    center2.x /= center2.w;
    center2.y /= center2.w;
    this._axes.forEach(function(axisInfo) {
      var lineCoords = axisInfo.axisLineCoords;
      axisInfo.labelsMesh.geometry;
      for (var i = 0; i < coords.length; i++) {
        coords[i].setArray(lineCoords[i]);
        coords[i].w = 1;
        coords[i].transformMat4(axisInfo.rootNode.worldTransform).transformMat4(camera2.viewMatrix).transformMat4(camera2.projectionMatrix);
        coords[i].x /= coords[i].w;
        coords[i].y /= coords[i].w;
      }
      var dx = coords[1].x - coords[0].x;
      var dy = coords[1].y - coords[0].y;
      var cx = (coords[1].x + coords[0].x) / 2;
      var cy = (coords[1].y + coords[0].y) / 2;
      var textAlign;
      var verticalAlign;
      if (Math.abs(dy / dx) < 0.5) {
        textAlign = "center";
        verticalAlign = cy > center2.y ? "bottom" : "top";
      } else {
        verticalAlign = "middle";
        textAlign = cx > center2.x ? "left" : "right";
      }
      axisInfo.setSpriteAlign(textAlign, verticalAlign, this._api);
    }, this);
  },
  _doShowAxisPointer: function() {
    if (!this._axisPointerLineMesh.invisible) {
      return;
    }
    this._axisPointerLineMesh.invisible = false;
    this._axisPointerLabelsMesh.invisible = false;
    this._api.getZr().refresh();
  },
  _doHideAxisPointer: function() {
    if (this._axisPointerLineMesh.invisible) {
      return;
    }
    this._axisPointerLineMesh.invisible = true;
    this._axisPointerLabelsMesh.invisible = true;
    this._api.getZr().refresh();
  },
  _updateAxisPointer: function(data) {
    var cartesian = this._model.coordinateSystem;
    var point = cartesian.dataToPoint(data);
    var axisPointerLineMesh = this._axisPointerLineMesh;
    var linesGeo = axisPointerLineMesh.geometry;
    var axisPointerParentModel = this._model.getModel("axisPointer");
    var dpr2 = this._api.getDevicePixelRatio();
    linesGeo.convertToDynamicArray(true);
    function ifShowAxisPointer(axis2) {
      return retrieve$1.firstNotNull(axis2.model.get("axisPointer.show"), axisPointerParentModel.get("show"));
    }
    function getAxisColorAndLineWidth(axis2) {
      var axisPointerModel = axis2.model.getModel("axisPointer", axisPointerParentModel);
      var lineStyleModel = axisPointerModel.getModel("lineStyle");
      var color = graphicGL$1.parseColor(lineStyleModel.get("color"));
      var lineWidth = firstNotNull(lineStyleModel.get("width"), 1);
      var opacity = firstNotNull(lineStyleModel.get("opacity"), 1);
      color[3] *= opacity;
      return {
        color,
        lineWidth
      };
    }
    for (var k = 0; k < this._faces.length; k++) {
      var face = this._faces[k];
      if (face.rootNode.invisible) {
        continue;
      }
      var faceInfo = face.faceInfo;
      var otherCoord = faceInfo[3] < 0 ? cartesian.getAxis(faceInfo[2]).getExtentMin() : cartesian.getAxis(faceInfo[2]).getExtentMax();
      var otherDimIdx = dimIndicesMap[faceInfo[2]];
      for (var i = 0; i < 2; i++) {
        var dim = faceInfo[i];
        var faceOtherDim = faceInfo[1 - i];
        var axis = cartesian.getAxis(dim);
        var faceOtherAxis = cartesian.getAxis(faceOtherDim);
        if (!ifShowAxisPointer(axis)) {
          continue;
        }
        var p02 = [0, 0, 0];
        var p12 = [0, 0, 0];
        var dimIdx = dimIndicesMap[dim];
        var faceOtherDimIdx = dimIndicesMap[faceOtherDim];
        p02[dimIdx] = p12[dimIdx] = point[dimIdx];
        p02[otherDimIdx] = p12[otherDimIdx] = otherCoord;
        p02[faceOtherDimIdx] = faceOtherAxis.getExtentMin();
        p12[faceOtherDimIdx] = faceOtherAxis.getExtentMax();
        var colorAndLineWidth = getAxisColorAndLineWidth(axis);
        linesGeo.addLine(p02, p12, colorAndLineWidth.color, colorAndLineWidth.lineWidth * dpr2);
      }
      if (ifShowAxisPointer(cartesian.getAxis(faceInfo[2]))) {
        var p02 = point.slice();
        var p12 = point.slice();
        p12[otherDimIdx] = otherCoord;
        var colorAndLineWidth = getAxisColorAndLineWidth(cartesian.getAxis(faceInfo[2]));
        linesGeo.addLine(p02, p12, colorAndLineWidth.color, colorAndLineWidth.lineWidth * dpr2);
      }
    }
    linesGeo.convertToTypedArray();
    this._updateAxisPointerLabelsMesh(data);
    this._api.getZr().refresh();
  },
  _updateAxisPointerLabelsMesh: function(data) {
    var grid3dModel = this._model;
    var axisPointerLabelsMesh = this._axisPointerLabelsMesh;
    var axisPointerLabelsSurface = this._axisPointerLabelsSurface;
    var cartesian = grid3dModel.coordinateSystem;
    var axisPointerParentModel = grid3dModel.getModel("axisPointer");
    axisPointerLabelsMesh.geometry.convertToDynamicArray(true);
    axisPointerLabelsSurface.clear();
    var otherDim2 = {
      x: "y",
      y: "x",
      z: "y"
    };
    this._axes.forEach(function(axisInfo, idx) {
      var axis = cartesian.getAxis(axisInfo.dim);
      var axisModel = axis.model;
      var axisPointerModel = axisModel.getModel("axisPointer", axisPointerParentModel);
      var labelModel = axisPointerModel.getModel("label");
      var lineColor = axisPointerModel.get("lineStyle.color");
      if (!labelModel.get("show") || !axisPointerModel.get("show")) {
        return;
      }
      var val = data[idx];
      var formatter = labelModel.get("formatter");
      var text = axis.scale.getLabel({
        value: val
      });
      if (formatter != null) {
        text = formatter(text, data);
      } else {
        if (axis.scale.type === "interval" || axis.scale.type === "log") {
          var precision = getPrecisionSafe(axis.scale.getTicks()[0]);
          text = val.toFixed(precision + 2);
        }
      }
      var labelColor = labelModel.get("color");
      var textEl = new ZRText$1({
        style: createTextStyle$1(labelModel, {
          text,
          fill: labelColor || lineColor,
          align: "left",
          verticalAlign: "top"
        })
      });
      var coords = axisPointerLabelsSurface.add(textEl);
      var rect = textEl.getBoundingRect();
      var dpr2 = this._api.getDevicePixelRatio();
      var pos = axisInfo.rootNode.position.toArray();
      var otherIdx = dimIndicesMap[otherDim2[axisInfo.dim]];
      pos[otherIdx] += (axisInfo.flipped ? -1 : 1) * labelModel.get("margin");
      pos[dimIndicesMap[axisInfo.dim]] = axis.dataToCoord(data[idx]);
      axisPointerLabelsMesh.geometry.addSprite(pos, [rect.width * dpr2, rect.height * dpr2], coords, axisInfo.textAlign, axisInfo.textVerticalAlign);
    }, this);
    axisPointerLabelsSurface.getZr().refreshImmediately();
    axisPointerLabelsMesh.material.set("uvScale", axisPointerLabelsSurface.getCoordsScale());
    axisPointerLabelsMesh.geometry.convertToTypedArray();
  },
  dispose: function() {
    this.groupGL.removeAll();
    this._control.dispose();
    this._axisLabelSurface.dispose();
    this._axisPointerLabelsSurface.dispose();
  }
});
function Cartesian3D(name) {
  Cartesian$1.call(this, name);
  this.type = "cartesian3D";
  this.dimensions = ["x", "y", "z"];
  this.size = [0, 0, 0];
}
Cartesian3D.prototype = {
  constructor: Cartesian3D,
  model: null,
  containPoint: function(point) {
    return this.getAxis("x").contain(point[0]) && this.getAxis("y").contain(point[2]) && this.getAxis("z").contain(point[1]);
  },
  containData: function(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]) && this.getAxis("z").containData(data[2]);
  },
  dataToPoint: function(data, out2, clamp2) {
    out2 = out2 || [];
    out2[0] = this.getAxis("x").dataToCoord(data[0], clamp2);
    out2[2] = this.getAxis("y").dataToCoord(data[1], clamp2);
    out2[1] = this.getAxis("z").dataToCoord(data[2], clamp2);
    return out2;
  },
  pointToData: function(point, out2, clamp2) {
    out2 = out2 || [];
    out2[0] = this.getAxis("x").coordToData(point[0], clamp2);
    out2[1] = this.getAxis("y").coordToData(point[2], clamp2);
    out2[2] = this.getAxis("z").coordToData(point[1], clamp2);
    return out2;
  }
};
inherits(Cartesian3D, Cartesian$1);
function Axis3D(dim, scale2, extent3) {
  Axis$1.call(this, dim, scale2, extent3);
}
Axis3D.prototype = {
  constructor: Axis3D,
  getExtentMin: function() {
    var extent3 = this._extent;
    return Math.min(extent3[0], extent3[1]);
  },
  getExtentMax: function() {
    var extent3 = this._extent;
    return Math.max(extent3[0], extent3[1]);
  },
  calculateCategoryInterval: function() {
    return Math.floor(this.scale.count() / 8);
  }
};
inherits(Axis3D, Axis$1);
var TexturePool = function() {
  this._pool = {};
  this._allocatedTextures = [];
};
TexturePool.prototype = {
  constructor: TexturePool,
  get: function(parameters) {
    var key = generateKey(parameters);
    if (!this._pool.hasOwnProperty(key)) {
      this._pool[key] = [];
    }
    var list = this._pool[key];
    if (!list.length) {
      var texture = new Texture2D$1(parameters);
      this._allocatedTextures.push(texture);
      return texture;
    }
    return list.pop();
  },
  put: function(texture) {
    var key = generateKey(texture);
    if (!this._pool.hasOwnProperty(key)) {
      this._pool[key] = [];
    }
    var list = this._pool[key];
    list.push(texture);
  },
  clear: function(renderer) {
    for (var i = 0; i < this._allocatedTextures.length; i++) {
      this._allocatedTextures[i].dispose(renderer);
    }
    this._pool = {};
    this._allocatedTextures = [];
  }
};
var defaultParams = {
  width: 512,
  height: 512,
  type: glenum.UNSIGNED_BYTE,
  format: glenum.RGBA,
  wrapS: glenum.CLAMP_TO_EDGE,
  wrapT: glenum.CLAMP_TO_EDGE,
  minFilter: glenum.LINEAR_MIPMAP_LINEAR,
  magFilter: glenum.LINEAR,
  useMipmap: true,
  anisotropic: 1,
  flipY: true,
  unpackAlignment: 4,
  premultiplyAlpha: false
};
var defaultParamPropList = Object.keys(defaultParams);
function generateKey(parameters) {
  util$1.defaultsWithPropList(parameters, defaultParams, defaultParamPropList);
  fallBack(parameters);
  var key = "";
  for (var i = 0; i < defaultParamPropList.length; i++) {
    var name = defaultParamPropList[i];
    var chunk = parameters[name].toString();
    key += chunk;
  }
  return key;
}
function fallBack(target) {
  var IPOT = isPowerOfTwo(target.width, target.height);
  if (target.format === glenum.DEPTH_COMPONENT) {
    target.useMipmap = false;
  }
  if (!IPOT || !target.useMipmap) {
    if (target.minFilter == glenum.NEAREST_MIPMAP_NEAREST || target.minFilter == glenum.NEAREST_MIPMAP_LINEAR) {
      target.minFilter = glenum.NEAREST;
    } else if (target.minFilter == glenum.LINEAR_MIPMAP_LINEAR || target.minFilter == glenum.LINEAR_MIPMAP_NEAREST) {
      target.minFilter = glenum.LINEAR;
    }
  }
  if (!IPOT) {
    target.wrapS = glenum.CLAMP_TO_EDGE;
    target.wrapT = glenum.CLAMP_TO_EDGE;
  }
}
function isPowerOfTwo(width, height) {
  return (width & width - 1) === 0 && (height & height - 1) === 0;
}
var TexturePool$1 = TexturePool;
var shadowmapEssl = "@export clay.sm.depth.vertex\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nattribute vec3 position : POSITION;\nattribute vec2 texcoord : TEXCOORD_0;\nuniform vec2 uvRepeat = vec2(1.0, 1.0);\nuniform vec2 uvOffset = vec2(0.0, 0.0);\n@import clay.chunk.skinning_header\n@import clay.chunk.instancing_header\nvarying vec4 v_ViewPosition;\nvarying vec2 v_Texcoord;\nvoid main(){\n vec4 P = vec4(position, 1.0);\n#ifdef SKINNING\n @import clay.chunk.skin_matrix\n P = skinMatrixWS * P;\n#endif\n#ifdef INSTANCING\n @import clay.chunk.instancing_matrix\n P = instanceMat * P;\n#endif\n v_ViewPosition = worldViewProjection * P;\n gl_Position = v_ViewPosition;\n v_Texcoord = texcoord * uvRepeat + uvOffset;\n}\n@end\n@export clay.sm.depth.fragment\nvarying vec4 v_ViewPosition;\nvarying vec2 v_Texcoord;\nuniform float bias : 0.001;\nuniform float slopeScale : 1.0;\nuniform sampler2D alphaMap;\nuniform float alphaCutoff: 0.0;\n@import clay.util.encode_float\nvoid main(){\n float depth = v_ViewPosition.z / v_ViewPosition.w;\n if (alphaCutoff > 0.0) {\n if (texture2D(alphaMap, v_Texcoord).a <= alphaCutoff) {\n discard;\n }\n }\n#ifdef USE_VSM\n depth = depth * 0.5 + 0.5;\n float moment1 = depth;\n float moment2 = depth * depth;\n #ifdef SUPPORT_STANDARD_DERIVATIVES\n float dx = dFdx(depth);\n float dy = dFdy(depth);\n moment2 += 0.25*(dx*dx+dy*dy);\n #endif\n gl_FragColor = vec4(moment1, moment2, 0.0, 1.0);\n#else\n #ifdef SUPPORT_STANDARD_DERIVATIVES\n float dx = dFdx(depth);\n float dy = dFdy(depth);\n depth += sqrt(dx*dx + dy*dy) * slopeScale + bias;\n #else\n depth += bias;\n #endif\n gl_FragColor = encodeFloat(depth * 0.5 + 0.5);\n#endif\n}\n@end\n@export clay.sm.debug_depth\nuniform sampler2D depthMap;\nvarying vec2 v_Texcoord;\n@import clay.util.decode_float\nvoid main() {\n vec4 tex = texture2D(depthMap, v_Texcoord);\n#ifdef USE_VSM\n gl_FragColor = vec4(tex.rgb, 1.0);\n#else\n float depth = decodeFloat(tex);\n gl_FragColor = vec4(depth, depth, depth, 1.0);\n#endif\n}\n@end\n@export clay.sm.distance.vertex\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 world : WORLD;\nattribute vec3 position : POSITION;\n@import clay.chunk.skinning_header\nvarying vec3 v_WorldPosition;\nvoid main (){\n vec4 P = vec4(position, 1.0);\n#ifdef SKINNING\n @import clay.chunk.skin_matrix\n P = skinMatrixWS * P;\n#endif\n#ifdef INSTANCING\n @import clay.chunk.instancing_matrix\n P = instanceMat * P;\n#endif\n gl_Position = worldViewProjection * P;\n v_WorldPosition = (world * P).xyz;\n}\n@end\n@export clay.sm.distance.fragment\nuniform vec3 lightPosition;\nuniform float range : 100;\nvarying vec3 v_WorldPosition;\n@import clay.util.encode_float\nvoid main(){\n float dist = distance(lightPosition, v_WorldPosition);\n#ifdef USE_VSM\n gl_FragColor = vec4(dist, dist * dist, 0.0, 0.0);\n#else\n dist = dist / range;\n gl_FragColor = encodeFloat(dist);\n#endif\n}\n@end\n@export clay.plugin.shadow_map_common\n@import clay.util.decode_float\nfloat tapShadowMap(sampler2D map, vec2 uv, float z){\n vec4 tex = texture2D(map, uv);\n return step(z, decodeFloat(tex) * 2.0 - 1.0);\n}\nfloat pcf(sampler2D map, vec2 uv, float z, float textureSize, vec2 scale) {\n float shadowContrib = tapShadowMap(map, uv, z);\n vec2 offset = vec2(1.0 / textureSize) * scale;\n#ifdef PCF_KERNEL_SIZE\n for (int _idx_ = 0; _idx_ < PCF_KERNEL_SIZE; _idx_++) {{\n shadowContrib += tapShadowMap(map, uv + offset * pcfKernel[_idx_], z);\n }}\n return shadowContrib / float(PCF_KERNEL_SIZE + 1);\n#else\n shadowContrib += tapShadowMap(map, uv+vec2(offset.x, 0.0), z);\n shadowContrib += tapShadowMap(map, uv+vec2(offset.x, offset.y), z);\n shadowContrib += tapShadowMap(map, uv+vec2(-offset.x, offset.y), z);\n shadowContrib += tapShadowMap(map, uv+vec2(0.0, offset.y), z);\n shadowContrib += tapShadowMap(map, uv+vec2(-offset.x, 0.0), z);\n shadowContrib += tapShadowMap(map, uv+vec2(-offset.x, -offset.y), z);\n shadowContrib += tapShadowMap(map, uv+vec2(offset.x, -offset.y), z);\n shadowContrib += tapShadowMap(map, uv+vec2(0.0, -offset.y), z);\n return shadowContrib / 9.0;\n#endif\n}\nfloat pcf(sampler2D map, vec2 uv, float z, float textureSize) {\n return pcf(map, uv, z, textureSize, vec2(1.0));\n}\nfloat chebyshevUpperBound(vec2 moments, float z){\n float p = 0.0;\n z = z * 0.5 + 0.5;\n if (z <= moments.x) {\n p = 1.0;\n }\n float variance = moments.y - moments.x * moments.x;\n variance = max(variance, 0.0000001);\n float mD = moments.x - z;\n float pMax = variance / (variance + mD * mD);\n pMax = clamp((pMax-0.4)/(1.0-0.4), 0.0, 1.0);\n return max(p, pMax);\n}\nfloat computeShadowContrib(\n sampler2D map, mat4 lightVPM, vec3 position, float textureSize, vec2 scale, vec2 offset\n) {\n vec4 posInLightSpace = lightVPM * vec4(position, 1.0);\n posInLightSpace.xyz /= posInLightSpace.w;\n float z = posInLightSpace.z;\n if(all(greaterThan(posInLightSpace.xyz, vec3(-0.99, -0.99, -1.0))) &&\n all(lessThan(posInLightSpace.xyz, vec3(0.99, 0.99, 1.0)))){\n vec2 uv = (posInLightSpace.xy+1.0) / 2.0;\n #ifdef USE_VSM\n vec2 moments = texture2D(map, uv * scale + offset).xy;\n return chebyshevUpperBound(moments, z);\n #else\n return pcf(map, uv * scale + offset, z, textureSize, scale);\n #endif\n }\n return 1.0;\n}\nfloat computeShadowContrib(sampler2D map, mat4 lightVPM, vec3 position, float textureSize) {\n return computeShadowContrib(map, lightVPM, position, textureSize, vec2(1.0), vec2(0.0));\n}\nfloat computeShadowContribOmni(samplerCube map, vec3 direction, float range)\n{\n float dist = length(direction);\n vec4 shadowTex = textureCube(map, direction);\n#ifdef USE_VSM\n vec2 moments = shadowTex.xy;\n float variance = moments.y - moments.x * moments.x;\n float mD = moments.x - dist;\n float p = variance / (variance + mD * mD);\n if(moments.x + 0.001 < dist){\n return clamp(p, 0.0, 1.0);\n }else{\n return 1.0;\n }\n#else\n return step(dist, (decodeFloat(shadowTex) + 0.0002) * range);\n#endif\n}\n@end\n@export clay.plugin.compute_shadow_map\n#if defined(SPOT_LIGHT_SHADOWMAP_COUNT) || defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT) || defined(POINT_LIGHT_SHADOWMAP_COUNT)\n#ifdef SPOT_LIGHT_SHADOWMAP_COUNT\nuniform sampler2D spotLightShadowMaps[SPOT_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\nuniform mat4 spotLightMatrices[SPOT_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\nuniform float spotLightShadowMapSizes[SPOT_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\n#endif\n#ifdef DIRECTIONAL_LIGHT_SHADOWMAP_COUNT\n#if defined(SHADOW_CASCADE)\nuniform sampler2D directionalLightShadowMaps[1]:unconfigurable;\nuniform mat4 directionalLightMatrices[SHADOW_CASCADE]:unconfigurable;\nuniform float directionalLightShadowMapSizes[1]:unconfigurable;\nuniform float shadowCascadeClipsNear[SHADOW_CASCADE]:unconfigurable;\nuniform float shadowCascadeClipsFar[SHADOW_CASCADE]:unconfigurable;\n#else\nuniform sampler2D directionalLightShadowMaps[DIRECTIONAL_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\nuniform mat4 directionalLightMatrices[DIRECTIONAL_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\nuniform float directionalLightShadowMapSizes[DIRECTIONAL_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\n#endif\n#endif\n#ifdef POINT_LIGHT_SHADOWMAP_COUNT\nuniform samplerCube pointLightShadowMaps[POINT_LIGHT_SHADOWMAP_COUNT]:unconfigurable;\n#endif\nuniform bool shadowEnabled : true;\n#ifdef PCF_KERNEL_SIZE\nuniform vec2 pcfKernel[PCF_KERNEL_SIZE];\n#endif\n@import clay.plugin.shadow_map_common\n#if defined(SPOT_LIGHT_SHADOWMAP_COUNT)\nvoid computeShadowOfSpotLights(vec3 position, inout float shadowContribs[SPOT_LIGHT_COUNT] ) {\n float shadowContrib;\n for(int _idx_ = 0; _idx_ < SPOT_LIGHT_SHADOWMAP_COUNT; _idx_++) {{\n shadowContrib = computeShadowContrib(\n spotLightShadowMaps[_idx_], spotLightMatrices[_idx_], position,\n spotLightShadowMapSizes[_idx_]\n );\n shadowContribs[_idx_] = shadowContrib;\n }}\n for(int _idx_ = SPOT_LIGHT_SHADOWMAP_COUNT; _idx_ < SPOT_LIGHT_COUNT; _idx_++){{\n shadowContribs[_idx_] = 1.0;\n }}\n}\n#endif\n#if defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n#ifdef SHADOW_CASCADE\nvoid computeShadowOfDirectionalLights(vec3 position, inout float shadowContribs[DIRECTIONAL_LIGHT_COUNT]){\n float depth = (2.0 * gl_FragCoord.z - gl_DepthRange.near - gl_DepthRange.far)\n / (gl_DepthRange.far - gl_DepthRange.near);\n float shadowContrib;\n shadowContribs[0] = 1.0;\n for (int _idx_ = 0; _idx_ < SHADOW_CASCADE; _idx_++) {{\n if (\n depth >= shadowCascadeClipsNear[_idx_] &&\n depth <= shadowCascadeClipsFar[_idx_]\n ) {\n shadowContrib = computeShadowContrib(\n directionalLightShadowMaps[0], directionalLightMatrices[_idx_], position,\n directionalLightShadowMapSizes[0],\n vec2(1.0 / float(SHADOW_CASCADE), 1.0),\n vec2(float(_idx_) / float(SHADOW_CASCADE), 0.0)\n );\n shadowContribs[0] = shadowContrib;\n }\n }}\n for(int _idx_ = DIRECTIONAL_LIGHT_SHADOWMAP_COUNT; _idx_ < DIRECTIONAL_LIGHT_COUNT; _idx_++) {{\n shadowContribs[_idx_] = 1.0;\n }}\n}\n#else\nvoid computeShadowOfDirectionalLights(vec3 position, inout float shadowContribs[DIRECTIONAL_LIGHT_COUNT]){\n float shadowContrib;\n for(int _idx_ = 0; _idx_ < DIRECTIONAL_LIGHT_SHADOWMAP_COUNT; _idx_++) {{\n shadowContrib = computeShadowContrib(\n directionalLightShadowMaps[_idx_], directionalLightMatrices[_idx_], position,\n directionalLightShadowMapSizes[_idx_]\n );\n shadowContribs[_idx_] = shadowContrib;\n }}\n for(int _idx_ = DIRECTIONAL_LIGHT_SHADOWMAP_COUNT; _idx_ < DIRECTIONAL_LIGHT_COUNT; _idx_++) {{\n shadowContribs[_idx_] = 1.0;\n }}\n}\n#endif\n#endif\n#if defined(POINT_LIGHT_SHADOWMAP_COUNT)\nvoid computeShadowOfPointLights(vec3 position, inout float shadowContribs[POINT_LIGHT_COUNT] ){\n vec3 lightPosition;\n vec3 direction;\n for(int _idx_ = 0; _idx_ < POINT_LIGHT_SHADOWMAP_COUNT; _idx_++) {{\n lightPosition = pointLightPosition[_idx_];\n direction = position - lightPosition;\n shadowContribs[_idx_] = computeShadowContribOmni(pointLightShadowMaps[_idx_], direction, pointLightRange[_idx_]);\n }}\n for(int _idx_ = POINT_LIGHT_SHADOWMAP_COUNT; _idx_ < POINT_LIGHT_COUNT; _idx_++) {{\n shadowContribs[_idx_] = 1.0;\n }}\n}\n#endif\n#endif\n@end";
var targets = ["px", "nx", "py", "ny", "pz", "nz"];
Shader["import"](shadowmapEssl);
function getDepthMaterialUniform(renderable, depthMaterial, symbol) {
  if (symbol === "alphaMap") {
    return renderable.material.get("diffuseMap");
  } else if (symbol === "alphaCutoff") {
    if (renderable.material.isDefined("fragment", "ALPHA_TEST") && renderable.material.get("diffuseMap")) {
      var alphaCutoff = renderable.material.get("alphaCutoff");
      return alphaCutoff || 0;
    }
    return 0;
  } else if (symbol === "uvRepeat") {
    return renderable.material.get("uvRepeat");
  } else if (symbol === "uvOffset") {
    return renderable.material.get("uvOffset");
  } else {
    return depthMaterial.get(symbol);
  }
}
function isDepthMaterialChanged(renderable, prevRenderable) {
  var matA = renderable.material;
  var matB = prevRenderable.material;
  return matA.get("diffuseMap") !== matB.get("diffuseMap") || (matA.get("alphaCutoff") || 0) !== (matB.get("alphaCutoff") || 0);
}
var ShadowMapPass = Base$1.extend(function() {
  return {
    softShadow: ShadowMapPass.PCF,
    shadowBlur: 1,
    lightFrustumBias: "auto",
    kernelPCF: new Float32Array([
      1,
      0,
      1,
      1,
      -1,
      1,
      0,
      1,
      -1,
      0,
      -1,
      -1,
      1,
      -1,
      0,
      -1
    ]),
    precision: "highp",
    _lastRenderNotCastShadow: false,
    _frameBuffer: new FrameBuffer$1(),
    _textures: {},
    _shadowMapNumber: {
      "POINT_LIGHT": 0,
      "DIRECTIONAL_LIGHT": 0,
      "SPOT_LIGHT": 0
    },
    _depthMaterials: {},
    _distanceMaterials: {},
    _receivers: [],
    _lightsCastShadow: [],
    _lightCameras: {},
    _lightMaterials: {},
    _texturePool: new TexturePool$1()
  };
}, function() {
  this._gaussianPassH = new Pass$1({
    fragment: Shader.source("clay.compositor.gaussian_blur")
  });
  this._gaussianPassV = new Pass$1({
    fragment: Shader.source("clay.compositor.gaussian_blur")
  });
  this._gaussianPassH.setUniform("blurSize", this.shadowBlur);
  this._gaussianPassH.setUniform("blurDir", 0);
  this._gaussianPassV.setUniform("blurSize", this.shadowBlur);
  this._gaussianPassV.setUniform("blurDir", 1);
  this._outputDepthPass = new Pass$1({
    fragment: Shader.source("clay.sm.debug_depth")
  });
}, {
  render: function(renderer, scene, sceneCamera, notUpdateScene) {
    if (!sceneCamera) {
      sceneCamera = scene.getMainCamera();
    }
    this.trigger("beforerender", this, renderer, scene, sceneCamera);
    this._renderShadowPass(renderer, scene, sceneCamera, notUpdateScene);
    this.trigger("afterrender", this, renderer, scene, sceneCamera);
  },
  renderDebug: function(renderer, size) {
    renderer.saveClear();
    var viewport = renderer.viewport;
    var x = 0, y = 0;
    var width = size || viewport.width / 4;
    var height = width;
    if (this.softShadow === ShadowMapPass.VSM) {
      this._outputDepthPass.material.define("fragment", "USE_VSM");
    } else {
      this._outputDepthPass.material.undefine("fragment", "USE_VSM");
    }
    for (var name in this._textures) {
      var texture = this._textures[name];
      renderer.setViewport(x, y, width * texture.width / texture.height, height);
      this._outputDepthPass.setUniform("depthMap", texture);
      this._outputDepthPass.render(renderer);
      x += width * texture.width / texture.height;
    }
    renderer.setViewport(viewport);
    renderer.restoreClear();
  },
  _updateReceivers: function(renderer, mesh2) {
    if (mesh2.receiveShadow) {
      this._receivers.push(mesh2);
      mesh2.material.set("shadowEnabled", 1);
      mesh2.material.set("pcfKernel", this.kernelPCF);
    } else {
      mesh2.material.set("shadowEnabled", 0);
    }
    if (this.softShadow === ShadowMapPass.VSM) {
      mesh2.material.define("fragment", "USE_VSM");
      mesh2.material.undefine("fragment", "PCF_KERNEL_SIZE");
    } else {
      mesh2.material.undefine("fragment", "USE_VSM");
      var kernelPCF = this.kernelPCF;
      if (kernelPCF && kernelPCF.length) {
        mesh2.material.define("fragment", "PCF_KERNEL_SIZE", kernelPCF.length / 2);
      } else {
        mesh2.material.undefine("fragment", "PCF_KERNEL_SIZE");
      }
    }
  },
  _update: function(renderer, scene) {
    var self2 = this;
    scene.traverse(function(renderable) {
      if (renderable.isRenderable()) {
        self2._updateReceivers(renderer, renderable);
      }
    });
    for (var i = 0; i < scene.lights.length; i++) {
      var light = scene.lights[i];
      if (light.castShadow && !light.invisible) {
        this._lightsCastShadow.push(light);
      }
    }
  },
  _renderShadowPass: function(renderer, scene, sceneCamera, notUpdateScene) {
    for (var name in this._shadowMapNumber) {
      this._shadowMapNumber[name] = 0;
    }
    this._lightsCastShadow.length = 0;
    this._receivers.length = 0;
    var _gl = renderer.gl;
    if (!notUpdateScene) {
      scene.update();
    }
    if (sceneCamera) {
      sceneCamera.update();
    }
    scene.updateLights();
    this._update(renderer, scene);
    if (!this._lightsCastShadow.length && this._lastRenderNotCastShadow) {
      return;
    }
    this._lastRenderNotCastShadow = this._lightsCastShadow === 0;
    _gl.enable(_gl.DEPTH_TEST);
    _gl.depthMask(true);
    _gl.disable(_gl.BLEND);
    _gl.clearColor(1, 1, 1, 1);
    var spotLightShadowMaps = [];
    var spotLightMatrices = [];
    var directionalLightShadowMaps = [];
    var directionalLightMatrices = [];
    var shadowCascadeClips = [];
    var pointLightShadowMaps = [];
    var dirLightHasCascade;
    for (var i = 0; i < this._lightsCastShadow.length; i++) {
      var light = this._lightsCastShadow[i];
      if (light.type === "DIRECTIONAL_LIGHT") {
        if (dirLightHasCascade) {
          console.warn("Only one direectional light supported with shadow cascade");
          continue;
        }
        if (light.shadowCascade > 4) {
          console.warn("Support at most 4 cascade");
          continue;
        }
        if (light.shadowCascade > 1) {
          dirLightHasCascade = light;
        }
        this.renderDirectionalLightShadow(renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps);
      } else if (light.type === "SPOT_LIGHT") {
        this.renderSpotLightShadow(renderer, scene, light, spotLightMatrices, spotLightShadowMaps);
      } else if (light.type === "POINT_LIGHT") {
        this.renderPointLightShadow(renderer, scene, light, pointLightShadowMaps);
      }
      this._shadowMapNumber[light.type]++;
    }
    for (var lightType in this._shadowMapNumber) {
      var number = this._shadowMapNumber[lightType];
      var key = lightType + "_SHADOWMAP_COUNT";
      for (var i = 0; i < this._receivers.length; i++) {
        var mesh2 = this._receivers[i];
        var material = mesh2.material;
        if (material.fragmentDefines[key] !== number) {
          if (number > 0) {
            material.define("fragment", key, number);
          } else if (material.isDefined("fragment", key)) {
            material.undefine("fragment", key);
          }
        }
      }
    }
    for (var i = 0; i < this._receivers.length; i++) {
      var mesh2 = this._receivers[i];
      var material = mesh2.material;
      if (dirLightHasCascade) {
        material.define("fragment", "SHADOW_CASCADE", dirLightHasCascade.shadowCascade);
      } else {
        material.undefine("fragment", "SHADOW_CASCADE");
      }
    }
    var shadowUniforms = scene.shadowUniforms;
    function getSize2(texture) {
      return texture.height;
    }
    if (directionalLightShadowMaps.length > 0) {
      var directionalLightShadowMapSizes = directionalLightShadowMaps.map(getSize2);
      shadowUniforms.directionalLightShadowMaps = { value: directionalLightShadowMaps, type: "tv" };
      shadowUniforms.directionalLightMatrices = { value: directionalLightMatrices, type: "m4v" };
      shadowUniforms.directionalLightShadowMapSizes = { value: directionalLightShadowMapSizes, type: "1fv" };
      if (dirLightHasCascade) {
        var shadowCascadeClipsNear = shadowCascadeClips.slice();
        var shadowCascadeClipsFar = shadowCascadeClips.slice();
        shadowCascadeClipsNear.pop();
        shadowCascadeClipsFar.shift();
        shadowCascadeClipsNear.reverse();
        shadowCascadeClipsFar.reverse();
        directionalLightMatrices.reverse();
        shadowUniforms.shadowCascadeClipsNear = { value: shadowCascadeClipsNear, type: "1fv" };
        shadowUniforms.shadowCascadeClipsFar = { value: shadowCascadeClipsFar, type: "1fv" };
      }
    }
    if (spotLightShadowMaps.length > 0) {
      var spotLightShadowMapSizes = spotLightShadowMaps.map(getSize2);
      var shadowUniforms = scene.shadowUniforms;
      shadowUniforms.spotLightShadowMaps = { value: spotLightShadowMaps, type: "tv" };
      shadowUniforms.spotLightMatrices = { value: spotLightMatrices, type: "m4v" };
      shadowUniforms.spotLightShadowMapSizes = { value: spotLightShadowMapSizes, type: "1fv" };
    }
    if (pointLightShadowMaps.length > 0) {
      shadowUniforms.pointLightShadowMaps = { value: pointLightShadowMaps, type: "tv" };
    }
  },
  renderDirectionalLightShadow: function() {
    var splitFrustum = new Frustum$1();
    var splitProjMatrix = new Matrix4$1();
    var cropBBox = new BoundingBox$1();
    var cropMatrix = new Matrix4$1();
    var lightViewMatrix = new Matrix4$1();
    var lightViewProjMatrix = new Matrix4$1();
    var lightProjMatrix = new Matrix4$1();
    return function(renderer, scene, sceneCamera, light, shadowCascadeClips, directionalLightMatrices, directionalLightShadowMaps) {
      var defaultShadowMaterial = this._getDepthMaterial(light);
      var passConfig = {
        getMaterial: function(renderable) {
          return renderable.shadowDepthMaterial || defaultShadowMaterial;
        },
        isMaterialChanged: isDepthMaterialChanged,
        getUniform: getDepthMaterialUniform,
        ifRender: function(renderable) {
          return renderable.castShadow;
        },
        sortCompare: Renderer$1.opaqueSortCompare
      };
      if (!scene.viewBoundingBoxLastFrame.isFinite()) {
        var boundingBox = scene.getBoundingBox();
        scene.viewBoundingBoxLastFrame.copy(boundingBox).applyTransform(sceneCamera.viewMatrix);
      }
      var clippedFar = Math.min(-scene.viewBoundingBoxLastFrame.min.z, sceneCamera.far);
      var clippedNear = Math.max(-scene.viewBoundingBoxLastFrame.max.z, sceneCamera.near);
      var lightCamera = this._getDirectionalLightCamera(light, scene, sceneCamera);
      var lvpMat4Arr = lightViewProjMatrix.array;
      lightProjMatrix.copy(lightCamera.projectionMatrix);
      mat4$3.invert(lightViewMatrix.array, lightCamera.worldTransform.array);
      mat4$3.multiply(lightViewMatrix.array, lightViewMatrix.array, sceneCamera.worldTransform.array);
      mat4$3.multiply(lvpMat4Arr, lightProjMatrix.array, lightViewMatrix.array);
      var clipPlanes = [];
      var isPerspective = sceneCamera instanceof PerspectiveCamera;
      var scaleZ = (sceneCamera.near + sceneCamera.far) / (sceneCamera.near - sceneCamera.far);
      var offsetZ = 2 * sceneCamera.near * sceneCamera.far / (sceneCamera.near - sceneCamera.far);
      for (var i = 0; i <= light.shadowCascade; i++) {
        var clog = clippedNear * Math.pow(clippedFar / clippedNear, i / light.shadowCascade);
        var cuni = clippedNear + (clippedFar - clippedNear) * i / light.shadowCascade;
        var c = clog * light.cascadeSplitLogFactor + cuni * (1 - light.cascadeSplitLogFactor);
        clipPlanes.push(c);
        shadowCascadeClips.push(-(-c * scaleZ + offsetZ) / -c);
      }
      var texture = this._getTexture(light, light.shadowCascade);
      directionalLightShadowMaps.push(texture);
      var viewport = renderer.viewport;
      var _gl = renderer.gl;
      this._frameBuffer.attach(texture);
      this._frameBuffer.bind(renderer);
      _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
      for (var i = 0; i < light.shadowCascade; i++) {
        var nearPlane = clipPlanes[i];
        var farPlane = clipPlanes[i + 1];
        if (isPerspective) {
          mat4$3.perspective(splitProjMatrix.array, sceneCamera.fov / 180 * Math.PI, sceneCamera.aspect, nearPlane, farPlane);
        } else {
          mat4$3.ortho(splitProjMatrix.array, sceneCamera.left, sceneCamera.right, sceneCamera.bottom, sceneCamera.top, nearPlane, farPlane);
        }
        splitFrustum.setFromProjection(splitProjMatrix);
        splitFrustum.getTransformedBoundingBox(cropBBox, lightViewMatrix);
        cropBBox.applyProjection(lightProjMatrix);
        var _min = cropBBox.min.array;
        var _max = cropBBox.max.array;
        _min[0] = Math.max(_min[0], -1);
        _min[1] = Math.max(_min[1], -1);
        _max[0] = Math.min(_max[0], 1);
        _max[1] = Math.min(_max[1], 1);
        cropMatrix.ortho(_min[0], _max[0], _min[1], _max[1], 1, -1);
        lightCamera.projectionMatrix.multiplyLeft(cropMatrix);
        var shadowSize = light.shadowResolution || 512;
        renderer.setViewport((light.shadowCascade - i - 1) * shadowSize, 0, shadowSize, shadowSize, 1);
        var renderList = scene.updateRenderList(lightCamera);
        renderer.renderPass(renderList.opaque, lightCamera, passConfig);
        if (this.softShadow === ShadowMapPass.VSM) {
          this._gaussianFilter(renderer, texture, texture.width);
        }
        var matrix = new Matrix4$1();
        matrix.copy(lightCamera.viewMatrix).multiplyLeft(lightCamera.projectionMatrix);
        directionalLightMatrices.push(matrix.array);
        lightCamera.projectionMatrix.copy(lightProjMatrix);
      }
      this._frameBuffer.unbind(renderer);
      renderer.setViewport(viewport);
    };
  }(),
  renderSpotLightShadow: function(renderer, scene, light, spotLightMatrices, spotLightShadowMaps) {
    var texture = this._getTexture(light);
    var lightCamera = this._getSpotLightCamera(light);
    var _gl = renderer.gl;
    this._frameBuffer.attach(texture);
    this._frameBuffer.bind(renderer);
    _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
    var defaultShadowMaterial = this._getDepthMaterial(light);
    var passConfig = {
      getMaterial: function(renderable) {
        return renderable.shadowDepthMaterial || defaultShadowMaterial;
      },
      isMaterialChanged: isDepthMaterialChanged,
      getUniform: getDepthMaterialUniform,
      ifRender: function(renderable) {
        return renderable.castShadow;
      },
      sortCompare: Renderer$1.opaqueSortCompare
    };
    var renderList = scene.updateRenderList(lightCamera);
    renderer.renderPass(renderList.opaque, lightCamera, passConfig);
    this._frameBuffer.unbind(renderer);
    if (this.softShadow === ShadowMapPass.VSM) {
      this._gaussianFilter(renderer, texture, texture.width);
    }
    var matrix = new Matrix4$1();
    matrix.copy(lightCamera.worldTransform).invert().multiplyLeft(lightCamera.projectionMatrix);
    spotLightShadowMaps.push(texture);
    spotLightMatrices.push(matrix.array);
  },
  renderPointLightShadow: function(renderer, scene, light, pointLightShadowMaps) {
    var texture = this._getTexture(light);
    var _gl = renderer.gl;
    pointLightShadowMaps.push(texture);
    var defaultShadowMaterial = this._getDepthMaterial(light);
    var passConfig = {
      getMaterial: function(renderable) {
        return renderable.shadowDepthMaterial || defaultShadowMaterial;
      },
      getUniform: getDepthMaterialUniform,
      sortCompare: Renderer$1.opaqueSortCompare
    };
    var renderListEachSide = {
      px: [],
      py: [],
      pz: [],
      nx: [],
      ny: [],
      nz: []
    };
    var bbox = new BoundingBox$1();
    var lightWorldPosition = light.getWorldPosition().array;
    var lightBBox = new BoundingBox$1();
    var range = light.range;
    lightBBox.min.setArray(lightWorldPosition);
    lightBBox.max.setArray(lightWorldPosition);
    var extent3 = new Vector3$1(range, range, range);
    lightBBox.max.add(extent3);
    lightBBox.min.sub(extent3);
    var targetsNeedRender = { px: false, py: false, pz: false, nx: false, ny: false, nz: false };
    scene.traverse(function(renderable) {
      if (renderable.isRenderable() && renderable.castShadow) {
        var geometry = renderable.geometry;
        if (!geometry.boundingBox) {
          for (var i2 = 0; i2 < targets.length; i2++) {
            renderListEachSide[targets[i2]].push(renderable);
          }
          return;
        }
        bbox.transformFrom(geometry.boundingBox, renderable.worldTransform);
        if (!bbox.intersectBoundingBox(lightBBox)) {
          return;
        }
        bbox.updateVertices();
        for (var i2 = 0; i2 < targets.length; i2++) {
          targetsNeedRender[targets[i2]] = false;
        }
        for (var i2 = 0; i2 < 8; i2++) {
          var vtx = bbox.vertices[i2];
          var x = vtx[0] - lightWorldPosition[0];
          var y = vtx[1] - lightWorldPosition[1];
          var z = vtx[2] - lightWorldPosition[2];
          var absx = Math.abs(x);
          var absy = Math.abs(y);
          var absz = Math.abs(z);
          if (absx > absy) {
            if (absx > absz) {
              targetsNeedRender[x > 0 ? "px" : "nx"] = true;
            } else {
              targetsNeedRender[z > 0 ? "pz" : "nz"] = true;
            }
          } else {
            if (absy > absz) {
              targetsNeedRender[y > 0 ? "py" : "ny"] = true;
            } else {
              targetsNeedRender[z > 0 ? "pz" : "nz"] = true;
            }
          }
        }
        for (var i2 = 0; i2 < targets.length; i2++) {
          if (targetsNeedRender[targets[i2]]) {
            renderListEachSide[targets[i2]].push(renderable);
          }
        }
      }
    });
    for (var i = 0; i < 6; i++) {
      var target = targets[i];
      var camera2 = this._getPointLightCamera(light, target);
      this._frameBuffer.attach(texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
      this._frameBuffer.bind(renderer);
      _gl.clear(_gl.COLOR_BUFFER_BIT | _gl.DEPTH_BUFFER_BIT);
      renderer.renderPass(renderListEachSide[target], camera2, passConfig);
    }
    this._frameBuffer.unbind(renderer);
  },
  _getDepthMaterial: function(light) {
    var shadowMaterial = this._lightMaterials[light.__uid__];
    var isPointLight = light.type === "POINT_LIGHT";
    if (!shadowMaterial) {
      var shaderPrefix = isPointLight ? "clay.sm.distance." : "clay.sm.depth.";
      shadowMaterial = new Material$1({
        precision: this.precision,
        shader: new Shader(Shader.source(shaderPrefix + "vertex"), Shader.source(shaderPrefix + "fragment"))
      });
      this._lightMaterials[light.__uid__] = shadowMaterial;
    }
    if (light.shadowSlopeScale != null) {
      shadowMaterial.setUniform("slopeScale", light.shadowSlopeScale);
    }
    if (light.shadowBias != null) {
      shadowMaterial.setUniform("bias", light.shadowBias);
    }
    if (this.softShadow === ShadowMapPass.VSM) {
      shadowMaterial.define("fragment", "USE_VSM");
    } else {
      shadowMaterial.undefine("fragment", "USE_VSM");
    }
    if (isPointLight) {
      shadowMaterial.set("lightPosition", light.getWorldPosition().array);
      shadowMaterial.set("range", light.range);
    }
    return shadowMaterial;
  },
  _gaussianFilter: function(renderer, texture, size) {
    var parameter = {
      width: size,
      height: size,
      type: Texture$1.FLOAT
    };
    var tmpTexture = this._texturePool.get(parameter);
    this._frameBuffer.attach(tmpTexture);
    this._frameBuffer.bind(renderer);
    this._gaussianPassH.setUniform("texture", texture);
    this._gaussianPassH.setUniform("textureWidth", size);
    this._gaussianPassH.render(renderer);
    this._frameBuffer.attach(texture);
    this._gaussianPassV.setUniform("texture", tmpTexture);
    this._gaussianPassV.setUniform("textureHeight", size);
    this._gaussianPassV.render(renderer);
    this._frameBuffer.unbind(renderer);
    this._texturePool.put(tmpTexture);
  },
  _getTexture: function(light, cascade) {
    var key = light.__uid__;
    var texture = this._textures[key];
    var resolution = light.shadowResolution || 512;
    cascade = cascade || 1;
    if (!texture) {
      if (light.type === "POINT_LIGHT") {
        texture = new TextureCube$1();
      } else {
        texture = new Texture2D$1();
      }
      texture.width = resolution * cascade;
      texture.height = resolution;
      if (this.softShadow === ShadowMapPass.VSM) {
        texture.type = Texture$1.FLOAT;
        texture.anisotropic = 4;
      } else {
        texture.minFilter = glenum.NEAREST;
        texture.magFilter = glenum.NEAREST;
        texture.useMipmap = false;
      }
      this._textures[key] = texture;
    }
    return texture;
  },
  _getPointLightCamera: function(light, target) {
    if (!this._lightCameras.point) {
      this._lightCameras.point = {
        px: new PerspectiveCamera(),
        nx: new PerspectiveCamera(),
        py: new PerspectiveCamera(),
        ny: new PerspectiveCamera(),
        pz: new PerspectiveCamera(),
        nz: new PerspectiveCamera()
      };
    }
    var camera2 = this._lightCameras.point[target];
    camera2.far = light.range;
    camera2.fov = 90;
    camera2.position.set(0, 0, 0);
    switch (target) {
      case "px":
        camera2.lookAt(Vector3$1.POSITIVE_X, Vector3$1.NEGATIVE_Y);
        break;
      case "nx":
        camera2.lookAt(Vector3$1.NEGATIVE_X, Vector3$1.NEGATIVE_Y);
        break;
      case "py":
        camera2.lookAt(Vector3$1.POSITIVE_Y, Vector3$1.POSITIVE_Z);
        break;
      case "ny":
        camera2.lookAt(Vector3$1.NEGATIVE_Y, Vector3$1.NEGATIVE_Z);
        break;
      case "pz":
        camera2.lookAt(Vector3$1.POSITIVE_Z, Vector3$1.NEGATIVE_Y);
        break;
      case "nz":
        camera2.lookAt(Vector3$1.NEGATIVE_Z, Vector3$1.NEGATIVE_Y);
        break;
    }
    light.getWorldPosition(camera2.position);
    camera2.update();
    return camera2;
  },
  _getDirectionalLightCamera: function() {
    var lightViewMatrix = new Matrix4$1();
    var sceneViewBoundingBox = new BoundingBox$1();
    var lightViewBBox = new BoundingBox$1();
    return function(light, scene, sceneCamera) {
      if (!this._lightCameras.directional) {
        this._lightCameras.directional = new OrthoCamera();
      }
      var camera2 = this._lightCameras.directional;
      sceneViewBoundingBox.copy(scene.viewBoundingBoxLastFrame);
      sceneViewBoundingBox.intersection(sceneCamera.frustum.boundingBox);
      camera2.position.copy(sceneViewBoundingBox.min).add(sceneViewBoundingBox.max).scale(0.5).transformMat4(sceneCamera.worldTransform);
      camera2.rotation.copy(light.rotation);
      camera2.scale.copy(light.scale);
      camera2.updateWorldTransform();
      Matrix4$1.invert(lightViewMatrix, camera2.worldTransform);
      Matrix4$1.multiply(lightViewMatrix, lightViewMatrix, sceneCamera.worldTransform);
      lightViewBBox.copy(sceneViewBoundingBox).applyTransform(lightViewMatrix);
      var min3 = lightViewBBox.min.array;
      var max3 = lightViewBBox.max.array;
      camera2.position.set((min3[0] + max3[0]) / 2, (min3[1] + max3[1]) / 2, max3[2]).transformMat4(camera2.worldTransform);
      camera2.near = 0;
      camera2.far = -min3[2] + max3[2];
      if (isNaN(this.lightFrustumBias)) {
        camera2.far *= 4;
      } else {
        camera2.far += this.lightFrustumBias;
      }
      camera2.left = min3[0];
      camera2.right = max3[0];
      camera2.top = max3[1];
      camera2.bottom = min3[1];
      camera2.update(true);
      return camera2;
    };
  }(),
  _getSpotLightCamera: function(light) {
    if (!this._lightCameras.spot) {
      this._lightCameras.spot = new PerspectiveCamera();
    }
    var camera2 = this._lightCameras.spot;
    camera2.fov = light.penumbraAngle * 2;
    camera2.far = light.range;
    camera2.worldTransform.copy(light.worldTransform);
    camera2.updateProjectionMatrix();
    mat4$3.invert(camera2.viewMatrix.array, camera2.worldTransform.array);
    return camera2;
  },
  dispose: function(renderer) {
    var _gl = renderer.gl || renderer;
    if (this._frameBuffer) {
      this._frameBuffer.dispose(_gl);
    }
    for (var name in this._textures) {
      this._textures[name].dispose(_gl);
    }
    this._texturePool.clear(renderer.gl);
    this._depthMaterials = {};
    this._distanceMaterials = {};
    this._textures = {};
    this._lightCameras = {};
    this._shadowMapNumber = {
      "POINT_LIGHT": 0,
      "DIRECTIONAL_LIGHT": 0,
      "SPOT_LIGHT": 0
    };
    this._meshMaterials = {};
    for (var i = 0; i < this._receivers.length; i++) {
      var mesh2 = this._receivers[i];
      if (mesh2.material) {
        var material = mesh2.material;
        material.undefine("fragment", "POINT_LIGHT_SHADOW_COUNT");
        material.undefine("fragment", "DIRECTIONAL_LIGHT_SHADOW_COUNT");
        material.undefine("fragment", "AMBIENT_LIGHT_SHADOW_COUNT");
        material.set("shadowEnabled", 0);
      }
    }
    this._receivers = [];
    this._lightsCastShadow = [];
  }
});
ShadowMapPass.VSM = 1;
ShadowMapPass.PCF = 2;
var ShadowMapPass$1 = ShadowMapPass;
var CompositorNode = Base$1.extend(function() {
  return {
    name: "",
    inputLinks: {},
    outputLinks: {},
    _prevOutputTextures: {},
    _outputTextures: {},
    _outputReferences: {},
    _rendering: false,
    _rendered: false,
    _compositor: null
  };
}, {
  updateParameter: function(outputName, renderer) {
    var outputInfo = this.outputs[outputName];
    var parameters = outputInfo.parameters;
    var parametersCopy = outputInfo._parametersCopy;
    if (!parametersCopy) {
      parametersCopy = outputInfo._parametersCopy = {};
    }
    if (parameters) {
      for (var key in parameters) {
        if (key !== "width" && key !== "height") {
          parametersCopy[key] = parameters[key];
        }
      }
    }
    var width, height;
    if (parameters.width instanceof Function) {
      width = parameters.width.call(this, renderer);
    } else {
      width = parameters.width;
    }
    if (parameters.height instanceof Function) {
      height = parameters.height.call(this, renderer);
    } else {
      height = parameters.height;
    }
    if (parametersCopy.width !== width || parametersCopy.height !== height) {
      if (this._outputTextures[outputName]) {
        this._outputTextures[outputName].dispose(renderer.gl);
      }
    }
    parametersCopy.width = width;
    parametersCopy.height = height;
    return parametersCopy;
  },
  setParameter: function(name, value) {
  },
  getParameter: function(name) {
  },
  setParameters: function(obj) {
    for (var name in obj) {
      this.setParameter(name, obj[name]);
    }
  },
  render: function() {
  },
  getOutput: function(renderer, name) {
    if (name == null) {
      name = renderer;
      return this._outputTextures[name];
    }
    var outputInfo = this.outputs[name];
    if (!outputInfo) {
      return;
    }
    if (this._rendered) {
      if (outputInfo.outputLastFrame) {
        return this._prevOutputTextures[name];
      } else {
        return this._outputTextures[name];
      }
    } else if (this._rendering) {
      if (!this._prevOutputTextures[name]) {
        this._prevOutputTextures[name] = this._compositor.allocateTexture(outputInfo.parameters || {});
      }
      return this._prevOutputTextures[name];
    }
    this.render(renderer);
    return this._outputTextures[name];
  },
  removeReference: function(outputName) {
    this._outputReferences[outputName]--;
    if (this._outputReferences[outputName] === 0) {
      var outputInfo = this.outputs[outputName];
      if (outputInfo.keepLastFrame) {
        if (this._prevOutputTextures[outputName]) {
          this._compositor.releaseTexture(this._prevOutputTextures[outputName]);
        }
        this._prevOutputTextures[outputName] = this._outputTextures[outputName];
      } else {
        this._compositor.releaseTexture(this._outputTextures[outputName]);
      }
    }
  },
  link: function(inputPinName, fromNode, fromPinName) {
    this.inputLinks[inputPinName] = {
      node: fromNode,
      pin: fromPinName
    };
    if (!fromNode.outputLinks[fromPinName]) {
      fromNode.outputLinks[fromPinName] = [];
    }
    fromNode.outputLinks[fromPinName].push({
      node: this,
      pin: inputPinName
    });
    this.pass.material.enableTexture(inputPinName);
  },
  clear: function() {
    this.inputLinks = {};
    this.outputLinks = {};
  },
  updateReference: function(outputName) {
    if (!this._rendering) {
      this._rendering = true;
      for (var inputName in this.inputLinks) {
        var link = this.inputLinks[inputName];
        link.node.updateReference(link.pin);
      }
      this._rendering = false;
    }
    if (outputName) {
      this._outputReferences[outputName]++;
    }
  },
  beforeFrame: function() {
    this._rendered = false;
    for (var name in this.outputLinks) {
      this._outputReferences[name] = 0;
    }
  },
  afterFrame: function() {
    for (var name in this.outputLinks) {
      if (this._outputReferences[name] > 0) {
        var outputInfo = this.outputs[name];
        if (outputInfo.keepLastFrame) {
          if (this._prevOutputTextures[name]) {
            this._compositor.releaseTexture(this._prevOutputTextures[name]);
          }
          this._prevOutputTextures[name] = this._outputTextures[name];
        } else {
          this._compositor.releaseTexture(this._outputTextures[name]);
        }
      }
    }
  }
});
var CompositorNode$1 = CompositorNode;
var Graph = Base$1.extend(function() {
  return {
    nodes: []
  };
}, {
  dirty: function() {
    this._dirty = true;
  },
  addNode: function(node) {
    if (this.nodes.indexOf(node) >= 0) {
      return;
    }
    this.nodes.push(node);
    this._dirty = true;
  },
  removeNode: function(node) {
    if (typeof node === "string") {
      node = this.getNodeByName(node);
    }
    var idx = this.nodes.indexOf(node);
    if (idx >= 0) {
      this.nodes.splice(idx, 1);
      this._dirty = true;
    }
  },
  getNodeByName: function(name) {
    for (var i = 0; i < this.nodes.length; i++) {
      if (this.nodes[i].name === name) {
        return this.nodes[i];
      }
    }
  },
  update: function() {
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].clear();
    }
    for (var i = 0; i < this.nodes.length; i++) {
      var node = this.nodes[i];
      if (!node.inputs) {
        continue;
      }
      for (var inputName in node.inputs) {
        if (!node.inputs[inputName]) {
          continue;
        }
        if (node.pass && !node.pass.material.isUniformEnabled(inputName)) {
          console.warn("Pin " + node.name + "." + inputName + " not used.");
          continue;
        }
        var fromPinInfo = node.inputs[inputName];
        var fromPin = this.findPin(fromPinInfo);
        if (fromPin) {
          node.link(inputName, fromPin.node, fromPin.pin);
        } else {
          if (typeof fromPinInfo === "string") {
            console.warn("Node " + fromPinInfo + " not exist");
          } else {
            console.warn("Pin of " + fromPinInfo.node + "." + fromPinInfo.pin + " not exist");
          }
        }
      }
    }
  },
  findPin: function(input) {
    var node;
    if (typeof input === "string" || input instanceof CompositorNode$1) {
      input = {
        node: input
      };
    }
    if (typeof input.node === "string") {
      for (var i = 0; i < this.nodes.length; i++) {
        var tmp = this.nodes[i];
        if (tmp.name === input.node) {
          node = tmp;
        }
      }
    } else {
      node = input.node;
    }
    if (node) {
      var inputPin = input.pin;
      if (!inputPin) {
        if (node.outputs) {
          inputPin = Object.keys(node.outputs)[0];
        }
      }
      if (node.outputs[inputPin]) {
        return {
          node,
          pin: inputPin
        };
      }
    }
  }
});
var Graph$1 = Graph;
var Compositor = Graph$1.extend(function() {
  return {
    _outputs: [],
    _texturePool: new TexturePool$1(),
    _frameBuffer: new FrameBuffer$1({
      depthBuffer: false
    })
  };
}, {
  addNode: function(node) {
    Graph$1.prototype.addNode.call(this, node);
    node._compositor = this;
  },
  render: function(renderer, frameBuffer) {
    if (this._dirty) {
      this.update();
      this._dirty = false;
      this._outputs.length = 0;
      for (var i = 0; i < this.nodes.length; i++) {
        if (!this.nodes[i].outputs) {
          this._outputs.push(this.nodes[i]);
        }
      }
    }
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].beforeFrame();
    }
    for (var i = 0; i < this._outputs.length; i++) {
      this._outputs[i].updateReference();
    }
    for (var i = 0; i < this._outputs.length; i++) {
      this._outputs[i].render(renderer, frameBuffer);
    }
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].afterFrame();
    }
  },
  allocateTexture: function(parameters) {
    return this._texturePool.get(parameters);
  },
  releaseTexture: function(parameters) {
    this._texturePool.put(parameters);
  },
  getFrameBuffer: function() {
    return this._frameBuffer;
  },
  dispose: function(renderer) {
    this._texturePool.clear(renderer);
  }
});
var Compositor$1 = Compositor;
var SceneNode = CompositorNode$1.extend({
  name: "scene",
  scene: null,
  camera: null,
  autoUpdateScene: true,
  preZ: false
}, function() {
  this.frameBuffer = new FrameBuffer$1();
}, {
  render: function(renderer) {
    this._rendering = true;
    var _gl = renderer.gl;
    this.trigger("beforerender");
    var renderInfo;
    if (!this.outputs) {
      renderInfo = renderer.render(this.scene, this.camera, !this.autoUpdateScene, this.preZ);
    } else {
      var frameBuffer = this.frameBuffer;
      for (var name in this.outputs) {
        var parameters = this.updateParameter(name, renderer);
        var outputInfo = this.outputs[name];
        var texture = this._compositor.allocateTexture(parameters);
        this._outputTextures[name] = texture;
        var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;
        if (typeof attachment == "string") {
          attachment = _gl[attachment];
        }
        frameBuffer.attach(texture, attachment);
      }
      frameBuffer.bind(renderer);
      var ext = renderer.getGLExtension("EXT_draw_buffers");
      if (ext) {
        var bufs = [];
        for (var attachment in this.outputs) {
          attachment = parseInt(attachment);
          if (attachment >= _gl.COLOR_ATTACHMENT0 && attachment <= _gl.COLOR_ATTACHMENT0 + 8) {
            bufs.push(attachment);
          }
        }
        ext.drawBuffersEXT(bufs);
      }
      renderer.saveClear();
      renderer.clearBit = glenum.DEPTH_BUFFER_BIT | glenum.COLOR_BUFFER_BIT;
      renderInfo = renderer.render(this.scene, this.camera, !this.autoUpdateScene, this.preZ);
      renderer.restoreClear();
      frameBuffer.unbind(renderer);
    }
    this.trigger("afterrender", renderInfo);
    this._rendering = false;
    this._rendered = true;
  }
});
var CompoSceneNode = SceneNode;
var TextureNode = CompositorNode$1.extend(function() {
  return {
    texture: null,
    outputs: {
      color: {}
    }
  };
}, function() {
}, {
  getOutput: function(renderer, name) {
    return this.texture;
  },
  beforeFrame: function() {
  },
  afterFrame: function() {
  }
});
var CompoTextureNode = TextureNode;
var FilterNode = CompositorNode$1.extend(function() {
  return {
    name: "",
    inputs: {},
    outputs: null,
    shader: "",
    inputLinks: {},
    outputLinks: {},
    pass: null,
    _prevOutputTextures: {},
    _outputTextures: {},
    _outputReferences: {},
    _rendering: false,
    _rendered: false,
    _compositor: null
  };
}, function() {
  var pass = new Pass$1({
    fragment: this.shader
  });
  this.pass = pass;
}, {
  render: function(renderer, frameBuffer) {
    this.trigger("beforerender", renderer);
    this._rendering = true;
    var _gl = renderer.gl;
    for (var inputName in this.inputLinks) {
      var link = this.inputLinks[inputName];
      var inputTexture = link.node.getOutput(renderer, link.pin);
      this.pass.setUniform(inputName, inputTexture);
    }
    if (!this.outputs) {
      this.pass.outputs = null;
      this._compositor.getFrameBuffer().unbind(renderer);
      this.pass.render(renderer, frameBuffer);
    } else {
      this.pass.outputs = {};
      var attachedTextures = {};
      for (var name in this.outputs) {
        var parameters = this.updateParameter(name, renderer);
        if (isNaN(parameters.width)) {
          this.updateParameter(name, renderer);
        }
        var outputInfo = this.outputs[name];
        var texture = this._compositor.allocateTexture(parameters);
        this._outputTextures[name] = texture;
        var attachment = outputInfo.attachment || _gl.COLOR_ATTACHMENT0;
        if (typeof attachment === "string") {
          attachment = _gl[attachment];
        }
        attachedTextures[attachment] = texture;
      }
      this._compositor.getFrameBuffer().bind(renderer);
      for (var attachment in attachedTextures) {
        this._compositor.getFrameBuffer().attach(attachedTextures[attachment], attachment);
      }
      this.pass.render(renderer);
      this._compositor.getFrameBuffer().updateMipmap(renderer);
    }
    for (var inputName in this.inputLinks) {
      var link = this.inputLinks[inputName];
      link.node.removeReference(link.pin);
    }
    this._rendering = false;
    this._rendered = true;
    this.trigger("afterrender", renderer);
  },
  updateParameter: function(outputName, renderer) {
    var outputInfo = this.outputs[outputName];
    var parameters = outputInfo.parameters;
    var parametersCopy = outputInfo._parametersCopy;
    if (!parametersCopy) {
      parametersCopy = outputInfo._parametersCopy = {};
    }
    if (parameters) {
      for (var key in parameters) {
        if (key !== "width" && key !== "height") {
          parametersCopy[key] = parameters[key];
        }
      }
    }
    var width, height;
    if (typeof parameters.width === "function") {
      width = parameters.width.call(this, renderer);
    } else {
      width = parameters.width;
    }
    if (typeof parameters.height === "function") {
      height = parameters.height.call(this, renderer);
    } else {
      height = parameters.height;
    }
    width = Math.ceil(width);
    height = Math.ceil(height);
    if (parametersCopy.width !== width || parametersCopy.height !== height) {
      if (this._outputTextures[outputName]) {
        this._outputTextures[outputName].dispose(renderer);
      }
    }
    parametersCopy.width = width;
    parametersCopy.height = height;
    return parametersCopy;
  },
  setParameter: function(name, value) {
    this.pass.setUniform(name, value);
  },
  getParameter: function(name) {
    return this.pass.getUniform(name);
  },
  setParameters: function(obj) {
    for (var name in obj) {
      this.setParameter(name, obj[name]);
    }
  },
  define: function(symbol, val) {
    this.pass.material.define("fragment", symbol, val);
  },
  undefine: function(symbol) {
    this.pass.material.undefine("fragment", symbol);
  },
  removeReference: function(outputName) {
    this._outputReferences[outputName]--;
    if (this._outputReferences[outputName] === 0) {
      var outputInfo = this.outputs[outputName];
      if (outputInfo.keepLastFrame) {
        if (this._prevOutputTextures[outputName]) {
          this._compositor.releaseTexture(this._prevOutputTextures[outputName]);
        }
        this._prevOutputTextures[outputName] = this._outputTextures[outputName];
      } else {
        this._compositor.releaseTexture(this._outputTextures[outputName]);
      }
    }
  },
  clear: function() {
    CompositorNode$1.prototype.clear.call(this);
    this.pass.material.disableTexturesAll();
  }
});
var CompoFilterNode = FilterNode;
var coloradjustEssl = "@export clay.compositor.coloradjust\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nuniform float brightness : 0.0;\nuniform float contrast : 1.0;\nuniform float exposure : 0.0;\nuniform float gamma : 1.0;\nuniform float saturation : 1.0;\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\nvoid main()\n{\n vec4 tex = texture2D( texture, v_Texcoord);\n vec3 color = clamp(tex.rgb + vec3(brightness), 0.0, 1.0);\n color = clamp( (color-vec3(0.5))*contrast+vec3(0.5), 0.0, 1.0);\n color = clamp( color * pow(2.0, exposure), 0.0, 1.0);\n color = clamp( pow(color, vec3(gamma)), 0.0, 1.0);\n float luminance = dot( color, w );\n color = mix(vec3(luminance), color, saturation);\n gl_FragColor = vec4(color, tex.a);\n}\n@end\n@export clay.compositor.brightness\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nuniform float brightness : 0.0;\nvoid main()\n{\n vec4 tex = texture2D( texture, v_Texcoord);\n vec3 color = tex.rgb + vec3(brightness);\n gl_FragColor = vec4(color, tex.a);\n}\n@end\n@export clay.compositor.contrast\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nuniform float contrast : 1.0;\nvoid main()\n{\n vec4 tex = texture2D( texture, v_Texcoord);\n vec3 color = (tex.rgb-vec3(0.5))*contrast+vec3(0.5);\n gl_FragColor = vec4(color, tex.a);\n}\n@end\n@export clay.compositor.exposure\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nuniform float exposure : 0.0;\nvoid main()\n{\n vec4 tex = texture2D(texture, v_Texcoord);\n vec3 color = tex.rgb * pow(2.0, exposure);\n gl_FragColor = vec4(color, tex.a);\n}\n@end\n@export clay.compositor.gamma\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nuniform float gamma : 1.0;\nvoid main()\n{\n vec4 tex = texture2D(texture, v_Texcoord);\n vec3 color = pow(tex.rgb, vec3(gamma));\n gl_FragColor = vec4(color, tex.a);\n}\n@end\n@export clay.compositor.saturation\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nuniform float saturation : 1.0;\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\nvoid main()\n{\n vec4 tex = texture2D(texture, v_Texcoord);\n vec3 color = tex.rgb;\n float luminance = dot(color, w);\n color = mix(vec3(luminance), color, saturation);\n gl_FragColor = vec4(color, tex.a);\n}\n@end";
var blurCode = "@export clay.compositor.kernel.gaussian_9\nfloat gaussianKernel[9];\ngaussianKernel[0] = 0.07;\ngaussianKernel[1] = 0.09;\ngaussianKernel[2] = 0.12;\ngaussianKernel[3] = 0.14;\ngaussianKernel[4] = 0.16;\ngaussianKernel[5] = 0.14;\ngaussianKernel[6] = 0.12;\ngaussianKernel[7] = 0.09;\ngaussianKernel[8] = 0.07;\n@end\n@export clay.compositor.kernel.gaussian_13\nfloat gaussianKernel[13];\ngaussianKernel[0] = 0.02;\ngaussianKernel[1] = 0.03;\ngaussianKernel[2] = 0.06;\ngaussianKernel[3] = 0.08;\ngaussianKernel[4] = 0.11;\ngaussianKernel[5] = 0.13;\ngaussianKernel[6] = 0.14;\ngaussianKernel[7] = 0.13;\ngaussianKernel[8] = 0.11;\ngaussianKernel[9] = 0.08;\ngaussianKernel[10] = 0.06;\ngaussianKernel[11] = 0.03;\ngaussianKernel[12] = 0.02;\n@end\n@export clay.compositor.gaussian_blur\n#define SHADER_NAME gaussian_blur\nuniform sampler2D texture;varying vec2 v_Texcoord;\nuniform float blurSize : 2.0;\nuniform vec2 textureSize : [512.0, 512.0];\nuniform float blurDir : 0.0;\n@import clay.util.rgbm\n@import clay.util.clamp_sample\nvoid main (void)\n{\n @import clay.compositor.kernel.gaussian_9\n vec2 off = blurSize / textureSize;\n off *= vec2(1.0 - blurDir, blurDir);\n vec4 sum = vec4(0.0);\n float weightAll = 0.0;\n for (int i = 0; i < 9; i++) {\n float w = gaussianKernel[i];\n vec4 texel = decodeHDR(clampSample(texture, v_Texcoord + float(i - 4) * off));\n sum += texel * w;\n weightAll += w;\n }\n gl_FragColor = encodeHDR(sum / max(weightAll, 0.01));\n}\n@end\n";
var lumEssl = "@export clay.compositor.hdr.log_lum\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\n@import clay.util.rgbm\nvoid main()\n{\n vec4 tex = decodeHDR(texture2D(texture, v_Texcoord));\n float luminance = dot(tex.rgb, w);\n luminance = log(luminance + 0.001);\n gl_FragColor = encodeHDR(vec4(vec3(luminance), 1.0));\n}\n@end\n@export clay.compositor.hdr.lum_adaption\nvarying vec2 v_Texcoord;\nuniform sampler2D adaptedLum;\nuniform sampler2D currentLum;\nuniform float frameTime : 0.02;\n@import clay.util.rgbm\nvoid main()\n{\n float fAdaptedLum = decodeHDR(texture2D(adaptedLum, vec2(0.5, 0.5))).r;\n float fCurrentLum = exp(encodeHDR(texture2D(currentLum, vec2(0.5, 0.5))).r);\n fAdaptedLum += (fCurrentLum - fAdaptedLum) * (1.0 - pow(0.98, 30.0 * frameTime));\n gl_FragColor = encodeHDR(vec4(vec3(fAdaptedLum), 1.0));\n}\n@end\n@export clay.compositor.lum\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nconst vec3 w = vec3(0.2125, 0.7154, 0.0721);\nvoid main()\n{\n vec4 tex = texture2D( texture, v_Texcoord );\n float luminance = dot(tex.rgb, w);\n gl_FragColor = vec4(vec3(luminance), 1.0);\n}\n@end";
var lutCode = "\n@export clay.compositor.lut\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nuniform sampler2D lookup;\nvoid main()\n{\n vec4 tex = texture2D(texture, v_Texcoord);\n float blueColor = tex.b * 63.0;\n vec2 quad1;\n quad1.y = floor(floor(blueColor) / 8.0);\n quad1.x = floor(blueColor) - (quad1.y * 8.0);\n vec2 quad2;\n quad2.y = floor(ceil(blueColor) / 8.0);\n quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n vec2 texPos1;\n texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.r);\n texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.g);\n vec2 texPos2;\n texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.r);\n texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * tex.g);\n vec4 newColor1 = texture2D(lookup, texPos1);\n vec4 newColor2 = texture2D(lookup, texPos2);\n vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n gl_FragColor = vec4(newColor.rgb, tex.w);\n}\n@end";
var vigentteEssl = "@export clay.compositor.vignette\n#define OUTPUT_ALPHA\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\nuniform float darkness: 1;\nuniform float offset: 1;\n@import clay.util.rgbm\nvoid main()\n{\n vec4 texel = decodeHDR(texture2D(texture, v_Texcoord));\n gl_FragColor.rgb = texel.rgb;\n vec2 uv = (v_Texcoord - vec2(0.5)) * vec2(offset);\n gl_FragColor = encodeHDR(vec4(mix(texel.rgb, vec3(1.0 - darkness), dot(uv, uv)), texel.a));\n}\n@end";
var outputCode = "@export clay.compositor.output\n#define OUTPUT_ALPHA\nvarying vec2 v_Texcoord;\nuniform sampler2D texture;\n@import clay.util.rgbm\nvoid main()\n{\n vec4 tex = decodeHDR(texture2D(texture, v_Texcoord));\n gl_FragColor.rgb = tex.rgb;\n#ifdef OUTPUT_ALPHA\n gl_FragColor.a = tex.a;\n#else\n gl_FragColor.a = 1.0;\n#endif\n gl_FragColor = encodeHDR(gl_FragColor);\n#ifdef PREMULTIPLY_ALPHA\n gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n}\n@end";
var brightCode = "@export clay.compositor.bright\nuniform sampler2D texture;\nuniform float threshold : 1;\nuniform float scale : 1.0;\nuniform vec2 textureSize: [512, 512];\nvarying vec2 v_Texcoord;\nconst vec3 lumWeight = vec3(0.2125, 0.7154, 0.0721);\n@import clay.util.rgbm\nvec4 median(vec4 a, vec4 b, vec4 c)\n{\n return a + b + c - min(min(a, b), c) - max(max(a, b), c);\n}\nvoid main()\n{\n vec4 texel = decodeHDR(texture2D(texture, v_Texcoord));\n#ifdef ANTI_FLICKER\n vec3 d = 1.0 / textureSize.xyx * vec3(1.0, 1.0, 0.0);\n vec4 s1 = decodeHDR(texture2D(texture, v_Texcoord - d.xz));\n vec4 s2 = decodeHDR(texture2D(texture, v_Texcoord + d.xz));\n vec4 s3 = decodeHDR(texture2D(texture, v_Texcoord - d.zy));\n vec4 s4 = decodeHDR(texture2D(texture, v_Texcoord + d.zy));\n texel = median(median(texel, s1, s2), s3, s4);\n#endif\n float lum = dot(texel.rgb , lumWeight);\n vec4 color;\n if (lum > threshold && texel.a > 0.0)\n {\n color = vec4(texel.rgb * scale, texel.a * scale);\n }\n else\n {\n color = vec4(0.0);\n }\n gl_FragColor = encodeHDR(color);\n}\n@end\n";
var downsampleCode = "@export clay.compositor.downsample\nuniform sampler2D texture;\nuniform vec2 textureSize : [512, 512];\nvarying vec2 v_Texcoord;\n@import clay.util.rgbm\nfloat brightness(vec3 c)\n{\n return max(max(c.r, c.g), c.b);\n}\n@import clay.util.clamp_sample\nvoid main()\n{\n vec4 d = vec4(-1.0, -1.0, 1.0, 1.0) / textureSize.xyxy;\n#ifdef ANTI_FLICKER\n vec3 s1 = decodeHDR(clampSample(texture, v_Texcoord + d.xy)).rgb;\n vec3 s2 = decodeHDR(clampSample(texture, v_Texcoord + d.zy)).rgb;\n vec3 s3 = decodeHDR(clampSample(texture, v_Texcoord + d.xw)).rgb;\n vec3 s4 = decodeHDR(clampSample(texture, v_Texcoord + d.zw)).rgb;\n float s1w = 1.0 / (brightness(s1) + 1.0);\n float s2w = 1.0 / (brightness(s2) + 1.0);\n float s3w = 1.0 / (brightness(s3) + 1.0);\n float s4w = 1.0 / (brightness(s4) + 1.0);\n float oneDivideSum = 1.0 / (s1w + s2w + s3w + s4w);\n vec4 color = vec4(\n (s1 * s1w + s2 * s2w + s3 * s3w + s4 * s4w) * oneDivideSum,\n 1.0\n );\n#else\n vec4 color = decodeHDR(clampSample(texture, v_Texcoord + d.xy));\n color += decodeHDR(clampSample(texture, v_Texcoord + d.zy));\n color += decodeHDR(clampSample(texture, v_Texcoord + d.xw));\n color += decodeHDR(clampSample(texture, v_Texcoord + d.zw));\n color *= 0.25;\n#endif\n gl_FragColor = encodeHDR(color);\n}\n@end";
var upsampleCode = "\n@export clay.compositor.upsample\n#define HIGH_QUALITY\nuniform sampler2D texture;\nuniform vec2 textureSize : [512, 512];\nuniform float sampleScale: 0.5;\nvarying vec2 v_Texcoord;\n@import clay.util.rgbm\n@import clay.util.clamp_sample\nvoid main()\n{\n#ifdef HIGH_QUALITY\n vec4 d = vec4(1.0, 1.0, -1.0, 0.0) / textureSize.xyxy * sampleScale;\n vec4 s;\n s = decodeHDR(clampSample(texture, v_Texcoord - d.xy));\n s += decodeHDR(clampSample(texture, v_Texcoord - d.wy)) * 2.0;\n s += decodeHDR(clampSample(texture, v_Texcoord - d.zy));\n s += decodeHDR(clampSample(texture, v_Texcoord + d.zw)) * 2.0;\n s += decodeHDR(clampSample(texture, v_Texcoord )) * 4.0;\n s += decodeHDR(clampSample(texture, v_Texcoord + d.xw)) * 2.0;\n s += decodeHDR(clampSample(texture, v_Texcoord + d.zy));\n s += decodeHDR(clampSample(texture, v_Texcoord + d.wy)) * 2.0;\n s += decodeHDR(clampSample(texture, v_Texcoord + d.xy));\n gl_FragColor = encodeHDR(s / 16.0);\n#else\n vec4 d = vec4(-1.0, -1.0, +1.0, +1.0) / textureSize.xyxy;\n vec4 s;\n s = decodeHDR(clampSample(texture, v_Texcoord + d.xy));\n s += decodeHDR(clampSample(texture, v_Texcoord + d.zy));\n s += decodeHDR(clampSample(texture, v_Texcoord + d.xw));\n s += decodeHDR(clampSample(texture, v_Texcoord + d.zw));\n gl_FragColor = encodeHDR(s / 4.0);\n#endif\n}\n@end";
var hdrCode = "@export clay.compositor.hdr.composite\n#define TONEMAPPING\nuniform sampler2D texture;\n#ifdef BLOOM_ENABLED\nuniform sampler2D bloom;\n#endif\n#ifdef LENSFLARE_ENABLED\nuniform sampler2D lensflare;\nuniform sampler2D lensdirt;\n#endif\n#ifdef LUM_ENABLED\nuniform sampler2D lum;\n#endif\n#ifdef LUT_ENABLED\nuniform sampler2D lut;\n#endif\n#ifdef COLOR_CORRECTION\nuniform float brightness : 0.0;\nuniform float contrast : 1.0;\nuniform float saturation : 1.0;\n#endif\n#ifdef VIGNETTE\nuniform float vignetteDarkness: 1.0;\nuniform float vignetteOffset: 1.0;\n#endif\nuniform float exposure : 1.0;\nuniform float bloomIntensity : 0.25;\nuniform float lensflareIntensity : 1;\nvarying vec2 v_Texcoord;\n@import clay.util.srgb\nvec3 ACESToneMapping(vec3 color)\n{\n const float A = 2.51;\n const float B = 0.03;\n const float C = 2.43;\n const float D = 0.59;\n const float E = 0.14;\n return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nfloat eyeAdaption(float fLum)\n{\n return mix(0.2, fLum, 0.5);\n}\n#ifdef LUT_ENABLED\nvec3 lutTransform(vec3 color) {\n float blueColor = color.b * 63.0;\n vec2 quad1;\n quad1.y = floor(floor(blueColor) / 8.0);\n quad1.x = floor(blueColor) - (quad1.y * 8.0);\n vec2 quad2;\n quad2.y = floor(ceil(blueColor) / 8.0);\n quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n vec2 texPos1;\n texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);\n texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);\n vec2 texPos2;\n texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.r);\n texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * color.g);\n vec4 newColor1 = texture2D(lut, texPos1);\n vec4 newColor2 = texture2D(lut, texPos2);\n vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n return newColor.rgb;\n}\n#endif\n@import clay.util.rgbm\nvoid main()\n{\n vec4 texel = vec4(0.0);\n vec4 originalTexel = vec4(0.0);\n#ifdef TEXTURE_ENABLED\n texel = decodeHDR(texture2D(texture, v_Texcoord));\n originalTexel = texel;\n#endif\n#ifdef BLOOM_ENABLED\n vec4 bloomTexel = decodeHDR(texture2D(bloom, v_Texcoord));\n texel.rgb += bloomTexel.rgb * bloomIntensity;\n texel.a += bloomTexel.a * bloomIntensity;\n#endif\n#ifdef LENSFLARE_ENABLED\n texel += decodeHDR(texture2D(lensflare, v_Texcoord)) * texture2D(lensdirt, v_Texcoord) * lensflareIntensity;\n#endif\n texel.a = min(texel.a, 1.0);\n#ifdef LUM_ENABLED\n float fLum = texture2D(lum, vec2(0.5, 0.5)).r;\n float adaptedLumDest = 3.0 / (max(0.1, 1.0 + 10.0*eyeAdaption(fLum)));\n float exposureBias = adaptedLumDest * exposure;\n#else\n float exposureBias = exposure;\n#endif\n#ifdef TONEMAPPING\n texel.rgb *= exposureBias;\n texel.rgb = ACESToneMapping(texel.rgb);\n#endif\n texel = linearTosRGB(texel);\n#ifdef LUT_ENABLED\n texel.rgb = lutTransform(clamp(texel.rgb,vec3(0.0),vec3(1.0)));\n#endif\n#ifdef COLOR_CORRECTION\n texel.rgb = clamp(texel.rgb + vec3(brightness), 0.0, 1.0);\n texel.rgb = clamp((texel.rgb - vec3(0.5))*contrast+vec3(0.5), 0.0, 1.0);\n float lum = dot(texel.rgb, vec3(0.2125, 0.7154, 0.0721));\n texel.rgb = mix(vec3(lum), texel.rgb, saturation);\n#endif\n#ifdef VIGNETTE\n vec2 uv = (v_Texcoord - vec2(0.5)) * vec2(vignetteOffset);\n texel.rgb = mix(texel.rgb, vec3(1.0 - vignetteDarkness), dot(uv, uv));\n#endif\n gl_FragColor = encodeHDR(texel);\n#ifdef DEBUG\n #if DEBUG == 1\n gl_FragColor = encodeHDR(decodeHDR(texture2D(texture, v_Texcoord)));\n #elif DEBUG == 2\n gl_FragColor = encodeHDR(decodeHDR(texture2D(bloom, v_Texcoord)) * bloomIntensity);\n #elif DEBUG == 3\n gl_FragColor = encodeHDR(decodeHDR(texture2D(lensflare, v_Texcoord) * lensflareIntensity));\n #endif\n#endif\n if (originalTexel.a <= 0.01 && gl_FragColor.a > 1e-5) {\n gl_FragColor.a = dot(gl_FragColor.rgb, vec3(0.2125, 0.7154, 0.0721));\n }\n#ifdef PREMULTIPLY_ALPHA\n gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n}\n@end";
var lensflareEssl = "@export clay.compositor.lensflare\n#define SAMPLE_NUMBER 8\nuniform sampler2D texture;\nuniform sampler2D lenscolor;\nuniform vec2 textureSize : [512, 512];\nuniform float dispersal : 0.3;\nuniform float haloWidth : 0.4;\nuniform float distortion : 1.0;\nvarying vec2 v_Texcoord;\n@import clay.util.rgbm\nvec4 textureDistorted(\n in vec2 texcoord,\n in vec2 direction,\n in vec3 distortion\n) {\n return vec4(\n decodeHDR(texture2D(texture, texcoord + direction * distortion.r)).r,\n decodeHDR(texture2D(texture, texcoord + direction * distortion.g)).g,\n decodeHDR(texture2D(texture, texcoord + direction * distortion.b)).b,\n 1.0\n );\n}\nvoid main()\n{\n vec2 texcoord = -v_Texcoord + vec2(1.0); vec2 textureOffset = 1.0 / textureSize;\n vec2 ghostVec = (vec2(0.5) - texcoord) * dispersal;\n vec2 haloVec = normalize(ghostVec) * haloWidth;\n vec3 distortion = vec3(-textureOffset.x * distortion, 0.0, textureOffset.x * distortion);\n vec4 result = vec4(0.0);\n for (int i = 0; i < SAMPLE_NUMBER; i++)\n {\n vec2 offset = fract(texcoord + ghostVec * float(i));\n float weight = length(vec2(0.5) - offset) / length(vec2(0.5));\n weight = pow(1.0 - weight, 10.0);\n result += textureDistorted(offset, normalize(ghostVec), distortion) * weight;\n }\n result *= texture2D(lenscolor, vec2(length(vec2(0.5) - texcoord)) / length(vec2(0.5)));\n float weight = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));\n weight = pow(1.0 - weight, 10.0);\n vec2 offset = fract(texcoord + haloVec);\n result += textureDistorted(offset, normalize(ghostVec), distortion) * weight;\n gl_FragColor = result;\n}\n@end";
var blendCode = "@export clay.compositor.blend\n#define SHADER_NAME blend\n#ifdef TEXTURE1_ENABLED\nuniform sampler2D texture1;\nuniform float weight1 : 1.0;\n#endif\n#ifdef TEXTURE2_ENABLED\nuniform sampler2D texture2;\nuniform float weight2 : 1.0;\n#endif\n#ifdef TEXTURE3_ENABLED\nuniform sampler2D texture3;\nuniform float weight3 : 1.0;\n#endif\n#ifdef TEXTURE4_ENABLED\nuniform sampler2D texture4;\nuniform float weight4 : 1.0;\n#endif\n#ifdef TEXTURE5_ENABLED\nuniform sampler2D texture5;\nuniform float weight5 : 1.0;\n#endif\n#ifdef TEXTURE6_ENABLED\nuniform sampler2D texture6;\nuniform float weight6 : 1.0;\n#endif\nvarying vec2 v_Texcoord;\n@import clay.util.rgbm\nvoid main()\n{\n vec4 tex = vec4(0.0);\n#ifdef TEXTURE1_ENABLED\n tex += decodeHDR(texture2D(texture1, v_Texcoord)) * weight1;\n#endif\n#ifdef TEXTURE2_ENABLED\n tex += decodeHDR(texture2D(texture2, v_Texcoord)) * weight2;\n#endif\n#ifdef TEXTURE3_ENABLED\n tex += decodeHDR(texture2D(texture3, v_Texcoord)) * weight3;\n#endif\n#ifdef TEXTURE4_ENABLED\n tex += decodeHDR(texture2D(texture4, v_Texcoord)) * weight4;\n#endif\n#ifdef TEXTURE5_ENABLED\n tex += decodeHDR(texture2D(texture5, v_Texcoord)) * weight5;\n#endif\n#ifdef TEXTURE6_ENABLED\n tex += decodeHDR(texture2D(texture6, v_Texcoord)) * weight6;\n#endif\n gl_FragColor = encodeHDR(tex);\n}\n@end";
var fxaaCode = "@export clay.compositor.fxaa\nuniform sampler2D texture;\nuniform vec4 viewport : VIEWPORT;\nvarying vec2 v_Texcoord;\n#define FXAA_REDUCE_MIN (1.0/128.0)\n#define FXAA_REDUCE_MUL (1.0/8.0)\n#define FXAA_SPAN_MAX 8.0\n@import clay.util.rgbm\nvoid main()\n{\n vec2 resolution = 1.0 / viewport.zw;\n vec3 rgbNW = decodeHDR( texture2D( texture, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ) ).xyz;\n vec3 rgbNE = decodeHDR( texture2D( texture, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ) ).xyz;\n vec3 rgbSW = decodeHDR( texture2D( texture, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ) ).xyz;\n vec3 rgbSE = decodeHDR( texture2D( texture, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ) ).xyz;\n vec4 rgbaM = decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution ) );\n vec3 rgbM = rgbaM.xyz;\n float opacity = rgbaM.w;\n vec3 luma = vec3( 0.299, 0.587, 0.114 );\n float lumaNW = dot( rgbNW, luma );\n float lumaNE = dot( rgbNE, luma );\n float lumaSW = dot( rgbSW, luma );\n float lumaSE = dot( rgbSE, luma );\n float lumaM = dot( rgbM, luma );\n float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\n vec2 dir;\n dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\n float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n dir = min( vec2( FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n dir * rcpDirMin)) * resolution;\n vec3 rgbA = decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ) ).xyz;\n rgbA += decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ) ).xyz;\n rgbA *= 0.5;\n vec3 rgbB = decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution + dir * -0.5 ) ).xyz;\n rgbB += decodeHDR( texture2D( texture, gl_FragCoord.xy * resolution + dir * 0.5 ) ).xyz;\n rgbB *= 0.25;\n rgbB += rgbA * 0.5;\n float lumaB = dot( rgbB, luma );\n if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) )\n {\n gl_FragColor = vec4( rgbA, opacity );\n }\n else {\n gl_FragColor = vec4( rgbB, opacity );\n }\n}\n@end";
function register(Shader2) {
  Shader2["import"](coloradjustEssl);
  Shader2["import"](blurCode);
  Shader2["import"](lumEssl);
  Shader2["import"](lutCode);
  Shader2["import"](vigentteEssl);
  Shader2["import"](outputCode);
  Shader2["import"](brightCode);
  Shader2["import"](downsampleCode);
  Shader2["import"](upsampleCode);
  Shader2["import"](hdrCode);
  Shader2["import"](lensflareEssl);
  Shader2["import"](blendCode);
  Shader2["import"](fxaaCode);
}
register(Shader);
var shaderSourceReg = /^#source\((.*?)\)/;
function createCompositor(json, opts) {
  var compositor = new Compositor$1();
  opts = opts || {};
  var lib = {
    textures: {},
    parameters: {}
  };
  var afterLoad = function(shaderLib, textureLib) {
    for (var i = 0; i < json.nodes.length; i++) {
      var nodeInfo = json.nodes[i];
      var node = createNode(nodeInfo, lib, opts);
      if (node) {
        compositor.addNode(node);
      }
    }
  };
  for (var name in json.parameters) {
    var paramInfo = json.parameters[name];
    lib.parameters[name] = convertParameter(paramInfo);
  }
  loadTextures(json, lib, opts, function(textureLib) {
    lib.textures = textureLib;
    afterLoad();
  });
  return compositor;
}
function createNode(nodeInfo, lib, opts) {
  var type = nodeInfo.type || "filter";
  var shaderSource;
  var inputs;
  var outputs;
  if (type === "filter") {
    var shaderExp = nodeInfo.shader.trim();
    var res = shaderSourceReg.exec(shaderExp);
    if (res) {
      shaderSource = Shader.source(res[1].trim());
    } else if (shaderExp.charAt(0) === "#") {
      shaderSource = lib.shaders[shaderExp.substr(1)];
    }
    if (!shaderSource) {
      shaderSource = shaderExp;
    }
    if (!shaderSource) {
      return;
    }
  }
  if (nodeInfo.inputs) {
    inputs = {};
    for (var name in nodeInfo.inputs) {
      if (typeof nodeInfo.inputs[name] === "string") {
        inputs[name] = nodeInfo.inputs[name];
      } else {
        inputs[name] = {
          node: nodeInfo.inputs[name].node,
          pin: nodeInfo.inputs[name].pin
        };
      }
    }
  }
  if (nodeInfo.outputs) {
    outputs = {};
    for (var name in nodeInfo.outputs) {
      var outputInfo = nodeInfo.outputs[name];
      outputs[name] = {};
      if (outputInfo.attachment != null) {
        outputs[name].attachment = outputInfo.attachment;
      }
      if (outputInfo.keepLastFrame != null) {
        outputs[name].keepLastFrame = outputInfo.keepLastFrame;
      }
      if (outputInfo.outputLastFrame != null) {
        outputs[name].outputLastFrame = outputInfo.outputLastFrame;
      }
      if (outputInfo.parameters) {
        outputs[name].parameters = convertParameter(outputInfo.parameters);
      }
    }
  }
  var node;
  if (type === "scene") {
    node = new CompoSceneNode({
      name: nodeInfo.name,
      scene: opts.scene,
      camera: opts.camera,
      outputs
    });
  } else if (type === "texture") {
    node = new CompoTextureNode({
      name: nodeInfo.name,
      outputs
    });
  } else {
    node = new CompoFilterNode({
      name: nodeInfo.name,
      shader: shaderSource,
      inputs,
      outputs
    });
  }
  if (node) {
    if (nodeInfo.parameters) {
      for (var name in nodeInfo.parameters) {
        var val = nodeInfo.parameters[name];
        if (typeof val === "string") {
          val = val.trim();
          if (val.charAt(0) === "#") {
            val = lib.textures[val.substr(1)];
          } else {
            node.on("beforerender", createSizeSetHandler(name, tryConvertExpr(val)));
          }
        } else if (typeof val === "function") {
          node.on("beforerender", val);
        }
        node.setParameter(name, val);
      }
    }
    if (nodeInfo.defines && node.pass) {
      for (var name in nodeInfo.defines) {
        var val = nodeInfo.defines[name];
        node.pass.material.define("fragment", name, val);
      }
    }
  }
  return node;
}
function defaultWidthFunc(width, height) {
  return width;
}
function defaultHeightFunc(width, height) {
  return height;
}
function convertParameter(paramInfo) {
  var param = {};
  if (!paramInfo) {
    return param;
  }
  ["type", "minFilter", "magFilter", "wrapS", "wrapT", "flipY", "useMipmap"].forEach(function(name) {
    var val = paramInfo[name];
    if (val != null) {
      if (typeof val === "string") {
        val = Texture$1[val];
      }
      param[name] = val;
    }
  });
  var sizeScale = paramInfo.scale || 1;
  ["width", "height"].forEach(function(name) {
    if (paramInfo[name] != null) {
      var val = paramInfo[name];
      if (typeof val === "string") {
        val = val.trim();
        param[name] = createSizeParser(name, tryConvertExpr(val), sizeScale);
      } else {
        param[name] = val;
      }
    }
  });
  if (!param.width) {
    param.width = defaultWidthFunc;
  }
  if (!param.height) {
    param.height = defaultHeightFunc;
  }
  if (paramInfo.useMipmap != null) {
    param.useMipmap = paramInfo.useMipmap;
  }
  return param;
}
function loadTextures(json, lib, opts, callback) {
  if (!json.textures) {
    callback({});
    return;
  }
  var textures = {};
  var loading = 0;
  var cbd = false;
  var textureRootPath = opts.textureRootPath;
  util$1.each(json.textures, function(textureInfo, name) {
    var texture;
    var path = textureInfo.path;
    var parameters = convertParameter(textureInfo.parameters);
    if (Array.isArray(path) && path.length === 6) {
      if (textureRootPath) {
        path = path.map(function(item) {
          return util$1.relative2absolute(item, textureRootPath);
        });
      }
      texture = new TextureCube$1(parameters);
    } else if (typeof path === "string") {
      if (textureRootPath) {
        path = util$1.relative2absolute(path, textureRootPath);
      }
      texture = new Texture2D$1(parameters);
    } else {
      return;
    }
    texture.load(path);
    loading++;
    texture.once("success", function() {
      textures[name] = texture;
      loading--;
      if (loading === 0) {
        callback(textures);
        cbd = true;
      }
    });
  });
  if (loading === 0 && !cbd) {
    callback(textures);
  }
}
function createSizeSetHandler(name, exprFunc) {
  return function(renderer) {
    var dpr2 = renderer.getDevicePixelRatio();
    var width = renderer.getWidth();
    var height = renderer.getHeight();
    var result = exprFunc(width, height, dpr2);
    this.setParameter(name, result);
  };
}
function createSizeParser(name, exprFunc, scale2) {
  scale2 = scale2 || 1;
  return function(renderer) {
    var dpr2 = renderer.getDevicePixelRatio();
    var width = renderer.getWidth() * scale2;
    var height = renderer.getHeight() * scale2;
    return exprFunc(width, height, dpr2);
  };
}
function tryConvertExpr(string) {
  var exprRes = /^expr\((.*)\)$/.exec(string);
  if (exprRes) {
    try {
      var func = new Function("width", "height", "dpr", "return " + exprRes[1]);
      func(1, 1);
      return func;
    } catch (e2) {
      throw new Error("Invalid expression.");
    }
  }
}
function halton(index, base2) {
  var result = 0;
  var f = 1 / base2;
  var i = index;
  while (i > 0) {
    result = result + f * (i % base2);
    i = Math.floor(i / base2);
    f = f / base2;
  }
  return result;
}
var SSAOGLSL = "@export ecgl.ssao.estimate\n\nuniform sampler2D depthTex;\n\nuniform sampler2D normalTex;\n\nuniform sampler2D noiseTex;\n\nuniform vec2 depthTexSize;\n\nuniform vec2 noiseTexSize;\n\nuniform mat4 projection;\n\nuniform mat4 projectionInv;\n\nuniform mat4 viewInverseTranspose;\n\nuniform vec3 kernel[KERNEL_SIZE];\n\nuniform float radius : 1;\n\nuniform float power : 1;\n\nuniform float bias: 1e-2;\n\nuniform float intensity: 1.0;\n\nvarying vec2 v_Texcoord;\n\nfloat ssaoEstimator(in vec3 originPos, in mat3 kernelBasis) {\n float occlusion = 0.0;\n\n for (int i = 0; i < KERNEL_SIZE; i++) {\n vec3 samplePos = kernel[i];\n#ifdef NORMALTEX_ENABLED\n samplePos = kernelBasis * samplePos;\n#endif\n samplePos = samplePos * radius + originPos;\n\n vec4 texCoord = projection * vec4(samplePos, 1.0);\n texCoord.xy /= texCoord.w;\n\n vec4 depthTexel = texture2D(depthTex, texCoord.xy * 0.5 + 0.5);\n\n float sampleDepth = depthTexel.r * 2.0 - 1.0;\n if (projection[3][3] == 0.0) {\n sampleDepth = projection[3][2] / (sampleDepth * projection[2][3] - projection[2][2]);\n }\n else {\n sampleDepth = (sampleDepth - projection[3][2]) / projection[2][2];\n }\n \n float rangeCheck = smoothstep(0.0, 1.0, radius / abs(originPos.z - sampleDepth));\n occlusion += rangeCheck * step(samplePos.z, sampleDepth - bias);\n }\n#ifdef NORMALTEX_ENABLED\n occlusion = 1.0 - occlusion / float(KERNEL_SIZE);\n#else\n occlusion = 1.0 - clamp((occlusion / float(KERNEL_SIZE) - 0.6) * 2.5, 0.0, 1.0);\n#endif\n return pow(occlusion, power);\n}\n\nvoid main()\n{\n\n vec4 depthTexel = texture2D(depthTex, v_Texcoord);\n\n#ifdef NORMALTEX_ENABLED\n vec4 tex = texture2D(normalTex, v_Texcoord);\n if (dot(tex.rgb, tex.rgb) == 0.0) {\n gl_FragColor = vec4(1.0);\n return;\n }\n vec3 N = tex.rgb * 2.0 - 1.0;\n N = (viewInverseTranspose * vec4(N, 0.0)).xyz;\n\n vec2 noiseTexCoord = depthTexSize / vec2(noiseTexSize) * v_Texcoord;\n vec3 rvec = texture2D(noiseTex, noiseTexCoord).rgb * 2.0 - 1.0;\n vec3 T = normalize(rvec - N * dot(rvec, N));\n vec3 BT = normalize(cross(N, T));\n mat3 kernelBasis = mat3(T, BT, N);\n#else\n if (depthTexel.r > 0.99999) {\n gl_FragColor = vec4(1.0);\n return;\n }\n mat3 kernelBasis;\n#endif\n\n float z = depthTexel.r * 2.0 - 1.0;\n\n vec4 projectedPos = vec4(v_Texcoord * 2.0 - 1.0, z, 1.0);\n vec4 p4 = projectionInv * projectedPos;\n\n vec3 position = p4.xyz / p4.w;\n\n float ao = ssaoEstimator(position, kernelBasis);\n ao = clamp(1.0 - (1.0 - ao) * intensity, 0.0, 1.0);\n gl_FragColor = vec4(vec3(ao), 1.0);\n}\n\n@end\n\n\n@export ecgl.ssao.blur\n#define SHADER_NAME SSAO_BLUR\n\nuniform sampler2D ssaoTexture;\n\n#ifdef NORMALTEX_ENABLED\nuniform sampler2D normalTex;\n#endif\n\nvarying vec2 v_Texcoord;\n\nuniform vec2 textureSize;\nuniform float blurSize : 1.0;\n\nuniform int direction: 0.0;\n\n#ifdef DEPTHTEX_ENABLED\nuniform sampler2D depthTex;\nuniform mat4 projection;\nuniform float depthRange : 0.5;\n\nfloat getLinearDepth(vec2 coord)\n{\n float depth = texture2D(depthTex, coord).r * 2.0 - 1.0;\n return projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n}\n#endif\n\nvoid main()\n{\n float kernel[5];\n kernel[0] = 0.122581;\n kernel[1] = 0.233062;\n kernel[2] = 0.288713;\n kernel[3] = 0.233062;\n kernel[4] = 0.122581;\n\n vec2 off = vec2(0.0);\n if (direction == 0) {\n off[0] = blurSize / textureSize.x;\n }\n else {\n off[1] = blurSize / textureSize.y;\n }\n\n vec2 coord = v_Texcoord;\n\n float sum = 0.0;\n float weightAll = 0.0;\n\n#ifdef NORMALTEX_ENABLED\n vec3 centerNormal = texture2D(normalTex, v_Texcoord).rgb * 2.0 - 1.0;\n#endif\n#if defined(DEPTHTEX_ENABLED)\n float centerDepth = getLinearDepth(v_Texcoord);\n#endif\n\n for (int i = 0; i < 5; i++) {\n vec2 coord = clamp(v_Texcoord + vec2(float(i) - 2.0) * off, vec2(0.0), vec2(1.0));\n\n float w = kernel[i];\n#ifdef NORMALTEX_ENABLED\n vec3 normal = texture2D(normalTex, coord).rgb * 2.0 - 1.0;\n w *= clamp(dot(normal, centerNormal), 0.0, 1.0);\n#endif\n#ifdef DEPTHTEX_ENABLED\n float d = getLinearDepth(coord);\n w *= (1.0 - smoothstep(abs(centerDepth - d) / depthRange, 0.0, 1.0));\n#endif\n\n weightAll += w;\n sum += texture2D(ssaoTexture, coord).r * w;\n }\n\n gl_FragColor = vec4(vec3(sum / weightAll), 1.0);\n}\n\n@end\n";
Shader.import(SSAOGLSL);
function generateNoiseData(size) {
  var data = new Uint8Array(size * size * 4);
  var n = 0;
  var v32 = new Vector3$1();
  for (var i = 0; i < size; i++) {
    for (var j = 0; j < size; j++) {
      v32.set(Math.random() * 2 - 1, Math.random() * 2 - 1, 0).normalize();
      data[n++] = (v32.x * 0.5 + 0.5) * 255;
      data[n++] = (v32.y * 0.5 + 0.5) * 255;
      data[n++] = 0;
      data[n++] = 255;
    }
  }
  return data;
}
function generateNoiseTexture(size) {
  return new Texture2D$1({
    pixels: generateNoiseData(size),
    wrapS: Texture$1.REPEAT,
    wrapT: Texture$1.REPEAT,
    width: size,
    height: size
  });
}
function generateKernel(size, offset, hemisphere) {
  var kernel = new Float32Array(size * 3);
  offset = offset || 0;
  for (var i = 0; i < size; i++) {
    var phi = halton(i + offset, 2) * (hemisphere ? 1 : 2) * Math.PI;
    var theta = halton(i + offset, 3) * Math.PI;
    var r = Math.random();
    var x = Math.cos(phi) * Math.sin(theta) * r;
    var y = Math.cos(theta) * r;
    var z = Math.sin(phi) * Math.sin(theta) * r;
    kernel[i * 3] = x;
    kernel[i * 3 + 1] = y;
    kernel[i * 3 + 2] = z;
  }
  return kernel;
}
function SSAOPass(opt) {
  opt = opt || {};
  this._ssaoPass = new Pass$1({
    fragment: Shader.source("ecgl.ssao.estimate")
  });
  this._blurPass = new Pass$1({
    fragment: Shader.source("ecgl.ssao.blur")
  });
  this._framebuffer = new FrameBuffer$1({
    depthBuffer: false
  });
  this._ssaoTexture = new Texture2D$1();
  this._blurTexture = new Texture2D$1();
  this._blurTexture2 = new Texture2D$1();
  this._depthTex = opt.depthTexture;
  this._normalTex = opt.normalTexture;
  this.setNoiseSize(4);
  this.setKernelSize(opt.kernelSize || 12);
  if (opt.radius != null) {
    this.setParameter("radius", opt.radius);
  }
  if (opt.power != null) {
    this.setParameter("power", opt.power);
  }
  if (!this._normalTex) {
    this._ssaoPass.material.disableTexture("normalTex");
    this._blurPass.material.disableTexture("normalTex");
  }
  if (!this._depthTex) {
    this._blurPass.material.disableTexture("depthTex");
  }
  this._blurPass.material.setUniform("normalTex", this._normalTex);
  this._blurPass.material.setUniform("depthTex", this._depthTex);
}
SSAOPass.prototype.setDepthTexture = function(depthTex) {
  this._depthTex = depthTex;
};
SSAOPass.prototype.setNormalTexture = function(normalTex) {
  this._normalTex = normalTex;
  this._ssaoPass.material[normalTex ? "enableTexture" : "disableTexture"]("normalTex");
  this.setKernelSize(this._kernelSize);
};
SSAOPass.prototype.update = function(renderer, camera2, frame) {
  var width = renderer.getWidth();
  var height = renderer.getHeight();
  var ssaoPass = this._ssaoPass;
  var blurPass = this._blurPass;
  ssaoPass.setUniform("kernel", this._kernels[frame % this._kernels.length]);
  ssaoPass.setUniform("depthTex", this._depthTex);
  if (this._normalTex != null) {
    ssaoPass.setUniform("normalTex", this._normalTex);
  }
  ssaoPass.setUniform("depthTexSize", [this._depthTex.width, this._depthTex.height]);
  var viewInverseTranspose = new Matrix4$1();
  Matrix4$1.transpose(viewInverseTranspose, camera2.worldTransform);
  ssaoPass.setUniform("projection", camera2.projectionMatrix.array);
  ssaoPass.setUniform("projectionInv", camera2.invProjectionMatrix.array);
  ssaoPass.setUniform("viewInverseTranspose", viewInverseTranspose.array);
  var ssaoTexture = this._ssaoTexture;
  var blurTexture = this._blurTexture;
  var blurTexture2 = this._blurTexture2;
  ssaoTexture.width = width / 2;
  ssaoTexture.height = height / 2;
  blurTexture.width = width;
  blurTexture.height = height;
  blurTexture2.width = width;
  blurTexture2.height = height;
  this._framebuffer.attach(ssaoTexture);
  this._framebuffer.bind(renderer);
  renderer.gl.clearColor(1, 1, 1, 1);
  renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
  ssaoPass.render(renderer);
  blurPass.setUniform("textureSize", [width / 2, height / 2]);
  blurPass.setUniform("projection", camera2.projectionMatrix.array);
  this._framebuffer.attach(blurTexture);
  blurPass.setUniform("direction", 0);
  blurPass.setUniform("ssaoTexture", ssaoTexture);
  blurPass.render(renderer);
  this._framebuffer.attach(blurTexture2);
  blurPass.setUniform("textureSize", [width, height]);
  blurPass.setUniform("direction", 1);
  blurPass.setUniform("ssaoTexture", blurTexture);
  blurPass.render(renderer);
  this._framebuffer.unbind(renderer);
  var clearColor = renderer.clearColor;
  renderer.gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
};
SSAOPass.prototype.getTargetTexture = function() {
  return this._blurTexture2;
};
SSAOPass.prototype.setParameter = function(name, val) {
  if (name === "noiseTexSize") {
    this.setNoiseSize(val);
  } else if (name === "kernelSize") {
    this.setKernelSize(val);
  } else if (name === "intensity") {
    this._ssaoPass.material.set("intensity", val);
  } else {
    this._ssaoPass.setUniform(name, val);
  }
};
SSAOPass.prototype.setKernelSize = function(size) {
  this._kernelSize = size;
  this._ssaoPass.material.define("fragment", "KERNEL_SIZE", size);
  this._kernels = this._kernels || [];
  for (var i = 0; i < 30; i++) {
    this._kernels[i] = generateKernel(size, i * size, !!this._normalTex);
  }
};
SSAOPass.prototype.setNoiseSize = function(size) {
  var texture = this._ssaoPass.getUniform("noiseTex");
  if (!texture) {
    texture = generateNoiseTexture(size);
    this._ssaoPass.setUniform("noiseTex", generateNoiseTexture(size));
  } else {
    texture.data = generateNoiseData(size);
    texture.width = texture.height = size;
    texture.dirty();
  }
  this._ssaoPass.setUniform("noiseTexSize", [size, size]);
};
SSAOPass.prototype.dispose = function(renderer) {
  this._blurTexture.dispose(renderer);
  this._ssaoTexture.dispose(renderer);
  this._blurTexture2.dispose(renderer);
};
var SSRGLSLCode = "@export ecgl.ssr.main\n\n#define SHADER_NAME SSR\n#define MAX_ITERATION 20;\n#define SAMPLE_PER_FRAME 5;\n#define TOTAL_SAMPLES 128;\n\nuniform sampler2D sourceTexture;\nuniform sampler2D gBufferTexture1;\nuniform sampler2D gBufferTexture2;\nuniform sampler2D gBufferTexture3;\nuniform samplerCube specularCubemap;\nuniform float specularIntensity: 1;\n\nuniform mat4 projection;\nuniform mat4 projectionInv;\nuniform mat4 toViewSpace;\nuniform mat4 toWorldSpace;\n\nuniform float maxRayDistance: 200;\n\nuniform float pixelStride: 16;\nuniform float pixelStrideZCutoff: 50; \nuniform float screenEdgeFadeStart: 0.9; \nuniform float eyeFadeStart : 0.2; uniform float eyeFadeEnd: 0.8; \nuniform float minGlossiness: 0.2; uniform float zThicknessThreshold: 1;\n\nuniform float nearZ;\nuniform vec2 viewportSize : VIEWPORT_SIZE;\n\nuniform float jitterOffset: 0;\n\nvarying vec2 v_Texcoord;\n\n#ifdef DEPTH_DECODE\n@import clay.util.decode_float\n#endif\n\n#ifdef PHYSICALLY_CORRECT\nuniform sampler2D normalDistribution;\nuniform float sampleOffset: 0;\nuniform vec2 normalDistributionSize;\n\nvec3 transformNormal(vec3 H, vec3 N) {\n vec3 upVector = N.y > 0.999 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n vec3 tangentX = normalize(cross(N, upVector));\n vec3 tangentZ = cross(N, tangentX);\n return normalize(tangentX * H.x + N * H.y + tangentZ * H.z);\n}\nvec3 importanceSampleNormalGGX(float i, float roughness, vec3 N) {\n float p = fract((i + sampleOffset) / float(TOTAL_SAMPLES));\n vec3 H = texture2D(normalDistribution,vec2(roughness, p)).rgb;\n return transformNormal(H, N);\n}\nfloat G_Smith(float g, float ndv, float ndl) {\n float roughness = 1.0 - g;\n float k = roughness * roughness / 2.0;\n float G1V = ndv / (ndv * (1.0 - k) + k);\n float G1L = ndl / (ndl * (1.0 - k) + k);\n return G1L * G1V;\n}\nvec3 F_Schlick(float ndv, vec3 spec) {\n return spec + (1.0 - spec) * pow(1.0 - ndv, 5.0);\n}\n#endif\n\nfloat fetchDepth(sampler2D depthTexture, vec2 uv)\n{\n vec4 depthTexel = texture2D(depthTexture, uv);\n return depthTexel.r * 2.0 - 1.0;\n}\n\nfloat linearDepth(float depth)\n{\n if (projection[3][3] == 0.0) {\n return projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n }\n else {\n return (depth - projection[3][2]) / projection[2][2];\n }\n}\n\nbool rayIntersectDepth(float rayZNear, float rayZFar, vec2 hitPixel)\n{\n if (rayZFar > rayZNear)\n {\n float t = rayZFar; rayZFar = rayZNear; rayZNear = t;\n }\n float cameraZ = linearDepth(fetchDepth(gBufferTexture2, hitPixel));\n return rayZFar <= cameraZ && rayZNear >= cameraZ - zThicknessThreshold;\n}\n\n\nbool traceScreenSpaceRay(\n vec3 rayOrigin, vec3 rayDir, float jitter,\n out vec2 hitPixel, out vec3 hitPoint, out float iterationCount\n)\n{\n float rayLength = ((rayOrigin.z + rayDir.z * maxRayDistance) > -nearZ)\n ? (-nearZ - rayOrigin.z) / rayDir.z : maxRayDistance;\n\n vec3 rayEnd = rayOrigin + rayDir * rayLength;\n\n vec4 H0 = projection * vec4(rayOrigin, 1.0);\n vec4 H1 = projection * vec4(rayEnd, 1.0);\n\n float k0 = 1.0 / H0.w, k1 = 1.0 / H1.w;\n\n vec3 Q0 = rayOrigin * k0, Q1 = rayEnd * k1;\n\n vec2 P0 = (H0.xy * k0 * 0.5 + 0.5) * viewportSize;\n vec2 P1 = (H1.xy * k1 * 0.5 + 0.5) * viewportSize;\n\n P1 += dot(P1 - P0, P1 - P0) < 0.0001 ? 0.01 : 0.0;\n vec2 delta = P1 - P0;\n\n bool permute = false;\n if (abs(delta.x) < abs(delta.y)) {\n permute = true;\n delta = delta.yx;\n P0 = P0.yx;\n P1 = P1.yx;\n }\n float stepDir = sign(delta.x);\n float invdx = stepDir / delta.x;\n\n vec3 dQ = (Q1 - Q0) * invdx;\n float dk = (k1 - k0) * invdx;\n\n vec2 dP = vec2(stepDir, delta.y * invdx);\n\n float strideScaler = 1.0 - min(1.0, -rayOrigin.z / pixelStrideZCutoff);\n float pixStride = 1.0 + strideScaler * pixelStride;\n\n dP *= pixStride; dQ *= pixStride; dk *= pixStride;\n\n vec4 pqk = vec4(P0, Q0.z, k0);\n vec4 dPQK = vec4(dP, dQ.z, dk);\n\n pqk += dPQK * jitter;\n float rayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n float rayZNear;\n\n bool intersect = false;\n\n vec2 texelSize = 1.0 / viewportSize;\n\n iterationCount = 0.0;\n\n for (int i = 0; i < MAX_ITERATION; i++)\n {\n pqk += dPQK;\n\n rayZNear = rayZFar;\n rayZFar = (dPQK.z * 0.5 + pqk.z) / (dPQK.w * 0.5 + pqk.w);\n\n hitPixel = permute ? pqk.yx : pqk.xy;\n hitPixel *= texelSize;\n\n intersect = rayIntersectDepth(rayZNear, rayZFar, hitPixel);\n\n iterationCount += 1.0;\n\n dPQK *= 1.2;\n\n if (intersect) {\n break;\n }\n }\n\n Q0.xy += dQ.xy * iterationCount;\n Q0.z = pqk.z;\n hitPoint = Q0 / pqk.w;\n\n return intersect;\n}\n\nfloat calculateAlpha(\n float iterationCount, float reflectivity,\n vec2 hitPixel, vec3 hitPoint, float dist, vec3 rayDir\n)\n{\n float alpha = clamp(reflectivity, 0.0, 1.0);\n alpha *= 1.0 - (iterationCount / float(MAX_ITERATION));\n vec2 hitPixelNDC = hitPixel * 2.0 - 1.0;\n float maxDimension = min(1.0, max(abs(hitPixelNDC.x), abs(hitPixelNDC.y)));\n alpha *= 1.0 - max(0.0, maxDimension - screenEdgeFadeStart) / (1.0 - screenEdgeFadeStart);\n\n float _eyeFadeStart = eyeFadeStart;\n float _eyeFadeEnd = eyeFadeEnd;\n if (_eyeFadeStart > _eyeFadeEnd) {\n float tmp = _eyeFadeEnd;\n _eyeFadeEnd = _eyeFadeStart;\n _eyeFadeStart = tmp;\n }\n\n float eyeDir = clamp(rayDir.z, _eyeFadeStart, _eyeFadeEnd);\n alpha *= 1.0 - (eyeDir - _eyeFadeStart) / (_eyeFadeEnd - _eyeFadeStart);\n\n alpha *= 1.0 - clamp(dist / maxRayDistance, 0.0, 1.0);\n\n return alpha;\n}\n\n@import clay.util.rand\n\n@import clay.util.rgbm\n\nvoid main()\n{\n vec4 normalAndGloss = texture2D(gBufferTexture1, v_Texcoord);\n\n if (dot(normalAndGloss.rgb, vec3(1.0)) == 0.0) {\n discard;\n }\n\n float g = normalAndGloss.a;\n#if !defined(PHYSICALLY_CORRECT)\n if (g <= minGlossiness) {\n discard;\n }\n#endif\n\n float reflectivity = (g - minGlossiness) / (1.0 - minGlossiness);\n\n vec3 N = normalize(normalAndGloss.rgb * 2.0 - 1.0);\n N = normalize((toViewSpace * vec4(N, 0.0)).xyz);\n\n vec4 projectedPos = vec4(v_Texcoord * 2.0 - 1.0, fetchDepth(gBufferTexture2, v_Texcoord), 1.0);\n vec4 pos = projectionInv * projectedPos;\n vec3 rayOrigin = pos.xyz / pos.w;\n vec3 V = -normalize(rayOrigin);\n\n float ndv = clamp(dot(N, V), 0.0, 1.0);\n float iterationCount;\n float jitter = rand(fract(v_Texcoord + jitterOffset));\n\n#ifdef PHYSICALLY_CORRECT\n vec4 color = vec4(vec3(0.0), 1.0);\n vec4 albedoMetalness = texture2D(gBufferTexture3, v_Texcoord);\n vec3 albedo = albedoMetalness.rgb;\n float m = albedoMetalness.a;\n vec3 diffuseColor = albedo * (1.0 - m);\n vec3 spec = mix(vec3(0.04), albedo, m);\n\n float jitter2 = rand(fract(v_Texcoord)) * float(TOTAL_SAMPLES);\n\n for (int i = 0; i < SAMPLE_PER_FRAME; i++) {\n vec3 H = importanceSampleNormalGGX(float(i) + jitter2, 1.0 - g, N);\n vec3 rayDir = normalize(reflect(-V, H));\n#else\n vec3 rayDir = normalize(reflect(-V, N));\n#endif\n vec2 hitPixel;\n vec3 hitPoint;\n\n bool intersect = traceScreenSpaceRay(rayOrigin, rayDir, jitter, hitPixel, hitPoint, iterationCount);\n\n float dist = distance(rayOrigin, hitPoint);\n\n vec3 hitNormal = texture2D(gBufferTexture1, hitPixel).rgb * 2.0 - 1.0;\n hitNormal = normalize((toViewSpace * vec4(hitNormal, 0.0)).xyz);\n#ifdef PHYSICALLY_CORRECT\n float ndl = clamp(dot(N, rayDir), 0.0, 1.0);\n float vdh = clamp(dot(V, H), 0.0, 1.0);\n float ndh = clamp(dot(N, H), 0.0, 1.0);\n vec3 litTexel = vec3(0.0);\n if (dot(hitNormal, rayDir) < 0.0 && intersect) {\n litTexel = texture2D(sourceTexture, hitPixel).rgb;\n litTexel *= pow(clamp(1.0 - dist / 200.0, 0.0, 1.0), 3.0);\n\n }\n else {\n #ifdef SPECULARCUBEMAP_ENABLED\n vec3 rayDirW = normalize(toWorldSpace * vec4(rayDir, 0.0)).rgb;\n litTexel = RGBMDecode(textureCubeLodEXT(specularCubemap, rayDirW, 0.0), 8.12).rgb * specularIntensity;\n#endif\n }\n color.rgb += ndl * litTexel * (\n F_Schlick(ndl, spec) * G_Smith(g, ndv, ndl) * vdh / (ndh * ndv + 0.001)\n );\n }\n color.rgb /= float(SAMPLE_PER_FRAME);\n#else\n #if !defined(SPECULARCUBEMAP_ENABLED)\n if (dot(hitNormal, rayDir) >= 0.0) {\n discard;\n }\n if (!intersect) {\n discard;\n }\n#endif\n float alpha = clamp(calculateAlpha(iterationCount, reflectivity, hitPixel, hitPoint, dist, rayDir), 0.0, 1.0);\n vec4 color = texture2D(sourceTexture, hitPixel);\n color.rgb *= alpha;\n\n#ifdef SPECULARCUBEMAP_ENABLED\n vec3 rayDirW = normalize(toWorldSpace * vec4(rayDir, 0.0)).rgb;\n alpha = alpha * (intersect ? 1.0 : 0.0);\n float bias = (1.0 -g) * 5.0;\n color.rgb += (1.0 - alpha)\n * RGBMDecode(textureCubeLodEXT(specularCubemap, rayDirW, bias), 8.12).rgb\n * specularIntensity;\n#endif\n\n#endif\n\n gl_FragColor = encodeHDR(color);\n}\n@end\n\n@export ecgl.ssr.blur\n\nuniform sampler2D texture;\nuniform sampler2D gBufferTexture1;\nuniform sampler2D gBufferTexture2;\nuniform mat4 projection;\nuniform float depthRange : 0.05;\n\nvarying vec2 v_Texcoord;\n\nuniform vec2 textureSize;\nuniform float blurSize : 1.0;\n\n#ifdef BLEND\n #ifdef SSAOTEX_ENABLED\nuniform sampler2D ssaoTex;\n #endif\nuniform sampler2D sourceTexture;\n#endif\n\nfloat getLinearDepth(vec2 coord)\n{\n float depth = texture2D(gBufferTexture2, coord).r * 2.0 - 1.0;\n return projection[3][2] / (depth * projection[2][3] - projection[2][2]);\n}\n\n@import clay.util.rgbm\n\n\nvoid main()\n{\n @import clay.compositor.kernel.gaussian_9\n\n vec4 centerNTexel = texture2D(gBufferTexture1, v_Texcoord);\n float g = centerNTexel.a;\n float maxBlurSize = clamp(1.0 - g, 0.0, 1.0) * blurSize;\n#ifdef VERTICAL\n vec2 off = vec2(0.0, maxBlurSize / textureSize.y);\n#else\n vec2 off = vec2(maxBlurSize / textureSize.x, 0.0);\n#endif\n\n vec2 coord = v_Texcoord;\n\n vec4 sum = vec4(0.0);\n float weightAll = 0.0;\n\n vec3 cN = centerNTexel.rgb * 2.0 - 1.0;\n float cD = getLinearDepth(v_Texcoord);\n for (int i = 0; i < 9; i++) {\n vec2 coord = clamp((float(i) - 4.0) * off + v_Texcoord, vec2(0.0), vec2(1.0));\n float w = gaussianKernel[i]\n * clamp(dot(cN, texture2D(gBufferTexture1, coord).rgb * 2.0 - 1.0), 0.0, 1.0);\n float d = getLinearDepth(coord);\n w *= (1.0 - smoothstep(abs(cD - d) / depthRange, 0.0, 1.0));\n\n weightAll += w;\n sum += decodeHDR(texture2D(texture, coord)) * w;\n }\n\n#ifdef BLEND\n float aoFactor = 1.0;\n #ifdef SSAOTEX_ENABLED\n aoFactor = texture2D(ssaoTex, v_Texcoord).r;\n #endif\n gl_FragColor = encodeHDR(\n sum / weightAll * aoFactor + decodeHDR(texture2D(sourceTexture, v_Texcoord))\n );\n#else\n gl_FragColor = encodeHDR(sum / weightAll);\n#endif\n}\n\n@end";
Shader.import(SSRGLSLCode);
function SSRPass(opt) {
  opt = opt || {};
  this._ssrPass = new Pass$1({
    fragment: Shader.source("ecgl.ssr.main"),
    clearColor: [0, 0, 0, 0]
  });
  this._blurPass1 = new Pass$1({
    fragment: Shader.source("ecgl.ssr.blur"),
    clearColor: [0, 0, 0, 0]
  });
  this._blurPass2 = new Pass$1({
    fragment: Shader.source("ecgl.ssr.blur"),
    clearColor: [0, 0, 0, 0]
  });
  this._blendPass = new Pass$1({
    fragment: Shader.source("clay.compositor.blend")
  });
  this._blendPass.material.disableTexturesAll();
  this._blendPass.material.enableTexture(["texture1", "texture2"]);
  this._ssrPass.setUniform("gBufferTexture1", opt.normalTexture);
  this._ssrPass.setUniform("gBufferTexture2", opt.depthTexture);
  this._blurPass1.setUniform("gBufferTexture1", opt.normalTexture);
  this._blurPass1.setUniform("gBufferTexture2", opt.depthTexture);
  this._blurPass2.setUniform("gBufferTexture1", opt.normalTexture);
  this._blurPass2.setUniform("gBufferTexture2", opt.depthTexture);
  this._blurPass2.material.define("fragment", "VERTICAL");
  this._blurPass2.material.define("fragment", "BLEND");
  this._ssrTexture = new Texture2D$1({
    type: Texture$1.HALF_FLOAT
  });
  this._texture2 = new Texture2D$1({
    type: Texture$1.HALF_FLOAT
  });
  this._texture3 = new Texture2D$1({
    type: Texture$1.HALF_FLOAT
  });
  this._prevTexture = new Texture2D$1({
    type: Texture$1.HALF_FLOAT
  });
  this._currentTexture = new Texture2D$1({
    type: Texture$1.HALF_FLOAT
  });
  this._frameBuffer = new FrameBuffer$1({
    depthBuffer: false
  });
  this._normalDistribution = null;
  this._totalSamples = 256;
  this._samplePerFrame = 4;
  this._ssrPass.material.define("fragment", "SAMPLE_PER_FRAME", this._samplePerFrame);
  this._ssrPass.material.define("fragment", "TOTAL_SAMPLES", this._totalSamples);
  this._downScale = 1;
}
SSRPass.prototype.setAmbientCubemap = function(specularCubemap, specularIntensity) {
  this._ssrPass.material.set("specularCubemap", specularCubemap);
  this._ssrPass.material.set("specularIntensity", specularIntensity);
  var enableSpecularMap = specularCubemap && specularIntensity;
  this._ssrPass.material[enableSpecularMap ? "enableTexture" : "disableTexture"]("specularCubemap");
};
SSRPass.prototype.update = function(renderer, camera2, sourceTexture, frame) {
  var width = renderer.getWidth();
  var height = renderer.getHeight();
  var ssrTexture = this._ssrTexture;
  var texture2 = this._texture2;
  var texture3 = this._texture3;
  ssrTexture.width = this._prevTexture.width = this._currentTexture.width = width / this._downScale;
  ssrTexture.height = this._prevTexture.height = this._currentTexture.height = height / this._downScale;
  texture2.width = texture3.width = width;
  texture2.height = texture3.height = height;
  var frameBuffer = this._frameBuffer;
  var ssrPass = this._ssrPass;
  var blurPass1 = this._blurPass1;
  var blurPass2 = this._blurPass2;
  var blendPass = this._blendPass;
  var toViewSpace = new Matrix4$1();
  var toWorldSpace = new Matrix4$1();
  Matrix4$1.transpose(toViewSpace, camera2.worldTransform);
  Matrix4$1.transpose(toWorldSpace, camera2.viewMatrix);
  ssrPass.setUniform("sourceTexture", sourceTexture);
  ssrPass.setUniform("projection", camera2.projectionMatrix.array);
  ssrPass.setUniform("projectionInv", camera2.invProjectionMatrix.array);
  ssrPass.setUniform("toViewSpace", toViewSpace.array);
  ssrPass.setUniform("toWorldSpace", toWorldSpace.array);
  ssrPass.setUniform("nearZ", camera2.near);
  var percent = frame / this._totalSamples * this._samplePerFrame;
  ssrPass.setUniform("jitterOffset", percent);
  ssrPass.setUniform("sampleOffset", frame * this._samplePerFrame);
  blurPass1.setUniform("textureSize", [ssrTexture.width, ssrTexture.height]);
  blurPass2.setUniform("textureSize", [width, height]);
  blurPass2.setUniform("sourceTexture", sourceTexture);
  blurPass1.setUniform("projection", camera2.projectionMatrix.array);
  blurPass2.setUniform("projection", camera2.projectionMatrix.array);
  frameBuffer.attach(ssrTexture);
  frameBuffer.bind(renderer);
  ssrPass.render(renderer);
  if (this._physicallyCorrect) {
    frameBuffer.attach(this._currentTexture);
    blendPass.setUniform("texture1", this._prevTexture);
    blendPass.setUniform("texture2", ssrTexture);
    blendPass.material.set({
      "weight1": frame >= 1 ? 0.95 : 0,
      "weight2": frame >= 1 ? 0.05 : 1
    });
    blendPass.render(renderer);
  }
  frameBuffer.attach(texture2);
  blurPass1.setUniform("texture", this._physicallyCorrect ? this._currentTexture : ssrTexture);
  blurPass1.render(renderer);
  frameBuffer.attach(texture3);
  blurPass2.setUniform("texture", texture2);
  blurPass2.render(renderer);
  frameBuffer.unbind(renderer);
  if (this._physicallyCorrect) {
    var tmp = this._prevTexture;
    this._prevTexture = this._currentTexture;
    this._currentTexture = tmp;
  }
};
SSRPass.prototype.getTargetTexture = function() {
  return this._texture3;
};
SSRPass.prototype.setParameter = function(name, val) {
  if (name === "maxIteration") {
    this._ssrPass.material.define("fragment", "MAX_ITERATION", val);
  } else {
    this._ssrPass.setUniform(name, val);
  }
};
SSRPass.prototype.setPhysicallyCorrect = function(isPhysicallyCorrect) {
  if (isPhysicallyCorrect) {
    if (!this._normalDistribution) {
      this._normalDistribution = cubemapUtil$1.generateNormalDistribution(64, this._totalSamples);
    }
    this._ssrPass.material.define("fragment", "PHYSICALLY_CORRECT");
    this._ssrPass.material.set("normalDistribution", this._normalDistribution);
    this._ssrPass.material.set("normalDistributionSize", [64, this._totalSamples]);
  } else {
    this._ssrPass.material.undefine("fragment", "PHYSICALLY_CORRECT");
  }
  this._physicallyCorrect = isPhysicallyCorrect;
};
SSRPass.prototype.setSSAOTexture = function(texture) {
  var blendPass = this._blurPass2;
  if (texture) {
    blendPass.material.enableTexture("ssaoTex");
    blendPass.material.set("ssaoTex", texture);
  } else {
    blendPass.material.disableTexture("ssaoTex");
  }
};
SSRPass.prototype.isFinished = function(frame) {
  if (this._physicallyCorrect) {
    return frame > this._totalSamples / this._samplePerFrame;
  } else {
    return true;
  }
};
SSRPass.prototype.dispose = function(renderer) {
  this._ssrTexture.dispose(renderer);
  this._texture2.dispose(renderer);
  this._texture3.dispose(renderer);
  this._prevTexture.dispose(renderer);
  this._currentTexture.dispose(renderer);
  this._frameBuffer.dispose(renderer);
};
var poissonKernel = [0, 0, -0.321585265978, -0.154972575841, 0.458126042375, 0.188473391593, 0.842080129861, 0.527766490688, 0.147304551086, -0.659453822776, -0.331943915203, -0.940619700594, 0.0479226680259, 0.54812163202, 0.701581552186, -0.709825561388, -0.295436780218, 0.940589268233, -0.901489676764, 0.237713156085, 0.973570876096, -0.109899459384, -0.866792314779, -0.451805525005, 0.330975007087, 0.800048655954, -0.344275183665, 0.381779221166, -0.386139432542, -0.437418421534, -0.576478634965, -0.0148463392551, 0.385798197415, -0.262426961053, -0.666302061145, 0.682427250835, -0.628010632582, -0.732836215494, 0.10163141741, -0.987658134403, 0.711995289051, -0.320024291314, 0.0296005138058, 0.950296523438, 0.0130612307608, -0.351024443122, -0.879596633704, -0.10478487883, 0.435712737232, 0.504254490347, 0.779203817497, 0.206477676721, 0.388264289969, -0.896736162545, -0.153106280781, -0.629203242522, -0.245517550697, 0.657969239148, 0.126830499058, 0.26862328493, -0.634888119007, -0.302301223431, 0.617074219636, 0.779817204925];
var normalGLSL = "@export ecgl.normal.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n@import ecgl.common.attributes\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\n@import ecgl.common.normalMap.vertexHeader\n\n@import ecgl.common.vertexAnimation.header\n\nvoid main()\n{\n\n @import ecgl.common.vertexAnimation.main\n\n @import ecgl.common.uv.main\n\n v_Normal = normalize((worldInverseTranspose * vec4(normal, 0.0)).xyz);\n v_WorldPosition = (world * vec4(pos, 1.0)).xyz;\n\n @import ecgl.common.normalMap.vertexMain\n\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n\n}\n\n\n@end\n\n\n@export ecgl.normal.fragment\n\n#define ROUGHNESS_CHANEL 0\n\nuniform bool useBumpMap;\nuniform bool useRoughnessMap;\nuniform bool doubleSide;\nuniform float roughness;\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform mat4 viewInverse : VIEWINVERSE;\n\n@import ecgl.common.normalMap.fragmentHeader\n@import ecgl.common.bumpMap.header\n\nuniform sampler2D roughnessMap;\n\nvoid main()\n{\n vec3 N = v_Normal;\n \n bool flipNormal = false;\n if (doubleSide) {\n vec3 eyePos = viewInverse[3].xyz;\n vec3 V = normalize(eyePos - v_WorldPosition);\n\n if (dot(N, V) < 0.0) {\n flipNormal = true;\n }\n }\n\n @import ecgl.common.normalMap.fragmentMain\n\n if (useBumpMap) {\n N = bumpNormal(v_WorldPosition, v_Normal, N);\n }\n\n float g = 1.0 - roughness;\n\n if (useRoughnessMap) {\n float g2 = 1.0 - texture2D(roughnessMap, v_DetailTexcoord)[ROUGHNESS_CHANEL];\n g = clamp(g2 + (g - 0.5) * 2.0, 0.0, 1.0);\n }\n\n if (flipNormal) {\n N = -N;\n }\n\n gl_FragColor.rgb = (N.xyz + 1.0) * 0.5;\n gl_FragColor.a = g;\n}\n@end";
Shader.import(normalGLSL);
function attachTextureToSlot(renderer, program, symbol, texture, slot) {
  var gl = renderer.gl;
  program.setUniform(gl, "1i", symbol, slot);
  gl.activeTexture(gl.TEXTURE0 + slot);
  if (texture.isRenderable()) {
    texture.bind(renderer);
  } else {
    texture.unbind(renderer);
  }
}
function getBeforeRenderHook(renderer, defaultNormalMap, defaultBumpMap, defaultRoughnessMap, normalMaterial) {
  var previousNormalMap;
  var previousBumpMap;
  var previousRoughnessMap;
  var previousRenderable;
  var gl = renderer.gl;
  return function(renderable, normalMaterial2, prevNormalMaterial) {
    if (previousRenderable && previousRenderable.material === renderable.material) {
      return;
    }
    var material = renderable.material;
    var program = renderable.__program;
    var roughness = material.get("roughness");
    if (roughness == null) {
      roughness = 1;
    }
    var normalMap = material.get("normalMap") || defaultNormalMap;
    var roughnessMap = material.get("roughnessMap");
    var bumpMap = material.get("bumpMap");
    var uvRepeat = material.get("uvRepeat");
    var uvOffset = material.get("uvOffset");
    var detailUvRepeat = material.get("detailUvRepeat");
    var detailUvOffset = material.get("detailUvOffset");
    var useBumpMap = !!bumpMap && material.isTextureEnabled("bumpMap");
    var useRoughnessMap = !!roughnessMap && material.isTextureEnabled("roughnessMap");
    var doubleSide = material.isDefined("fragment", "DOUBLE_SIDED");
    bumpMap = bumpMap || defaultBumpMap;
    roughnessMap = roughnessMap || defaultRoughnessMap;
    if (prevNormalMaterial !== normalMaterial2) {
      normalMaterial2.set("normalMap", normalMap);
      normalMaterial2.set("bumpMap", bumpMap);
      normalMaterial2.set("roughnessMap", roughnessMap);
      normalMaterial2.set("useBumpMap", useBumpMap);
      normalMaterial2.set("useRoughnessMap", useRoughnessMap);
      normalMaterial2.set("doubleSide", doubleSide);
      uvRepeat != null && normalMaterial2.set("uvRepeat", uvRepeat);
      uvOffset != null && normalMaterial2.set("uvOffset", uvOffset);
      detailUvRepeat != null && normalMaterial2.set("detailUvRepeat", detailUvRepeat);
      detailUvOffset != null && normalMaterial2.set("detailUvOffset", detailUvOffset);
      normalMaterial2.set("roughness", roughness);
    } else {
      program.setUniform(gl, "1f", "roughness", roughness);
      if (previousNormalMap !== normalMap) {
        attachTextureToSlot(renderer, program, "normalMap", normalMap, 0);
      }
      if (previousBumpMap !== bumpMap && bumpMap) {
        attachTextureToSlot(renderer, program, "bumpMap", bumpMap, 1);
      }
      if (previousRoughnessMap !== roughnessMap && roughnessMap) {
        attachTextureToSlot(renderer, program, "roughnessMap", roughnessMap, 2);
      }
      if (uvRepeat != null) {
        program.setUniform(gl, "2f", "uvRepeat", uvRepeat);
      }
      if (uvOffset != null) {
        program.setUniform(gl, "2f", "uvOffset", uvOffset);
      }
      if (detailUvRepeat != null) {
        program.setUniform(gl, "2f", "detailUvRepeat", detailUvRepeat);
      }
      if (detailUvOffset != null) {
        program.setUniform(gl, "2f", "detailUvOffset", detailUvOffset);
      }
      program.setUniform(gl, "1i", "useBumpMap", +useBumpMap);
      program.setUniform(gl, "1i", "useRoughnessMap", +useRoughnessMap);
      program.setUniform(gl, "1i", "doubleSide", +doubleSide);
    }
    previousNormalMap = normalMap;
    previousBumpMap = bumpMap;
    previousRoughnessMap = roughnessMap;
    previousRenderable = renderable;
  };
}
function NormalPass(opt) {
  this._depthTex = new Texture2D$1({
    format: Texture$1.DEPTH_COMPONENT,
    type: Texture$1.UNSIGNED_INT
  });
  this._normalTex = new Texture2D$1({
    type: Texture$1.HALF_FLOAT
  });
  this._framebuffer = new FrameBuffer$1();
  this._framebuffer.attach(this._normalTex);
  this._framebuffer.attach(this._depthTex, FrameBuffer$1.DEPTH_ATTACHMENT);
  this._normalMaterial = new Material$1({
    shader: new Shader(Shader.source("ecgl.normal.vertex"), Shader.source("ecgl.normal.fragment"))
  });
  this._normalMaterial.enableTexture(["normalMap", "bumpMap", "roughnessMap"]);
  this._defaultNormalMap = textureUtil$1.createBlank("#000");
  this._defaultBumpMap = textureUtil$1.createBlank("#000");
  this._defaultRoughessMap = textureUtil$1.createBlank("#000");
  this._debugPass = new Pass$1({
    fragment: Shader.source("clay.compositor.output")
  });
  this._debugPass.setUniform("texture", this._normalTex);
  this._debugPass.material.undefine("fragment", "OUTPUT_ALPHA");
}
NormalPass.prototype.getDepthTexture = function() {
  return this._depthTex;
};
NormalPass.prototype.getNormalTexture = function() {
  return this._normalTex;
};
NormalPass.prototype.update = function(renderer, scene, camera2) {
  var width = renderer.getWidth();
  var height = renderer.getHeight();
  var depthTexture = this._depthTex;
  var normalTexture = this._normalTex;
  var normalMaterial = this._normalMaterial;
  depthTexture.width = width;
  depthTexture.height = height;
  normalTexture.width = width;
  normalTexture.height = height;
  var opaqueList = scene.getRenderList(camera2).opaque;
  this._framebuffer.bind(renderer);
  renderer.gl.clearColor(0, 0, 0, 0);
  renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT | renderer.gl.DEPTH_BUFFER_BIT);
  renderer.gl.disable(renderer.gl.BLEND);
  renderer.renderPass(opaqueList, camera2, {
    getMaterial: function() {
      return normalMaterial;
    },
    ifRender: function(object) {
      return object.renderNormal;
    },
    beforeRender: getBeforeRenderHook(renderer, this._defaultNormalMap, this._defaultBumpMap, this._defaultRoughessMap, this._normalMaterial),
    sort: renderer.opaqueSortCompare
  });
  this._framebuffer.unbind(renderer);
};
NormalPass.prototype.renderDebug = function(renderer) {
  this._debugPass.render(renderer);
};
NormalPass.prototype.dispose = function(renderer) {
  this._depthTex.dispose(renderer);
  this._normalTex.dispose(renderer);
};
function EdgePass(opt) {
  opt = opt || {};
  this._edgePass = new Pass$1({
    fragment: Shader.source("ecgl.edge")
  });
  this._edgePass.setUniform("normalTexture", opt.normalTexture);
  this._edgePass.setUniform("depthTexture", opt.depthTexture);
  this._targetTexture = new Texture2D$1({
    type: Texture$1.HALF_FLOAT
  });
  this._frameBuffer = new FrameBuffer$1();
  this._frameBuffer.attach(this._targetTexture);
}
EdgePass.prototype.update = function(renderer, camera2, sourceTexture, frame) {
  var width = renderer.getWidth();
  var height = renderer.getHeight();
  var texture = this._targetTexture;
  texture.width = width;
  texture.height = height;
  var frameBuffer = this._frameBuffer;
  frameBuffer.bind(renderer);
  this._edgePass.setUniform("projectionInv", camera2.invProjectionMatrix.array);
  this._edgePass.setUniform("textureSize", [width, height]);
  this._edgePass.setUniform("texture", sourceTexture);
  this._edgePass.render(renderer);
  frameBuffer.unbind(renderer);
};
EdgePass.prototype.getTargetTexture = function() {
  return this._targetTexture;
};
EdgePass.prototype.setParameter = function(name, val) {
  this._edgePass.setUniform(name, val);
};
EdgePass.prototype.dispose = function(renderer) {
  this._targetTexture.dispose(renderer);
  this._frameBuffer.dispose(renderer);
};
var effectJson = {
  "type": "compositor",
  "nodes": [{
    "name": "source",
    "type": "texture",
    "outputs": {
      "color": {}
    }
  }, {
    "name": "source_half",
    "shader": "#source(clay.compositor.downsample)",
    "inputs": {
      "texture": "source"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 2)",
          "height": "expr(height * 1.0 / 2)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "textureSize": "expr( [width * 1.0, height * 1.0] )"
    }
  }, {
    "name": "bright",
    "shader": "#source(clay.compositor.bright)",
    "inputs": {
      "texture": "source_half"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 2)",
          "height": "expr(height * 1.0 / 2)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "threshold": 2,
      "scale": 4,
      "textureSize": "expr([width * 1.0 / 2, height / 2])"
    }
  }, {
    "name": "bright_downsample_4",
    "shader": "#source(clay.compositor.downsample)",
    "inputs": {
      "texture": "bright"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 4)",
          "height": "expr(height * 1.0 / 4)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "textureSize": "expr( [width * 1.0 / 2, height / 2] )"
    }
  }, {
    "name": "bright_downsample_8",
    "shader": "#source(clay.compositor.downsample)",
    "inputs": {
      "texture": "bright_downsample_4"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 8)",
          "height": "expr(height * 1.0 / 8)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "textureSize": "expr( [width * 1.0 / 4, height / 4] )"
    }
  }, {
    "name": "bright_downsample_16",
    "shader": "#source(clay.compositor.downsample)",
    "inputs": {
      "texture": "bright_downsample_8"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 16)",
          "height": "expr(height * 1.0 / 16)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "textureSize": "expr( [width * 1.0 / 8, height / 8] )"
    }
  }, {
    "name": "bright_downsample_32",
    "shader": "#source(clay.compositor.downsample)",
    "inputs": {
      "texture": "bright_downsample_16"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 32)",
          "height": "expr(height * 1.0 / 32)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "textureSize": "expr( [width * 1.0 / 16, height / 16] )"
    }
  }, {
    "name": "bright_upsample_16_blur_h",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_downsample_32"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 16)",
          "height": "expr(height * 1.0 / 16)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 0,
      "textureSize": "expr( [width * 1.0 / 32, height / 32] )"
    }
  }, {
    "name": "bright_upsample_16_blur_v",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_upsample_16_blur_h"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 16)",
          "height": "expr(height * 1.0 / 16)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 1,
      "textureSize": "expr( [width * 1.0 / 16, height * 1.0 / 16] )"
    }
  }, {
    "name": "bright_upsample_8_blur_h",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_downsample_16"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 8)",
          "height": "expr(height * 1.0 / 8)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 0,
      "textureSize": "expr( [width * 1.0 / 16, height * 1.0 / 16] )"
    }
  }, {
    "name": "bright_upsample_8_blur_v",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_upsample_8_blur_h"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 8)",
          "height": "expr(height * 1.0 / 8)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 1,
      "textureSize": "expr( [width * 1.0 / 8, height * 1.0 / 8] )"
    }
  }, {
    "name": "bright_upsample_8_blend",
    "shader": "#source(clay.compositor.blend)",
    "inputs": {
      "texture1": "bright_upsample_8_blur_v",
      "texture2": "bright_upsample_16_blur_v"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 8)",
          "height": "expr(height * 1.0 / 8)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "weight1": 0.3,
      "weight2": 0.7
    }
  }, {
    "name": "bright_upsample_4_blur_h",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_downsample_8"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 4)",
          "height": "expr(height * 1.0 / 4)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 0,
      "textureSize": "expr( [width * 1.0 / 8, height * 1.0 / 8] )"
    }
  }, {
    "name": "bright_upsample_4_blur_v",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_upsample_4_blur_h"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 4)",
          "height": "expr(height * 1.0 / 4)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 1,
      "textureSize": "expr( [width * 1.0 / 4, height * 1.0 / 4] )"
    }
  }, {
    "name": "bright_upsample_4_blend",
    "shader": "#source(clay.compositor.blend)",
    "inputs": {
      "texture1": "bright_upsample_4_blur_v",
      "texture2": "bright_upsample_8_blend"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 4)",
          "height": "expr(height * 1.0 / 4)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "weight1": 0.3,
      "weight2": 0.7
    }
  }, {
    "name": "bright_upsample_2_blur_h",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_downsample_4"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 2)",
          "height": "expr(height * 1.0 / 2)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 0,
      "textureSize": "expr( [width * 1.0 / 4, height * 1.0 / 4] )"
    }
  }, {
    "name": "bright_upsample_2_blur_v",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_upsample_2_blur_h"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 2)",
          "height": "expr(height * 1.0 / 2)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 1,
      "textureSize": "expr( [width * 1.0 / 2, height * 1.0 / 2] )"
    }
  }, {
    "name": "bright_upsample_2_blend",
    "shader": "#source(clay.compositor.blend)",
    "inputs": {
      "texture1": "bright_upsample_2_blur_v",
      "texture2": "bright_upsample_4_blend"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0 / 2)",
          "height": "expr(height * 1.0 / 2)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "weight1": 0.3,
      "weight2": 0.7
    }
  }, {
    "name": "bright_upsample_full_blur_h",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 0,
      "textureSize": "expr( [width * 1.0 / 2, height * 1.0 / 2] )"
    }
  }, {
    "name": "bright_upsample_full_blur_v",
    "shader": "#source(clay.compositor.gaussian_blur)",
    "inputs": {
      "texture": "bright_upsample_full_blur_h"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "blurSize": 1,
      "blurDir": 1,
      "textureSize": "expr( [width * 1.0, height * 1.0] )"
    }
  }, {
    "name": "bloom_composite",
    "shader": "#source(clay.compositor.blend)",
    "inputs": {
      "texture1": "bright_upsample_full_blur_v",
      "texture2": "bright_upsample_2_blend"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "weight1": 0.3,
      "weight2": 0.7
    }
  }, {
    "name": "coc",
    "shader": "#source(ecgl.dof.coc)",
    "outputs": {
      "color": {
        "parameters": {
          "minFilter": "NEAREST",
          "magFilter": "NEAREST",
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)"
        }
      }
    },
    "parameters": {
      "focalDist": 50,
      "focalRange": 30
    }
  }, {
    "name": "dof_far_blur",
    "shader": "#source(ecgl.dof.diskBlur)",
    "inputs": {
      "texture": "source",
      "coc": "coc"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "textureSize": "expr( [width * 1.0, height * 1.0] )"
    }
  }, {
    "name": "dof_near_blur",
    "shader": "#source(ecgl.dof.diskBlur)",
    "inputs": {
      "texture": "source",
      "coc": "coc"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)",
          "type": "HALF_FLOAT"
        }
      }
    },
    "parameters": {
      "textureSize": "expr( [width * 1.0, height * 1.0] )"
    },
    "defines": {
      "BLUR_NEARFIELD": null
    }
  }, {
    "name": "dof_coc_blur",
    "shader": "#source(ecgl.dof.diskBlur)",
    "inputs": {
      "texture": "coc"
    },
    "outputs": {
      "color": {
        "parameters": {
          "minFilter": "NEAREST",
          "magFilter": "NEAREST",
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)"
        }
      }
    },
    "parameters": {
      "textureSize": "expr( [width * 1.0, height * 1.0] )"
    },
    "defines": {
      "BLUR_COC": null
    }
  }, {
    "name": "dof_composite",
    "shader": "#source(ecgl.dof.composite)",
    "inputs": {
      "original": "source",
      "blurred": "dof_far_blur",
      "nearfield": "dof_near_blur",
      "coc": "coc",
      "nearcoc": "dof_coc_blur"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)",
          "type": "HALF_FLOAT"
        }
      }
    }
  }, {
    "name": "composite",
    "shader": "#source(clay.compositor.hdr.composite)",
    "inputs": {
      "texture": "source",
      "bloom": "bloom_composite"
    },
    "outputs": {
      "color": {
        "parameters": {
          "width": "expr(width * 1.0)",
          "height": "expr(height * 1.0)"
        }
      }
    },
    "defines": {}
  }, {
    "name": "FXAA",
    "shader": "#source(clay.compositor.fxaa)",
    "inputs": {
      "texture": "composite"
    }
  }]
};
var DOFCode = "@export ecgl.dof.coc\n\nuniform sampler2D depth;\n\nuniform float zNear: 0.1;\nuniform float zFar: 2000;\n\nuniform float focalDistance: 3;\nuniform float focalRange: 1;\nuniform float focalLength: 30;\nuniform float fstop: 2.8;\n\nvarying vec2 v_Texcoord;\n\n@import clay.util.encode_float\n\nvoid main()\n{\n float z = texture2D(depth, v_Texcoord).r * 2.0 - 1.0;\n\n float dist = 2.0 * zNear * zFar / (zFar + zNear - z * (zFar - zNear));\n\n float aperture = focalLength / fstop;\n\n float coc;\n\n float uppper = focalDistance + focalRange;\n float lower = focalDistance - focalRange;\n if (dist <= uppper && dist >= lower) {\n coc = 0.5;\n }\n else {\n float focalAdjusted = dist > uppper ? uppper : lower;\n\n coc = abs(aperture * (focalLength * (dist - focalAdjusted)) / (dist * (focalAdjusted - focalLength)));\n coc = clamp(coc, 0.0, 2.0) / 2.00001;\n\n if (dist < lower) {\n coc = -coc;\n }\n coc = coc * 0.5 + 0.5;\n }\n\n gl_FragColor = encodeFloat(coc);\n}\n@end\n\n\n@export ecgl.dof.composite\n\n#define DEBUG 0\n\nuniform sampler2D original;\nuniform sampler2D blurred;\nuniform sampler2D nearfield;\nuniform sampler2D coc;\nuniform sampler2D nearcoc;\nvarying vec2 v_Texcoord;\n\n@import clay.util.rgbm\n@import clay.util.float\n\nvoid main()\n{\n vec4 blurredColor = texture2D(blurred, v_Texcoord);\n vec4 originalColor = texture2D(original, v_Texcoord);\n\n float fCoc = decodeFloat(texture2D(coc, v_Texcoord));\n\n fCoc = abs(fCoc * 2.0 - 1.0);\n\n float weight = smoothstep(0.0, 1.0, fCoc);\n \n#ifdef NEARFIELD_ENABLED\n vec4 nearfieldColor = texture2D(nearfield, v_Texcoord);\n float fNearCoc = decodeFloat(texture2D(nearcoc, v_Texcoord));\n fNearCoc = abs(fNearCoc * 2.0 - 1.0);\n\n gl_FragColor = encodeHDR(\n mix(\n nearfieldColor, mix(originalColor, blurredColor, weight),\n pow(1.0 - fNearCoc, 4.0)\n )\n );\n#else\n gl_FragColor = encodeHDR(mix(originalColor, blurredColor, weight));\n#endif\n\n}\n\n@end\n\n\n\n@export ecgl.dof.diskBlur\n\n#define POISSON_KERNEL_SIZE 16;\n\nuniform sampler2D texture;\nuniform sampler2D coc;\nvarying vec2 v_Texcoord;\n\nuniform float blurRadius : 10.0;\nuniform vec2 textureSize : [512.0, 512.0];\n\nuniform vec2 poissonKernel[POISSON_KERNEL_SIZE];\n\nuniform float percent;\n\nfloat nrand(const in vec2 n) {\n return fract(sin(dot(n.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n@import clay.util.rgbm\n@import clay.util.float\n\n\nvoid main()\n{\n vec2 offset = blurRadius / textureSize;\n\n float rnd = 6.28318 * nrand(v_Texcoord + 0.07 * percent );\n float cosa = cos(rnd);\n float sina = sin(rnd);\n vec4 basis = vec4(cosa, -sina, sina, cosa);\n\n#if !defined(BLUR_NEARFIELD) && !defined(BLUR_COC)\n offset *= abs(decodeFloat(texture2D(coc, v_Texcoord)) * 2.0 - 1.0);\n#endif\n\n#ifdef BLUR_COC\n float cocSum = 0.0;\n#else\n vec4 color = vec4(0.0);\n#endif\n\n\n float weightSum = 0.0;\n\n for (int i = 0; i < POISSON_KERNEL_SIZE; i++) {\n vec2 ofs = poissonKernel[i];\n\n ofs = vec2(dot(ofs, basis.xy), dot(ofs, basis.zw));\n\n vec2 uv = v_Texcoord + ofs * offset;\n vec4 texel = texture2D(texture, uv);\n\n float w = 1.0;\n#ifdef BLUR_COC\n float fCoc = decodeFloat(texel) * 2.0 - 1.0;\n cocSum += clamp(fCoc, -1.0, 0.0) * w;\n#else\n texel = texel;\n #if !defined(BLUR_NEARFIELD)\n float fCoc = decodeFloat(texture2D(coc, uv)) * 2.0 - 1.0;\n w *= abs(fCoc);\n #endif\n texel.rgb *= texel.a;\n color += texel * w;\n#endif\n\n weightSum += w;\n }\n\n#ifdef BLUR_COC\n gl_FragColor = encodeFloat(clamp(cocSum / weightSum, -1.0, 0.0) * 0.5 + 0.5);\n#else\n color /= weightSum;\n color.rgb /= (color.a + 0.0001);\n gl_FragColor = color;\n#endif\n}\n\n@end";
var edgeCode = "@export ecgl.edge\n\nuniform sampler2D texture;\n\nuniform sampler2D normalTexture;\nuniform sampler2D depthTexture;\n\nuniform mat4 projectionInv;\n\nuniform vec2 textureSize;\n\nuniform vec4 edgeColor: [0,0,0,0.8];\n\nvarying vec2 v_Texcoord;\n\nvec3 packColor(vec2 coord) {\n float z = texture2D(depthTexture, coord).r * 2.0 - 1.0;\n vec4 p = vec4(v_Texcoord * 2.0 - 1.0, z, 1.0);\n vec4 p4 = projectionInv * p;\n\n return vec3(\n texture2D(normalTexture, coord).rg,\n -p4.z / p4.w / 5.0\n );\n}\n\nvoid main() {\n vec2 cc = v_Texcoord;\n vec3 center = packColor(cc);\n\n float size = clamp(1.0 - (center.z - 10.0) / 100.0, 0.0, 1.0) * 0.5;\n float dx = size / textureSize.x;\n float dy = size / textureSize.y;\n\n vec2 coord;\n vec3 topLeft = packColor(cc+vec2(-dx, -dy));\n vec3 top = packColor(cc+vec2(0.0, -dy));\n vec3 topRight = packColor(cc+vec2(dx, -dy));\n vec3 left = packColor(cc+vec2(-dx, 0.0));\n vec3 right = packColor(cc+vec2(dx, 0.0));\n vec3 bottomLeft = packColor(cc+vec2(-dx, dy));\n vec3 bottom = packColor(cc+vec2(0.0, dy));\n vec3 bottomRight = packColor(cc+vec2(dx, dy));\n\n vec3 v = -topLeft-2.0*top-topRight+bottomLeft+2.0*bottom+bottomRight;\n vec3 h = -bottomLeft-2.0*left-topLeft+bottomRight+2.0*right+topRight;\n\n float edge = sqrt(dot(h, h) + dot(v, v));\n\n edge = smoothstep(0.8, 1.0, edge);\n\n gl_FragColor = mix(texture2D(texture, v_Texcoord), vec4(edgeColor.rgb, 1.0), edgeColor.a * edge);\n}\n@end";
Shader["import"](blurCode);
Shader["import"](lutCode);
Shader["import"](outputCode);
Shader["import"](brightCode);
Shader["import"](downsampleCode);
Shader["import"](upsampleCode);
Shader["import"](hdrCode);
Shader["import"](blendCode);
Shader["import"](fxaaCode);
Shader["import"](DOFCode);
Shader["import"](edgeCode);
function makeCommonOutputs(getWidth2, getHeight) {
  return {
    color: {
      parameters: {
        width: getWidth2,
        height: getHeight
      }
    }
  };
}
var FINAL_NODES_CHAIN = ["composite", "FXAA"];
function EffectCompositor() {
  this._width;
  this._height;
  this._dpr;
  this._sourceTexture = new Texture2D$1({
    type: Texture$1.HALF_FLOAT
  });
  this._depthTexture = new Texture2D$1({
    format: Texture$1.DEPTH_COMPONENT,
    type: Texture$1.UNSIGNED_INT
  });
  this._framebuffer = new FrameBuffer$1();
  this._framebuffer.attach(this._sourceTexture);
  this._framebuffer.attach(this._depthTexture, FrameBuffer$1.DEPTH_ATTACHMENT);
  this._normalPass = new NormalPass();
  this._compositor = createCompositor(effectJson);
  var sourceNode = this._compositor.getNodeByName("source");
  sourceNode.texture = this._sourceTexture;
  var cocNode = this._compositor.getNodeByName("coc");
  this._sourceNode = sourceNode;
  this._cocNode = cocNode;
  this._compositeNode = this._compositor.getNodeByName("composite");
  this._fxaaNode = this._compositor.getNodeByName("FXAA");
  this._dofBlurNodes = ["dof_far_blur", "dof_near_blur", "dof_coc_blur"].map(function(name) {
    return this._compositor.getNodeByName(name);
  }, this);
  this._dofBlurKernel = 0;
  this._dofBlurKernelSize = new Float32Array(0);
  this._finalNodesChain = FINAL_NODES_CHAIN.map(function(name) {
    return this._compositor.getNodeByName(name);
  }, this);
  var gBufferObj = {
    normalTexture: this._normalPass.getNormalTexture(),
    depthTexture: this._normalPass.getDepthTexture()
  };
  this._ssaoPass = new SSAOPass(gBufferObj);
  this._ssrPass = new SSRPass(gBufferObj);
  this._edgePass = new EdgePass(gBufferObj);
}
EffectCompositor.prototype.resize = function(width, height, dpr2) {
  dpr2 = dpr2 || 1;
  var width = width * dpr2;
  var height = height * dpr2;
  var sourceTexture = this._sourceTexture;
  var depthTexture = this._depthTexture;
  sourceTexture.width = width;
  sourceTexture.height = height;
  depthTexture.width = width;
  depthTexture.height = height;
  var rendererMock = {
    getWidth: function() {
      return width;
    },
    getHeight: function() {
      return height;
    },
    getDevicePixelRatio: function() {
      return dpr2;
    }
  };
  function wrapCallback(obj, key) {
    if (typeof obj[key] === "function") {
      var oldFunc = obj[key].__original || obj[key];
      obj[key] = function(renderer) {
        return oldFunc.call(this, rendererMock);
      };
      obj[key].__original = oldFunc;
    }
  }
  this._compositor.nodes.forEach(function(node) {
    for (var outKey in node.outputs) {
      var parameters = node.outputs[outKey].parameters;
      if (parameters) {
        wrapCallback(parameters, "width");
        wrapCallback(parameters, "height");
      }
    }
    for (var paramKey in node.parameters) {
      wrapCallback(node.parameters, paramKey);
    }
  });
  this._width = width;
  this._height = height;
  this._dpr = dpr2;
};
EffectCompositor.prototype.getWidth = function() {
  return this._width;
};
EffectCompositor.prototype.getHeight = function() {
  return this._height;
};
EffectCompositor.prototype._ifRenderNormalPass = function() {
  return this._enableSSAO || this._enableEdge || this._enableSSR;
};
EffectCompositor.prototype._getPrevNode = function(node) {
  var idx = FINAL_NODES_CHAIN.indexOf(node.name) - 1;
  var prevNode = this._finalNodesChain[idx];
  while (prevNode && !this._compositor.getNodeByName(prevNode.name)) {
    idx -= 1;
    prevNode = this._finalNodesChain[idx];
  }
  return prevNode;
};
EffectCompositor.prototype._getNextNode = function(node) {
  var idx = FINAL_NODES_CHAIN.indexOf(node.name) + 1;
  var nextNode = this._finalNodesChain[idx];
  while (nextNode && !this._compositor.getNodeByName(nextNode.name)) {
    idx += 1;
    nextNode = this._finalNodesChain[idx];
  }
  return nextNode;
};
EffectCompositor.prototype._addChainNode = function(node) {
  var prevNode = this._getPrevNode(node);
  var nextNode = this._getNextNode(node);
  if (!prevNode) {
    return;
  }
  node.inputs.texture = prevNode.name;
  if (nextNode) {
    node.outputs = makeCommonOutputs(this.getWidth.bind(this), this.getHeight.bind(this));
    nextNode.inputs.texture = node.name;
  } else {
    node.outputs = null;
  }
  this._compositor.addNode(node);
};
EffectCompositor.prototype._removeChainNode = function(node) {
  var prevNode = this._getPrevNode(node);
  var nextNode = this._getNextNode(node);
  if (!prevNode) {
    return;
  }
  if (nextNode) {
    prevNode.outputs = makeCommonOutputs(this.getWidth.bind(this), this.getHeight.bind(this));
    nextNode.inputs.texture = prevNode.name;
  } else {
    prevNode.outputs = null;
  }
  this._compositor.removeNode(node);
};
EffectCompositor.prototype.updateNormal = function(renderer, scene, camera2, frame) {
  if (this._ifRenderNormalPass()) {
    this._normalPass.update(renderer, scene, camera2);
  }
};
EffectCompositor.prototype.updateSSAO = function(renderer, scene, camera2, frame) {
  this._ssaoPass.update(renderer, camera2, frame);
};
EffectCompositor.prototype.enableSSAO = function() {
  this._enableSSAO = true;
};
EffectCompositor.prototype.disableSSAO = function() {
  this._enableSSAO = false;
};
EffectCompositor.prototype.enableSSR = function() {
  this._enableSSR = true;
};
EffectCompositor.prototype.disableSSR = function() {
  this._enableSSR = false;
};
EffectCompositor.prototype.getSSAOTexture = function() {
  return this._ssaoPass.getTargetTexture();
};
EffectCompositor.prototype.getSourceFrameBuffer = function() {
  return this._framebuffer;
};
EffectCompositor.prototype.getSourceTexture = function() {
  return this._sourceTexture;
};
EffectCompositor.prototype.disableFXAA = function() {
  this._removeChainNode(this._fxaaNode);
};
EffectCompositor.prototype.enableFXAA = function() {
  this._addChainNode(this._fxaaNode);
};
EffectCompositor.prototype.enableBloom = function() {
  this._compositeNode.inputs.bloom = "bloom_composite";
  this._compositor.dirty();
};
EffectCompositor.prototype.disableBloom = function() {
  this._compositeNode.inputs.bloom = null;
  this._compositor.dirty();
};
EffectCompositor.prototype.enableDOF = function() {
  this._compositeNode.inputs.texture = "dof_composite";
  this._compositor.dirty();
};
EffectCompositor.prototype.disableDOF = function() {
  this._compositeNode.inputs.texture = "source";
  this._compositor.dirty();
};
EffectCompositor.prototype.enableColorCorrection = function() {
  this._compositeNode.define("COLOR_CORRECTION");
  this._enableColorCorrection = true;
};
EffectCompositor.prototype.disableColorCorrection = function() {
  this._compositeNode.undefine("COLOR_CORRECTION");
  this._enableColorCorrection = false;
};
EffectCompositor.prototype.enableEdge = function() {
  this._enableEdge = true;
};
EffectCompositor.prototype.disableEdge = function() {
  this._enableEdge = false;
};
EffectCompositor.prototype.setBloomIntensity = function(value) {
  this._compositeNode.setParameter("bloomIntensity", value);
};
EffectCompositor.prototype.setSSAOParameter = function(name, value) {
  switch (name) {
    case "quality":
      var kernelSize = {
        low: 6,
        medium: 12,
        high: 32,
        ultra: 62
      }[value] || 12;
      this._ssaoPass.setParameter("kernelSize", kernelSize);
      break;
    case "radius":
      this._ssaoPass.setParameter(name, value);
      this._ssaoPass.setParameter("bias", value / 200);
      break;
    case "intensity":
      this._ssaoPass.setParameter(name, value);
      break;
  }
};
EffectCompositor.prototype.setDOFParameter = function(name, value) {
  switch (name) {
    case "focalDistance":
    case "focalRange":
    case "fstop":
      this._cocNode.setParameter(name, value);
      break;
    case "blurRadius":
      for (var i = 0; i < this._dofBlurNodes.length; i++) {
        this._dofBlurNodes[i].setParameter("blurRadius", value);
      }
      break;
    case "quality":
      var kernelSize = {
        low: 4,
        medium: 8,
        high: 16,
        ultra: 32
      }[value] || 8;
      this._dofBlurKernelSize = kernelSize;
      for (var i = 0; i < this._dofBlurNodes.length; i++) {
        this._dofBlurNodes[i].pass.material.define("POISSON_KERNEL_SIZE", kernelSize);
      }
      this._dofBlurKernel = new Float32Array(kernelSize * 2);
      break;
  }
};
EffectCompositor.prototype.setSSRParameter = function(name, value) {
  if (value == null) {
    return;
  }
  switch (name) {
    case "quality":
      var maxIteration = {
        low: 10,
        medium: 15,
        high: 30,
        ultra: 80
      }[value] || 20;
      var pixelStride = {
        low: 32,
        medium: 16,
        high: 8,
        ultra: 4
      }[value] || 16;
      this._ssrPass.setParameter("maxIteration", maxIteration);
      this._ssrPass.setParameter("pixelStride", pixelStride);
      break;
    case "maxRoughness":
      this._ssrPass.setParameter("minGlossiness", Math.max(Math.min(1 - value, 1), 0));
      break;
    case "physical":
      this.setPhysicallyCorrectSSR(value);
      break;
    default:
      console.warn("Unkown SSR parameter " + name);
  }
};
EffectCompositor.prototype.setPhysicallyCorrectSSR = function(physical) {
  this._ssrPass.setPhysicallyCorrect(physical);
};
EffectCompositor.prototype.setEdgeColor = function(value) {
  var color = graphicGL$1.parseColor(value);
  this._edgePass.setParameter("edgeColor", color);
};
EffectCompositor.prototype.setExposure = function(value) {
  this._compositeNode.setParameter("exposure", Math.pow(2, value));
};
EffectCompositor.prototype.setColorLookupTexture = function(image, api) {
  this._compositeNode.pass.material.setTextureImage("lut", this._enableColorCorrection ? image : "none", api, {
    minFilter: graphicGL$1.Texture.NEAREST,
    magFilter: graphicGL$1.Texture.NEAREST,
    flipY: false
  });
};
EffectCompositor.prototype.setColorCorrection = function(type, value) {
  this._compositeNode.setParameter(type, value);
};
EffectCompositor.prototype.isSSREnabled = function() {
  return this._enableSSR;
};
EffectCompositor.prototype.composite = function(renderer, scene, camera2, framebuffer, frame) {
  var sourceTexture = this._sourceTexture;
  var targetTexture = sourceTexture;
  if (this._enableEdge) {
    this._edgePass.update(renderer, camera2, sourceTexture, frame);
    sourceTexture = targetTexture = this._edgePass.getTargetTexture();
  }
  if (this._enableSSR) {
    this._ssrPass.update(renderer, camera2, sourceTexture, frame);
    targetTexture = this._ssrPass.getTargetTexture();
    this._ssrPass.setSSAOTexture(this._enableSSAO ? this._ssaoPass.getTargetTexture() : null);
  }
  this._sourceNode.texture = targetTexture;
  this._cocNode.setParameter("depth", this._depthTexture);
  var blurKernel = this._dofBlurKernel;
  var blurKernelSize = this._dofBlurKernelSize;
  var frameAll = Math.floor(poissonKernel.length / 2 / blurKernelSize);
  var kernelOffset = frame % frameAll;
  for (var i = 0; i < blurKernelSize * 2; i++) {
    blurKernel[i] = poissonKernel[i + kernelOffset * blurKernelSize * 2];
  }
  for (var i = 0; i < this._dofBlurNodes.length; i++) {
    this._dofBlurNodes[i].setParameter("percent", frame / 30);
    this._dofBlurNodes[i].setParameter("poissonKernel", blurKernel);
  }
  this._cocNode.setParameter("zNear", camera2.near);
  this._cocNode.setParameter("zFar", camera2.far);
  this._compositor.render(renderer, framebuffer);
};
EffectCompositor.prototype.dispose = function(renderer) {
  this._sourceTexture.dispose(renderer);
  this._depthTexture.dispose(renderer);
  this._framebuffer.dispose(renderer);
  this._compositor.dispose(renderer);
  this._normalPass.dispose(renderer);
  this._ssaoPass.dispose(renderer);
};
function TemporalSuperSampling(frames) {
  var haltonSequence = [];
  for (var i = 0; i < 30; i++) {
    haltonSequence.push([halton(i, 2), halton(i, 3)]);
  }
  this._haltonSequence = haltonSequence;
  this._frame = 0;
  this._sourceTex = new Texture2D$1();
  this._sourceFb = new FrameBuffer$1();
  this._sourceFb.attach(this._sourceTex);
  this._prevFrameTex = new Texture2D$1();
  this._outputTex = new Texture2D$1();
  var blendPass = this._blendPass = new Pass$1({
    fragment: Shader.source("clay.compositor.blend")
  });
  blendPass.material.disableTexturesAll();
  blendPass.material.enableTexture(["texture1", "texture2"]);
  this._blendFb = new FrameBuffer$1({
    depthBuffer: false
  });
  this._outputPass = new Pass$1({
    fragment: Shader.source("clay.compositor.output"),
    blendWithPrevious: true
  });
  this._outputPass.material.define("fragment", "OUTPUT_ALPHA");
  this._outputPass.material.blend = function(_gl) {
    _gl.blendEquationSeparate(_gl.FUNC_ADD, _gl.FUNC_ADD);
    _gl.blendFuncSeparate(_gl.ONE, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA);
  };
}
TemporalSuperSampling.prototype = {
  constructor: TemporalSuperSampling,
  jitterProjection: function(renderer, camera2) {
    var viewport = renderer.viewport;
    var dpr2 = viewport.devicePixelRatio || renderer.getDevicePixelRatio();
    var width = viewport.width * dpr2;
    var height = viewport.height * dpr2;
    var offset = this._haltonSequence[this._frame % this._haltonSequence.length];
    var translationMat = new Matrix4$1();
    translationMat.array[12] = (offset[0] * 2 - 1) / width;
    translationMat.array[13] = (offset[1] * 2 - 1) / height;
    Matrix4$1.mul(camera2.projectionMatrix, translationMat, camera2.projectionMatrix);
    Matrix4$1.invert(camera2.invProjectionMatrix, camera2.projectionMatrix);
  },
  resetFrame: function() {
    this._frame = 0;
  },
  getFrame: function() {
    return this._frame;
  },
  getSourceFrameBuffer: function() {
    return this._sourceFb;
  },
  getOutputTexture: function() {
    return this._outputTex;
  },
  resize: function(width, height) {
    this._prevFrameTex.width = width;
    this._prevFrameTex.height = height;
    this._outputTex.width = width;
    this._outputTex.height = height;
    this._sourceTex.width = width;
    this._sourceTex.height = height;
    this._prevFrameTex.dirty();
    this._outputTex.dirty();
    this._sourceTex.dirty();
  },
  isFinished: function() {
    return this._frame >= this._haltonSequence.length;
  },
  render: function(renderer, sourceTex, notOutput) {
    var blendPass = this._blendPass;
    if (this._frame === 0) {
      blendPass.setUniform("weight1", 0);
      blendPass.setUniform("weight2", 1);
    } else {
      blendPass.setUniform("weight1", 0.9);
      blendPass.setUniform("weight2", 0.1);
    }
    blendPass.setUniform("texture1", this._prevFrameTex);
    blendPass.setUniform("texture2", sourceTex || this._sourceTex);
    this._blendFb.attach(this._outputTex);
    this._blendFb.bind(renderer);
    blendPass.render(renderer);
    this._blendFb.unbind(renderer);
    if (!notOutput) {
      this._outputPass.setUniform("texture", this._outputTex);
      this._outputPass.render(renderer);
    }
    var tmp = this._prevFrameTex;
    this._prevFrameTex = this._outputTex;
    this._outputTex = tmp;
    this._frame++;
  },
  dispose: function(renderer) {
    this._sourceFb.dispose(renderer);
    this._blendFb.dispose(renderer);
    this._prevFrameTex.dispose(renderer);
    this._outputTex.dispose(renderer);
    this._sourceTex.dispose(renderer);
    this._outputPass.dispose(renderer);
    this._blendPass.dispose(renderer);
  }
};
function ViewGL(projection) {
  projection = projection || "perspective";
  this.layer = null;
  this.scene = new Scene$1();
  this.rootNode = this.scene;
  this.viewport = {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  this.setProjection(projection);
  this._compositor = new EffectCompositor();
  this._temporalSS = new TemporalSuperSampling();
  this._shadowMapPass = new ShadowMapPass$1();
  var pcfKernels = [];
  var off = 0;
  for (var i = 0; i < 30; i++) {
    var pcfKernel = [];
    for (var k = 0; k < 6; k++) {
      pcfKernel.push(halton(off, 2) * 4 - 2);
      pcfKernel.push(halton(off, 3) * 4 - 2);
      off++;
    }
    pcfKernels.push(pcfKernel);
  }
  this._pcfKernels = pcfKernels;
  this.scene.on("beforerender", function(renderer, scene, camera2) {
    if (this.needsTemporalSS()) {
      this._temporalSS.jitterProjection(renderer, camera2);
    }
  }, this);
}
ViewGL.prototype.setProjection = function(projection) {
  var oldCamera = this.camera;
  oldCamera && oldCamera.update();
  if (projection === "perspective") {
    if (!(this.camera instanceof PerspectiveCamera)) {
      this.camera = new PerspectiveCamera();
      if (oldCamera) {
        this.camera.setLocalTransform(oldCamera.localTransform);
      }
    }
  } else {
    if (!(this.camera instanceof OrthoCamera)) {
      this.camera = new OrthoCamera();
      if (oldCamera) {
        this.camera.setLocalTransform(oldCamera.localTransform);
      }
    }
  }
  this.camera.near = 0.1;
  this.camera.far = 2e3;
};
ViewGL.prototype.setViewport = function(x, y, width, height, dpr2) {
  if (this.camera instanceof PerspectiveCamera) {
    this.camera.aspect = width / height;
  }
  dpr2 = dpr2 || 1;
  this.viewport.x = x;
  this.viewport.y = y;
  this.viewport.width = width;
  this.viewport.height = height;
  this.viewport.devicePixelRatio = dpr2;
  this._compositor.resize(width * dpr2, height * dpr2);
  this._temporalSS.resize(width * dpr2, height * dpr2);
};
ViewGL.prototype.containPoint = function(x, y) {
  var viewport = this.viewport;
  var height = this.layer.renderer.getHeight();
  y = height - y;
  return x >= viewport.x && y >= viewport.y && x <= viewport.x + viewport.width && y <= viewport.y + viewport.height;
};
var ndc = new Vector2$1();
ViewGL.prototype.castRay = function(x, y, out2) {
  var renderer = this.layer.renderer;
  var oldViewport = renderer.viewport;
  renderer.viewport = this.viewport;
  renderer.screenToNDC(x, y, ndc);
  this.camera.castRay(ndc, out2);
  renderer.viewport = oldViewport;
  return out2;
};
ViewGL.prototype.prepareRender = function() {
  this.scene.update();
  this.camera.update();
  this.scene.updateLights();
  var renderList = this.scene.updateRenderList(this.camera);
  this._needsSortProgressively = false;
  for (var i = 0; i < renderList.transparent.length; i++) {
    var renderable = renderList.transparent[i];
    var geometry = renderable.geometry;
    if (geometry.needsSortVerticesProgressively && geometry.needsSortVerticesProgressively()) {
      this._needsSortProgressively = true;
    }
    if (geometry.needsSortTrianglesProgressively && geometry.needsSortTrianglesProgressively()) {
      this._needsSortProgressively = true;
    }
  }
  this._frame = 0;
  this._temporalSS.resetFrame();
};
ViewGL.prototype.render = function(renderer, accumulating) {
  this._doRender(renderer, accumulating, this._frame);
  this._frame++;
};
ViewGL.prototype.needsAccumulate = function() {
  return this.needsTemporalSS() || this._needsSortProgressively;
};
ViewGL.prototype.needsTemporalSS = function() {
  var enableTemporalSS = this._enableTemporalSS;
  if (enableTemporalSS === "auto") {
    enableTemporalSS = this._enablePostEffect;
  }
  return enableTemporalSS;
};
ViewGL.prototype.hasDOF = function() {
  return this._enableDOF;
};
ViewGL.prototype.isAccumulateFinished = function() {
  return this.needsTemporalSS() ? this._temporalSS.isFinished() : this._frame > 30;
};
ViewGL.prototype._doRender = function(renderer, accumulating, accumFrame) {
  var scene = this.scene;
  var camera2 = this.camera;
  accumFrame = accumFrame || 0;
  this._updateTransparent(renderer, scene, camera2, accumFrame);
  if (!accumulating) {
    this._shadowMapPass.kernelPCF = this._pcfKernels[0];
    this._shadowMapPass.render(renderer, scene, camera2, true);
  }
  this._updateShadowPCFKernel(accumFrame);
  var bgColor = renderer.clearColor;
  renderer.gl.clearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]);
  if (this._enablePostEffect) {
    if (this.needsTemporalSS()) {
      this._temporalSS.jitterProjection(renderer, camera2);
    }
    this._compositor.updateNormal(renderer, scene, camera2, this._temporalSS.getFrame());
  }
  this._updateSSAO(renderer, scene, camera2, this._temporalSS.getFrame());
  if (this._enablePostEffect) {
    var frameBuffer = this._compositor.getSourceFrameBuffer();
    frameBuffer.bind(renderer);
    renderer.gl.clear(renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT);
    renderer.render(scene, camera2, true, true);
    frameBuffer.unbind(renderer);
    if (this.needsTemporalSS() && accumulating) {
      this._compositor.composite(renderer, scene, camera2, this._temporalSS.getSourceFrameBuffer(), this._temporalSS.getFrame());
      renderer.setViewport(this.viewport);
      this._temporalSS.render(renderer);
    } else {
      renderer.setViewport(this.viewport);
      this._compositor.composite(renderer, scene, camera2, null, 0);
    }
  } else {
    if (this.needsTemporalSS() && accumulating) {
      var frameBuffer = this._temporalSS.getSourceFrameBuffer();
      frameBuffer.bind(renderer);
      renderer.saveClear();
      renderer.clearBit = renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT;
      renderer.render(scene, camera2, true, true);
      renderer.restoreClear();
      frameBuffer.unbind(renderer);
      renderer.setViewport(this.viewport);
      this._temporalSS.render(renderer);
    } else {
      renderer.setViewport(this.viewport);
      renderer.render(scene, camera2, true, true);
    }
  }
};
ViewGL.prototype._updateTransparent = function(renderer, scene, camera2, frame) {
  var v32 = new Vector3$1();
  var invWorldTransform = new Matrix4$1();
  var cameraWorldPosition = camera2.getWorldPosition();
  var transparentList = scene.getRenderList(camera2).transparent;
  for (var i = 0; i < transparentList.length; i++) {
    var renderable = transparentList[i];
    var geometry = renderable.geometry;
    Matrix4$1.invert(invWorldTransform, renderable.worldTransform);
    Vector3$1.transformMat4(v32, cameraWorldPosition, invWorldTransform);
    if (geometry.needsSortTriangles && geometry.needsSortTriangles()) {
      geometry.doSortTriangles(v32, frame);
    }
    if (geometry.needsSortVertices && geometry.needsSortVertices()) {
      geometry.doSortVertices(v32, frame);
    }
  }
};
ViewGL.prototype._updateSSAO = function(renderer, scene, camera2) {
  var ifEnableSSAO = this._enableSSAO && this._enablePostEffect;
  if (ifEnableSSAO) {
    this._compositor.updateSSAO(renderer, scene, camera2, this._temporalSS.getFrame());
  }
  var renderList = scene.getRenderList(camera2);
  for (var i = 0; i < renderList.opaque.length; i++) {
    var renderable = renderList.opaque[i];
    if (renderable.renderNormal) {
      renderable.material[ifEnableSSAO ? "enableTexture" : "disableTexture"]("ssaoMap");
    }
    if (ifEnableSSAO) {
      renderable.material.set("ssaoMap", this._compositor.getSSAOTexture());
    }
  }
};
ViewGL.prototype._updateShadowPCFKernel = function(frame) {
  var pcfKernel = this._pcfKernels[frame % this._pcfKernels.length];
  var renderList = this.scene.getRenderList(this.camera);
  var opaqueList = renderList.opaque;
  for (var i = 0; i < opaqueList.length; i++) {
    if (opaqueList[i].receiveShadow) {
      opaqueList[i].material.set("pcfKernel", pcfKernel);
      opaqueList[i].material.define("fragment", "PCF_KERNEL_SIZE", pcfKernel.length / 2);
    }
  }
};
ViewGL.prototype.dispose = function(renderer) {
  this._compositor.dispose(renderer.gl);
  this._temporalSS.dispose(renderer.gl);
  this._shadowMapPass.dispose(renderer);
};
ViewGL.prototype.setPostEffect = function(postEffectModel, api) {
  var compositor = this._compositor;
  this._enablePostEffect = postEffectModel.get("enable");
  var bloomModel = postEffectModel.getModel("bloom");
  var edgeModel = postEffectModel.getModel("edge");
  var dofModel = postEffectModel.getModel("DOF", postEffectModel.getModel("depthOfField"));
  var ssaoModel = postEffectModel.getModel("SSAO", postEffectModel.getModel("screenSpaceAmbientOcclusion"));
  var ssrModel = postEffectModel.getModel("SSR", postEffectModel.getModel("screenSpaceReflection"));
  var fxaaModel = postEffectModel.getModel("FXAA");
  var colorCorrModel = postEffectModel.getModel("colorCorrection");
  bloomModel.get("enable") ? compositor.enableBloom() : compositor.disableBloom();
  dofModel.get("enable") ? compositor.enableDOF() : compositor.disableDOF();
  ssrModel.get("enable") ? compositor.enableSSR() : compositor.disableSSR();
  colorCorrModel.get("enable") ? compositor.enableColorCorrection() : compositor.disableColorCorrection();
  edgeModel.get("enable") ? compositor.enableEdge() : compositor.disableEdge();
  fxaaModel.get("enable") ? compositor.enableFXAA() : compositor.disableFXAA();
  this._enableDOF = dofModel.get("enable");
  this._enableSSAO = ssaoModel.get("enable");
  this._enableSSAO ? compositor.enableSSAO() : compositor.disableSSAO();
  compositor.setBloomIntensity(bloomModel.get("intensity"));
  compositor.setEdgeColor(edgeModel.get("color"));
  compositor.setColorLookupTexture(colorCorrModel.get("lookupTexture"), api);
  compositor.setExposure(colorCorrModel.get("exposure"));
  ["radius", "quality", "intensity"].forEach(function(name) {
    compositor.setSSAOParameter(name, ssaoModel.get(name));
  });
  ["quality", "maxRoughness", "physical"].forEach(function(name) {
    compositor.setSSRParameter(name, ssrModel.get(name));
  });
  ["quality", "focalDistance", "focalRange", "blurRadius", "fstop"].forEach(function(name) {
    compositor.setDOFParameter(name, dofModel.get(name));
  });
  ["brightness", "contrast", "saturation"].forEach(function(name) {
    compositor.setColorCorrection(name, colorCorrModel.get(name));
  });
};
ViewGL.prototype.setDOFFocusOnPoint = function(depth) {
  if (this._enablePostEffect) {
    if (depth > this.camera.far || depth < this.camera.near) {
      return;
    }
    this._compositor.setDOFParameter("focalDistance", depth);
    return true;
  }
};
ViewGL.prototype.setTemporalSuperSampling = function(temporalSuperSamplingModel) {
  this._enableTemporalSS = temporalSuperSamplingModel.get("enable");
};
ViewGL.prototype.isLinearSpace = function() {
  return this._enablePostEffect;
};
ViewGL.prototype.setRootNode = function(rootNode) {
  if (this.rootNode === rootNode) {
    return;
  }
  var children = this.rootNode.children();
  for (var i = 0; i < children.length; i++) {
    rootNode.add(children[i]);
  }
  if (rootNode !== this.scene) {
    this.scene.add(rootNode);
  }
  this.rootNode = rootNode;
};
ViewGL.prototype.add = function(node3D) {
  this.rootNode.add(node3D);
};
ViewGL.prototype.remove = function(node3D) {
  this.rootNode.remove(node3D);
};
ViewGL.prototype.removeAll = function(node3D) {
  this.rootNode.removeAll(node3D);
};
Object.assign(ViewGL.prototype, notifier$1);
function resizeCartesian3D(grid3DModel, api) {
  var boxLayoutOption = grid3DModel.getBoxLayoutParams();
  var viewport = getLayoutRect(boxLayoutOption, {
    width: api.getWidth(),
    height: api.getHeight()
  });
  viewport.y = api.getHeight() - viewport.y - viewport.height;
  this.viewGL.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, api.getDevicePixelRatio());
  var boxWidth = grid3DModel.get("boxWidth");
  var boxHeight = grid3DModel.get("boxHeight");
  var boxDepth = grid3DModel.get("boxDepth");
  this.getAxis("x").setExtent(-boxWidth / 2, boxWidth / 2);
  this.getAxis("y").setExtent(boxDepth / 2, -boxDepth / 2);
  this.getAxis("z").setExtent(-boxHeight / 2, boxHeight / 2);
  this.size = [boxWidth, boxHeight, boxDepth];
}
function updateCartesian3D(ecModel, api) {
  var dataExtents = {};
  function unionDataExtents(dim, extent3) {
    dataExtents[dim] = dataExtents[dim] || [Infinity, -Infinity];
    dataExtents[dim][0] = Math.min(extent3[0], dataExtents[dim][0]);
    dataExtents[dim][1] = Math.max(extent3[1], dataExtents[dim][1]);
  }
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem !== this) {
      return;
    }
    var data = seriesModel.getData();
    ["x", "y", "z"].forEach(function(coordDim) {
      data.mapDimensionsAll(coordDim, true).forEach(function(dataDim) {
        unionDataExtents(coordDim, data.getDataExtent(dataDim, true));
      });
    });
  }, this);
  ["xAxis3D", "yAxis3D", "zAxis3D"].forEach(function(axisType) {
    ecModel.eachComponent(axisType, function(axisModel) {
      var dim = axisType.charAt(0);
      var grid3DModel = axisModel.getReferringComponents("grid3D").models[0];
      var cartesian3D = grid3DModel.coordinateSystem;
      if (cartesian3D !== this) {
        return;
      }
      var axis = cartesian3D.getAxis(dim);
      if (axis) {
        return;
      }
      var scale2 = createScale(dataExtents[dim] || [Infinity, -Infinity], axisModel);
      axis = new Axis3D(dim, scale2);
      axis.type = axisModel.get("type");
      var isCategory2 = axis.type === "category";
      axis.onBand = isCategory2 && axisModel.get("boundaryGap");
      axis.inverse = axisModel.get("inverse");
      axisModel.axis = axis;
      axis.model = axisModel;
      axis.getLabelModel = function() {
        return axisModel.getModel("axisLabel", grid3DModel.getModel("axisLabel"));
      };
      axis.getTickModel = function() {
        return axisModel.getModel("axisTick", grid3DModel.getModel("axisTick"));
      };
      cartesian3D.addAxis(axis);
    }, this);
  }, this);
  this.resize(this.model, api);
}
var grid3DCreator = {
  dimensions: Cartesian3D.prototype.dimensions,
  create: function(ecModel, api) {
    var cartesian3DList = [];
    ecModel.eachComponent("grid3D", function(grid3DModel) {
      grid3DModel.__viewGL = grid3DModel.__viewGL || new ViewGL();
      var cartesian3D = new Cartesian3D();
      cartesian3D.model = grid3DModel;
      cartesian3D.viewGL = grid3DModel.__viewGL;
      grid3DModel.coordinateSystem = cartesian3D;
      cartesian3DList.push(cartesian3D);
      cartesian3D.resize = resizeCartesian3D;
      cartesian3D.update = updateCartesian3D;
    });
    var axesTypes = ["xAxis3D", "yAxis3D", "zAxis3D"];
    function findAxesModels(seriesModel, ecModel2) {
      return axesTypes.map(function(axisType) {
        var axisModel = seriesModel.getReferringComponents(axisType).models[0];
        if (axisModel == null) {
          axisModel = ecModel2.getComponent(axisType);
        }
        return axisModel;
      });
    }
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") !== "cartesian3D") {
        return;
      }
      var firstGridModel = seriesModel.getReferringComponents("grid3D").models[0];
      if (firstGridModel == null) {
        var axesModels = findAxesModels(seriesModel, ecModel);
        var firstGridModel = axesModels[0].getCoordSysModel();
        axesModels.forEach(function(axisModel) {
          axisModel.getCoordSysModel();
        });
      }
      var coordSys = firstGridModel.coordinateSystem;
      seriesModel.coordinateSystem = coordSys;
    });
    return cartesian3DList;
  }
};
var grid3DCreator$1 = grid3DCreator;
var Axis3DModel = ComponentModel$1.extend({
  type: "cartesian3DAxis",
  axis: null,
  getCoordSysModel: function() {
    return this.ecModel.queryComponents({
      mainType: "grid3D",
      index: this.option.gridIndex,
      id: this.option.gridId
    })[0];
  }
});
mixinAxisModelCommonMethods(Axis3DModel);
var Axis3DModel$1 = Axis3DModel;
var defaultOption = {
  show: true,
  grid3DIndex: 0,
  inverse: false,
  name: "",
  nameLocation: "middle",
  nameTextStyle: {
    fontSize: 16
  },
  nameGap: 20,
  axisPointer: {},
  axisLine: {},
  axisTick: {},
  axisLabel: {},
  splitArea: {}
};
var categoryAxis = merge({
  boundaryGap: true,
  axisTick: {
    alignWithLabel: false,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  },
  axisPointer: {
    label: {
      show: false
    }
  }
}, defaultOption);
var valueAxis = merge({
  boundaryGap: [0, 0],
  splitNumber: 5,
  axisPointer: {
    label: {}
  }
}, defaultOption);
var timeAxis = defaults({
  scale: true,
  min: "dataMin",
  max: "dataMax"
}, valueAxis);
var logAxis = defaults({
  logBase: 10
}, valueAxis);
logAxis.scale = true;
var axisDefault = {
  categoryAxis3D: categoryAxis,
  valueAxis3D: valueAxis,
  timeAxis3D: timeAxis,
  logAxis3D: logAxis
};
var AXIS_TYPES = ["value", "category", "time", "log"];
function createAxis3DModel(registers, dim, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
  AXIS_TYPES.forEach(function(axisType) {
    var AxisModel = BaseAxisModelClass.extend({
      type: dim + "Axis3D." + axisType,
      __ordinalMeta: null,
      mergeDefaultAndTheme: function(option, ecModel) {
        var themeModel = ecModel.getTheme();
        merge(option, themeModel.get(axisType + "Axis3D"));
        merge(option, this.getDefaultOption());
        option.type = axisTypeDefaulter(dim, option);
      },
      optionUpdated: function() {
        var thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta$1.createByAxisModel(this);
        }
      },
      getCategories: function() {
        if (this.option.type === "category") {
          return this.__ordinalMeta.categories;
        }
      },
      getOrdinalMeta: function() {
        return this.__ordinalMeta;
      },
      defaultOption: merge(clone$4(axisDefault[axisType + "Axis3D"]), extraDefaultOption || {}, true)
    });
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(dim + "Axis3D", curry$1(axisTypeDefaulter, dim));
}
function getAxisType(axisDim, option) {
  return option.type || (option.data ? "category" : "value");
}
function install$f(registers) {
  registers.registerComponentModel(Grid3DModel$1);
  registers.registerComponentView(Grid3DView);
  registers.registerCoordinateSystem("grid3D", grid3DCreator$1);
  ["x", "y", "z"].forEach(function(dim) {
    createAxis3DModel(registers, dim, Axis3DModel$1, getAxisType, {
      name: dim.toUpperCase()
    });
    const AxisView2 = registers.ComponentView.extend({
      type: dim + "Axis3D"
    });
    registers.registerComponentView(AxisView2);
  });
  registers.registerAction({
    type: "grid3DChangeCamera",
    event: "grid3dcamerachanged",
    update: "series:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "grid3D",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
  registers.registerAction({
    type: "grid3DShowAxisPointer",
    event: "grid3dshowaxispointer",
    update: "grid3D:showAxisPointer"
  }, function(payload, ecModel) {
  });
  registers.registerAction({
    type: "grid3DHideAxisPointer",
    event: "grid3dhideaxispointer",
    update: "grid3D:hideAxisPointer"
  }, function(payload, ecModel) {
  });
}
use(install$f);
var componentShadingMixin = {
  defaultOption: {
    shading: null,
    realisticMaterial: {
      textureTiling: 1,
      textureOffset: 0,
      detailTexture: null
    },
    lambertMaterial: {
      textureTiling: 1,
      textureOffset: 0,
      detailTexture: null
    },
    colorMaterial: {
      textureTiling: 1,
      textureOffset: 0,
      detailTexture: null
    },
    hatchingMaterial: {
      textureTiling: 1,
      textureOffset: 0,
      paperColor: "#fff"
    }
  }
};
var geo3DModelMixin = {
  getFilledRegions: function(regions, mapData) {
    var regionsArr = (regions || []).slice();
    var geoJson;
    if (typeof mapData === "string") {
      mapData = getMap(mapData);
      geoJson = mapData && mapData.geoJson;
    } else {
      if (mapData && mapData.features) {
        geoJson = mapData;
      }
    }
    if (!geoJson) {
      return [];
    }
    var dataNameMap = {};
    var features2 = geoJson.features;
    for (var i = 0; i < regionsArr.length; i++) {
      dataNameMap[regionsArr[i].name] = regionsArr[i];
    }
    for (var i = 0; i < features2.length; i++) {
      var name = features2[i].properties.name;
      if (!dataNameMap[name]) {
        regionsArr.push({
          name
        });
      }
    }
    return regionsArr;
  },
  defaultOption: {
    show: true,
    zlevel: -10,
    map: "",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    boxWidth: 100,
    boxHeight: 10,
    boxDepth: "auto",
    regionHeight: 3,
    environment: "auto",
    groundPlane: {
      show: false,
      color: "#aaa"
    },
    shading: "lambert",
    light: {
      main: {
        alpha: 40,
        beta: 30
      }
    },
    viewControl: {
      alpha: 40,
      beta: 0,
      distance: 100,
      orthographicSize: 60,
      minAlpha: 5,
      minBeta: -80,
      maxBeta: 80
    },
    label: {
      show: false,
      distance: 2,
      textStyle: {
        fontSize: 20,
        color: "#000",
        backgroundColor: "rgba(255,255,255,0.7)",
        padding: 3,
        borderRadius: 4
      }
    },
    itemStyle: {
      color: "#fff",
      borderWidth: 0,
      borderColor: "#333"
    },
    emphasis: {
      itemStyle: {
        color: "#639fc0"
      },
      label: {
        show: true
      }
    }
  }
};
var Geo3DModel = ComponentModel$1.extend({
  type: "geo3D",
  layoutMode: "box",
  coordinateSystem: null,
  optionUpdated: function() {
    var option = this.option;
    option.regions = this.getFilledRegions(option.regions, option.map);
    var dimensions = createDimensions(option.data || [], {
      coordDimensions: ["value"],
      encodeDefine: this.get("encode"),
      dimensionsDefine: this.get("dimensions")
    });
    var list = new SeriesData$1(dimensions, this);
    list.initData(option.regions);
    var regionModelMap = {};
    list.each(function(idx) {
      var name = list.getName(idx);
      var itemModel = list.getItemModel(idx);
      regionModelMap[name] = itemModel;
    });
    this._regionModelMap = regionModelMap;
    this._data = list;
  },
  getData: function() {
    return this._data;
  },
  getRegionModel: function(idx) {
    var name = this.getData().getName(idx);
    return this._regionModelMap[name] || new Model$1(null, this);
  },
  getRegionPolygonCoords: function(idx) {
    var name = this.getData().getName(idx);
    var region = this.coordinateSystem.getRegion(name);
    return region ? region.geometries : [];
  },
  getFormattedLabel: function(dataIndex, status) {
    var name = this._data.getName(dataIndex);
    var regionModel = this.getRegionModel(dataIndex);
    var formatter = regionModel.get(status === "normal" ? ["label", "formatter"] : ["emphasis", "label", "formatter"]);
    if (formatter == null) {
      formatter = regionModel.get(["label", "formatter"]);
    }
    var params = {
      name
    };
    if (typeof formatter === "function") {
      params.status = status;
      return formatter(params);
    } else if (typeof formatter === "string") {
      var serName = params.seriesName;
      return formatter.replace("{a}", serName != null ? serName : "");
    } else {
      return name;
    }
  },
  defaultOption: {
    regions: []
  }
});
merge(Geo3DModel.prototype, geo3DModelMixin);
merge(Geo3DModel.prototype, componentViewControlMixin);
merge(Geo3DModel.prototype, componentPostEffectMixin);
merge(Geo3DModel.prototype, componentLightMixin);
merge(Geo3DModel.prototype, componentShadingMixin);
var Geo3DModel$1 = Geo3DModel;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode)
    return triangles;
  var minX, minY, maxX, maxY, x, y, size;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
    }
    size = Math.max(maxX - minX, maxY - minY);
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, size);
  return triangles;
}
function linkedList(data, start2, end2, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start2, end2, dim) > 0) {
    for (i = start2; i < end2; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end2 - dim; i >= start2; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start2, end2) {
  if (!start2)
    return start2;
  if (!end2)
    end2 = start2;
  var p = start2, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end2 = p.prev;
      if (p === p.next)
        return null;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end2);
  return end2;
}
function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
  if (!ear)
    return;
  if (!pass && size)
    indexCurve(ear, minX, minY, size);
  var stop2 = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      removeNode(ear);
      ear = next.next;
      stop2 = next.next;
      continue;
    }
    ear = next;
    if (ear === stop2) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(ear, triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, size, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, size);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  var p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, size) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
  var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);
  var p = ear.nextZ;
  while (p && p.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.nextZ;
  }
  p = ear.prevZ;
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  return true;
}
function cureLocalIntersections(start2, triangles, dim) {
  var p = start2;
  do {
    var a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      removeNode(p);
      removeNode(p.next);
      p = start2 = b;
    }
    p = p.next;
  } while (p !== start2);
  return p;
}
function splitEarcut(start2, triangles, dim, minX, minY, size) {
  var a = start2;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        var c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, size);
        earcutLinked(c, triangles, dim, minX, minY, size);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start2);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i, len2, start2, end2, list;
  for (i = 0, len2 = holeIndices.length; i < len2; i++) {
    start2 = holeIndices[i] * dim;
    end2 = i < len2 - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start2, end2, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    eliminateHole(queue[i], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    var b = splitPolygon(outerNode, hole);
    filterPoints(b, b.next);
  }
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m2;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m2 = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m2)
    return null;
  if (hx === qx)
    return m2.prev;
  var stop2 = m2, mx = m2.x, my = m2.y, tanMin = Infinity, tan2;
  p = m2.next;
  while (p !== stop2) {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan2 = Math.abs(hy - p.y) / (hx - p.x);
      if ((tan2 < tanMin || tan2 === tanMin && p.x > m2.x) && locallyInside(p, hole)) {
        m2 = p;
        tanMin = tan2;
      }
    }
    p = p.next;
  }
  return m2;
}
function indexCurve(start2, minX, minY, size) {
  var p = start2;
  do {
    if (p.z === null)
      p.z = zOrder(p.x, p.y, minX, minY, size);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start2);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i, p, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e2 = p;
          p = p.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e2;
        else
          list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, size) {
  x = 32767 * (x - minX) / size;
  y = 32767 * (y - minY) / size;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start2) {
  var p = start2, leftmost = start2;
  do {
    if (p.x < leftmost.x)
      leftmost = p;
    p = p.next;
  } while (p !== start2);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p12, p22) {
  return p12.x === p22.x && p12.y === p22.y;
}
function intersects(p12, q1, p22, q2) {
  if (equals(p12, q1) && equals(p22, q2) || equals(p12, q2) && equals(p22, q1))
    return true;
  return area(p12, q1, p22) > 0 !== area(p12, q1, q2) > 0 && area(p22, q2, p12) > 0 !== area(p22, q2, q1) > 0;
}
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len2 = holeIndices.length; i < len2; i++) {
      var start2 = holeIndices[i] * dim;
      var end2 = i < len2 - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start2, end2, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start2, end2, dim) {
  var sum2 = 0;
  for (var i = start2, j = end2 - dim; i < end2; i += dim) {
    sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum2;
}
function swap(arr, a, b) {
  var tmp = arr[a];
  arr[a] = arr[b];
  arr[b] = tmp;
}
function partition(arr, pivot, left, right, compare2) {
  var storeIndex = left;
  var pivotValue = arr[pivot];
  swap(arr, pivot, right);
  for (var v = left; v < right; v++) {
    if (compare2(arr[v], pivotValue) < 0) {
      swap(arr, v, storeIndex);
      storeIndex++;
    }
  }
  swap(arr, right, storeIndex);
  return storeIndex;
}
function quickSort(array, compare2, left, right) {
  if (left < right) {
    var pivot = Math.floor((left + right) / 2);
    var newPivot = partition(array, pivot, left, right, compare2);
    quickSort(array, compare2, left, newPivot - 1);
    quickSort(array, compare2, newPivot + 1, right);
  }
}
function ProgressiveQuickSort() {
  this._parts = [];
}
ProgressiveQuickSort.prototype.step = function(arr, compare2, frame) {
  var len2 = arr.length;
  if (frame === 0) {
    this._parts = [];
    this._sorted = false;
    var pivot = Math.floor(len2 / 2);
    this._parts.push({
      pivot,
      left: 0,
      right: len2 - 1
    });
    this._currentSortPartIdx = 0;
  }
  if (this._sorted) {
    return;
  }
  var parts = this._parts;
  if (parts.length === 0) {
    this._sorted = true;
    return true;
  } else if (parts.length < 512) {
    for (var i = 0; i < parts.length; i++) {
      parts[i].pivot = partition(arr, parts[i].pivot, parts[i].left, parts[i].right, compare2);
    }
    var subdividedParts = [];
    for (var i = 0; i < parts.length; i++) {
      var left = parts[i].left;
      var right = parts[i].pivot - 1;
      if (right > left) {
        subdividedParts.push({
          pivot: Math.floor((right + left) / 2),
          left,
          right
        });
      }
      var left = parts[i].pivot + 1;
      var right = parts[i].right;
      if (right > left) {
        subdividedParts.push({
          pivot: Math.floor((right + left) / 2),
          left,
          right
        });
      }
    }
    parts = this._parts = subdividedParts;
  } else {
    for (var i = 0; i < Math.floor(parts.length / 10); i++) {
      var idx = parts.length - 1 - this._currentSortPartIdx;
      quickSort(arr, compare2, parts[idx].left, parts[idx].right);
      this._currentSortPartIdx++;
      if (this._currentSortPartIdx === parts.length) {
        this._sorted = true;
        return true;
      }
    }
  }
  return false;
};
ProgressiveQuickSort.sort = quickSort;
var vec3$c = glmatrix.vec3;
var p0 = vec3$c.create();
var p1 = vec3$c.create();
var p2 = vec3$c.create();
var trianglesSortMixin = {
  needsSortTriangles: function() {
    return this.indices && this.sortTriangles;
  },
  needsSortTrianglesProgressively: function() {
    return this.needsSortTriangles() && this.triangleCount >= 2e4;
  },
  doSortTriangles: function(cameraPos, frame) {
    var indices = this.indices;
    if (frame === 0) {
      var posAttr = this.attributes.position;
      var cameraPos = cameraPos.array;
      if (!this._triangleZList || this._triangleZList.length !== this.triangleCount) {
        this._triangleZList = new Float32Array(this.triangleCount);
        this._sortedTriangleIndices = new Uint32Array(this.triangleCount);
        this._indicesTmp = new indices.constructor(indices.length);
        this._triangleZListTmp = new Float32Array(this.triangleCount);
      }
      var cursor = 0;
      var firstZ;
      for (var i = 0; i < indices.length; ) {
        posAttr.get(indices[i++], p0);
        posAttr.get(indices[i++], p1);
        posAttr.get(indices[i++], p2);
        var z0 = vec3$c.sqrDist(p0, cameraPos);
        var z1 = vec3$c.sqrDist(p1, cameraPos);
        var z2 = vec3$c.sqrDist(p2, cameraPos);
        var zMax = Math.min(z0, z1);
        zMax = Math.min(zMax, z2);
        if (i === 3) {
          firstZ = zMax;
          zMax = 0;
        } else {
          zMax = zMax - firstZ;
        }
        this._triangleZList[cursor++] = zMax;
      }
    }
    var sortedTriangleIndices = this._sortedTriangleIndices;
    for (var i = 0; i < sortedTriangleIndices.length; i++) {
      sortedTriangleIndices[i] = i;
    }
    if (this.triangleCount < 2e4) {
      if (frame === 0) {
        this._simpleSort(true);
      }
    } else {
      for (var i = 0; i < 3; i++) {
        this._progressiveQuickSort(frame * 3 + i);
      }
    }
    var targetIndices = this._indicesTmp;
    var targetTriangleZList = this._triangleZListTmp;
    var faceZList = this._triangleZList;
    for (var i = 0; i < this.triangleCount; i++) {
      var fromIdx3 = sortedTriangleIndices[i] * 3;
      var toIdx3 = i * 3;
      targetIndices[toIdx3++] = indices[fromIdx3++];
      targetIndices[toIdx3++] = indices[fromIdx3++];
      targetIndices[toIdx3] = indices[fromIdx3];
      targetTriangleZList[i] = faceZList[sortedTriangleIndices[i]];
    }
    var tmp = this._indicesTmp;
    this._indicesTmp = this.indices;
    this.indices = tmp;
    var tmp = this._triangleZListTmp;
    this._triangleZListTmp = this._triangleZList;
    this._triangleZList = tmp;
    this.dirtyIndices();
  },
  _simpleSort: function(useNativeQuickSort) {
    var faceZList = this._triangleZList;
    var sortedTriangleIndices = this._sortedTriangleIndices;
    function compare2(a, b) {
      return faceZList[b] - faceZList[a];
    }
    if (useNativeQuickSort) {
      Array.prototype.sort.call(sortedTriangleIndices, compare2);
    } else {
      ProgressiveQuickSort.sort(sortedTriangleIndices, compare2, 0, sortedTriangleIndices.length - 1);
    }
  },
  _progressiveQuickSort: function(frame) {
    var faceZList = this._triangleZList;
    var sortedTriangleIndices = this._sortedTriangleIndices;
    this._quickSort = this._quickSort || new ProgressiveQuickSort();
    this._quickSort.step(sortedTriangleIndices, function(a, b) {
      return faceZList[b] - faceZList[a];
    }, frame);
  }
};
function getVisualColor(data) {
  const style = data.getVisual("style");
  if (style) {
    const drawType = data.getVisual("drawType");
    return style[drawType];
  }
}
function getVisualOpacity(data) {
  const style = data.getVisual("style");
  return style.opacity;
}
function getItemVisualColor(data, idx) {
  const style = data.getItemVisual(idx, "style");
  if (style) {
    const drawType = data.getVisual("drawType");
    return style[drawType];
  }
}
function getItemVisualOpacity(data, idx) {
  const style = data.getItemVisual(idx, "style");
  return style && style.opacity;
}
var LABEL_NORMAL_SHOW_BIT = 1;
var LABEL_EMPHASIS_SHOW_BIT = 2;
function LabelsBuilder(width, height, api) {
  this._labelsMesh = new LabelsMesh();
  this._labelTextureSurface = new ZRTextureAtlasSurface({
    width: 512,
    height: 512,
    devicePixelRatio: api.getDevicePixelRatio(),
    onupdate: function() {
      api.getZr().refresh();
    }
  });
  this._api = api;
  this._labelsMesh.material.set("textureAtlas", this._labelTextureSurface.getTexture());
}
LabelsBuilder.prototype.getLabelPosition = function(dataIndex, positionDesc, distance2) {
  return [0, 0, 0];
};
LabelsBuilder.prototype.getLabelDistance = function(dataIndex, positionDesc, distance2) {
  return 0;
};
LabelsBuilder.prototype.getMesh = function() {
  return this._labelsMesh;
};
LabelsBuilder.prototype.updateData = function(data, start2, end2) {
  if (start2 == null) {
    start2 = 0;
  }
  if (end2 == null) {
    end2 = data.count();
  }
  if (!this._labelsVisibilitiesBits || this._labelsVisibilitiesBits.length !== end2 - start2) {
    this._labelsVisibilitiesBits = new Uint8Array(end2 - start2);
  }
  var normalLabelVisibilityQuery = ["label", "show"];
  var emphasisLabelVisibilityQuery = ["emphasis", "label", "show"];
  for (var idx = start2; idx < end2; idx++) {
    var itemModel = data.getItemModel(idx);
    var normalVisibility = itemModel.get(normalLabelVisibilityQuery);
    var emphasisVisibility = itemModel.get(emphasisLabelVisibilityQuery);
    if (emphasisVisibility == null) {
      emphasisVisibility = normalVisibility;
    }
    var bit = (normalVisibility ? LABEL_NORMAL_SHOW_BIT : 0) | (emphasisVisibility ? LABEL_EMPHASIS_SHOW_BIT : 0);
    this._labelsVisibilitiesBits[idx - start2] = bit;
  }
  this._start = start2;
  this._end = end2;
  this._data = data;
};
LabelsBuilder.prototype.updateLabels = function(highlightDataIndices) {
  if (!this._data) {
    return;
  }
  highlightDataIndices = highlightDataIndices || [];
  var hasHighlightData = highlightDataIndices.length > 0;
  var highlightDataIndicesMap = {};
  for (var i = 0; i < highlightDataIndices.length; i++) {
    highlightDataIndicesMap[highlightDataIndices[i]] = true;
  }
  this._labelsMesh.geometry.convertToDynamicArray(true);
  this._labelTextureSurface.clear();
  var normalLabelQuery = ["label"];
  var emphasisLabelQuery = ["emphasis", "label"];
  var seriesModel = this._data.hostModel;
  var data = this._data;
  var seriesLabelModel = seriesModel.getModel(normalLabelQuery);
  var seriesLabelEmphasisModel = seriesModel.getModel(emphasisLabelQuery, seriesLabelModel);
  var textAlignMap = {
    left: "right",
    right: "left",
    top: "center",
    bottom: "center"
  };
  var textVerticalAlignMap = {
    left: "middle",
    right: "middle",
    top: "bottom",
    bottom: "top"
  };
  for (var dataIndex = this._start; dataIndex < this._end; dataIndex++) {
    var isEmphasis = false;
    if (hasHighlightData && highlightDataIndicesMap[dataIndex]) {
      isEmphasis = true;
    }
    var ifShow = this._labelsVisibilitiesBits[dataIndex - this._start] & (isEmphasis ? LABEL_EMPHASIS_SHOW_BIT : LABEL_NORMAL_SHOW_BIT);
    if (!ifShow) {
      continue;
    }
    var itemModel = data.getItemModel(dataIndex);
    var labelModel = itemModel.getModel(isEmphasis ? emphasisLabelQuery : normalLabelQuery, isEmphasis ? seriesLabelEmphasisModel : seriesLabelModel);
    var distance2 = labelModel.get("distance") || 0;
    var position2 = labelModel.get("position");
    var dpr2 = this._api.getDevicePixelRatio();
    var text = seriesModel.getFormattedLabel(dataIndex, isEmphasis ? "emphasis" : "normal");
    if (text == null || text === "") {
      return;
    }
    var textEl = new ZRText$1({
      style: createTextStyle$1(labelModel, {
        text,
        fill: labelModel.get("color") || getItemVisualColor(data, dataIndex) || "#000",
        align: "left",
        verticalAlign: "top",
        opacity: retrieve$1.firstNotNull(labelModel.get("opacity"), getItemVisualOpacity(data, dataIndex), 1)
      })
    });
    var rect = textEl.getBoundingRect();
    var lineHeight = 1.2;
    rect.height *= lineHeight;
    var coords = this._labelTextureSurface.add(textEl);
    var textAlign = textAlignMap[position2] || "center";
    var textVerticalAlign = textVerticalAlignMap[position2] || "bottom";
    this._labelsMesh.geometry.addSprite(this.getLabelPosition(dataIndex, position2, distance2), [rect.width * dpr2, rect.height * dpr2], coords, textAlign, textVerticalAlign, this.getLabelDistance(dataIndex, position2, distance2) * dpr2);
  }
  this._labelsMesh.material.set("uvScale", this._labelTextureSurface.getCoordsScale());
  this._labelTextureSurface.getZr().refreshImmediately();
  this._labelsMesh.geometry.convertToTypedArray();
  this._labelsMesh.geometry.dirty();
};
LabelsBuilder.prototype.dispose = function() {
  this._labelTextureSurface.dispose();
};
var vec3$b = glmatrix.vec3;
graphicGL$1.Shader.import(lines3DGLSL);
function Geo3DBuilder(api) {
  this.rootNode = new graphicGL$1.Node();
  this._triangulationResults = {};
  this._shadersMap = graphicGL$1.COMMON_SHADERS.filter(function(shaderName) {
    return shaderName !== "shadow";
  }).reduce(function(obj, shaderName) {
    obj[shaderName] = graphicGL$1.createShader("ecgl." + shaderName);
    return obj;
  }, {});
  this._linesShader = graphicGL$1.createShader("ecgl.meshLines3D");
  var groundMaterials = {};
  graphicGL$1.COMMON_SHADERS.forEach(function(shading) {
    groundMaterials[shading] = new graphicGL$1.Material({
      shader: graphicGL$1.createShader("ecgl." + shading)
    });
  });
  this._groundMaterials = groundMaterials;
  this._groundMesh = new graphicGL$1.Mesh({
    geometry: new graphicGL$1.PlaneGeometry({
      dynamic: true
    }),
    castShadow: false,
    renderNormal: true,
    $ignorePicking: true
  });
  this._groundMesh.rotation.rotateX(-Math.PI / 2);
  this._labelsBuilder = new LabelsBuilder(512, 512, api);
  this._labelsBuilder.getMesh().renderOrder = 100;
  this._labelsBuilder.getMesh().material.depthTest = false;
  this.rootNode.add(this._labelsBuilder.getMesh());
  this._initMeshes();
  this._api = api;
}
Geo3DBuilder.prototype = {
  constructor: Geo3DBuilder,
  extrudeY: true,
  update: function(componentModel, ecModel, api, start2, end2) {
    var data = componentModel.getData();
    if (start2 == null) {
      start2 = 0;
    }
    if (end2 == null) {
      end2 = data.count();
    }
    this._startIndex = start2;
    this._endIndex = end2 - 1;
    this._triangulation(componentModel, start2, end2);
    var shader = this._getShader(componentModel.get("shading"));
    this._prepareMesh(componentModel, shader, api, start2, end2);
    this.rootNode.updateWorldTransform();
    this._updateRegionMesh(componentModel, api, start2, end2);
    var coordSys = componentModel.coordinateSystem;
    if (coordSys.type === "geo3D") {
      this._updateGroundPlane(componentModel, coordSys, api);
    }
    var self2 = this;
    this._labelsBuilder.updateData(data, start2, end2);
    this._labelsBuilder.getLabelPosition = function(dataIndex, positionDesc, distance2) {
      var name = data.getName(dataIndex);
      var center2;
      var height = distance2;
      if (coordSys.type === "geo3D") {
        var region = coordSys.getRegion(name);
        if (!region) {
          return [NaN, NaN, NaN];
        }
        center2 = region.getCenter();
        var pos = coordSys.dataToPoint([center2[0], center2[1], height]);
        return pos;
      } else {
        var tmp = self2._triangulationResults[dataIndex - self2._startIndex];
        var center2 = self2.extrudeY ? [(tmp.max[0] + tmp.min[0]) / 2, tmp.max[1] + height, (tmp.max[2] + tmp.min[2]) / 2] : [(tmp.max[0] + tmp.min[0]) / 2, (tmp.max[1] + tmp.min[1]) / 2, tmp.max[2] + height];
      }
    };
    this._data = data;
    this._labelsBuilder.updateLabels();
    this._updateDebugWireframe(componentModel);
    this._lastHoverDataIndex = 0;
  },
  _initMeshes: function() {
    var self2 = this;
    function createPolygonMesh() {
      var mesh2 = new graphicGL$1.Mesh({
        name: "Polygon",
        material: new graphicGL$1.Material({
          shader: self2._shadersMap.lambert
        }),
        geometry: new graphicGL$1.Geometry({
          sortTriangles: true,
          dynamic: true
        }),
        culling: false,
        ignorePicking: true,
        renderNormal: true
      });
      Object.assign(mesh2.geometry, trianglesSortMixin);
      return mesh2;
    }
    var polygonMesh = createPolygonMesh();
    var linesMesh = new graphicGL$1.Mesh({
      material: new graphicGL$1.Material({
        shader: this._linesShader
      }),
      castShadow: false,
      ignorePicking: true,
      $ignorePicking: true,
      geometry: new LinesGeometry$3({
        useNativeLine: false
      })
    });
    this.rootNode.add(polygonMesh);
    this.rootNode.add(linesMesh);
    polygonMesh.material.define("both", "VERTEX_COLOR");
    polygonMesh.material.define("fragment", "DOUBLE_SIDED");
    this._polygonMesh = polygonMesh;
    this._linesMesh = linesMesh;
    this.rootNode.add(this._groundMesh);
  },
  _getShader: function(shading) {
    var shader = this._shadersMap[shading];
    if (!shader) {
      shader = this._shadersMap.lambert;
    }
    shader.__shading = shading;
    return shader;
  },
  _prepareMesh: function(componentModel, shader, api, start2, end2) {
    var polygonVertexCount = 0;
    var polygonTriangleCount = 0;
    var linesVertexCount = 0;
    var linesTriangleCount = 0;
    for (var idx = start2; idx < end2; idx++) {
      var polyInfo = this._getRegionPolygonInfo(idx);
      var lineInfo = this._getRegionLinesInfo(idx, componentModel, this._linesMesh.geometry);
      polygonVertexCount += polyInfo.vertexCount;
      polygonTriangleCount += polyInfo.triangleCount;
      linesVertexCount += lineInfo.vertexCount;
      linesTriangleCount += lineInfo.triangleCount;
    }
    var polygonMesh = this._polygonMesh;
    var polygonGeo = polygonMesh.geometry;
    ["position", "normal", "texcoord0", "color"].forEach(function(attrName) {
      polygonGeo.attributes[attrName].init(polygonVertexCount);
    });
    polygonGeo.indices = polygonVertexCount > 65535 ? new Uint32Array(polygonTriangleCount * 3) : new Uint16Array(polygonTriangleCount * 3);
    if (polygonMesh.material.shader !== shader) {
      polygonMesh.material.attachShader(shader, true);
    }
    graphicGL$1.setMaterialFromModel(shader.__shading, polygonMesh.material, componentModel, api);
    if (linesVertexCount > 0) {
      this._linesMesh.geometry.resetOffset();
      this._linesMesh.geometry.setVertexCount(linesVertexCount);
      this._linesMesh.geometry.setTriangleCount(linesTriangleCount);
    }
    this._dataIndexOfVertex = new Uint32Array(polygonVertexCount);
    this._vertexRangeOfDataIndex = new Uint32Array((end2 - start2) * 2);
  },
  _updateRegionMesh: function(componentModel, api, start2, end2) {
    var data = componentModel.getData();
    var vertexOffset = 0;
    var triangleOffset = 0;
    var hasTranparentRegion = false;
    var polygonMesh = this._polygonMesh;
    var linesMesh = this._linesMesh;
    for (var dataIndex = start2; dataIndex < end2; dataIndex++) {
      var regionModel = componentModel.getRegionModel(dataIndex);
      var itemStyleModel = regionModel.getModel("itemStyle");
      var color = retrieve$1.firstNotNull(getItemVisualColor(data, dataIndex), itemStyleModel.get("color"), "#fff");
      var opacity = retrieve$1.firstNotNull(getItemVisualOpacity(data, dataIndex), 1);
      var colorArr = graphicGL$1.parseColor(color);
      var borderColorArr = graphicGL$1.parseColor(itemStyleModel.get("borderColor"));
      colorArr[3] *= opacity;
      borderColorArr[3] *= opacity;
      var isTransparent = colorArr[3] < 0.99;
      polygonMesh.material.set("color", [1, 1, 1, 1]);
      hasTranparentRegion = hasTranparentRegion || isTransparent;
      var regionHeight = retrieve$1.firstNotNull(regionModel.get("height", true), componentModel.get("regionHeight"));
      var newOffsets = this._updatePolygonGeometry(componentModel, polygonMesh.geometry, dataIndex, regionHeight, vertexOffset, triangleOffset, colorArr);
      for (var i = vertexOffset; i < newOffsets.vertexOffset; i++) {
        this._dataIndexOfVertex[i] = dataIndex;
      }
      this._vertexRangeOfDataIndex[(dataIndex - start2) * 2] = vertexOffset;
      this._vertexRangeOfDataIndex[(dataIndex - start2) * 2 + 1] = newOffsets.vertexOffset;
      vertexOffset = newOffsets.vertexOffset;
      triangleOffset = newOffsets.triangleOffset;
      var lineWidth = itemStyleModel.get("borderWidth");
      var hasLine = lineWidth > 0;
      if (hasLine) {
        lineWidth *= api.getDevicePixelRatio();
        this._updateLinesGeometry(linesMesh.geometry, componentModel, dataIndex, regionHeight, lineWidth, componentModel.coordinateSystem.transform);
      }
      linesMesh.invisible = !hasLine;
      linesMesh.material.set({
        color: borderColorArr
      });
    }
    var polygonMesh = this._polygonMesh;
    polygonMesh.material.transparent = hasTranparentRegion;
    polygonMesh.material.depthMask = !hasTranparentRegion;
    polygonMesh.geometry.updateBoundingBox();
    polygonMesh.frontFace = this.extrudeY ? graphicGL$1.Mesh.CCW : graphicGL$1.Mesh.CW;
    if (polygonMesh.material.get("normalMap")) {
      polygonMesh.geometry.generateTangents();
    }
    polygonMesh.seriesIndex = componentModel.seriesIndex;
    polygonMesh.on("mousemove", this._onmousemove, this);
    polygonMesh.on("mouseout", this._onmouseout, this);
  },
  _updateDebugWireframe: function(componentModel) {
    var debugWireframeModel = componentModel.getModel("debug.wireframe");
    if (debugWireframeModel.get("show")) {
      var color = graphicGL$1.parseColor(debugWireframeModel.get("lineStyle.color") || "rgba(0,0,0,0.5)");
      var width = retrieve$1.firstNotNull(debugWireframeModel.get("lineStyle.width"), 1);
      var mesh2 = this._polygonMesh;
      mesh2.geometry.generateBarycentric();
      mesh2.material.define("both", "WIREFRAME_TRIANGLE");
      mesh2.material.set("wireframeLineColor", color);
      mesh2.material.set("wireframeLineWidth", width);
    }
  },
  _onmousemove: function(e2) {
    var dataIndex = this._dataIndexOfVertex[e2.triangle[0]];
    if (dataIndex == null) {
      dataIndex = -1;
    }
    if (dataIndex !== this._lastHoverDataIndex) {
      this.downplay(this._lastHoverDataIndex);
      this.highlight(dataIndex);
      this._labelsBuilder.updateLabels([dataIndex]);
    }
    this._lastHoverDataIndex = dataIndex;
    this._polygonMesh.dataIndex = dataIndex;
  },
  _onmouseout: function(e2) {
    if (e2.target) {
      this.downplay(this._lastHoverDataIndex);
      this._lastHoverDataIndex = -1;
      this._polygonMesh.dataIndex = -1;
    }
    this._labelsBuilder.updateLabels([]);
  },
  _updateGroundPlane: function(componentModel, geo3D, api) {
    var groundModel = componentModel.getModel("groundPlane", componentModel);
    this._groundMesh.invisible = !groundModel.get("show", true);
    if (this._groundMesh.invisible) {
      return;
    }
    var shading = componentModel.get("shading");
    var material = this._groundMaterials[shading];
    if (!material) {
      material = this._groundMaterials.lambert;
    }
    graphicGL$1.setMaterialFromModel(shading, material, groundModel, api);
    if (material.get("normalMap")) {
      this._groundMesh.geometry.generateTangents();
    }
    this._groundMesh.material = material;
    this._groundMesh.material.set("color", graphicGL$1.parseColor(groundModel.get("color")));
    this._groundMesh.scale.set(geo3D.size[0], geo3D.size[2], 1);
  },
  _triangulation: function(componentModel, start2, end2) {
    this._triangulationResults = [];
    var minAll = [Infinity, Infinity, Infinity];
    var maxAll = [-Infinity, -Infinity, -Infinity];
    var coordSys = componentModel.coordinateSystem;
    for (var idx = start2; idx < end2; idx++) {
      var polygons = [];
      var polygonCoords = componentModel.getRegionPolygonCoords(idx);
      for (var i = 0; i < polygonCoords.length; i++) {
        var exterior = polygonCoords[i].exterior;
        var interiors = polygonCoords[i].interiors;
        var points2 = [];
        var holes = [];
        if (exterior.length < 3) {
          continue;
        }
        var offset = 0;
        for (var j = 0; j < exterior.length; j++) {
          var p = exterior[j];
          points2[offset++] = p[0];
          points2[offset++] = p[1];
        }
        for (var j = 0; j < interiors.length; j++) {
          if (interiors[j].length < 3) {
            continue;
          }
          var startIdx = points2.length / 2;
          for (var k = 0; k < interiors[j].length; k++) {
            var p = interiors[j][k];
            points2.push(p[0]);
            points2.push(p[1]);
          }
          holes.push(startIdx);
        }
        var triangles = earcut(points2, holes);
        var points3 = new Float64Array(points2.length / 2 * 3);
        var pos = [];
        var min3 = [Infinity, Infinity, Infinity];
        var max3 = [-Infinity, -Infinity, -Infinity];
        var off3 = 0;
        for (var j = 0; j < points2.length; ) {
          vec3$b.set(pos, points2[j++], 0, points2[j++]);
          if (coordSys && coordSys.transform) {
            vec3$b.transformMat4(pos, pos, coordSys.transform);
          }
          vec3$b.min(min3, min3, pos);
          vec3$b.max(max3, max3, pos);
          points3[off3++] = pos[0];
          points3[off3++] = pos[1];
          points3[off3++] = pos[2];
        }
        vec3$b.min(minAll, minAll, min3);
        vec3$b.max(maxAll, maxAll, max3);
        polygons.push({
          points: points3,
          indices: triangles,
          min: min3,
          max: max3
        });
      }
      this._triangulationResults.push(polygons);
    }
    this._geoBoundingBox = [minAll, maxAll];
  },
  _getRegionPolygonInfo: function(idx) {
    var polygons = this._triangulationResults[idx - this._startIndex];
    var sideVertexCount = 0;
    var sideTriangleCount = 0;
    for (var i = 0; i < polygons.length; i++) {
      sideVertexCount += polygons[i].points.length / 3;
      sideTriangleCount += polygons[i].indices.length / 3;
    }
    var vertexCount = sideVertexCount * 2 + sideVertexCount * 4;
    var triangleCount = sideTriangleCount * 2 + sideVertexCount * 2;
    return {
      vertexCount,
      triangleCount
    };
  },
  _updatePolygonGeometry: function(componentModel, geometry, dataIndex, regionHeight, vertexOffset, triangleOffset, color) {
    var projectUVOnGround = componentModel.get("projectUVOnGround");
    var positionAttr = geometry.attributes.position;
    var normalAttr = geometry.attributes.normal;
    var texcoordAttr = geometry.attributes.texcoord0;
    var colorAttr = geometry.attributes.color;
    var polygons = this._triangulationResults[dataIndex - this._startIndex];
    var hasColor = colorAttr.value && color;
    var indices = geometry.indices;
    var extrudeCoordIndex = this.extrudeY ? 1 : 2;
    var sideCoordIndex = this.extrudeY ? 2 : 1;
    var scale2 = [this.rootNode.worldTransform.x.len(), this.rootNode.worldTransform.y.len(), this.rootNode.worldTransform.z.len()];
    var min3 = vec3$b.mul([], this._geoBoundingBox[0], scale2);
    var max3 = vec3$b.mul([], this._geoBoundingBox[1], scale2);
    var maxDimSize = Math.max(max3[0] - min3[0], max3[2] - min3[2]);
    function addVertices(polygon2, y, insideOffset) {
      var points2 = polygon2.points;
      var pointsLen = points2.length;
      var currentPosition = [];
      var uv2 = [];
      for (var k2 = 0; k2 < pointsLen; k2 += 3) {
        currentPosition[0] = points2[k2];
        currentPosition[extrudeCoordIndex] = y;
        currentPosition[sideCoordIndex] = points2[k2 + 2];
        uv2[0] = (points2[k2] * scale2[0] - min3[0]) / maxDimSize;
        uv2[1] = (points2[k2 + 2] * scale2[sideCoordIndex] - min3[2]) / maxDimSize;
        positionAttr.set(vertexOffset, currentPosition);
        if (hasColor) {
          colorAttr.set(vertexOffset, color);
        }
        texcoordAttr.set(vertexOffset++, uv2);
      }
    }
    function buildTopBottom(polygon2, y, insideOffset) {
      var startVertexOffset2 = vertexOffset;
      addVertices(polygon2, y);
      var len3 = polygon2.indices.length;
      for (var k2 = 0; k2 < len3; k2++) {
        indices[triangleOffset * 3 + k2] = polygon2.indices[k2] + startVertexOffset2;
      }
      triangleOffset += polygon2.indices.length / 3;
    }
    var normalTop = this.extrudeY ? [0, 1, 0] : [0, 0, 1];
    var normalBottom = vec3$b.negate([], normalTop);
    for (var p = 0; p < polygons.length; p++) {
      var startVertexOffset = vertexOffset;
      var polygon = polygons[p];
      buildTopBottom(polygon, 0);
      buildTopBottom(polygon, regionHeight);
      var ringVertexCount = polygon.points.length / 3;
      for (var v = 0; v < ringVertexCount; v++) {
        normalAttr.set(startVertexOffset + v, normalBottom);
        normalAttr.set(startVertexOffset + v + ringVertexCount, normalTop);
      }
      var quadToTriangle = [0, 3, 1, 1, 3, 2];
      var quadPos = [[], [], [], []];
      var a = [];
      var b = [];
      var normal2 = [];
      var uv = [];
      var len2 = 0;
      for (var v = 0; v < ringVertexCount; v++) {
        var next = (v + 1) % ringVertexCount;
        var dx = (polygon.points[next * 3] - polygon.points[v * 3]) * scale2[0];
        var dy = (polygon.points[next * 3 + 2] - polygon.points[v * 3 + 2]) * scale2[sideCoordIndex];
        var sideLen = Math.sqrt(dx * dx + dy * dy);
        for (var k = 0; k < 4; k++) {
          var isCurrent = k === 0 || k === 3;
          var idx3 = (isCurrent ? v : next) * 3;
          quadPos[k][0] = polygon.points[idx3];
          quadPos[k][extrudeCoordIndex] = k > 1 ? regionHeight : 0;
          quadPos[k][sideCoordIndex] = polygon.points[idx3 + 2];
          positionAttr.set(vertexOffset + k, quadPos[k]);
          if (projectUVOnGround) {
            uv[0] = (polygon.points[idx3] * scale2[0] - min3[0]) / maxDimSize;
            uv[1] = (polygon.points[idx3 + 2] * scale2[sideCoordIndex] - min3[sideCoordIndex]) / maxDimSize;
          } else {
            uv[0] = (isCurrent ? len2 : len2 + sideLen) / maxDimSize;
            uv[1] = (quadPos[k][extrudeCoordIndex] * scale2[extrudeCoordIndex] - min3[extrudeCoordIndex]) / maxDimSize;
          }
          texcoordAttr.set(vertexOffset + k, uv);
        }
        vec3$b.sub(a, quadPos[1], quadPos[0]);
        vec3$b.sub(b, quadPos[3], quadPos[0]);
        vec3$b.cross(normal2, a, b);
        vec3$b.normalize(normal2, normal2);
        for (var k = 0; k < 4; k++) {
          normalAttr.set(vertexOffset + k, normal2);
          if (hasColor) {
            colorAttr.set(vertexOffset + k, color);
          }
        }
        for (var k = 0; k < 6; k++) {
          indices[triangleOffset * 3 + k] = quadToTriangle[k] + vertexOffset;
        }
        vertexOffset += 4;
        triangleOffset += 2;
        len2 += sideLen;
      }
    }
    geometry.dirty();
    return {
      vertexOffset,
      triangleOffset
    };
  },
  _getRegionLinesInfo: function(idx, componentModel, geometry) {
    var vertexCount = 0;
    var triangleCount = 0;
    var regionModel = componentModel.getRegionModel(idx);
    var itemStyleModel = regionModel.getModel("itemStyle");
    var lineWidth = itemStyleModel.get("borderWidth");
    if (lineWidth > 0) {
      var polygonCoords = componentModel.getRegionPolygonCoords(idx);
      polygonCoords.forEach(function(coords) {
        var exterior = coords.exterior;
        var interiors = coords.interiors;
        vertexCount += geometry.getPolylineVertexCount(exterior);
        triangleCount += geometry.getPolylineTriangleCount(exterior);
        for (var i = 0; i < interiors.length; i++) {
          vertexCount += geometry.getPolylineVertexCount(interiors[i]);
          triangleCount += geometry.getPolylineTriangleCount(interiors[i]);
        }
      }, this);
    }
    return {
      vertexCount,
      triangleCount
    };
  },
  _updateLinesGeometry: function(geometry, componentModel, dataIndex, regionHeight, lineWidth, transform2) {
    function convertToPoints3(polygon) {
      var points2 = new Float64Array(polygon.length * 3);
      var offset = 0;
      var pos = [];
      for (var i = 0; i < polygon.length; i++) {
        pos[0] = polygon[i][0];
        pos[1] = regionHeight + 0.1;
        pos[2] = polygon[i][1];
        if (transform2) {
          vec3$b.transformMat4(pos, pos, transform2);
        }
        points2[offset++] = pos[0];
        points2[offset++] = pos[1];
        points2[offset++] = pos[2];
      }
      return points2;
    }
    var whiteColor = [1, 1, 1, 1];
    var coords = componentModel.getRegionPolygonCoords(dataIndex);
    coords.forEach(function(geo) {
      var exterior = geo.exterior;
      var interiors = geo.interiors;
      geometry.addPolyline(convertToPoints3(exterior), whiteColor, lineWidth);
      for (var i = 0; i < interiors.length; i++) {
        geometry.addPolyline(convertToPoints3(interiors[i]), whiteColor, lineWidth);
      }
    });
  },
  highlight: function(dataIndex) {
    var data = this._data;
    if (!data) {
      return;
    }
    var itemModel = data.getItemModel(dataIndex);
    var emphasisItemStyleModel = itemModel.getModel(["emphasis", "itemStyle"]);
    var emphasisColor = emphasisItemStyleModel.get("color");
    var emphasisOpacity = retrieve$1.firstNotNull(emphasisItemStyleModel.get("opacity"), getItemVisualOpacity(data, dataIndex), 1);
    if (emphasisColor == null) {
      var color = getItemVisualColor(data, dataIndex);
      emphasisColor = lift(color, -0.4);
    }
    if (emphasisOpacity == null) {
      emphasisOpacity = getItemVisualOpacity(data, dataIndex);
    }
    var colorArr = graphicGL$1.parseColor(emphasisColor);
    colorArr[3] *= emphasisOpacity;
    this._setColorOfDataIndex(data, dataIndex, colorArr);
  },
  downplay: function(dataIndex) {
    var data = this._data;
    if (!data) {
      return;
    }
    var color = retrieve$1.firstNotNull(getItemVisualColor(data, dataIndex), data.getItemModel(dataIndex).get(["itemStyle", "color"]), "#fff");
    var opacity = retrieve$1.firstNotNull(getItemVisualOpacity(data, dataIndex), 1);
    var colorArr = graphicGL$1.parseColor(color);
    colorArr[3] *= opacity;
    this._setColorOfDataIndex(data, dataIndex, colorArr);
  },
  dispose: function() {
    this._labelsBuilder.dispose();
  },
  _setColorOfDataIndex: function(data, dataIndex, colorArr) {
    if (dataIndex < this._startIndex && dataIndex > this._endIndex) {
      return;
    }
    dataIndex -= this._startIndex;
    for (var i = this._vertexRangeOfDataIndex[dataIndex * 2]; i < this._vertexRangeOfDataIndex[dataIndex * 2 + 1]; i++) {
      this._polygonMesh.geometry.attributes.color.set(i, colorArr);
    }
    this._polygonMesh.geometry.dirty();
    this._api.getZr().refresh();
  }
};
var Geo3DView = ComponentView$1.extend({
  type: "geo3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this._geo3DBuilder = new Geo3DBuilder(api);
    this.groupGL = new graphicGL$1.Node();
    this._lightRoot = new graphicGL$1.Node();
    this._sceneHelper = new SceneHelper(this._lightRoot);
    this._sceneHelper.initLight(this._lightRoot);
    this._control = new OrbitControl$1({
      zr: api.getZr()
    });
    this._control.init();
  },
  render: function(geo3DModel, ecModel, api) {
    this.groupGL.add(this._geo3DBuilder.rootNode);
    var geo3D = geo3DModel.coordinateSystem;
    if (!geo3D || !geo3D.viewGL) {
      return;
    }
    geo3D.viewGL.add(this._lightRoot);
    if (geo3DModel.get("show")) {
      geo3D.viewGL.add(this.groupGL);
    } else {
      geo3D.viewGL.remove(this.groupGL);
    }
    var control = this._control;
    control.setViewGL(geo3D.viewGL);
    var viewControlModel = geo3DModel.getModel("viewControl");
    control.setFromViewControlModel(viewControlModel, 0);
    this._sceneHelper.setScene(geo3D.viewGL.scene);
    this._sceneHelper.updateLight(geo3DModel);
    geo3D.viewGL.setPostEffect(geo3DModel.getModel("postEffect"), api);
    geo3D.viewGL.setTemporalSuperSampling(geo3DModel.getModel("temporalSuperSampling"));
    this._geo3DBuilder.update(geo3DModel, ecModel, api, 0, geo3DModel.getData().count());
    var srgbDefineMethod = geo3D.viewGL.isLinearSpace() ? "define" : "undefine";
    this._geo3DBuilder.rootNode.traverse(function(mesh2) {
      if (mesh2.material) {
        mesh2.material[srgbDefineMethod]("fragment", "SRGB_DECODE");
      }
    });
    control.off("update");
    control.on("update", function() {
      api.dispatchAction({
        type: "geo3DChangeCamera",
        alpha: control.getAlpha(),
        beta: control.getBeta(),
        distance: control.getDistance(),
        center: control.getCenter(),
        from: this.uid,
        geo3DId: geo3DModel.id
      });
    });
    control.update();
  },
  afterRender: function(geo3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, geo3DModel, api);
    this._sceneHelper.updateSkybox(renderer, geo3DModel, api);
  },
  dispose: function() {
    this._control.dispose();
    this._geo3DBuilder.dispose();
  }
});
var geoCoordMap = {
  "Russia": [100, 60],
  "United States": [-99, 38],
  "United States of America": [-99, 38]
};
function fixGeoCoords(mapType, region) {
  if (mapType === "world") {
    var geoCoord2 = geoCoordMap[region.name];
    if (geoCoord2) {
      var cp = [geoCoord2[0], geoCoord2[1]];
      region.setCenter(cp);
    }
  }
}
var vec3$a = glmatrix.vec3;
var mat4$1 = glmatrix.mat4;
var geoFixFuncs = [fixTextCoords, fixGeoCoords];
function Geo3D(name, map2, geoJson, specialAreas, nameMap) {
  this.name = name;
  this.map = map2;
  this.regionHeight = 0;
  this.regions = [];
  this._nameCoordMap = {};
  this.loadGeoJson(geoJson, specialAreas, nameMap);
  this.transform = mat4$1.identity(new Float64Array(16));
  this.invTransform = mat4$1.identity(new Float64Array(16));
  this.extrudeY = true;
  this.altitudeAxis;
}
Geo3D.prototype = {
  constructor: Geo3D,
  type: "geo3D",
  dimensions: ["lng", "lat", "alt"],
  containPoint: function() {
  },
  loadGeoJson: function(geoJson, specialAreas, nameMap) {
    var parseGeoJSON$1 = parseGeoJSON || parseGeoJSON;
    try {
      this.regions = geoJson ? parseGeoJSON$1(geoJson) : [];
    } catch (e2) {
      throw "Invalid geoJson format\n" + e2;
    }
    specialAreas = specialAreas || {};
    nameMap = nameMap || {};
    var regions = this.regions;
    var regionsMap = {};
    for (var i = 0; i < regions.length; i++) {
      var regionName = regions[i].name;
      regionName = nameMap[regionName] || regionName;
      regions[i].name = regionName;
      regionsMap[regionName] = regions[i];
      this.addGeoCoord(regionName, regions[i].getCenter());
      var specialArea = specialAreas[regionName];
      if (specialArea) {
        regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
      }
    }
    this._regionsMap = regionsMap;
    this._geoRect = null;
    geoFixFuncs.forEach(function(fixFunc) {
      fixFunc(this);
    }, this);
  },
  getGeoBoundingRect: function() {
    if (this._geoRect) {
      return this._geoRect;
    }
    var rect;
    var regions = this.regions;
    for (var i = 0; i < regions.length; i++) {
      var regionRect = regions[i].getBoundingRect();
      rect = rect || regionRect.clone();
      rect.union(regionRect);
    }
    return this._geoRect = rect || new BoundingRect$1(0, 0, 0, 0);
  },
  addGeoCoord: function(name, geoCoord2) {
    this._nameCoordMap[name] = geoCoord2;
  },
  getRegion: function(name) {
    return this._regionsMap[name];
  },
  getRegionByCoord: function(coord) {
    var regions = this.regions;
    for (var i = 0; i < regions.length; i++) {
      if (regions[i].contain(coord)) {
        return regions[i];
      }
    }
  },
  setSize: function(width, height, depth) {
    this.size = [width, height, depth];
    var rect = this.getGeoBoundingRect();
    var scaleX = width / rect.width;
    var scaleZ = -depth / rect.height;
    var translateX = -width / 2 - rect.x * scaleX;
    var translateZ = depth / 2 - rect.y * scaleZ;
    var position2 = this.extrudeY ? [translateX, 0, translateZ] : [translateX, translateZ, 0];
    var scale2 = this.extrudeY ? [scaleX, 1, scaleZ] : [scaleX, scaleZ, 1];
    var m2 = this.transform;
    mat4$1.identity(m2);
    mat4$1.translate(m2, m2, position2);
    mat4$1.scale(m2, m2, scale2);
    mat4$1.invert(this.invTransform, m2);
  },
  dataToPoint: function(data, out2) {
    out2 = out2 || [];
    var extrudeCoordIndex = this.extrudeY ? 1 : 2;
    var sideCoordIndex = this.extrudeY ? 2 : 1;
    var altitudeVal = data[2];
    if (isNaN(altitudeVal)) {
      altitudeVal = 0;
    }
    out2[0] = data[0];
    out2[sideCoordIndex] = data[1];
    if (this.altitudeAxis) {
      out2[extrudeCoordIndex] = this.altitudeAxis.dataToCoord(altitudeVal);
    } else {
      out2[extrudeCoordIndex] = 0;
    }
    out2[extrudeCoordIndex] += this.regionHeight;
    vec3$a.transformMat4(out2, out2, this.transform);
    return out2;
  },
  pointToData: function(point, out2) {
  }
};
function resizeGeo3D(geo3DModel, api) {
  var boxLayoutOption = geo3DModel.getBoxLayoutParams();
  var viewport = getLayoutRect(boxLayoutOption, {
    width: api.getWidth(),
    height: api.getHeight()
  });
  viewport.y = api.getHeight() - viewport.y - viewport.height;
  this.viewGL.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, api.getDevicePixelRatio());
  var geoRect = this.getGeoBoundingRect();
  var aspect = geoRect.width / geoRect.height * (geo3DModel.get("aspectScale") || 0.75);
  var width = geo3DModel.get("boxWidth");
  var depth = geo3DModel.get("boxDepth");
  var height = geo3DModel.get("boxHeight");
  if (height == null) {
    height = 5;
  }
  if (isNaN(width) && isNaN(depth)) {
    width = 100;
  }
  if (isNaN(depth)) {
    depth = width / aspect;
  } else if (isNaN(width)) {
    width = depth / aspect;
  }
  this.setSize(width, height, depth);
  this.regionHeight = geo3DModel.get("regionHeight");
  if (this.altitudeAxis) {
    this.altitudeAxis.setExtent(0, Math.max(height - this.regionHeight, 0));
  }
}
function updateGeo3D(ecModel, api) {
  var altitudeDataExtent = [Infinity, -Infinity];
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem !== this) {
      return;
    }
    if (seriesModel.type === "series.map3D") {
      return;
    }
    var data = seriesModel.getData();
    var altDims = seriesModel.coordDimToDataDim("alt");
    var altDim = altDims && altDims[0];
    if (altDim) {
      var dataExtent = data.getDataExtent(altDim, true);
      altitudeDataExtent[0] = Math.min(altitudeDataExtent[0], dataExtent[0]);
      altitudeDataExtent[1] = Math.max(altitudeDataExtent[1], dataExtent[1]);
    }
  }, this);
  if (altitudeDataExtent && isFinite(altitudeDataExtent[1] - altitudeDataExtent[0])) {
    var scale2 = createScale(altitudeDataExtent, {
      type: "value",
      min: "dataMin",
      max: "dataMax"
    });
    this.altitudeAxis = new Axis$1("altitude", scale2);
    this.resize(this.model, api);
  }
}
var idStart = 0;
var geo3DCreator = {
  dimensions: Geo3D.prototype.dimensions,
  create: function(ecModel, api) {
    var geo3DList = [];
    if (!getMap) {
      throw new Error("geo3D component depends on geo component");
    }
    function createGeo3D(componentModel, idx) {
      var geo3D = geo3DCreator.createGeo3D(componentModel);
      componentModel.__viewGL = componentModel.__viewGL || new ViewGL();
      geo3D.viewGL = componentModel.__viewGL;
      componentModel.coordinateSystem = geo3D;
      geo3D.model = componentModel;
      geo3DList.push(geo3D);
      geo3D.resize = resizeGeo3D;
      geo3D.resize(componentModel, api);
      geo3D.update = updateGeo3D;
    }
    ecModel.eachComponent("geo3D", function(geo3DModel, idx) {
      createGeo3D(geo3DModel);
    });
    ecModel.eachSeriesByType("map3D", function(map3DModel, idx) {
      var coordSys = map3DModel.get("coordinateSystem");
      if (coordSys == null) {
        coordSys = "geo3D";
      }
      if (coordSys === "geo3D") {
        createGeo3D(map3DModel);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "geo3D") {
        if (seriesModel.type === "series.map3D") {
          return;
        }
        var geo3DModel = seriesModel.getReferringComponents("geo3D").models[0];
        if (!geo3DModel) {
          geo3DModel = ecModel.getComponent("geo3D");
        }
        if (!geo3DModel) {
          throw new Error('geo "' + retrieve$1.firstNotNull(seriesModel.get("geo3DIndex"), seriesModel.get("geo3DId"), 0) + '" not found');
        }
        seriesModel.coordinateSystem = geo3DModel.coordinateSystem;
      }
    });
    return geo3DList;
  },
  createGeo3D: function(componentModel) {
    var mapData = componentModel.get("map");
    var name;
    if (typeof mapData === "string") {
      name = mapData;
      mapData = getMap(mapData);
    } else {
      if (mapData && mapData.features) {
        mapData = {
          geoJson: mapData
        };
      }
    }
    if (name == null) {
      name = "GEO_ANONYMOUS_" + idStart++;
    }
    return new Geo3D(name + idStart++, name, mapData && mapData.geoJson, mapData && mapData.specialAreas, componentModel.get("nameMap"));
  }
};
var geo3DCreator$1 = geo3DCreator;
function install$e(registers) {
  registers.registerComponentModel(Geo3DModel$1);
  registers.registerComponentView(Geo3DView);
  registers.registerAction({
    type: "geo3DChangeCamera",
    event: "geo3dcamerachanged",
    update: "series:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "geo3D",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
  registers.registerCoordinateSystem("geo3D", geo3DCreator$1);
}
use(install$e);
function defaultId(option, idx) {
  option.id = option.id || option.name || idx + "";
}
var GlobeModel = ComponentModel$1.extend({
  type: "globe",
  layoutMode: "box",
  coordinateSystem: null,
  init: function() {
    GlobeModel.superApply(this, "init", arguments);
    each$f(this.option.layers, function(layerOption, idx) {
      merge(layerOption, this.defaultLayerOption);
      defaultId(layerOption, idx);
    }, this);
  },
  mergeOption: function(option) {
    var oldLayers = this.option.layers;
    this.option.layers = null;
    GlobeModel.superApply(this, "mergeOption", arguments);
    function createLayerMap(layers) {
      return reduce(layers, function(obj, layerOption, idx) {
        defaultId(layerOption, idx);
        obj[layerOption.id] = layerOption;
        return obj;
      }, {});
    }
    if (oldLayers && oldLayers.length) {
      var newLayerMap = createLayerMap(option.layers);
      var oldLayerMap = createLayerMap(oldLayers);
      for (var id in newLayerMap) {
        if (oldLayerMap[id]) {
          merge(oldLayerMap[id], newLayerMap[id], true);
        } else {
          oldLayers.push(option.layers[id]);
        }
      }
      this.option.layers = oldLayers;
    }
    each$f(this.option.layers, function(layerOption) {
      merge(layerOption, this.defaultLayerOption);
    }, this);
  },
  optionUpdated: function() {
    this.updateDisplacementHash();
  },
  defaultLayerOption: {
    show: true,
    type: "overlay"
  },
  defaultOption: {
    show: true,
    zlevel: -10,
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    environment: "auto",
    baseColor: "#fff",
    baseTexture: "",
    heightTexture: "",
    displacementTexture: "",
    displacementScale: 0,
    displacementQuality: "medium",
    globeRadius: 100,
    globeOuterRadius: 150,
    shading: "lambert",
    light: {
      main: {
        time: ""
      }
    },
    atmosphere: {
      show: false,
      offset: 5,
      color: "#ffffff",
      glowPower: 6,
      innerGlowPower: 2
    },
    viewControl: {
      autoRotate: true,
      panSensitivity: 0,
      targetCoord: null
    },
    layers: []
  },
  setDisplacementData: function(data, width, height) {
    this.displacementData = data;
    this.displacementWidth = width;
    this.displacementHeight = height;
  },
  getDisplacementTexture: function() {
    return this.get("displacementTexture") || this.get("heightTexture");
  },
  getDisplacemenScale: function() {
    var displacementTexture = this.getDisplacementTexture();
    var displacementScale = this.get("displacementScale");
    if (!displacementTexture || displacementTexture === "none") {
      displacementScale = 0;
    }
    return displacementScale;
  },
  hasDisplacement: function() {
    return this.getDisplacemenScale() > 0;
  },
  _displacementChanged: true,
  _displacementScale: 0,
  updateDisplacementHash: function() {
    var displacementTexture = this.getDisplacementTexture();
    var displacementScale = this.getDisplacemenScale();
    this._displacementChanged = this._displacementTexture !== displacementTexture || this._displacementScale !== displacementScale;
    this._displacementTexture = displacementTexture;
    this._displacementScale = displacementScale;
  },
  isDisplacementChanged: function() {
    return this._displacementChanged;
  }
});
merge(GlobeModel.prototype, componentViewControlMixin);
merge(GlobeModel.prototype, componentPostEffectMixin);
merge(GlobeModel.prototype, componentLightMixin);
merge(GlobeModel.prototype, componentShadingMixin);
var GlobeModel$1 = GlobeModel;
var PI$1 = Math.PI, sin = Math.sin, cos = Math.cos, tan = Math.tan, asin = Math.asin, atan = Math.atan2, rad = PI$1 / 180;
var dayMs = 1e3 * 60 * 60 * 24, J1970 = 2440588, J2000 = 2451545;
function toJulian(date) {
  return date.valueOf() / dayMs - 0.5 + J1970;
}
function toDays(date) {
  return toJulian(date) - J2000;
}
var e = rad * 23.4397;
function rightAscension(l, b) {
  return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));
}
function declination(l, b) {
  return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));
}
function azimuth(H, phi, dec) {
  return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
}
function altitude(H, phi, dec) {
  return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
}
function siderealTime(d, lw) {
  return rad * (280.16 + 360.9856235 * d) - lw;
}
function solarMeanAnomaly(d) {
  return rad * (357.5291 + 0.98560028 * d);
}
function eclipticLongitude(M) {
  var C = rad * (1.9148 * sin(M) + 0.02 * sin(2 * M) + 3e-4 * sin(3 * M)), P = rad * 102.9372;
  return M + C + P + PI$1;
}
function sunCoords(d) {
  var M = solarMeanAnomaly(d), L = eclipticLongitude(M);
  return {
    dec: declination(L, 0),
    ra: rightAscension(L, 0)
  };
}
var SunCalc = {};
SunCalc.getPosition = function(date, lat, lng) {
  var lw = rad * -lng, phi = rad * lat, d = toDays(date), c = sunCoords(d), H = siderealTime(d, lw) - c.ra;
  return {
    azimuth: azimuth(H, phi, c.dec),
    altitude: altitude(H, phi, c.dec)
  };
};
var sunCalc = SunCalc;
var atmosphereShaderCode = "@export ecgl.atmosphere.vertex\nattribute vec3 position: POSITION;\nattribute vec3 normal : NORMAL;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform mat4 normalMatrix : WORLDINVERSETRANSPOSE;\n\nvarying vec3 v_Normal;\n\nvoid main() {\n v_Normal = normalize((normalMatrix * vec4(normal, 0.0)).xyz);\n gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n@end\n\n\n@export ecgl.atmosphere.fragment\nuniform mat4 viewTranspose: VIEWTRANSPOSE;\nuniform float glowPower;\nuniform vec3 glowColor;\n\nvarying vec3 v_Normal;\n\nvoid main() {\n float intensity = pow(1.0 - dot(v_Normal, (viewTranspose * vec4(0.0, 0.0, 1.0, 0.0)).xyz), glowPower);\n gl_FragColor = vec4(glowColor, intensity * intensity);\n}\n@end";
graphicGL$1.Shader["import"](utilShaderCode);
graphicGL$1.Shader["import"](atmosphereShaderCode);
var GlobeView = ComponentView$1.extend({
  type: "globe",
  __ecgl__: true,
  _displacementScale: 0,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this._sphereGeometry = new graphicGL$1.SphereGeometry({
      widthSegments: 200,
      heightSegments: 100,
      dynamic: true
    });
    this._overlayGeometry = new graphicGL$1.SphereGeometry({
      widthSegments: 80,
      heightSegments: 40
    });
    this._planeGeometry = new graphicGL$1.PlaneGeometry();
    this._earthMesh = new graphicGL$1.Mesh({
      renderNormal: true
    });
    this._atmosphereMesh = new graphicGL$1.Mesh();
    this._atmosphereGeometry = new graphicGL$1.SphereGeometry({
      widthSegments: 80,
      heightSegments: 40
    });
    this._atmosphereMaterial = new graphicGL$1.Material({
      shader: new graphicGL$1.Shader(graphicGL$1.Shader.source("ecgl.atmosphere.vertex"), graphicGL$1.Shader.source("ecgl.atmosphere.fragment")),
      transparent: true
    });
    this._atmosphereMesh.geometry = this._atmosphereGeometry;
    this._atmosphereMesh.material = this._atmosphereMaterial;
    this._atmosphereMesh.frontFace = graphicGL$1.Mesh.CW;
    this._lightRoot = new graphicGL$1.Node();
    this._sceneHelper = new SceneHelper();
    this._sceneHelper.initLight(this._lightRoot);
    this.groupGL.add(this._atmosphereMesh);
    this.groupGL.add(this._earthMesh);
    this._control = new OrbitControl$1({
      zr: api.getZr()
    });
    this._control.init();
    this._layerMeshes = {};
  },
  render: function(globeModel, ecModel, api) {
    var coordSys = globeModel.coordinateSystem;
    var shading = globeModel.get("shading");
    coordSys.viewGL.add(this._lightRoot);
    if (globeModel.get("show")) {
      coordSys.viewGL.add(this.groupGL);
    } else {
      coordSys.viewGL.remove(this.groupGL);
    }
    this._sceneHelper.setScene(coordSys.viewGL.scene);
    coordSys.viewGL.setPostEffect(globeModel.getModel("postEffect"), api);
    coordSys.viewGL.setTemporalSuperSampling(globeModel.getModel("temporalSuperSampling"));
    var earthMesh = this._earthMesh;
    earthMesh.geometry = this._sphereGeometry;
    var shadingPrefix = "ecgl." + shading;
    if (!earthMesh.material || earthMesh.material.shader.name !== shadingPrefix) {
      earthMesh.material = graphicGL$1.createMaterial(shadingPrefix);
    }
    graphicGL$1.setMaterialFromModel(shading, earthMesh.material, globeModel, api);
    ["roughnessMap", "metalnessMap", "detailMap", "normalMap"].forEach(function(texName) {
      var texture = earthMesh.material.get(texName);
      if (texture) {
        texture.flipY = false;
      }
    });
    earthMesh.material.set("color", graphicGL$1.parseColor(globeModel.get("baseColor")));
    var scale2 = coordSys.radius * 0.99;
    earthMesh.scale.set(scale2, scale2, scale2);
    if (globeModel.get("atmosphere.show")) {
      earthMesh.material.define("both", "ATMOSPHERE_ENABLED");
      this._atmosphereMesh.invisible = false;
      this._atmosphereMaterial.setUniforms({
        glowPower: globeModel.get("atmosphere.glowPower") || 6,
        glowColor: globeModel.get("atmosphere.color") || "#ffffff"
      });
      earthMesh.material.setUniforms({
        glowPower: globeModel.get("atmosphere.innerGlowPower") || 2,
        glowColor: globeModel.get("atmosphere.color") || "#ffffff"
      });
      var offset = globeModel.get("atmosphere.offset") || 5;
      this._atmosphereMesh.scale.set(scale2 + offset, scale2 + offset, scale2 + offset);
    } else {
      earthMesh.material.undefine("both", "ATMOSPHERE_ENABLED");
      this._atmosphereMesh.invisible = true;
    }
    var diffuseTexture = earthMesh.material.setTextureImage("diffuseMap", globeModel.get("baseTexture"), api, {
      flipY: false,
      anisotropic: 8
    });
    if (diffuseTexture && diffuseTexture.surface) {
      diffuseTexture.surface.attachToMesh(earthMesh);
    }
    var bumpTexture = earthMesh.material.setTextureImage("bumpMap", globeModel.get("heightTexture"), api, {
      flipY: false,
      anisotropic: 8
    });
    if (bumpTexture && bumpTexture.surface) {
      bumpTexture.surface.attachToMesh(earthMesh);
    }
    earthMesh.material[globeModel.get("postEffect.enable") ? "define" : "undefine"]("fragment", "SRGB_DECODE");
    this._updateLight(globeModel, api);
    this._displaceVertices(globeModel, api);
    this._updateViewControl(globeModel, api);
    this._updateLayers(globeModel, api);
  },
  afterRender: function(globeModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, globeModel, api);
    this._sceneHelper.updateSkybox(renderer, globeModel, api);
  },
  _updateLayers: function(globeModel, api) {
    var coordSys = globeModel.coordinateSystem;
    var layers = globeModel.get("layers");
    var lastDistance = coordSys.radius;
    var layerDiffuseTextures = [];
    var layerDiffuseIntensity = [];
    var layerEmissiveTextures = [];
    var layerEmissionIntensity = [];
    each$f(layers, function(layerOption) {
      var layerModel = new Model$1(layerOption);
      var layerType = layerModel.get("type");
      var texture = graphicGL$1.loadTexture(layerModel.get("texture"), api, {
        flipY: false,
        anisotropic: 8
      });
      if (texture.surface) {
        texture.surface.attachToMesh(this._earthMesh);
      }
      if (layerType === "blend") {
        var blendTo = layerModel.get("blendTo");
        var intensity = retrieve$1.firstNotNull(layerModel.get("intensity"), 1);
        if (blendTo === "emission") {
          layerEmissiveTextures.push(texture);
          layerEmissionIntensity.push(intensity);
        } else {
          layerDiffuseTextures.push(texture);
          layerDiffuseIntensity.push(intensity);
        }
      } else {
        var id = layerModel.get("id");
        var overlayMesh = this._layerMeshes[id];
        if (!overlayMesh) {
          overlayMesh = this._layerMeshes[id] = new graphicGL$1.Mesh({
            geometry: this._overlayGeometry,
            castShadow: false,
            ignorePicking: true
          });
        }
        var shading = layerModel.get("shading");
        if (shading === "lambert") {
          overlayMesh.material = overlayMesh.__lambertMaterial || new graphicGL$1.Material({
            autoUpdateTextureStatus: false,
            shader: graphicGL$1.createShader("ecgl.lambert"),
            transparent: true,
            depthMask: false
          });
          overlayMesh.__lambertMaterial = overlayMesh.material;
        } else {
          overlayMesh.material = overlayMesh.__colorMaterial || new graphicGL$1.Material({
            autoUpdateTextureStatus: false,
            shader: graphicGL$1.createShader("ecgl.color"),
            transparent: true,
            depthMask: false
          });
          overlayMesh.__colorMaterial = overlayMesh.material;
        }
        overlayMesh.material.enableTexture("diffuseMap");
        var distance2 = layerModel.get("distance");
        var radius = lastDistance + (distance2 == null ? coordSys.radius / 100 : distance2);
        overlayMesh.scale.set(radius, radius, radius);
        lastDistance = radius;
        var blankTexture = this._blankTexture || (this._blankTexture = graphicGL$1.createBlankTexture("rgba(255, 255, 255, 0)"));
        overlayMesh.material.set("diffuseMap", blankTexture);
        graphicGL$1.loadTexture(layerModel.get("texture"), api, {
          flipY: false,
          anisotropic: 8
        }, function(texture2) {
          if (texture2.surface) {
            texture2.surface.attachToMesh(overlayMesh);
          }
          overlayMesh.material.set("diffuseMap", texture2);
          api.getZr().refresh();
        });
        layerModel.get("show") ? this.groupGL.add(overlayMesh) : this.groupGL.remove(overlayMesh);
      }
    }, this);
    var earthMaterial = this._earthMesh.material;
    earthMaterial.define("fragment", "LAYER_DIFFUSEMAP_COUNT", layerDiffuseTextures.length);
    earthMaterial.define("fragment", "LAYER_EMISSIVEMAP_COUNT", layerEmissiveTextures.length);
    earthMaterial.set("layerDiffuseMap", layerDiffuseTextures);
    earthMaterial.set("layerDiffuseIntensity", layerDiffuseIntensity);
    earthMaterial.set("layerEmissiveMap", layerEmissiveTextures);
    earthMaterial.set("layerEmissionIntensity", layerEmissionIntensity);
    var debugWireframeModel = globeModel.getModel("debug.wireframe");
    if (debugWireframeModel.get("show")) {
      earthMaterial.define("both", "WIREFRAME_TRIANGLE");
      var color = graphicGL$1.parseColor(debugWireframeModel.get("lineStyle.color") || "rgba(0,0,0,0.5)");
      var width = retrieve$1.firstNotNull(debugWireframeModel.get("lineStyle.width"), 1);
      earthMaterial.set("wireframeLineWidth", width);
      earthMaterial.set("wireframeLineColor", color);
    } else {
      earthMaterial.undefine("both", "WIREFRAME_TRIANGLE");
    }
  },
  _updateViewControl: function(globeModel, api) {
    var coordSys = globeModel.coordinateSystem;
    var viewControlModel = globeModel.getModel("viewControl");
    coordSys.viewGL.camera;
    var self2 = this;
    function makeAction() {
      return {
        type: "globeChangeCamera",
        alpha: control.getAlpha(),
        beta: control.getBeta(),
        distance: control.getDistance() - coordSys.radius,
        center: control.getCenter(),
        from: self2.uid,
        globeId: globeModel.id
      };
    }
    var control = this._control;
    control.setViewGL(coordSys.viewGL);
    var coord = viewControlModel.get("targetCoord");
    var alpha, beta;
    if (coord != null) {
      beta = coord[0] + 90;
      alpha = coord[1];
    }
    control.setFromViewControlModel(viewControlModel, {
      baseDistance: coordSys.radius,
      alpha,
      beta
    });
    control.off("update");
    control.on("update", function() {
      api.dispatchAction(makeAction());
    });
  },
  _displaceVertices: function(globeModel, api) {
    var displacementQuality = globeModel.get("displacementQuality");
    var showDebugWireframe = globeModel.get("debug.wireframe.show");
    var globe = globeModel.coordinateSystem;
    if (!globeModel.isDisplacementChanged() && displacementQuality === this._displacementQuality && showDebugWireframe === this._showDebugWireframe) {
      return;
    }
    this._displacementQuality = displacementQuality;
    this._showDebugWireframe = showDebugWireframe;
    var geometry = this._sphereGeometry;
    var widthSegments = {
      low: 100,
      medium: 200,
      high: 400,
      ultra: 800
    }[displacementQuality] || 200;
    var heightSegments = widthSegments / 2;
    if (geometry.widthSegments !== widthSegments || showDebugWireframe) {
      geometry.widthSegments = widthSegments;
      geometry.heightSegments = heightSegments;
      geometry.build();
    }
    this._doDisplaceVertices(geometry, globe);
    if (showDebugWireframe) {
      geometry.generateBarycentric();
    }
  },
  _doDisplaceVertices: function(geometry, globe) {
    var positionArr = geometry.attributes.position.value;
    var uvArr = geometry.attributes.texcoord0.value;
    var originalPositionArr = geometry.__originalPosition;
    if (!originalPositionArr || originalPositionArr.length !== positionArr.length) {
      originalPositionArr = new Float32Array(positionArr.length);
      originalPositionArr.set(positionArr);
      geometry.__originalPosition = originalPositionArr;
    }
    var width = globe.displacementWidth;
    var height = globe.displacementHeight;
    var data = globe.displacementData;
    for (var i = 0; i < geometry.vertexCount; i++) {
      var i3 = i * 3;
      var i2 = i * 2;
      var x = originalPositionArr[i3 + 1];
      var y = originalPositionArr[i3 + 2];
      var z = originalPositionArr[i3 + 3];
      var u = uvArr[i2++];
      var v = uvArr[i2++];
      var j = Math.round(u * (width - 1));
      var k = Math.round(v * (height - 1));
      var idx = k * width + j;
      var scale2 = data ? data[idx] : 0;
      positionArr[i3 + 1] = x + x * scale2;
      positionArr[i3 + 2] = y + y * scale2;
      positionArr[i3 + 3] = z + z * scale2;
    }
    geometry.generateVertexNormals();
    geometry.dirty();
    geometry.updateBoundingBox();
  },
  _updateLight: function(globeModel, api) {
    var earthMesh = this._earthMesh;
    this._sceneHelper.updateLight(globeModel);
    var mainLight = this._sceneHelper.mainLight;
    var time = globeModel.get("light.main.time") || new Date();
    var pos = sunCalc.getPosition(parseDate(time), 0, 0);
    var r0 = Math.cos(pos.altitude);
    mainLight.position.y = -r0 * Math.cos(pos.azimuth);
    mainLight.position.x = Math.sin(pos.altitude);
    mainLight.position.z = r0 * Math.sin(pos.azimuth);
    mainLight.lookAt(earthMesh.getWorldPosition());
  },
  dispose: function(ecModel, api) {
    this.groupGL.removeAll();
    this._control.dispose();
  }
});
var vec3$9 = glmatrix.vec3;
function Globe(radius) {
  this.radius = radius;
  this.viewGL = null;
  this.altitudeAxis;
  this.displacementData = null;
  this.displacementWidth;
  this.displacementHeight;
}
Globe.prototype = {
  constructor: Globe,
  dimensions: ["lng", "lat", "alt"],
  type: "globe",
  containPoint: function() {
  },
  setDisplacementData: function(data, width, height) {
    this.displacementData = data;
    this.displacementWidth = width;
    this.displacementHeight = height;
  },
  _getDisplacementScale: function(lng, lat) {
    var i = (lng + 180) / 360 * (this.displacementWidth - 1);
    var j = (90 - lat) / 180 * (this.displacementHeight - 1);
    var idx = Math.round(i) + Math.round(j) * this.displacementWidth;
    return this.displacementData[idx];
  },
  dataToPoint: function(data, out2) {
    var lng = data[0];
    var lat = data[1];
    var altVal = data[2] || 0;
    var r = this.radius;
    if (this.displacementData) {
      r *= 1 + this._getDisplacementScale(lng, lat);
    }
    if (this.altitudeAxis) {
      r += this.altitudeAxis.dataToCoord(altVal);
    }
    lng = lng * Math.PI / 180;
    lat = lat * Math.PI / 180;
    var r0 = Math.cos(lat) * r;
    out2 = out2 || [];
    out2[0] = -r0 * Math.cos(lng + Math.PI);
    out2[1] = Math.sin(lat) * r;
    out2[2] = r0 * Math.sin(lng + Math.PI);
    return out2;
  },
  pointToData: function(point, out2) {
    var x = point[0];
    var y = point[1];
    var z = point[2];
    var len2 = vec3$9.len(point);
    x /= len2;
    y /= len2;
    z /= len2;
    var theta = Math.asin(y);
    var phi = Math.atan2(z, -x);
    if (phi < 0) {
      phi = Math.PI * 2 + phi;
    }
    var lat = theta * 180 / Math.PI;
    var lng = phi * 180 / Math.PI - 180;
    out2 = out2 || [];
    out2[0] = lng;
    out2[1] = lat;
    out2[2] = len2 - this.radius;
    if (this.altitudeAxis) {
      out2[2] = this.altitudeAxis.coordToData(out2[2]);
    }
    return out2;
  }
};
function getDisplacementData(img, displacementScale) {
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext("2d");
  var width = img.width;
  var height = img.height;
  canvas.width = width;
  canvas.height = height;
  ctx.drawImage(img, 0, 0, width, height);
  var rgbaArr = ctx.getImageData(0, 0, width, height).data;
  var displacementArr = new Float32Array(rgbaArr.length / 4);
  for (var i = 0; i < rgbaArr.length / 4; i++) {
    var x = rgbaArr[i * 4];
    displacementArr[i] = x / 255 * displacementScale;
  }
  return {
    data: displacementArr,
    width,
    height
  };
}
function resizeGlobe(globeModel, api) {
  var boxLayoutOption = globeModel.getBoxLayoutParams();
  var viewport = getLayoutRect(boxLayoutOption, {
    width: api.getWidth(),
    height: api.getHeight()
  });
  viewport.y = api.getHeight() - viewport.y - viewport.height;
  this.viewGL.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, api.getDevicePixelRatio());
  this.radius = globeModel.get("globeRadius");
  var outerRadius = globeModel.get("globeOuterRadius");
  if (this.altitudeAxis) {
    this.altitudeAxis.setExtent(0, outerRadius - this.radius);
  }
}
function updateGlobe(ecModel, api) {
  var altitudeDataExtent = [Infinity, -Infinity];
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem !== this) {
      return;
    }
    var data = seriesModel.getData();
    var altDims = seriesModel.coordDimToDataDim("alt");
    var altDim = altDims && altDims[0];
    if (altDim) {
      var dataExtent = data.getDataExtent(altDim, true);
      altitudeDataExtent[0] = Math.min(altitudeDataExtent[0], dataExtent[0]);
      altitudeDataExtent[1] = Math.max(altitudeDataExtent[1], dataExtent[1]);
    }
  }, this);
  if (altitudeDataExtent && isFinite(altitudeDataExtent[1] - altitudeDataExtent[0])) {
    var scale2 = createScale(altitudeDataExtent, {
      type: "value",
      min: "dataMin",
      max: "dataMax"
    });
    this.altitudeAxis = new Axis$1("altitude", scale2);
    this.resize(this.model, api);
  }
}
var globeCreator = {
  dimensions: Globe.prototype.dimensions,
  create: function(ecModel, api) {
    var globeList = [];
    ecModel.eachComponent("globe", function(globeModel) {
      globeModel.__viewGL = globeModel.__viewGL || new ViewGL();
      var globe = new Globe();
      globe.viewGL = globeModel.__viewGL;
      globeModel.coordinateSystem = globe;
      globe.model = globeModel;
      globeList.push(globe);
      globe.resize = resizeGlobe;
      globe.resize(globeModel, api);
      globe.update = updateGlobe;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "globe") {
        var globeModel = seriesModel.getReferringComponents("globe").models[0];
        if (!globeModel) {
          globeModel = ecModel.getComponent("globe");
        }
        if (!globeModel) {
          throw new Error('globe "' + retrieve$1.firstNotNull(seriesModel.get("globe3DIndex"), seriesModel.get("globe3DId"), 0) + '" not found');
        }
        var coordSys = globeModel.coordinateSystem;
        seriesModel.coordinateSystem = coordSys;
      }
    });
    ecModel.eachComponent("globe", function(globeModel, idx) {
      var globe = globeModel.coordinateSystem;
      var displacementTextureValue = globeModel.getDisplacementTexture();
      var displacementScale = globeModel.getDisplacemenScale();
      if (globeModel.isDisplacementChanged()) {
        if (globeModel.hasDisplacement()) {
          var immediateLoaded = true;
          graphicGL$1.loadTexture(displacementTextureValue, api, function(texture) {
            var img = texture.image;
            var displacementData = getDisplacementData(img, displacementScale);
            globeModel.setDisplacementData(displacementData.data, displacementData.width, displacementData.height);
            if (!immediateLoaded) {
              api.dispatchAction({
                type: "globeUpdateDisplacment"
              });
            }
          });
          immediateLoaded = false;
        } else {
          globe.setDisplacementData(null, 0, 0);
        }
        globe.setDisplacementData(globeModel.displacementData, globeModel.displacementWidth, globeModel.displacementHeight);
      }
    });
    return globeList;
  }
};
var globeCreator$1 = globeCreator;
function install$d(registers) {
  registers.registerComponentModel(GlobeModel$1);
  registers.registerComponentView(GlobeView);
  registers.registerCoordinateSystem("globe", globeCreator$1);
  registers.registerAction({
    type: "globeChangeCamera",
    event: "globecamerachanged",
    update: "series:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "globe",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
  registers.registerAction({
    type: "globeUpdateDisplacment",
    event: "globedisplacementupdated",
    update: "update"
  }, function(payload, ecModel) {
  });
}
use(install$d);
var MAPBOX_CAMERA_OPTION = ["zoom", "center", "pitch", "bearing"];
var Mapbox3DModel = ComponentModel$1.extend({
  type: "mapbox3D",
  layoutMode: "box",
  coordinateSystem: null,
  defaultOption: {
    zlevel: -10,
    style: "mapbox://styles/mapbox/light-v9",
    center: [0, 0],
    zoom: 0,
    pitch: 0,
    bearing: 0,
    light: {
      main: {
        alpha: 20,
        beta: 30
      }
    },
    altitudeScale: 1,
    boxHeight: "auto"
  },
  getMapboxCameraOption: function() {
    var self2 = this;
    return MAPBOX_CAMERA_OPTION.reduce(function(obj, key) {
      obj[key] = self2.get(key);
      return obj;
    }, {});
  },
  setMapboxCameraOption: function(option) {
    if (option != null) {
      MAPBOX_CAMERA_OPTION.forEach(function(key) {
        if (option[key] != null) {
          this.option[key] = option[key];
        }
      }, this);
    }
  },
  getMapbox: function() {
    return this._mapbox;
  },
  setMapbox: function(mapbox) {
    this._mapbox = mapbox;
  }
});
merge(Mapbox3DModel.prototype, componentPostEffectMixin);
merge(Mapbox3DModel.prototype, componentLightMixin);
var Mapbox3DModel$1 = Mapbox3DModel;
function Mapbox3DLayer(id, zr) {
  this.id = id;
  this.zr = zr;
  this.dom = document.createElement("div");
  this.dom.style.cssText = "position:absolute;left:0;right:0;top:0;bottom:0;";
  if (!mapboxgl) {
    throw new Error("Mapbox GL library must be included. See https://www.mapbox.com/mapbox-gl-js/api/");
  }
  this._mapbox = new mapboxgl.Map({
    container: this.dom
  });
  this._initEvents();
}
Mapbox3DLayer.prototype.setUnpainted = function() {
};
Mapbox3DLayer.prototype.resize = function() {
  this._mapbox.resize();
};
Mapbox3DLayer.prototype.getMapbox = function() {
  return this._mapbox;
};
Mapbox3DLayer.prototype.clear = function() {
};
Mapbox3DLayer.prototype.refresh = function() {
  this._mapbox.resize();
};
var EVENTS$1 = ["mousedown", "mouseup", "click", "dblclick", "mousemove", "mousewheel", "wheel", "touchstart", "touchend", "touchmove", "touchcancel"];
Mapbox3DLayer.prototype._initEvents = function() {
  var mapboxRoot = this._mapbox.getCanvasContainer();
  this._handlers = this._handlers || {
    contextmenu: function(e2) {
      e2.preventDefault();
      return false;
    }
  };
  EVENTS$1.forEach(function(eName) {
    this._handlers[eName] = function(e2) {
      var obj = {};
      for (var name in e2) {
        obj[name] = e2[name];
      }
      obj.bubbles = false;
      var newE = new e2.constructor(e2.type, obj);
      mapboxRoot.dispatchEvent(newE);
    };
    this.zr.dom.addEventListener(eName, this._handlers[eName]);
  }, this);
  this.zr.dom.addEventListener("contextmenu", this._handlers.contextmenu);
};
Mapbox3DLayer.prototype.dispose = function() {
  EVENTS$1.forEach(function(eName) {
    this.zr.dom.removeEventListener(eName, this._handlers[eName]);
  }, this);
};
var displayShadowGLSL = "\n@export ecgl.displayShadow.vertex\n\n@import ecgl.common.transformUniforms\n\n@import ecgl.common.uv.header\n\n@import ecgl.common.attributes\n\nvarying vec3 v_WorldPosition;\n\nvarying vec3 v_Normal;\n\nvoid main()\n{\n @import ecgl.common.uv.main\n v_Normal = normalize((worldInverseTranspose * vec4(normal, 0.0)).xyz);\n\n v_WorldPosition = (world * vec4(position, 1.0)).xyz;\n gl_Position = worldViewProjection * vec4(position, 1.0);\n}\n\n@end\n\n\n@export ecgl.displayShadow.fragment\n\n@import ecgl.common.uv.fragmentHeader\n\nvarying vec3 v_Normal;\nvarying vec3 v_WorldPosition;\n\nuniform float roughness: 0.2;\n\n#ifdef DIRECTIONAL_LIGHT_COUNT\n@import clay.header.directional_light\n#endif\n\n@import ecgl.common.ssaoMap.header\n\n@import clay.plugin.compute_shadow_map\n\nvoid main()\n{\n float shadow = 1.0;\n\n @import ecgl.common.ssaoMap.main\n\n#if defined(DIRECTIONAL_LIGHT_COUNT) && defined(DIRECTIONAL_LIGHT_SHADOWMAP_COUNT)\n float shadowContribsDir[DIRECTIONAL_LIGHT_COUNT];\n if(shadowEnabled)\n {\n computeShadowOfDirectionalLights(v_WorldPosition, shadowContribsDir);\n }\n for (int i = 0; i < DIRECTIONAL_LIGHT_COUNT; i++) {\n shadow = min(shadow, shadowContribsDir[i] * 0.5 + 0.5);\n }\n#endif\n\n shadow *= 0.5 + ao * 0.5;\n shadow = clamp(shadow, 0.0, 1.0);\n\n gl_FragColor = vec4(vec3(0.0), 1.0 - shadow);\n}\n\n@end";
graphicGL$1.Shader.import(displayShadowGLSL);
var Mapbox3DView = ComponentView$1.extend({
  type: "mapbox3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    var zr = api.getZr();
    this._zrLayer = new Mapbox3DLayer("mapbox3D", zr);
    zr.painter.insertLayer(-1e3, this._zrLayer);
    this._lightRoot = new graphicGL$1.Node();
    this._sceneHelper = new SceneHelper(this._lightRoot);
    this._sceneHelper.initLight(this._lightRoot);
    var mapbox = this._zrLayer.getMapbox();
    var dispatchInteractAction = this._dispatchInteractAction.bind(this, api, mapbox);
    ["zoom", "rotate", "drag", "pitch", "rotate", "move"].forEach(function(eName) {
      mapbox.on(eName, dispatchInteractAction);
    });
    this._groundMesh = new graphicGL$1.Mesh({
      geometry: new graphicGL$1.PlaneGeometry(),
      material: new graphicGL$1.Material({
        shader: new graphicGL$1.Shader({
          vertex: graphicGL$1.Shader.source("ecgl.displayShadow.vertex"),
          fragment: graphicGL$1.Shader.source("ecgl.displayShadow.fragment")
        }),
        depthMask: false
      }),
      renderOrder: -100,
      culling: false,
      castShadow: false,
      $ignorePicking: true,
      renderNormal: true
    });
  },
  render: function(mapbox3DModel, ecModel, api) {
    var mapbox = this._zrLayer.getMapbox();
    var styleDesc = mapbox3DModel.get("style");
    var styleStr = JSON.stringify(styleDesc);
    if (styleStr !== this._oldStyleStr) {
      if (styleDesc) {
        mapbox.setStyle(styleDesc);
      }
    }
    this._oldStyleStr = styleStr;
    mapbox.setCenter(mapbox3DModel.get("center"));
    mapbox.setZoom(mapbox3DModel.get("zoom"));
    mapbox.setPitch(mapbox3DModel.get("pitch"));
    mapbox.setBearing(mapbox3DModel.get("bearing"));
    mapbox3DModel.setMapbox(mapbox);
    var coordSys = mapbox3DModel.coordinateSystem;
    coordSys.viewGL.scene.add(this._lightRoot);
    coordSys.viewGL.add(this._groundMesh);
    this._updateGroundMesh();
    this._sceneHelper.setScene(coordSys.viewGL.scene);
    this._sceneHelper.updateLight(mapbox3DModel);
    coordSys.viewGL.setPostEffect(mapbox3DModel.getModel("postEffect"), api);
    coordSys.viewGL.setTemporalSuperSampling(mapbox3DModel.getModel("temporalSuperSampling"));
    this._mapbox3DModel = mapbox3DModel;
  },
  afterRender: function(mapbox3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, mapbox3DModel, api);
    this._sceneHelper.updateSkybox(renderer, mapbox3DModel, api);
    mapbox3DModel.coordinateSystem.viewGL.scene.traverse(function(mesh2) {
      if (mesh2.material) {
        mesh2.material.define("fragment", "NORMAL_UP_AXIS", 2);
        mesh2.material.define("fragment", "NORMAL_FRONT_AXIS", 1);
      }
    });
  },
  updateCamera: function(mapbox3DModel, ecModel, api, payload) {
    mapbox3DModel.coordinateSystem.setCameraOption(payload);
    this._updateGroundMesh();
    api.getZr().refresh();
  },
  _dispatchInteractAction: function(api, mapbox, mapbox3DModel) {
    api.dispatchAction({
      type: "mapbox3DChangeCamera",
      pitch: mapbox.getPitch(),
      zoom: mapbox.getZoom(),
      center: mapbox.getCenter().toArray(),
      bearing: mapbox.getBearing(),
      mapbox3DId: this._mapbox3DModel && this._mapbox3DModel.id
    });
  },
  _updateGroundMesh: function() {
    if (this._mapbox3DModel) {
      var coordSys = this._mapbox3DModel.coordinateSystem;
      var pt = coordSys.dataToPoint(coordSys.center);
      this._groundMesh.position.set(pt[0], pt[1], -1e-3);
      var plane = new graphicGL$1.Plane(new graphicGL$1.Vector3(0, 0, 1), 0);
      var ray1 = coordSys.viewGL.camera.castRay(new graphicGL$1.Vector2(-1, -1));
      var ray2 = coordSys.viewGL.camera.castRay(new graphicGL$1.Vector2(1, 1));
      var pos0 = ray1.intersectPlane(plane);
      var pos1 = ray2.intersectPlane(plane);
      var scale2 = pos0.dist(pos1) / coordSys.viewGL.rootNode.scale.x;
      this._groundMesh.scale.set(scale2, scale2, 1);
    }
  },
  dispose: function(ecModel, api) {
    if (this._zrLayer) {
      this._zrLayer.dispose();
    }
    api.getZr().painter.delLayer(-1e3);
  }
});
var mat4 = glmatrix.mat4;
var TILE_SIZE = 512;
var FOV = 0.6435011087932844;
var PI = Math.PI;
var WORLD_SCALE = 1 / 10;
function MapServiceCoordSys3D() {
  this.width = 0;
  this.height = 0;
  this.altitudeScale = 1;
  this.boxHeight = "auto";
  this.altitudeExtent;
  this.bearing = 0;
  this.pitch = 0;
  this.center = [0, 0];
  this._origin;
  this.zoom = 0;
  this._initialZoom;
  this.maxPitch = 60;
  this.zoomOffset = 0;
}
MapServiceCoordSys3D.prototype = {
  constructor: MapServiceCoordSys3D,
  dimensions: ["lng", "lat", "alt"],
  containPoint: function() {
  },
  setCameraOption: function(option) {
    this.bearing = option.bearing;
    this.pitch = option.pitch;
    this.center = option.center;
    this.zoom = option.zoom;
    if (!this._origin) {
      this._origin = this.projectOnTileWithScale(this.center, TILE_SIZE);
    }
    if (this._initialZoom == null) {
      this._initialZoom = this.zoom;
    }
    this.updateTransform();
  },
  updateTransform: function() {
    if (!this.height) {
      return;
    }
    var cameraToCenterDistance = 0.5 / Math.tan(FOV / 2) * this.height * WORLD_SCALE;
    var pitch = Math.max(Math.min(this.pitch, this.maxPitch), 0) / 180 * Math.PI;
    var halfFov = FOV / 2;
    var groundAngle = Math.PI / 2 + pitch;
    var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov);
    var furthestDistance = Math.cos(Math.PI / 2 - pitch) * topHalfSurfaceDistance + cameraToCenterDistance;
    var farZ = furthestDistance * 1.1;
    if (this.pitch > 50) {
      farZ = 1e3;
    }
    var m2 = [];
    mat4.perspective(m2, FOV, this.width / this.height, 1, farZ);
    this.viewGL.camera.projectionMatrix.setArray(m2);
    this.viewGL.camera.decomposeProjectionMatrix();
    var m2 = mat4.identity([]);
    var pt = this.dataToPoint(this.center);
    mat4.scale(m2, m2, [1, -1, 1]);
    mat4.translate(m2, m2, [0, 0, -cameraToCenterDistance]);
    mat4.rotateX(m2, m2, pitch);
    mat4.rotateZ(m2, m2, -this.bearing / 180 * Math.PI);
    mat4.translate(m2, m2, [-pt[0] * this.getScale() * WORLD_SCALE, -pt[1] * this.getScale() * WORLD_SCALE, 0]);
    this.viewGL.camera.viewMatrix.array = m2;
    var invertM = [];
    mat4.invert(invertM, m2);
    this.viewGL.camera.worldTransform.array = invertM;
    this.viewGL.camera.decomposeWorldTransform();
    var worldSize = TILE_SIZE * this.getScale();
    var verticalScale;
    if (this.altitudeExtent && !isNaN(this.boxHeight)) {
      var range = this.altitudeExtent[1] - this.altitudeExtent[0];
      verticalScale = this.boxHeight / range * this.getScale() / Math.pow(2, this._initialZoom - this.zoomOffset);
    } else {
      verticalScale = worldSize / (2 * Math.PI * 6378e3 * Math.abs(Math.cos(this.center[1] * (Math.PI / 180)))) * this.altitudeScale * WORLD_SCALE;
    }
    this.viewGL.rootNode.scale.set(this.getScale() * WORLD_SCALE, this.getScale() * WORLD_SCALE, verticalScale);
  },
  getScale: function() {
    return Math.pow(2, this.zoom - this.zoomOffset);
  },
  projectOnTile: function(data, out2) {
    return this.projectOnTileWithScale(data, this.getScale() * TILE_SIZE, out2);
  },
  projectOnTileWithScale: function(data, scale2, out2) {
    var lng = data[0];
    var lat = data[1];
    var lambda2 = lng * PI / 180;
    var phi2 = lat * PI / 180;
    var x = scale2 * (lambda2 + PI) / (2 * PI);
    var y = scale2 * (PI - Math.log(Math.tan(PI / 4 + phi2 * 0.5))) / (2 * PI);
    out2 = out2 || [];
    out2[0] = x;
    out2[1] = y;
    return out2;
  },
  unprojectFromTile: function(point, out2) {
    return this.unprojectOnTileWithScale(point, this.getScale() * TILE_SIZE, out2);
  },
  unprojectOnTileWithScale: function(point, scale2, out2) {
    var x = point[0];
    var y = point[1];
    var lambda2 = x / scale2 * (2 * PI) - PI;
    var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale2 * (2 * PI))) - PI / 4);
    out2 = out2 || [];
    out2[0] = lambda2 * 180 / PI;
    out2[1] = phi2 * 180 / PI;
    return out2;
  },
  dataToPoint: function(data, out2) {
    out2 = this.projectOnTileWithScale(data, TILE_SIZE, out2);
    out2[0] -= this._origin[0];
    out2[1] -= this._origin[1];
    out2[2] = !isNaN(data[2]) ? data[2] : 0;
    if (!isNaN(data[2])) {
      out2[2] = data[2];
      if (this.altitudeExtent) {
        out2[2] -= this.altitudeExtent[0];
      }
    }
    return out2;
  }
};
function Mapbox3D() {
  MapServiceCoordSys3D.apply(this, arguments);
}
Mapbox3D.prototype = new MapServiceCoordSys3D();
Mapbox3D.prototype.constructor = Mapbox3D;
Mapbox3D.prototype.type = "mapbox3D";
function createMapService3DCreator(serviceComponentType, ServiceCtor, afterCreate) {
  function resizeMapService3D(mapService3DModel, api) {
    var width = api.getWidth();
    var height = api.getHeight();
    var dpr2 = api.getDevicePixelRatio();
    this.viewGL.setViewport(0, 0, width, height, dpr2);
    this.width = width;
    this.height = height;
    this.altitudeScale = mapService3DModel.get("altitudeScale");
    this.boxHeight = mapService3DModel.get("boxHeight");
  }
  function updateService3D(ecModel, api) {
    if (this.model.get("boxHeight") === "auto") {
      return;
    }
    var altitudeDataExtent = [Infinity, -Infinity];
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem !== this) {
        return;
      }
      var data = seriesModel.getData();
      var altDim = seriesModel.coordDimToDataDim("alt")[0];
      if (altDim) {
        var dataExtent = data.getDataExtent(altDim, true);
        altitudeDataExtent[0] = Math.min(altitudeDataExtent[0], dataExtent[0]);
        altitudeDataExtent[1] = Math.max(altitudeDataExtent[1], dataExtent[1]);
      }
    }, this);
    if (altitudeDataExtent && isFinite(altitudeDataExtent[1] - altitudeDataExtent[0])) {
      this.altitudeExtent = altitudeDataExtent;
    }
  }
  return {
    dimensions: ServiceCtor.prototype.dimensions,
    create: function(ecModel, api) {
      var mapService3DList = [];
      ecModel.eachComponent(serviceComponentType, function(mapService3DModel) {
        var viewGL = mapService3DModel.__viewGL;
        if (!viewGL) {
          viewGL = mapService3DModel.__viewGL = new ViewGL();
          viewGL.setRootNode(new graphicGL$1.Node());
        }
        var mapService3DCoordSys = new ServiceCtor();
        mapService3DCoordSys.viewGL = mapService3DModel.__viewGL;
        mapService3DCoordSys.resize = resizeMapService3D;
        mapService3DCoordSys.resize(mapService3DModel, api);
        mapService3DList.push(mapService3DCoordSys);
        mapService3DModel.coordinateSystem = mapService3DCoordSys;
        mapService3DCoordSys.model = mapService3DModel;
        mapService3DCoordSys.update = updateService3D;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get("coordinateSystem") === serviceComponentType) {
          var mapService3DModel = seriesModel.getReferringComponents(serviceComponentType).models[0];
          if (!mapService3DModel) {
            mapService3DModel = ecModel.getComponent(serviceComponentType);
          }
          if (!mapService3DModel) {
            throw new Error(serviceComponentType + ' "' + retrieve$1.firstNotNull(seriesModel.get(serviceComponentType + "Index"), seriesModel.get(serviceComponentType + "Id"), 0) + '" not found');
          }
          seriesModel.coordinateSystem = mapService3DModel.coordinateSystem;
        }
      });
      afterCreate && afterCreate(mapService3DList, ecModel, api);
      return mapService3DList;
    }
  };
}
var mapbox3DCreator = createMapService3DCreator("mapbox3D", Mapbox3D, function(mapbox3DList) {
  mapbox3DList.forEach(function(mapbox3D) {
    mapbox3D.setCameraOption(mapbox3D.model.getMapboxCameraOption());
  });
});
var mapbox3DCreator$1 = mapbox3DCreator;
function install$c(registers) {
  registers.registerComponentModel(Mapbox3DModel$1);
  registers.registerComponentView(Mapbox3DView);
  registers.registerCoordinateSystem("mapbox3D", mapbox3DCreator$1);
  registers.registerAction({
    type: "mapbox3DChangeCamera",
    event: "mapbox3dcamerachanged",
    update: "mapbox3D:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "mapbox3D",
      query: payload
    }, function(componentModel) {
      componentModel.setMapboxCameraOption(payload);
    });
  });
}
use(install$c);
var MAPTALKS_CAMERA_OPTION = ["zoom", "center", "pitch", "bearing"];
var Maptalks3DModel = ComponentModel$1.extend({
  type: "maptalks3D",
  layoutMode: "box",
  coordinateSystem: null,
  defaultOption: {
    zlevel: -10,
    urlTemplate: "http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
    attribution: '&copy; <a href="http://osm.org">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/">CARTO</a>',
    center: [0, 0],
    zoom: 0,
    pitch: 0,
    bearing: 0,
    light: {
      main: {
        alpha: 20,
        beta: 30
      }
    },
    altitudeScale: 1,
    boxHeight: "auto"
  },
  getMaptalksCameraOption: function() {
    var self2 = this;
    return MAPTALKS_CAMERA_OPTION.reduce(function(obj, key) {
      obj[key] = self2.get(key);
      return obj;
    }, {});
  },
  setMaptalksCameraOption: function(option) {
    if (option != null) {
      MAPTALKS_CAMERA_OPTION.forEach(function(key) {
        if (option[key] != null) {
          this.option[key] = option[key];
        }
      }, this);
    }
  },
  getMaptalks: function() {
    return this._maptalks;
  },
  setMaptalks: function(maptalks2) {
    this._maptalks = maptalks2;
  }
});
merge(Maptalks3DModel.prototype, componentPostEffectMixin);
merge(Maptalks3DModel.prototype, componentLightMixin);
var Maptalks3DModel$1 = Maptalks3DModel;
function Maptalks3DLayer(id, zr, defaultCenter, defaultZoom) {
  this.id = id;
  this.zr = zr;
  this.dom = document.createElement("div");
  this.dom.style.cssText = "position:absolute;left:0;right:0;top:0;bottom:0;";
  if (!maptalks) {
    throw new Error("Maptalks library must be included. See https://maptalks.org");
  }
  this._maptalks = new maptalks.Map(this.dom, {
    center: defaultCenter,
    zoom: defaultZoom,
    doubleClickZoom: false,
    fog: false
  });
  this._initEvents();
}
Maptalks3DLayer.prototype.setUnpainted = function() {
};
Maptalks3DLayer.prototype.resize = function() {
  this._maptalks.checkSize();
};
Maptalks3DLayer.prototype.getMaptalks = function() {
  return this._maptalks;
};
Maptalks3DLayer.prototype.clear = function() {
};
Maptalks3DLayer.prototype.refresh = function() {
  this._maptalks.checkSize();
};
var EVENTS = ["mousedown", "mouseup", "click", "dblclick", "mousemove", "mousewheel", "DOMMouseScroll", "touchstart", "touchend", "touchmove", "touchcancel"];
Maptalks3DLayer.prototype._initEvents = function() {
  var maptalksRoot = this.dom;
  this._handlers = this._handlers || {
    contextmenu: function(e2) {
      e2.preventDefault();
      return false;
    }
  };
  EVENTS.forEach(function(eName) {
    this._handlers[eName] = function(e2) {
      var obj = {};
      for (var name in e2) {
        obj[name] = e2[name];
      }
      obj.bubbles = false;
      var newE = new e2.constructor(e2.type, obj);
      if (eName === "mousewheel" || eName === "DOMMouseScroll") {
        maptalksRoot.dispatchEvent(newE);
      } else {
        maptalksRoot.firstElementChild.dispatchEvent(newE);
      }
    };
    this.zr.dom.addEventListener(eName, this._handlers[eName]);
  }, this);
  this.zr.dom.addEventListener("contextmenu", this._handlers.contextmenu);
};
Maptalks3DLayer.prototype.dispose = function() {
  EVENTS.forEach(function(eName) {
    this.zr.dom.removeEventListener(eName, this._handlers[eName]);
  }, this);
  this._maptalks.remove();
};
graphicGL$1.Shader.import(displayShadowGLSL);
var Maptalks3DView = ComponentView$1.extend({
  type: "maptalks3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this._groundMesh = new graphicGL$1.Mesh({
      geometry: new graphicGL$1.PlaneGeometry(),
      material: new graphicGL$1.Material({
        shader: new graphicGL$1.Shader({
          vertex: graphicGL$1.Shader.source("ecgl.displayShadow.vertex"),
          fragment: graphicGL$1.Shader.source("ecgl.displayShadow.fragment")
        }),
        depthMask: false
      }),
      renderOrder: -100,
      culling: false,
      castShadow: false,
      $ignorePicking: true,
      renderNormal: true
    });
  },
  _initMaptalksLayer: function(mapbox3DModel, api) {
    var zr = api.getZr();
    this._zrLayer = new Maptalks3DLayer("maptalks3D", zr, mapbox3DModel.get("center"), mapbox3DModel.get("zoom"));
    zr.painter.insertLayer(-1e3, this._zrLayer);
    this._lightRoot = new graphicGL$1.Node();
    this._sceneHelper = new SceneHelper(this._lightRoot);
    this._sceneHelper.initLight(this._lightRoot);
    var maptalks2 = this._zrLayer.getMaptalks();
    var dispatchInteractAction = this._dispatchInteractAction.bind(this, api, maptalks2);
    ["zoomend", "zooming", "zoomstart", "dragrotating", "pitch", "pitchend", "movestart", "moving", "moveend", "resize", "touchstart", "touchmove", "touchend", "animating"].forEach(function(eName) {
      maptalks2.on(eName, dispatchInteractAction);
    });
  },
  render: function(maptalks3DModel, ecModel, api) {
    if (!this._zrLayer) {
      this._initMaptalksLayer(maptalks3DModel, api);
    }
    var mtks = this._zrLayer.getMaptalks();
    var urlTemplate = maptalks3DModel.get("urlTemplate");
    var baseLayer = mtks.getBaseLayer();
    if (urlTemplate !== this._oldUrlTemplate) {
      if (!baseLayer) {
        baseLayer = new maptalks.TileLayer("maptalks-echarts-gl-baselayer", {
          urlTemplate,
          subdomains: ["a", "b", "c"],
          attribution: maptalks3DModel.get("attribution")
        });
        mtks.setBaseLayer(baseLayer);
      } else {
        baseLayer.setOptions({
          urlTemplate,
          attribution: maptalks3DModel.get("attribution")
        });
      }
    }
    this._oldUrlTemplate = urlTemplate;
    mtks.setCenter(maptalks3DModel.get("center"));
    mtks.setZoom(maptalks3DModel.get("zoom"), {
      animation: false
    });
    mtks.setPitch(maptalks3DModel.get("pitch"));
    mtks.setBearing(maptalks3DModel.get("bearing"));
    maptalks3DModel.setMaptalks(mtks);
    var coordSys = maptalks3DModel.coordinateSystem;
    coordSys.viewGL.scene.add(this._lightRoot);
    coordSys.viewGL.add(this._groundMesh);
    this._updateGroundMesh();
    this._sceneHelper.setScene(coordSys.viewGL.scene);
    this._sceneHelper.updateLight(maptalks3DModel);
    coordSys.viewGL.setPostEffect(maptalks3DModel.getModel("postEffect"), api);
    coordSys.viewGL.setTemporalSuperSampling(maptalks3DModel.getModel("temporalSuperSampling"));
    this._maptalks3DModel = maptalks3DModel;
  },
  afterRender: function(maptalks3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._sceneHelper.updateAmbientCubemap(renderer, maptalks3DModel, api);
    this._sceneHelper.updateSkybox(renderer, maptalks3DModel, api);
    maptalks3DModel.coordinateSystem.viewGL.scene.traverse(function(mesh2) {
      if (mesh2.material) {
        mesh2.material.define("fragment", "NORMAL_UP_AXIS", 2);
        mesh2.material.define("fragment", "NORMAL_FRONT_AXIS", 1);
      }
    });
  },
  updateCamera: function(maptalks3DModel, ecModel, api, payload) {
    maptalks3DModel.coordinateSystem.setCameraOption(payload);
    this._updateGroundMesh();
    api.getZr().refresh();
  },
  _dispatchInteractAction: function(api, maptalks2, maptalks3DModel) {
    api.dispatchAction({
      type: "maptalks3DChangeCamera",
      pitch: maptalks2.getPitch(),
      zoom: getMapboxZoom(maptalks2.getResolution()) + 1,
      center: maptalks2.getCenter().toArray(),
      bearing: maptalks2.getBearing(),
      maptalks3DId: this._maptalks3DModel && this._maptalks3DModel.id
    });
  },
  _updateGroundMesh: function() {
    if (this._maptalks3DModel) {
      var coordSys = this._maptalks3DModel.coordinateSystem;
      var pt = coordSys.dataToPoint(coordSys.center);
      this._groundMesh.position.set(pt[0], pt[1], -1e-3);
      var plane = new graphicGL$1.Plane(new graphicGL$1.Vector3(0, 0, 1), 0);
      var ray1 = coordSys.viewGL.camera.castRay(new graphicGL$1.Vector2(-1, -1));
      var ray2 = coordSys.viewGL.camera.castRay(new graphicGL$1.Vector2(1, 1));
      var pos0 = ray1.intersectPlane(plane);
      var pos1 = ray2.intersectPlane(plane);
      var scale2 = pos0.dist(pos1) / coordSys.viewGL.rootNode.scale.x;
      this._groundMesh.scale.set(scale2, scale2, 1);
    }
  },
  dispose: function(ecModel, api) {
    if (this._zrLayer) {
      this._zrLayer.dispose();
    }
    api.getZr().painter.delLayer(-1e3);
  }
});
const MAX_RES = 2 * 6378137 * Math.PI / (256 * Math.pow(2, 20));
function getMapboxZoom(res) {
  return 19 - Math.log(res / MAX_RES) / Math.LN2;
}
function Maptalks3D() {
  MapServiceCoordSys3D.apply(this, arguments);
  this.maxPitch = 85;
  this.zoomOffset = 1;
}
Maptalks3D.prototype = new MapServiceCoordSys3D();
Maptalks3D.prototype.constructor = Maptalks3D;
Maptalks3D.prototype.type = "maptalks3D";
var maptalks3DCreator = createMapService3DCreator("maptalks3D", Maptalks3D, function(maptalks3DList) {
  maptalks3DList.forEach(function(maptalks3D) {
    maptalks3D.setCameraOption(maptalks3D.model.getMaptalksCameraOption());
  });
});
var maptalks3DCreator$1 = maptalks3DCreator;
function install$b(registers) {
  registers.registerComponentModel(Maptalks3DModel$1);
  registers.registerComponentView(Maptalks3DView);
  registers.registerCoordinateSystem("maptalks3D", maptalks3DCreator$1);
  registers.registerAction({
    type: "maptalks3DChangeCamera",
    event: "maptalks3dcamerachanged",
    update: "maptalks3D:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "maptalks3D",
      query: payload
    }, function(componentModel) {
      componentModel.setMaptalksCameraOption(payload);
    });
  });
}
use(install$b);
var vec3$8 = glmatrix.vec3;
var isDimensionStacked$1 = dataStack.isDimensionStacked;
function ifCrossZero(extent3) {
  var min3 = extent3[0];
  var max3 = extent3[1];
  return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
}
function cartesian3DLayout(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var barSize = seriesModel.get("barSize");
  if (barSize == null) {
    var size = coordSys.size;
    var barWidth;
    var barDepth;
    var xAxis = coordSys.getAxis("x");
    var yAxis = coordSys.getAxis("y");
    if (xAxis.type === "category") {
      barWidth = xAxis.getBandWidth() * 0.7;
    } else {
      barWidth = Math.round(size[0] / Math.sqrt(data.count())) * 0.6;
    }
    if (yAxis.type === "category") {
      barDepth = yAxis.getBandWidth() * 0.7;
    } else {
      barDepth = Math.round(size[1] / Math.sqrt(data.count())) * 0.6;
    }
    barSize = [barWidth, barDepth];
  } else if (!isArray$1(barSize)) {
    barSize = [barSize, barSize];
  }
  var zAxisExtent = coordSys.getAxis("z").scale.getExtent();
  var ifZAxisCrossZero = ifCrossZero(zAxisExtent);
  var dims = ["x", "y", "z"].map(function(coordDimName) {
    return seriesModel.coordDimToDataDim(coordDimName)[0];
  });
  var isStacked = isDimensionStacked$1(data, dims[2]);
  var valueDim = isStacked ? data.getCalculationInfo("stackResultDimension") : dims[2];
  data.each(dims, function(x, y, z, idx) {
    var stackedValue = data.get(valueDim, idx);
    var baseValue = isStacked ? stackedValue - z : ifZAxisCrossZero ? 0 : zAxisExtent[0];
    var start2 = coordSys.dataToPoint([x, y, baseValue]);
    var end2 = coordSys.dataToPoint([x, y, stackedValue]);
    var height = vec3$8.dist(start2, end2);
    var dir3 = [0, end2[1] < start2[1] ? -1 : 1, 0];
    if (Math.abs(height) === 0) {
      height = 0.1;
    }
    var size2 = [barSize[0], height, barSize[1]];
    data.setItemLayout(idx, [start2, dir3, size2]);
  });
  data.setLayout("orient", [1, 0, 0]);
}
function evaluateBarSparseness(data, dimX, dimY) {
  var xExtent = data.getDataExtent(dimX);
  var yExtent = data.getDataExtent(dimY);
  var xSpan = xExtent[1] - xExtent[0] || xExtent[0];
  var ySpan = yExtent[1] - yExtent[0] || yExtent[0];
  var dimSize = 50;
  var tmp = new Uint8Array(dimSize * dimSize);
  for (var i = 0; i < data.count(); i++) {
    var x = data.get(dimX, i);
    var y = data.get(dimY, i);
    var xIdx = Math.floor((x - xExtent[0]) / xSpan * (dimSize - 1));
    var yIdx = Math.floor((y - yExtent[0]) / ySpan * (dimSize - 1));
    var idx = yIdx * dimSize + xIdx;
    tmp[idx] = tmp[idx] || 1;
  }
  var filledCount = 0;
  for (var i = 0; i < tmp.length; i++) {
    if (tmp[i]) {
      filledCount++;
    }
  }
  return filledCount / tmp.length;
}
var vec3$7 = glmatrix.vec3;
var isDimensionStacked = dataStack.isDimensionStacked;
function globeLayout(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var barMinHeight = seriesModel.get("minHeight") || 0;
  var barSize = seriesModel.get("barSize");
  var dims = ["lng", "lat", "alt"].map(function(coordDimName) {
    return seriesModel.coordDimToDataDim(coordDimName)[0];
  });
  if (barSize == null) {
    var perimeter = coordSys.radius * Math.PI;
    var fillRatio = evaluateBarSparseness(data, dims[0], dims[1]);
    barSize = [perimeter / Math.sqrt(data.count() / fillRatio), perimeter / Math.sqrt(data.count() / fillRatio)];
  } else if (!isArray$1(barSize)) {
    barSize = [barSize, barSize];
  }
  var valueDim = getValueDimension(data, dims);
  data.each(dims, function(lng, lat, val, idx) {
    var stackedValue = data.get(valueDim.dimension, idx);
    var baseValue = valueDim.isStacked ? stackedValue - val : coordSys.altitudeAxis.scale.getExtent()[0];
    var height = Math.max(coordSys.altitudeAxis.dataToCoord(val), barMinHeight);
    var start2 = coordSys.dataToPoint([lng, lat, baseValue]);
    var end2 = coordSys.dataToPoint([lng, lat, stackedValue]);
    var dir3 = vec3$7.sub([], end2, start2);
    vec3$7.normalize(dir3, dir3);
    var size = [barSize[0], height, barSize[1]];
    data.setItemLayout(idx, [start2, dir3, size]);
  });
  data.setLayout("orient", Vector3$1.UP.array);
}
function geo3DLayout(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var barSize = seriesModel.get("barSize");
  var barMinHeight = seriesModel.get("minHeight") || 0;
  var dims = ["lng", "lat", "alt"].map(function(coordDimName) {
    return seriesModel.coordDimToDataDim(coordDimName)[0];
  });
  if (barSize == null) {
    var size = Math.min(coordSys.size[0], coordSys.size[2]);
    var fillRatio = evaluateBarSparseness(data, dims[0], dims[1]);
    barSize = [size / Math.sqrt(data.count() / fillRatio), size / Math.sqrt(data.count() / fillRatio)];
  } else if (!isArray$1(barSize)) {
    barSize = [barSize, barSize];
  }
  var dir3 = [0, 1, 0];
  var valueDim = getValueDimension(data, dims);
  data.each(dims, function(lng, lat, val, idx) {
    var stackedValue = data.get(valueDim.dimension, idx);
    var baseValue = valueDim.isStacked ? stackedValue - val : coordSys.altitudeAxis.scale.getExtent()[0];
    var height = Math.max(coordSys.altitudeAxis.dataToCoord(val), barMinHeight);
    var start2 = coordSys.dataToPoint([lng, lat, baseValue]);
    var size2 = [barSize[0], height, barSize[1]];
    data.setItemLayout(idx, [start2, dir3, size2]);
  });
  data.setLayout("orient", [1, 0, 0]);
}
function mapService3DLayout(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var dimLng = seriesModel.coordDimToDataDim("lng")[0];
  var dimLat = seriesModel.coordDimToDataDim("lat")[0];
  var dimAlt = seriesModel.coordDimToDataDim("alt")[0];
  var barSize = seriesModel.get("barSize");
  var barMinHeight = seriesModel.get("minHeight") || 0;
  if (barSize == null) {
    var xExtent = data.getDataExtent(dimLng);
    var yExtent = data.getDataExtent(dimLat);
    var corner0 = coordSys.dataToPoint([xExtent[0], yExtent[0]]);
    var corner1 = coordSys.dataToPoint([xExtent[1], yExtent[1]]);
    var size = Math.min(Math.abs(corner0[0] - corner1[0]), Math.abs(corner0[1] - corner1[1])) || 1;
    var fillRatio = evaluateBarSparseness(data, dimLng, dimLat);
    barSize = [size / Math.sqrt(data.count() / fillRatio), size / Math.sqrt(data.count() / fillRatio)];
  } else {
    if (!isArray$1(barSize)) {
      barSize = [barSize, barSize];
    }
    barSize[0] /= coordSys.getScale() / 16;
    barSize[1] /= coordSys.getScale() / 16;
  }
  var dir3 = [0, 0, 1];
  var dims = [dimLng, dimLat, dimAlt];
  var valueDim = getValueDimension(data, dims);
  data.each(dims, function(lng, lat, val, idx) {
    var stackedValue = data.get(valueDim.dimension, idx);
    var baseValue = valueDim.isStacked ? stackedValue - val : 0;
    var start2 = coordSys.dataToPoint([lng, lat, baseValue]);
    var end2 = coordSys.dataToPoint([lng, lat, stackedValue]);
    var height = Math.max(end2[2] - start2[2], barMinHeight);
    var size2 = [barSize[0], height, barSize[1]];
    data.setItemLayout(idx, [start2, dir3, size2]);
  });
  data.setLayout("orient", [1, 0, 0]);
}
function getValueDimension(data, dataDims) {
  var isStacked = isDimensionStacked(data, dataDims[2]);
  return {
    dimension: isStacked ? data.getCalculationInfo("stackResultDimension") : dataDims[2],
    isStacked
  };
}
function registerBarLayout(registers) {
  registers.registerLayout(function(ecModel, api) {
    ecModel.eachSeriesByType("bar3D", function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var coordSysType = coordSys && coordSys.type;
      if (coordSysType === "globe") {
        globeLayout(seriesModel, coordSys);
      } else if (coordSysType === "cartesian3D") {
        cartesian3DLayout(seriesModel, coordSys);
      } else if (coordSysType === "geo3D") {
        geo3DLayout(seriesModel, coordSys);
      } else if (coordSysType === "mapbox3D" || coordSysType === "maptalks3D") {
        mapService3DLayout(seriesModel, coordSys);
      } else
        ;
    });
  });
}
var formatUtil = {};
formatUtil.getFormattedLabel = function(seriesModel, dataIndex, status, dataType, dimIndex) {
  status = status || "normal";
  var data = seriesModel.getData(dataType);
  var itemModel = data.getItemModel(dataIndex);
  var params = seriesModel.getDataParams(dataIndex, dataType);
  if (dimIndex != null && params.value instanceof Array) {
    params.value = params.value[dimIndex];
  }
  var formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : ["emphasis", "label", "formatter"]);
  if (formatter == null) {
    formatter = itemModel.get(["label", "formatter"]);
  }
  var text;
  if (typeof formatter === "function") {
    params.status = status;
    text = formatter(params);
  } else if (typeof formatter === "string") {
    text = formatTpl(formatter, params);
  }
  return text;
};
formatUtil.normalizeToArray = function(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
};
var formatUtil$1 = formatUtil;
function otherDimToDataDim(data, otherDim2) {
  var dataDim = [];
  each$f(data.dimensions, function(dimName) {
    var dimItem = data.getDimensionInfo(dimName);
    var otherDims = dimItem.otherDims;
    var dimIndex = otherDims[otherDim2];
    if (dimIndex != null && dimIndex !== false) {
      dataDim[dimIndex] = dimItem.name;
    }
  });
  return dataDim;
}
function formatTooltip(seriesModel, dataIndex, multipleSeries) {
  function formatArrayValue(value2) {
    var vertially = true;
    var result = [];
    var tooltipDims = otherDimToDataDim(data, "tooltip");
    tooltipDims.length ? each$f(tooltipDims, function(dimIdx) {
      setEachItem(data.get(dimIdx, dataIndex), dimIdx);
    }) : each$f(value2, setEachItem);
    function setEachItem(val, dimIdx) {
      var dimInfo = data.getDimensionInfo(dimIdx);
      if (!dimInfo || dimInfo.otherDims.tooltip === false) {
        return;
      }
      var dimType = dimInfo.type;
      var valStr = "- " + (dimInfo.tooltipName || dimInfo.name) + ": " + (dimType === "ordinal" ? val + "" : dimType === "time" ? multipleSeries ? "" : formatTime("yyyy/MM/dd hh:mm:ss", val) : addCommas(val));
      valStr && result.push(encodeHTML(valStr));
    }
    return (vertially ? "<br/>" : "") + result.join(vertially ? "<br/>" : ", ");
  }
  var data = seriesModel.getData();
  var value = seriesModel.getRawValue(dataIndex);
  var formattedValue = isArray$1(value) ? formatArrayValue(value) : encodeHTML(addCommas(value));
  var name = data.getName(dataIndex);
  var color = getItemVisualColor(data, dataIndex);
  if (isObject$3(color) && color.colorStops) {
    color = (color.colorStops[0] || {}).color;
  }
  color = color || "transparent";
  var colorEl = getTooltipMarker(color);
  var seriesName = seriesModel.name;
  if (seriesName === "\0-") {
    seriesName = "";
  }
  seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? "<br/>" : ": ") : "";
  return !multipleSeries ? seriesName + colorEl + (name ? encodeHTML(name) + ": " + formattedValue : formattedValue) : colorEl + seriesName + formattedValue;
}
function createList(seriesModel, dims, source) {
  source = source || seriesModel.getSource();
  var coordSysDimensions = dims || getCoordinateSystemDimensions(seriesModel.get("coordinateSystem")) || ["x", "y", "z"];
  var dimensions = createDimensions(source, {
    dimensionsDefine: source.dimensionsDefine || seriesModel.get("dimensions"),
    encodeDefine: source.encodeDefine || seriesModel.get("encode"),
    coordDimensions: coordSysDimensions.map(function(dim) {
      var axis3DModel = seriesModel.getReferringComponents(dim + "Axis3D").models[0];
      return {
        type: axis3DModel && axis3DModel.get("type") === "category" ? "ordinal" : "float",
        name: dim
      };
    })
  });
  if (seriesModel.get("coordinateSystem") === "cartesian3D") {
    dimensions.forEach(function(dimInfo) {
      if (coordSysDimensions.indexOf(dimInfo.coordDim) >= 0) {
        var axis3DModel = seriesModel.getReferringComponents(dimInfo.coordDim + "Axis3D").models[0];
        if (axis3DModel && axis3DModel.get("type") === "category") {
          dimInfo.ordinalMeta = axis3DModel.getOrdinalMeta();
        }
      }
    });
  }
  var stackCalculationInfo = dataStack.enableDataStack(seriesModel, dimensions, {
    byIndex: true,
    stackedCoordDimension: "z"
  });
  var data = new SeriesData$1(dimensions, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  data.initData(source);
  return data;
}
var Bar3DSeries = SeriesModel$1.extend({
  type: "series.bar3D",
  dependencies: ["globe"],
  visualStyleAccessPathvisu: "itemStyle",
  getInitialData: function(option, ecModel) {
    return createList(this);
  },
  getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
    var text = formatUtil$1.getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
    if (text == null) {
      text = this.getData().get("z", dataIndex);
    }
    return text;
  },
  formatTooltip: function(dataIndex) {
    return formatTooltip(this, dataIndex);
  },
  defaultOption: {
    coordinateSystem: "cartesian3D",
    globeIndex: 0,
    grid3DIndex: 0,
    zlevel: -10,
    bevelSize: 0,
    bevelSmoothness: 2,
    onGridPlane: "xy",
    shading: "color",
    minHeight: 0,
    itemStyle: {
      opacity: 1
    },
    label: {
      show: false,
      distance: 2,
      textStyle: {
        fontSize: 14,
        color: "#000",
        backgroundColor: "rgba(255,255,255,0.7)",
        padding: 3,
        borderRadius: 3
      }
    },
    emphasis: {
      label: {
        show: true
      }
    },
    animationDurationUpdate: 500
  }
});
merge(Bar3DSeries.prototype, componentShadingMixin);
var Bar3DSeries$1 = Bar3DSeries;
var vec3$6 = glmatrix.vec3;
var mat3 = glmatrix.mat3;
var BarsGeometry = Geometry$1.extend(function() {
  return {
    attributes: {
      position: new Geometry$1.Attribute("position", "float", 3, "POSITION"),
      normal: new Geometry$1.Attribute("normal", "float", 3, "NORMAL"),
      color: new Geometry$1.Attribute("color", "float", 4, "COLOR"),
      prevPosition: new Geometry$1.Attribute("prevPosition", "float", 3),
      prevNormal: new Geometry$1.Attribute("prevNormal", "float", 3)
    },
    dynamic: true,
    enableNormal: false,
    bevelSize: 1,
    bevelSegments: 0,
    _dataIndices: null,
    _vertexOffset: 0,
    _triangleOffset: 0
  };
}, {
  resetOffset: function() {
    this._vertexOffset = 0;
    this._triangleOffset = 0;
  },
  setBarCount: function(barCount) {
    var enableNormal = this.enableNormal;
    var vertexCount = this.getBarVertexCount() * barCount;
    var triangleCount = this.getBarTriangleCount() * barCount;
    if (this.vertexCount !== vertexCount) {
      this.attributes.position.init(vertexCount);
      if (enableNormal) {
        this.attributes.normal.init(vertexCount);
      } else {
        this.attributes.normal.value = null;
      }
      this.attributes.color.init(vertexCount);
    }
    if (this.triangleCount !== triangleCount) {
      this.indices = vertexCount > 65535 ? new Uint32Array(triangleCount * 3) : new Uint16Array(triangleCount * 3);
      this._dataIndices = new Uint32Array(vertexCount);
    }
  },
  getBarVertexCount: function() {
    var bevelSegments = this.bevelSize > 0 ? this.bevelSegments : 0;
    return bevelSegments > 0 ? this._getBevelBarVertexCount(bevelSegments) : this.enableNormal ? 24 : 8;
  },
  getBarTriangleCount: function() {
    var bevelSegments = this.bevelSize > 0 ? this.bevelSegments : 0;
    return bevelSegments > 0 ? this._getBevelBarTriangleCount(bevelSegments) : 12;
  },
  _getBevelBarVertexCount: function(bevelSegments) {
    return (bevelSegments + 1) * 4 * (bevelSegments + 1) * 2;
  },
  _getBevelBarTriangleCount: function(bevelSegments) {
    var widthSegments = bevelSegments * 4 + 3;
    var heightSegments = bevelSegments * 2 + 1;
    return (widthSegments + 1) * heightSegments * 2 + 4;
  },
  setColor: function(idx, color) {
    var vertexCount = this.getBarVertexCount();
    var start2 = vertexCount * idx;
    var end2 = vertexCount * (idx + 1);
    for (var i = start2; i < end2; i++) {
      this.attributes.color.set(i, color);
    }
    this.dirtyAttribute("color");
  },
  getDataIndexOfVertex: function(vertexIndex) {
    return this._dataIndices ? this._dataIndices[vertexIndex] : null;
  },
  addBar: function() {
    var v3Create = vec3$6.create;
    var v3ScaleAndAdd = vec3$6.scaleAndAdd;
    var end2 = v3Create();
    var px = v3Create();
    var py = v3Create();
    var pz = v3Create();
    var nx = v3Create();
    var ny = v3Create();
    var nz = v3Create();
    var pts = [];
    var normals = [];
    for (var i = 0; i < 8; i++) {
      pts[i] = v3Create();
    }
    var cubeFaces4 = [
      [0, 1, 5, 4],
      [2, 3, 7, 6],
      [4, 5, 6, 7],
      [3, 2, 1, 0],
      [0, 4, 7, 3],
      [1, 2, 6, 5]
    ];
    var face4To3 = [0, 1, 2, 0, 2, 3];
    var cubeFaces3 = [];
    for (var i = 0; i < cubeFaces4.length; i++) {
      var face4 = cubeFaces4[i];
      for (var j = 0; j < 2; j++) {
        var face = [];
        for (var k = 0; k < 3; k++) {
          face.push(face4[face4To3[j * 3 + k]]);
        }
        cubeFaces3.push(face);
      }
    }
    return function(start2, dir3, leftDir, size, color, dataIndex) {
      var startVertex = this._vertexOffset;
      if (this.bevelSize > 0 && this.bevelSegments > 0) {
        this._addBevelBar(start2, dir3, leftDir, size, this.bevelSize, this.bevelSegments, color);
      } else {
        vec3$6.copy(py, dir3);
        vec3$6.normalize(py, py);
        vec3$6.cross(pz, leftDir, py);
        vec3$6.normalize(pz, pz);
        vec3$6.cross(px, py, pz);
        vec3$6.normalize(pz, pz);
        vec3$6.negate(nx, px);
        vec3$6.negate(ny, py);
        vec3$6.negate(nz, pz);
        v3ScaleAndAdd(pts[0], start2, px, size[0] / 2);
        v3ScaleAndAdd(pts[0], pts[0], pz, size[2] / 2);
        v3ScaleAndAdd(pts[1], start2, px, size[0] / 2);
        v3ScaleAndAdd(pts[1], pts[1], nz, size[2] / 2);
        v3ScaleAndAdd(pts[2], start2, nx, size[0] / 2);
        v3ScaleAndAdd(pts[2], pts[2], nz, size[2] / 2);
        v3ScaleAndAdd(pts[3], start2, nx, size[0] / 2);
        v3ScaleAndAdd(pts[3], pts[3], pz, size[2] / 2);
        v3ScaleAndAdd(end2, start2, py, size[1]);
        v3ScaleAndAdd(pts[4], end2, px, size[0] / 2);
        v3ScaleAndAdd(pts[4], pts[4], pz, size[2] / 2);
        v3ScaleAndAdd(pts[5], end2, px, size[0] / 2);
        v3ScaleAndAdd(pts[5], pts[5], nz, size[2] / 2);
        v3ScaleAndAdd(pts[6], end2, nx, size[0] / 2);
        v3ScaleAndAdd(pts[6], pts[6], nz, size[2] / 2);
        v3ScaleAndAdd(pts[7], end2, nx, size[0] / 2);
        v3ScaleAndAdd(pts[7], pts[7], pz, size[2] / 2);
        var attributes = this.attributes;
        if (this.enableNormal) {
          normals[0] = px;
          normals[1] = nx;
          normals[2] = py;
          normals[3] = ny;
          normals[4] = pz;
          normals[5] = nz;
          var vertexOffset = this._vertexOffset;
          for (var i2 = 0; i2 < cubeFaces4.length; i2++) {
            var idx3 = this._triangleOffset * 3;
            for (var k2 = 0; k2 < 6; k2++) {
              this.indices[idx3++] = vertexOffset + face4To3[k2];
            }
            vertexOffset += 4;
            this._triangleOffset += 2;
          }
          for (var i2 = 0; i2 < cubeFaces4.length; i2++) {
            var normal2 = normals[i2];
            for (var k2 = 0; k2 < 4; k2++) {
              var idx = cubeFaces4[i2][k2];
              attributes.position.set(this._vertexOffset, pts[idx]);
              attributes.normal.set(this._vertexOffset, normal2);
              attributes.color.set(this._vertexOffset++, color);
            }
          }
        } else {
          for (var i2 = 0; i2 < cubeFaces3.length; i2++) {
            var idx3 = this._triangleOffset * 3;
            for (var k2 = 0; k2 < 3; k2++) {
              this.indices[idx3 + k2] = cubeFaces3[i2][k2] + this._vertexOffset;
            }
            this._triangleOffset++;
          }
          for (var i2 = 0; i2 < pts.length; i2++) {
            attributes.position.set(this._vertexOffset, pts[i2]);
            attributes.color.set(this._vertexOffset++, color);
          }
        }
      }
      var endVerex = this._vertexOffset;
      for (var i2 = startVertex; i2 < endVerex; i2++) {
        this._dataIndices[i2] = dataIndex;
      }
    };
  }(),
  _addBevelBar: function() {
    var px = vec3$6.create();
    var py = vec3$6.create();
    var pz = vec3$6.create();
    var rotateMat = mat3.create();
    var bevelStartSize = [];
    var xOffsets = [1, -1, -1, 1];
    var zOffsets = [1, 1, -1, -1];
    var yOffsets = [2, 0];
    return function(start2, dir3, leftDir, size, bevelSize, bevelSegments, color) {
      vec3$6.copy(py, dir3);
      vec3$6.normalize(py, py);
      vec3$6.cross(pz, leftDir, py);
      vec3$6.normalize(pz, pz);
      vec3$6.cross(px, py, pz);
      vec3$6.normalize(pz, pz);
      rotateMat[0] = px[0];
      rotateMat[1] = px[1];
      rotateMat[2] = px[2];
      rotateMat[3] = py[0];
      rotateMat[4] = py[1];
      rotateMat[5] = py[2];
      rotateMat[6] = pz[0];
      rotateMat[7] = pz[1];
      rotateMat[8] = pz[2];
      bevelSize = Math.min(size[0], size[2]) / 2 * bevelSize;
      for (var i = 0; i < 3; i++) {
        bevelStartSize[i] = Math.max(size[i] - bevelSize * 2, 0);
      }
      var rx = (size[0] - bevelStartSize[0]) / 2;
      var ry = (size[1] - bevelStartSize[1]) / 2;
      var rz = (size[2] - bevelStartSize[2]) / 2;
      var pos = [];
      var normal2 = [];
      var vertexOffset = this._vertexOffset;
      var endIndices = [];
      for (var i = 0; i < 2; i++) {
        endIndices[i] = endIndices[i] = [];
        for (var m2 = 0; m2 <= bevelSegments; m2++) {
          for (var j = 0; j < 4; j++) {
            if (m2 === 0 && i === 0 || i === 1 && m2 === bevelSegments) {
              endIndices[i].push(vertexOffset);
            }
            for (var n = 0; n <= bevelSegments; n++) {
              var phi = n / bevelSegments * Math.PI / 2 + Math.PI / 2 * j;
              var theta = m2 / bevelSegments * Math.PI / 2 + Math.PI / 2 * i;
              normal2[0] = rx * Math.cos(phi) * Math.sin(theta);
              normal2[1] = ry * Math.cos(theta);
              normal2[2] = rz * Math.sin(phi) * Math.sin(theta);
              pos[0] = normal2[0] + xOffsets[j] * bevelStartSize[0] / 2;
              pos[1] = normal2[1] + ry + yOffsets[i] * bevelStartSize[1] / 2;
              pos[2] = normal2[2] + zOffsets[j] * bevelStartSize[2] / 2;
              if (!(Math.abs(rx - ry) < 1e-6 && Math.abs(ry - rz) < 1e-6)) {
                normal2[0] /= rx * rx;
                normal2[1] /= ry * ry;
                normal2[2] /= rz * rz;
              }
              vec3$6.normalize(normal2, normal2);
              vec3$6.transformMat3(pos, pos, rotateMat);
              vec3$6.transformMat3(normal2, normal2, rotateMat);
              vec3$6.add(pos, pos, start2);
              this.attributes.position.set(vertexOffset, pos);
              if (this.enableNormal) {
                this.attributes.normal.set(vertexOffset, normal2);
              }
              this.attributes.color.set(vertexOffset, color);
              vertexOffset++;
            }
          }
        }
      }
      var widthSegments = bevelSegments * 4 + 3;
      var heightSegments = bevelSegments * 2 + 1;
      var len2 = widthSegments + 1;
      for (var j = 0; j < heightSegments; j++) {
        for (var i = 0; i <= widthSegments; i++) {
          var i2 = j * len2 + i + this._vertexOffset;
          var i1 = j * len2 + (i + 1) % len2 + this._vertexOffset;
          var i4 = (j + 1) * len2 + (i + 1) % len2 + this._vertexOffset;
          var i3 = (j + 1) * len2 + i + this._vertexOffset;
          this.setTriangleIndices(this._triangleOffset++, [i4, i2, i1]);
          this.setTriangleIndices(this._triangleOffset++, [i4, i3, i2]);
        }
      }
      this.setTriangleIndices(this._triangleOffset++, [endIndices[0][0], endIndices[0][2], endIndices[0][1]]);
      this.setTriangleIndices(this._triangleOffset++, [endIndices[0][0], endIndices[0][3], endIndices[0][2]]);
      this.setTriangleIndices(this._triangleOffset++, [endIndices[1][0], endIndices[1][1], endIndices[1][2]]);
      this.setTriangleIndices(this._triangleOffset++, [endIndices[1][0], endIndices[1][2], endIndices[1][3]]);
      this._vertexOffset = vertexOffset;
    };
  }()
});
defaults(BarsGeometry.prototype, dynamicConvertMixin);
defaults(BarsGeometry.prototype, trianglesSortMixin);
var BarsGeometry$1 = BarsGeometry;
var vec3$5 = glmatrix.vec3;
var Bar3DView = ChartView$1.extend({
  type: "bar3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this._api = api;
    this._labelsBuilder = new LabelsBuilder(256, 256, api);
    var self2 = this;
    this._labelsBuilder.getLabelPosition = function(dataIndex, position2, distance2) {
      if (self2._data) {
        var layout2 = self2._data.getItemLayout(dataIndex);
        var start2 = layout2[0];
        var dir3 = layout2[1];
        var height = layout2[2][1];
        return vec3$5.scaleAndAdd([], start2, dir3, distance2 + height);
      } else {
        return [0, 0];
      }
    };
    this._labelsBuilder.getMesh().renderOrder = 100;
  },
  render: function(seriesModel, ecModel, api) {
    var tmp = this._prevBarMesh;
    this._prevBarMesh = this._barMesh;
    this._barMesh = tmp;
    if (!this._barMesh) {
      this._barMesh = new graphicGL$1.Mesh({
        geometry: new BarsGeometry$1(),
        shadowDepthMaterial: new graphicGL$1.Material({
          shader: new graphicGL$1.Shader(graphicGL$1.Shader.source("ecgl.sm.depth.vertex"), graphicGL$1.Shader.source("ecgl.sm.depth.fragment"))
        }),
        culling: seriesModel.coordinateSystem.type === "cartesian3D",
        renderOrder: 10,
        renderNormal: true
      });
    }
    this.groupGL.remove(this._prevBarMesh);
    this.groupGL.add(this._barMesh);
    this.groupGL.add(this._labelsBuilder.getMesh());
    var coordSys = seriesModel.coordinateSystem;
    this._doRender(seriesModel, api);
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      this._barMesh.material[methodName]("fragment", "SRGB_DECODE");
    }
    this._data = seriesModel.getData();
    this._labelsBuilder.updateData(this._data);
    this._labelsBuilder.updateLabels();
    this._updateAnimation(seriesModel);
  },
  _updateAnimation: function(seriesModel) {
    graphicGL$1.updateVertexAnimation([["prevPosition", "position"], ["prevNormal", "normal"]], this._prevBarMesh, this._barMesh, seriesModel);
  },
  _doRender: function(seriesModel, api) {
    var data = seriesModel.getData();
    var shading = seriesModel.get("shading");
    var enableNormal = shading !== "color";
    var self2 = this;
    var barMesh = this._barMesh;
    var shadingPrefix = "ecgl." + shading;
    if (!barMesh.material || barMesh.material.shader.name !== shadingPrefix) {
      barMesh.material = graphicGL$1.createMaterial(shadingPrefix, ["VERTEX_COLOR"]);
    }
    graphicGL$1.setMaterialFromModel(shading, barMesh.material, seriesModel, api);
    barMesh.geometry.enableNormal = enableNormal;
    barMesh.geometry.resetOffset();
    var bevelSize = seriesModel.get("bevelSize");
    var bevelSegments = seriesModel.get("bevelSmoothness");
    barMesh.geometry.bevelSegments = bevelSegments;
    barMesh.geometry.bevelSize = bevelSize;
    var colorArr = [];
    var vertexColors = new Float32Array(data.count() * 4);
    var colorOffset = 0;
    var barCount = 0;
    var hasTransparent = false;
    data.each(function(idx) {
      if (!data.hasValue(idx)) {
        return;
      }
      var color = getItemVisualColor(data, idx);
      var opacity = getItemVisualOpacity(data, idx);
      if (opacity == null) {
        opacity = 1;
      }
      graphicGL$1.parseColor(color, colorArr);
      colorArr[3] *= opacity;
      vertexColors[colorOffset++] = colorArr[0];
      vertexColors[colorOffset++] = colorArr[1];
      vertexColors[colorOffset++] = colorArr[2];
      vertexColors[colorOffset++] = colorArr[3];
      if (colorArr[3] > 0) {
        barCount++;
        if (colorArr[3] < 0.99) {
          hasTransparent = true;
        }
      }
    });
    barMesh.geometry.setBarCount(barCount);
    var orient = data.getLayout("orient");
    var barIndexOfData = this._barIndexOfData = new Int32Array(data.count());
    var barCount = 0;
    data.each(function(idx) {
      if (!data.hasValue(idx)) {
        barIndexOfData[idx] = -1;
        return;
      }
      var layout2 = data.getItemLayout(idx);
      var start2 = layout2[0];
      var dir3 = layout2[1];
      var size = layout2[2];
      var idx4 = idx * 4;
      colorArr[0] = vertexColors[idx4++];
      colorArr[1] = vertexColors[idx4++];
      colorArr[2] = vertexColors[idx4++];
      colorArr[3] = vertexColors[idx4++];
      if (colorArr[3] > 0) {
        self2._barMesh.geometry.addBar(start2, dir3, orient, size, colorArr, idx);
        barIndexOfData[idx] = barCount++;
      }
    });
    barMesh.geometry.dirty();
    barMesh.geometry.updateBoundingBox();
    var material = barMesh.material;
    material.transparent = hasTransparent;
    material.depthMask = !hasTransparent;
    barMesh.geometry.sortTriangles = hasTransparent;
    this._initHandler(seriesModel, api);
  },
  _initHandler: function(seriesModel, api) {
    var data = seriesModel.getData();
    var barMesh = this._barMesh;
    var isCartesian3D = seriesModel.coordinateSystem.type === "cartesian3D";
    barMesh.seriesIndex = seriesModel.seriesIndex;
    var lastDataIndex = -1;
    barMesh.off("mousemove");
    barMesh.off("mouseout");
    barMesh.on("mousemove", function(e2) {
      var dataIndex = barMesh.geometry.getDataIndexOfVertex(e2.triangle[0]);
      if (dataIndex !== lastDataIndex) {
        this._downplay(lastDataIndex);
        this._highlight(dataIndex);
        this._labelsBuilder.updateLabels([dataIndex]);
        if (isCartesian3D) {
          api.dispatchAction({
            type: "grid3DShowAxisPointer",
            value: [data.get("x", dataIndex), data.get("y", dataIndex), data.get("z", dataIndex, true)]
          });
        }
      }
      lastDataIndex = dataIndex;
      barMesh.dataIndex = dataIndex;
    }, this);
    barMesh.on("mouseout", function(e2) {
      this._downplay(lastDataIndex);
      this._labelsBuilder.updateLabels();
      lastDataIndex = -1;
      barMesh.dataIndex = -1;
      if (isCartesian3D) {
        api.dispatchAction({
          type: "grid3DHideAxisPointer"
        });
      }
    }, this);
  },
  _highlight: function(dataIndex) {
    var data = this._data;
    if (!data) {
      return;
    }
    var barIndex = this._barIndexOfData[dataIndex];
    if (barIndex < 0) {
      return;
    }
    var itemModel = data.getItemModel(dataIndex);
    var emphasisItemStyleModel = itemModel.getModel("emphasis.itemStyle");
    var emphasisColor = emphasisItemStyleModel.get("color");
    var emphasisOpacity = emphasisItemStyleModel.get("opacity");
    if (emphasisColor == null) {
      var color = getItemVisualColor(data, dataIndex);
      emphasisColor = lift(color, -0.4);
    }
    if (emphasisOpacity == null) {
      emphasisOpacity = getItemVisualOpacity(data, dataIndex);
    }
    var colorArr = graphicGL$1.parseColor(emphasisColor);
    colorArr[3] *= emphasisOpacity;
    this._barMesh.geometry.setColor(barIndex, colorArr);
    this._api.getZr().refresh();
  },
  _downplay: function(dataIndex) {
    var data = this._data;
    if (!data) {
      return;
    }
    var barIndex = this._barIndexOfData[dataIndex];
    if (barIndex < 0) {
      return;
    }
    var color = getItemVisualColor(data, dataIndex);
    var opacity = getItemVisualOpacity(data, dataIndex);
    var colorArr = graphicGL$1.parseColor(color);
    colorArr[3] *= opacity;
    this._barMesh.geometry.setColor(barIndex, colorArr);
    this._api.getZr().refresh();
  },
  highlight: function(seriesModel, ecModel, api, payload) {
    this._toggleStatus("highlight", seriesModel, ecModel, api, payload);
  },
  downplay: function(seriesModel, ecModel, api, payload) {
    this._toggleStatus("downplay", seriesModel, ecModel, api, payload);
  },
  _toggleStatus: function(status, seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = retrieve$1.queryDataIndex(data, payload);
    var self2 = this;
    if (dataIndex != null) {
      each$f(formatUtil$1.normalizeToArray(dataIndex), function(dataIdx) {
        status === "highlight" ? this._highlight(dataIdx) : this._downplay(dataIdx);
      }, this);
    } else {
      data.each(function(dataIdx) {
        status === "highlight" ? self2._highlight(dataIdx) : self2._downplay(dataIdx);
      });
    }
  },
  remove: function() {
    this.groupGL.removeAll();
  },
  dispose: function() {
    this._labelsBuilder.dispose();
    this.groupGL.removeAll();
  }
});
function install$a(registers) {
  registers.registerChartView(Bar3DView);
  registers.registerSeriesModel(Bar3DSeries$1);
  registerBarLayout(registers);
  registers.registerProcessor(function(ecModel, api) {
    ecModel.eachSeriesByType("bar3d", function(seriesModel) {
      var data = seriesModel.getData();
      data.filterSelf(function(idx) {
        return data.hasValue(idx);
      });
    });
  });
}
use(install$a);
var Line3DSeries = SeriesModel$1.extend({
  type: "series.line3D",
  dependencies: ["grid3D"],
  visualStyleAccessPath: "lineStyle",
  visualDrawType: "stroke",
  getInitialData: function(option, ecModel) {
    return createList(this);
  },
  formatTooltip: function(dataIndex) {
    return formatTooltip(this, dataIndex);
  },
  defaultOption: {
    coordinateSystem: "cartesian3D",
    zlevel: -10,
    grid3DIndex: 0,
    lineStyle: {
      width: 2
    },
    animationDurationUpdate: 500
  }
});
var Line3DSeries$1 = Line3DSeries;
var vec3$4 = glmatrix.vec3;
graphicGL$1.Shader.import(lines3DGLSL);
var Line3DView = ChartView$1.extend({
  type: "line3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this._api = api;
  },
  render: function(seriesModel, ecModel, api) {
    var tmp = this._prevLine3DMesh;
    this._prevLine3DMesh = this._line3DMesh;
    this._line3DMesh = tmp;
    if (!this._line3DMesh) {
      this._line3DMesh = new graphicGL$1.Mesh({
        geometry: new LinesGeometry$3({
          useNativeLine: false,
          sortTriangles: true
        }),
        material: new graphicGL$1.Material({
          shader: graphicGL$1.createShader("ecgl.meshLines3D")
        }),
        renderOrder: 10
      });
      this._line3DMesh.geometry.pick = this._pick.bind(this);
    }
    this.groupGL.remove(this._prevLine3DMesh);
    this.groupGL.add(this._line3DMesh);
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      this._line3DMesh.material[methodName]("fragment", "SRGB_DECODE");
    }
    this._doRender(seriesModel, api);
    this._data = seriesModel.getData();
    this._camera = coordSys.viewGL.camera;
    this.updateCamera();
    this._updateAnimation(seriesModel);
  },
  updateCamera: function() {
    this._updateNDCPosition();
  },
  _doRender: function(seriesModel, api) {
    var data = seriesModel.getData();
    var lineMesh = this._line3DMesh;
    lineMesh.geometry.resetOffset();
    var points2 = data.getLayout("points");
    var colorArr = [];
    var vertexColors = new Float32Array(points2.length / 3 * 4);
    var colorOffset = 0;
    var hasTransparent = false;
    data.each(function(idx) {
      var color = getItemVisualColor(data, idx);
      var opacity = getItemVisualOpacity(data, idx);
      if (opacity == null) {
        opacity = 1;
      }
      graphicGL$1.parseColor(color, colorArr);
      colorArr[3] *= opacity;
      vertexColors[colorOffset++] = colorArr[0];
      vertexColors[colorOffset++] = colorArr[1];
      vertexColors[colorOffset++] = colorArr[2];
      vertexColors[colorOffset++] = colorArr[3];
      if (colorArr[3] < 0.99) {
        hasTransparent = true;
      }
    });
    lineMesh.geometry.setVertexCount(lineMesh.geometry.getPolylineVertexCount(points2));
    lineMesh.geometry.setTriangleCount(lineMesh.geometry.getPolylineTriangleCount(points2));
    lineMesh.geometry.addPolyline(points2, vertexColors, retrieve$1.firstNotNull(seriesModel.get("lineStyle.width"), 1));
    lineMesh.geometry.dirty();
    lineMesh.geometry.updateBoundingBox();
    var material = lineMesh.material;
    material.transparent = hasTransparent;
    material.depthMask = !hasTransparent;
    var debugWireframeModel = seriesModel.getModel("debug.wireframe");
    if (debugWireframeModel.get("show")) {
      lineMesh.geometry.createAttribute("barycentric", "float", 3);
      lineMesh.geometry.generateBarycentric();
      lineMesh.material.set("both", "WIREFRAME_TRIANGLE");
      lineMesh.material.set("wireframeLineColor", graphicGL$1.parseColor(debugWireframeModel.get("lineStyle.color") || "rgba(0,0,0,0.5)"));
      lineMesh.material.set("wireframeLineWidth", retrieve$1.firstNotNull(debugWireframeModel.get("lineStyle.width"), 1));
    } else {
      lineMesh.material.set("both", "WIREFRAME_TRIANGLE");
    }
    this._points = points2;
    this._initHandler(seriesModel, api);
  },
  _updateAnimation: function(seriesModel) {
    graphicGL$1.updateVertexAnimation([["prevPosition", "position"], ["prevPositionPrev", "positionPrev"], ["prevPositionNext", "positionNext"]], this._prevLine3DMesh, this._line3DMesh, seriesModel);
  },
  _initHandler: function(seriesModel, api) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    var lineMesh = this._line3DMesh;
    var lastDataIndex = -1;
    lineMesh.seriesIndex = seriesModel.seriesIndex;
    lineMesh.off("mousemove");
    lineMesh.off("mouseout");
    lineMesh.on("mousemove", function(e2) {
      var value = coordSys.pointToData(e2.point.array);
      var dataIndex = data.indicesOfNearest("x", value[0])[0];
      if (dataIndex !== lastDataIndex) {
        api.dispatchAction({
          type: "grid3DShowAxisPointer",
          value: [data.get("x", dataIndex), data.get("y", dataIndex), data.get("z", dataIndex)]
        });
        lineMesh.dataIndex = dataIndex;
      }
      lastDataIndex = dataIndex;
    }, this);
    lineMesh.on("mouseout", function(e2) {
      lastDataIndex = -1;
      lineMesh.dataIndex = -1;
      api.dispatchAction({
        type: "grid3DHideAxisPointer"
      });
    }, this);
  },
  _updateNDCPosition: function() {
    var worldViewProjection = new Matrix4$1();
    var camera2 = this._camera;
    Matrix4$1.multiply(worldViewProjection, camera2.projectionMatrix, camera2.viewMatrix);
    var positionNDC = this._positionNDC;
    var points2 = this._points;
    var nPoints = points2.length / 3;
    if (!positionNDC || positionNDC.length / 2 !== nPoints) {
      positionNDC = this._positionNDC = new Float32Array(nPoints * 2);
    }
    var pos = [];
    for (var i = 0; i < nPoints; i++) {
      var i3 = i * 3;
      var i2 = i * 2;
      pos[0] = points2[i3];
      pos[1] = points2[i3 + 1];
      pos[2] = points2[i3 + 2];
      pos[3] = 1;
      vec3$4.transformMat4(pos, pos, worldViewProjection.array);
      positionNDC[i2] = pos[0] / pos[3];
      positionNDC[i2 + 1] = pos[1] / pos[3];
    }
  },
  _pick: function(x, y, renderer, camera2, renderable, out2) {
    var positionNDC = this._positionNDC;
    var seriesModel = this._data.hostModel;
    var lineWidth = seriesModel.get("lineStyle.width");
    var dataIndex = -1;
    var width = renderer.viewport.width;
    var height = renderer.viewport.height;
    var halfWidth = width * 0.5;
    var halfHeight = height * 0.5;
    x = (x + 1) * halfWidth;
    y = (y + 1) * halfHeight;
    for (var i = 1; i < positionNDC.length / 2; i++) {
      var x0 = (positionNDC[(i - 1) * 2] + 1) * halfWidth;
      var y0 = (positionNDC[(i - 1) * 2 + 1] + 1) * halfHeight;
      var x1 = (positionNDC[i * 2] + 1) * halfWidth;
      var y1 = (positionNDC[i * 2 + 1] + 1) * halfHeight;
      if (containStroke$4(x0, y0, x1, y1, lineWidth, x, y)) {
        var dist0 = (x0 - x) * (x0 - x) + (y0 - y) * (y0 - y);
        var dist1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
        dataIndex = dist0 < dist1 ? i - 1 : i;
      }
    }
    if (dataIndex >= 0) {
      var i3 = dataIndex * 3;
      var point = new Vector3$1(this._points[i3], this._points[i3 + 1], this._points[i3 + 2]);
      out2.push({
        dataIndex,
        point,
        pointWorld: point.clone(),
        target: this._line3DMesh,
        distance: this._camera.getWorldPosition().dist(point)
      });
    }
  },
  remove: function() {
    this.groupGL.removeAll();
  },
  dispose: function() {
    this.groupGL.removeAll();
  }
});
function install$9(registers) {
  registers.registerChartView(Line3DView);
  registers.registerSeriesModel(Line3DSeries$1);
  registers.registerLayout(function(ecModel, api) {
    ecModel.eachSeriesByType("line3D", function(seriesModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys) {
        if (coordSys.type !== "cartesian3D") {
          return;
        }
        var points2 = new Float32Array(data.count() * 3);
        var item = [];
        var out2 = [];
        var coordDims = coordSys.dimensions;
        var dims = coordDims.map(function(coordDim) {
          return seriesModel.coordDimToDataDim(coordDim)[0];
        });
        if (coordSys) {
          data.each(dims, function(x, y, z, idx) {
            item[0] = x;
            item[1] = y;
            item[2] = z;
            coordSys.dataToPoint(item, out2);
            points2[idx * 3] = out2[0];
            points2[idx * 3 + 1] = out2[1];
            points2[idx * 3 + 2] = out2[2];
          });
        }
        data.setLayout("points", points2);
      }
    });
  });
}
use(install$9);
var Scatter3DSeries = SeriesModel$1.extend({
  type: "series.scatter3D",
  dependencies: ["globe", "grid3D", "geo3D"],
  visualStyleAccessPath: "itemStyle",
  hasSymbolVisual: true,
  getInitialData: function(option, ecModel) {
    return createList(this);
  },
  getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
    var text = formatUtil$1.getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
    if (text == null) {
      var data = this.getData();
      var lastDim = data.dimensions[data.dimensions.length - 1];
      text = data.get(lastDim, dataIndex);
    }
    return text;
  },
  formatTooltip: function(dataIndex) {
    return formatTooltip(this, dataIndex);
  },
  defaultOption: {
    coordinateSystem: "cartesian3D",
    zlevel: -10,
    progressive: 1e5,
    progressiveThreshold: 1e5,
    grid3DIndex: 0,
    globeIndex: 0,
    symbol: "circle",
    symbolSize: 10,
    blendMode: "source-over",
    label: {
      show: false,
      position: "right",
      distance: 5,
      textStyle: {
        fontSize: 14,
        color: "#000",
        backgroundColor: "rgba(255,255,255,0.7)",
        padding: 3,
        borderRadius: 3
      }
    },
    itemStyle: {
      opacity: 0.8
    },
    emphasis: {
      label: {
        show: true
      }
    },
    animationDurationUpdate: 500
  }
});
function makeSprite(size, canvas, draw) {
  var canvas = canvas || document.createElement("canvas");
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext("2d");
  draw && draw(ctx);
  return canvas;
}
function makePath(symbol, symbolSize, style, marginBias) {
  if (!isArray$1(symbolSize)) {
    symbolSize = [symbolSize, symbolSize];
  }
  var margin = spriteUtil.getMarginByStyle(style, marginBias);
  var width = symbolSize[0] + margin.left + margin.right;
  var height = symbolSize[1] + margin.top + margin.bottom;
  var path = createSymbol$1(symbol, 0, 0, symbolSize[0], symbolSize[1]);
  var size = Math.max(width, height);
  path.x = margin.left;
  path.y = margin.top;
  if (width > height) {
    path.y += (size - height) / 2;
  } else {
    path.x += (size - width) / 2;
  }
  var rect = path.getBoundingRect();
  path.x -= rect.x;
  path.y -= rect.y;
  path.setStyle(style);
  path.update();
  path.__size = size;
  return path;
}
function generateSDF(ctx, sourceImageData, range) {
  var sourceWidth = sourceImageData.width;
  var sourceHeight = sourceImageData.height;
  var width = ctx.canvas.width;
  var height = ctx.canvas.height;
  var scaleX = sourceWidth / width;
  var scaleY = sourceHeight / height;
  function sign2(r) {
    return r < 128 ? 1 : -1;
  }
  function searchMinDistance(x2, y2) {
    var minDistSqr = Infinity;
    x2 = Math.floor(x2 * scaleX);
    y2 = Math.floor(y2 * scaleY);
    var i2 = y2 * sourceWidth + x2;
    var r = sourceImageData.data[i2 * 4];
    var a = sign2(r);
    for (var y22 = Math.max(y2 - range, 0); y22 < Math.min(y2 + range, sourceHeight); y22++) {
      for (var x22 = Math.max(x2 - range, 0); x22 < Math.min(x2 + range, sourceWidth); x22++) {
        var i2 = y22 * sourceWidth + x22;
        var r2 = sourceImageData.data[i2 * 4];
        var b = sign2(r2);
        var dx = x22 - x2;
        var dy = y22 - y2;
        if (a !== b) {
          var distSqr = dx * dx + dy * dy;
          if (distSqr < minDistSqr) {
            minDistSqr = distSqr;
          }
        }
      }
    }
    return a * Math.sqrt(minDistSqr);
  }
  var sdfImageData = ctx.createImageData(width, height);
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var dist2 = searchMinDistance(x, y);
      var normalized = dist2 / range * 0.5 + 0.5;
      var i = (y * width + x) * 4;
      sdfImageData.data[i++] = (1 - normalized) * 255;
      sdfImageData.data[i++] = (1 - normalized) * 255;
      sdfImageData.data[i++] = (1 - normalized) * 255;
      sdfImageData.data[i++] = 255;
    }
  }
  return sdfImageData;
}
var spriteUtil = {
  getMarginByStyle: function(style) {
    var minMargin = style.minMargin || 0;
    var lineWidth = 0;
    if (style.stroke && style.stroke !== "none") {
      lineWidth = style.lineWidth == null ? 1 : style.lineWidth;
    }
    var shadowBlurSize = style.shadowBlur || 0;
    var shadowOffsetX = style.shadowOffsetX || 0;
    var shadowOffsetY = style.shadowOffsetY || 0;
    var margin = {};
    margin.left = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize, minMargin);
    margin.right = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize, minMargin);
    margin.top = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize, minMargin);
    margin.bottom = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize, minMargin);
    return margin;
  },
  createSymbolSprite: function(symbol, symbolSize, style, canvas) {
    var path = makePath(symbol, symbolSize, style);
    var margin = spriteUtil.getMarginByStyle(style);
    return {
      image: makeSprite(path.__size, canvas, function(ctx) {
        brushSingle(ctx, path);
      }),
      margin
    };
  },
  createSDFFromCanvas: function(canvas, size, range, outCanvas) {
    return makeSprite(size, outCanvas, function(outCtx) {
      var ctx = canvas.getContext("2d");
      var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      outCtx.putImageData(generateSDF(outCtx, imgData, range), 0, 0);
    });
  },
  createSimpleSprite: function(size, canvas) {
    return makeSprite(size, canvas, function(ctx) {
      var halfSize = size / 2;
      ctx.beginPath();
      ctx.arc(halfSize, halfSize, 60, 0, Math.PI * 2, false);
      ctx.closePath();
      var gradient = ctx.createRadialGradient(halfSize, halfSize, 0, halfSize, halfSize, halfSize);
      gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
      gradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
      gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
      ctx.fillStyle = gradient;
      ctx.fill();
    });
  }
};
var spriteUtil$1 = spriteUtil;
var vec3$3 = glmatrix.vec3;
var verticesSortMixin = {
  needsSortVertices: function() {
    return this.sortVertices;
  },
  needsSortVerticesProgressively: function() {
    return this.needsSortVertices() && this.vertexCount >= 2e4;
  },
  doSortVertices: function(cameraPos, frame) {
    var indices = this.indices;
    var p = vec3$3.create();
    if (!indices) {
      indices = this.indices = this.vertexCount > 65535 ? new Uint32Array(this.vertexCount) : new Uint16Array(this.vertexCount);
      for (var i = 0; i < indices.length; i++) {
        indices[i] = i;
      }
    }
    if (frame === 0) {
      var posAttr = this.attributes.position;
      var cameraPos = cameraPos.array;
      var noneCount = 0;
      if (!this._zList || this._zList.length !== this.vertexCount) {
        this._zList = new Float32Array(this.vertexCount);
      }
      var firstZ;
      for (var i = 0; i < this.vertexCount; i++) {
        posAttr.get(i, p);
        var z = vec3$3.sqrDist(p, cameraPos);
        if (isNaN(z)) {
          z = 1e7;
          noneCount++;
        }
        if (i === 0) {
          firstZ = z;
          z = 0;
        } else {
          z = z - firstZ;
        }
        this._zList[i] = z;
      }
      this._noneCount = noneCount;
    }
    if (this.vertexCount < 2e4) {
      if (frame === 0) {
        this._simpleSort(this._noneCount / this.vertexCount > 0.05);
      }
    } else {
      for (var i = 0; i < 3; i++) {
        this._progressiveQuickSort(frame * 3 + i);
      }
    }
    this.dirtyIndices();
  },
  _simpleSort: function(useNativeQuickSort) {
    var zList = this._zList;
    var indices = this.indices;
    function compare2(a, b) {
      return zList[b] - zList[a];
    }
    if (useNativeQuickSort) {
      Array.prototype.sort.call(indices, compare2);
    } else {
      ProgressiveQuickSort.sort(indices, compare2, 0, indices.length - 1);
    }
  },
  _progressiveQuickSort: function(frame) {
    var zList = this._zList;
    var indices = this.indices;
    this._quickSort = this._quickSort || new ProgressiveQuickSort();
    this._quickSort.step(indices, function(a, b) {
      return zList[b] - zList[a];
    }, frame);
  }
};
var sdfSpriteGLSL = "@export ecgl.sdfSprite.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform float elapsedTime : 0;\n\nattribute vec3 position : POSITION;\n\n#ifdef VERTEX_SIZE\nattribute float size;\n#else\nuniform float u_Size;\n#endif\n\n#ifdef VERTEX_COLOR\nattribute vec4 a_FillColor: COLOR;\nvarying vec4 v_Color;\n#endif\n\n#ifdef VERTEX_ANIMATION\nattribute vec3 prevPosition;\nattribute float prevSize;\nuniform float percent : 1.0;\n#endif\n\n\n#ifdef POSITIONTEXTURE_ENABLED\nuniform sampler2D positionTexture;\n#endif\n\nvarying float v_Size;\n\nvoid main()\n{\n\n#ifdef POSITIONTEXTURE_ENABLED\n gl_Position = worldViewProjection * vec4(texture2D(positionTexture, position.xy).xy, -10.0, 1.0);\n#else\n\n #ifdef VERTEX_ANIMATION\n vec3 pos = mix(prevPosition, position, percent);\n #else\n vec3 pos = position;\n #endif\n gl_Position = worldViewProjection * vec4(pos, 1.0);\n#endif\n\n#ifdef VERTEX_SIZE\n#ifdef VERTEX_ANIMATION\n v_Size = mix(prevSize, size, percent);\n#else\n v_Size = size;\n#endif\n#else\n v_Size = u_Size;\n#endif\n\n#ifdef VERTEX_COLOR\n v_Color = a_FillColor;\n #endif\n\n gl_PointSize = v_Size;\n}\n\n@end\n\n@export ecgl.sdfSprite.fragment\n\nuniform vec4 color: [1, 1, 1, 1];\nuniform vec4 strokeColor: [1, 1, 1, 1];\nuniform float smoothing: 0.07;\n\nuniform float lineWidth: 0.0;\n\n#ifdef VERTEX_COLOR\nvarying vec4 v_Color;\n#endif\n\nvarying float v_Size;\n\nuniform sampler2D sprite;\n\n@import clay.util.srgb\n\nvoid main()\n{\n gl_FragColor = color;\n\n vec4 _strokeColor = strokeColor;\n\n#ifdef VERTEX_COLOR\n gl_FragColor *= v_Color;\n #endif\n\n#ifdef SPRITE_ENABLED\n float d = texture2D(sprite, gl_PointCoord).r;\n gl_FragColor.a *= smoothstep(0.5 - smoothing, 0.5 + smoothing, d);\n\n if (lineWidth > 0.0) {\n float sLineWidth = lineWidth / 2.0;\n\n float outlineMaxValue0 = 0.5 + sLineWidth;\n float outlineMaxValue1 = 0.5 + sLineWidth + smoothing;\n float outlineMinValue0 = 0.5 - sLineWidth - smoothing;\n float outlineMinValue1 = 0.5 - sLineWidth;\n\n if (d <= outlineMaxValue1 && d >= outlineMinValue0) {\n float a = _strokeColor.a;\n if (d <= outlineMinValue1) {\n a = a * smoothstep(outlineMinValue0, outlineMinValue1, d);\n }\n else {\n a = a * smoothstep(outlineMaxValue1, outlineMaxValue0, d);\n }\n gl_FragColor.rgb = mix(gl_FragColor.rgb * gl_FragColor.a, _strokeColor.rgb, a);\n gl_FragColor.a = gl_FragColor.a * (1.0 - a) + a;\n }\n }\n#endif\n\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(gl_FragColor);\n#endif\n}\n@end";
var vec4 = glmatrix.vec4;
graphicGL$1.Shader.import(sdfSpriteGLSL);
var PointsMesh = graphicGL$1.Mesh.extend(function() {
  var geometry = new graphicGL$1.Geometry({
    dynamic: true,
    attributes: {
      color: new graphicGL$1.Geometry.Attribute("color", "float", 4, "COLOR"),
      position: new graphicGL$1.Geometry.Attribute("position", "float", 3, "POSITION"),
      size: new graphicGL$1.Geometry.Attribute("size", "float", 1),
      prevPosition: new graphicGL$1.Geometry.Attribute("prevPosition", "float", 3),
      prevSize: new graphicGL$1.Geometry.Attribute("prevSize", "float", 1)
    }
  });
  Object.assign(geometry, verticesSortMixin);
  var material = new graphicGL$1.Material({
    shader: graphicGL$1.createShader("ecgl.sdfSprite"),
    transparent: true,
    depthMask: false
  });
  material.enableTexture("sprite");
  material.define("both", "VERTEX_COLOR");
  material.define("both", "VERTEX_SIZE");
  var sdfTexture = new graphicGL$1.Texture2D({
    image: document.createElement("canvas"),
    flipY: false
  });
  material.set("sprite", sdfTexture);
  geometry.pick = this._pick.bind(this);
  return {
    geometry,
    material,
    mode: graphicGL$1.Mesh.POINTS,
    sizeScale: 1
  };
}, {
  _pick: function(x, y, renderer, camera2, renderable, out2) {
    var positionNDC = this._positionNDC;
    if (!positionNDC) {
      return;
    }
    var viewport = renderer.viewport;
    var ndcScaleX = 2 / viewport.width;
    var ndcScaleY = 2 / viewport.height;
    for (var i = this.geometry.vertexCount - 1; i >= 0; i--) {
      var idx;
      if (!this.geometry.indices) {
        idx = i;
      } else {
        idx = this.geometry.indices[i];
      }
      var cx = positionNDC[idx * 2];
      var cy = positionNDC[idx * 2 + 1];
      var size = this.geometry.attributes.size.get(idx) / this.sizeScale;
      var halfSize = size / 2;
      if (x > cx - halfSize * ndcScaleX && x < cx + halfSize * ndcScaleX && y > cy - halfSize * ndcScaleY && y < cy + halfSize * ndcScaleY) {
        var point = new graphicGL$1.Vector3();
        var pointWorld = new graphicGL$1.Vector3();
        this.geometry.attributes.position.get(idx, point.array);
        graphicGL$1.Vector3.transformMat4(pointWorld, point, this.worldTransform);
        out2.push({
          vertexIndex: idx,
          point,
          pointWorld,
          target: this,
          distance: pointWorld.distance(camera2.getWorldPosition())
        });
      }
    }
  },
  updateNDCPosition: function(worldViewProjection, is2D, api) {
    var positionNDC = this._positionNDC;
    var geometry = this.geometry;
    if (!positionNDC || positionNDC.length / 2 !== geometry.vertexCount) {
      positionNDC = this._positionNDC = new Float32Array(geometry.vertexCount * 2);
    }
    var pos = vec4.create();
    for (var i = 0; i < geometry.vertexCount; i++) {
      geometry.attributes.position.get(i, pos);
      pos[3] = 1;
      vec4.transformMat4(pos, pos, worldViewProjection.array);
      vec4.scale(pos, pos, 1 / pos[3]);
      positionNDC[i * 2] = pos[0];
      positionNDC[i * 2 + 1] = pos[1];
    }
  }
});
var PointsMesh$1 = PointsMesh;
var SDF_RANGE = 20;
var Z_2D = -10;
function isSymbolSizeSame(a, b) {
  return a && b && a[0] === b[0] && a[1] === b[1];
}
function PointsBuilder(is2D, api) {
  this.rootNode = new graphicGL$1.Node();
  this.is2D = is2D;
  this._labelsBuilder = new LabelsBuilder(256, 256, api);
  this._labelsBuilder.getMesh().renderOrder = 100;
  this.rootNode.add(this._labelsBuilder.getMesh());
  this._api = api;
  this._spriteImageCanvas = document.createElement("canvas");
  this._startDataIndex = 0;
  this._endDataIndex = 0;
  this._sizeScale = 1;
}
PointsBuilder.prototype = {
  constructor: PointsBuilder,
  highlightOnMouseover: true,
  update: function(seriesModel, ecModel, api, start2, end2) {
    var tmp = this._prevMesh;
    this._prevMesh = this._mesh;
    this._mesh = tmp;
    var data = seriesModel.getData();
    if (start2 == null) {
      start2 = 0;
    }
    if (end2 == null) {
      end2 = data.count();
    }
    this._startDataIndex = start2;
    this._endDataIndex = end2 - 1;
    if (!this._mesh) {
      var material = this._prevMesh && this._prevMesh.material;
      this._mesh = new PointsMesh$1({
        renderOrder: 10,
        frustumCulling: false
      });
      if (material) {
        this._mesh.material = material;
      }
    }
    var material = this._mesh.material;
    var geometry = this._mesh.geometry;
    var attributes = geometry.attributes;
    this.rootNode.remove(this._prevMesh);
    this.rootNode.add(this._mesh);
    this._setPositionTextureToMesh(this._mesh, this._positionTexture);
    var symbolInfo = this._getSymbolInfo(seriesModel, start2, end2);
    var dpr2 = api.getDevicePixelRatio();
    var itemStyle = seriesModel.getModel("itemStyle").getItemStyle();
    var largeMode = seriesModel.get("large");
    var pointSizeScale = 1;
    if (symbolInfo.maxSize > 2) {
      pointSizeScale = this._updateSymbolSprite(seriesModel, itemStyle, symbolInfo, dpr2);
      material.enableTexture("sprite");
    } else {
      material.disableTexture("sprite");
    }
    attributes.position.init(end2 - start2);
    var rgbaArr = [];
    if (largeMode) {
      material.undefine("VERTEX_SIZE");
      material.undefine("VERTEX_COLOR");
      var color = getVisualColor(data);
      var opacity = getVisualOpacity(data);
      graphicGL$1.parseColor(color, rgbaArr);
      rgbaArr[3] *= opacity;
      material.set({
        color: rgbaArr,
        "u_Size": symbolInfo.maxSize * this._sizeScale
      });
    } else {
      material.set({
        color: [1, 1, 1, 1]
      });
      material.define("VERTEX_SIZE");
      material.define("VERTEX_COLOR");
      attributes.size.init(end2 - start2);
      attributes.color.init(end2 - start2);
      this._originalOpacity = new Float32Array(end2 - start2);
    }
    var points2 = data.getLayout("points");
    var positionArr = attributes.position.value;
    for (var i = 0; i < end2 - start2; i++) {
      var i3 = i * 3;
      var i2 = i * 2;
      if (this.is2D) {
        positionArr[i3] = points2[i2];
        positionArr[i3 + 1] = points2[i2 + 1];
        positionArr[i3 + 2] = Z_2D;
      } else {
        positionArr[i3] = points2[i3];
        positionArr[i3 + 1] = points2[i3 + 1];
        positionArr[i3 + 2] = points2[i3 + 2];
      }
      if (!largeMode) {
        var color = getItemVisualColor(data, i);
        var opacity = getItemVisualOpacity(data, i);
        graphicGL$1.parseColor(color, rgbaArr);
        rgbaArr[3] *= opacity;
        attributes.color.set(i, rgbaArr);
        if (rgbaArr[3] < 0.99)
          ;
        var symbolSize = data.getItemVisual(i, "symbolSize");
        symbolSize = symbolSize instanceof Array ? Math.max(symbolSize[0], symbolSize[1]) : symbolSize;
        if (isNaN(symbolSize)) {
          symbolSize = 0;
        }
        attributes.size.value[i] = symbolSize * pointSizeScale * this._sizeScale;
        this._originalOpacity[i] = rgbaArr[3];
      }
    }
    this._mesh.sizeScale = pointSizeScale;
    geometry.updateBoundingBox();
    geometry.dirty();
    this._updateMaterial(seriesModel, itemStyle);
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      material[methodName]("fragment", "SRGB_DECODE");
    }
    if (!largeMode) {
      this._updateLabelBuilder(seriesModel, start2, end2);
    }
    this._updateHandler(seriesModel, ecModel, api);
    this._updateAnimation(seriesModel);
    this._api = api;
  },
  getPointsMesh: function() {
    return this._mesh;
  },
  updateLabels: function(highlightDataIndices) {
    this._labelsBuilder.updateLabels(highlightDataIndices);
  },
  hideLabels: function() {
    this.rootNode.remove(this._labelsBuilder.getMesh());
  },
  showLabels: function() {
    this.rootNode.add(this._labelsBuilder.getMesh());
  },
  dispose: function() {
    this._labelsBuilder.dispose();
  },
  _updateSymbolSprite: function(seriesModel, itemStyle, symbolInfo, dpr2) {
    symbolInfo.maxSize = Math.min(symbolInfo.maxSize * 2, 200);
    var symbolSize = [];
    if (symbolInfo.aspect > 1) {
      symbolSize[0] = symbolInfo.maxSize;
      symbolSize[1] = symbolInfo.maxSize / symbolInfo.aspect;
    } else {
      symbolSize[1] = symbolInfo.maxSize;
      symbolSize[0] = symbolInfo.maxSize * symbolInfo.aspect;
    }
    symbolSize[0] = symbolSize[0] || 1;
    symbolSize[1] = symbolSize[1] || 1;
    if (this._symbolType !== symbolInfo.type || !isSymbolSizeSame(this._symbolSize, symbolSize) || this._lineWidth !== itemStyle.lineWidth) {
      spriteUtil$1.createSymbolSprite(symbolInfo.type, symbolSize, {
        fill: "#fff",
        lineWidth: itemStyle.lineWidth,
        stroke: "transparent",
        shadowColor: "transparent",
        minMargin: Math.min(symbolSize[0] / 2, 10)
      }, this._spriteImageCanvas);
      spriteUtil$1.createSDFFromCanvas(this._spriteImageCanvas, Math.min(this._spriteImageCanvas.width, 32), SDF_RANGE, this._mesh.material.get("sprite").image);
      this._symbolType = symbolInfo.type;
      this._symbolSize = symbolSize;
      this._lineWidth = itemStyle.lineWidth;
    }
    return this._spriteImageCanvas.width / symbolInfo.maxSize * dpr2;
  },
  _updateMaterial: function(seriesModel, itemStyle) {
    var blendFunc = seriesModel.get("blendMode") === "lighter" ? graphicGL$1.additiveBlend : null;
    var material = this._mesh.material;
    material.blend = blendFunc;
    material.set("lineWidth", itemStyle.lineWidth / SDF_RANGE);
    var strokeColor = graphicGL$1.parseColor(itemStyle.stroke);
    material.set("strokeColor", strokeColor);
    material.transparent = true;
    material.depthMask = false;
    material.depthTest = !this.is2D;
    material.sortVertices = !this.is2D;
  },
  _updateLabelBuilder: function(seriesModel, start2, end2) {
    var data = seriesModel.getData();
    var geometry = this._mesh.geometry;
    var positionArr = geometry.attributes.position.value;
    var start2 = this._startDataIndex;
    var pointSizeScale = this._mesh.sizeScale;
    this._labelsBuilder.updateData(data, start2, end2);
    this._labelsBuilder.getLabelPosition = function(dataIndex, positionDesc, distance2) {
      var idx3 = (dataIndex - start2) * 3;
      return [positionArr[idx3], positionArr[idx3 + 1], positionArr[idx3 + 2]];
    };
    this._labelsBuilder.getLabelDistance = function(dataIndex, positionDesc, distance2) {
      var size = geometry.attributes.size.get(dataIndex - start2) / pointSizeScale;
      return size / 2 + distance2;
    };
    this._labelsBuilder.updateLabels();
  },
  _updateAnimation: function(seriesModel) {
    graphicGL$1.updateVertexAnimation([["prevPosition", "position"], ["prevSize", "size"]], this._prevMesh, this._mesh, seriesModel);
  },
  _updateHandler: function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var pointsMesh = this._mesh;
    var self2 = this;
    var lastDataIndex = -1;
    var isCartesian3D = seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian3D";
    var grid3DModel;
    if (isCartesian3D) {
      grid3DModel = seriesModel.coordinateSystem.model;
    }
    pointsMesh.seriesIndex = seriesModel.seriesIndex;
    pointsMesh.off("mousemove");
    pointsMesh.off("mouseout");
    pointsMesh.on("mousemove", function(e2) {
      var dataIndex = e2.vertexIndex + self2._startDataIndex;
      if (dataIndex !== lastDataIndex) {
        if (this.highlightOnMouseover) {
          this.downplay(data, lastDataIndex);
          this.highlight(data, dataIndex);
          this._labelsBuilder.updateLabels([dataIndex]);
        }
        if (isCartesian3D) {
          api.dispatchAction({
            type: "grid3DShowAxisPointer",
            value: [data.get(seriesModel.coordDimToDataDim("x")[0], dataIndex), data.get(seriesModel.coordDimToDataDim("y")[0], dataIndex), data.get(seriesModel.coordDimToDataDim("z")[0], dataIndex)],
            grid3DIndex: grid3DModel.componentIndex
          });
        }
      }
      pointsMesh.dataIndex = dataIndex;
      lastDataIndex = dataIndex;
    }, this);
    pointsMesh.on("mouseout", function(e2) {
      var dataIndex = e2.vertexIndex + self2._startDataIndex;
      if (this.highlightOnMouseover) {
        this.downplay(data, dataIndex);
        this._labelsBuilder.updateLabels();
      }
      lastDataIndex = -1;
      pointsMesh.dataIndex = -1;
      if (isCartesian3D) {
        api.dispatchAction({
          type: "grid3DHideAxisPointer",
          grid3DIndex: grid3DModel.componentIndex
        });
      }
    }, this);
  },
  updateLayout: function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    if (!this._mesh) {
      return;
    }
    var positionArr = this._mesh.geometry.attributes.position.value;
    var points2 = data.getLayout("points");
    if (this.is2D) {
      for (var i = 0; i < points2.length / 2; i++) {
        var i3 = i * 3;
        var i2 = i * 2;
        positionArr[i3] = points2[i2];
        positionArr[i3 + 1] = points2[i2 + 1];
        positionArr[i3 + 2] = Z_2D;
      }
    } else {
      for (var i = 0; i < points2.length; i++) {
        positionArr[i] = points2[i];
      }
    }
    this._mesh.geometry.dirty();
    api.getZr().refresh();
  },
  updateView: function(camera2) {
    if (!this._mesh) {
      return;
    }
    var worldViewProjection = new Matrix4$1();
    Matrix4$1.mul(worldViewProjection, camera2.viewMatrix, this._mesh.worldTransform);
    Matrix4$1.mul(worldViewProjection, camera2.projectionMatrix, worldViewProjection);
    this._mesh.updateNDCPosition(worldViewProjection, this.is2D, this._api);
  },
  highlight: function(data, dataIndex) {
    if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {
      return;
    }
    var itemModel = data.getItemModel(dataIndex);
    var emphasisItemStyleModel = itemModel.getModel("emphasis.itemStyle");
    var emphasisColor = emphasisItemStyleModel.get("color");
    var emphasisOpacity = emphasisItemStyleModel.get("opacity");
    if (emphasisColor == null) {
      var color = getItemVisualColor(data, dataIndex);
      emphasisColor = lift(color, -0.4);
    }
    if (emphasisOpacity == null) {
      emphasisOpacity = getItemVisualOpacity(data, dataIndex);
    }
    var colorArr = graphicGL$1.parseColor(emphasisColor);
    colorArr[3] *= emphasisOpacity;
    this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);
    this._mesh.geometry.dirtyAttribute("color");
    this._api.getZr().refresh();
  },
  downplay: function(data, dataIndex) {
    if (dataIndex > this._endDataIndex || dataIndex < this._startDataIndex) {
      return;
    }
    var color = getItemVisualColor(data, dataIndex);
    var opacity = getItemVisualOpacity(data, dataIndex);
    var colorArr = graphicGL$1.parseColor(color);
    colorArr[3] *= opacity;
    this._mesh.geometry.attributes.color.set(dataIndex - this._startDataIndex, colorArr);
    this._mesh.geometry.dirtyAttribute("color");
    this._api.getZr().refresh();
  },
  fadeOutAll: function(fadeOutPercent) {
    if (this._originalOpacity) {
      var geo = this._mesh.geometry;
      for (var i = 0; i < geo.vertexCount; i++) {
        var fadeOutOpacity = this._originalOpacity[i] * fadeOutPercent;
        geo.attributes.color.value[i * 4 + 3] = fadeOutOpacity;
      }
      geo.dirtyAttribute("color");
      this._api.getZr().refresh();
    }
  },
  fadeInAll: function() {
    this.fadeOutAll(1);
  },
  setPositionTexture: function(texture) {
    if (this._mesh) {
      this._setPositionTextureToMesh(this._mesh, texture);
    }
    this._positionTexture = texture;
  },
  removePositionTexture: function() {
    this._positionTexture = null;
    if (this._mesh) {
      this._setPositionTextureToMesh(this._mesh, null);
    }
  },
  setSizeScale: function(sizeScale) {
    if (sizeScale !== this._sizeScale) {
      if (this._mesh) {
        var originalSize = this._mesh.material.get("u_Size");
        this._mesh.material.set("u_Size", originalSize / this._sizeScale * sizeScale);
        var attributes = this._mesh.geometry.attributes;
        if (attributes.size.value) {
          for (var i = 0; i < attributes.size.value.length; i++) {
            attributes.size.value[i] = attributes.size.value[i] / this._sizeScale * sizeScale;
          }
        }
      }
      this._sizeScale = sizeScale;
    }
  },
  _setPositionTextureToMesh: function(mesh2, texture) {
    if (texture) {
      mesh2.material.set("positionTexture", texture);
    }
    mesh2.material[texture ? "enableTexture" : "disableTexture"]("positionTexture");
  },
  _getSymbolInfo: function(seriesModel, start2, end2) {
    if (seriesModel.get("large")) {
      var symbolSize = retrieve$1.firstNotNull(seriesModel.get("symbolSize"), 1);
      var maxSymbolSize;
      var symbolAspect;
      if (symbolSize instanceof Array) {
        maxSymbolSize = Math.max(symbolSize[0], symbolSize[1]);
        symbolAspect = symbolSize[0] / symbolSize[1];
      } else {
        maxSymbolSize = symbolSize;
        symbolAspect = 1;
      }
      return {
        maxSize: symbolSize,
        type: seriesModel.get("symbol"),
        aspect: symbolAspect
      };
    }
    var data = seriesModel.getData();
    var symbolAspect;
    var symbolType = data.getItemVisual(0, "symbol") || "circle";
    var maxSymbolSize = 0;
    for (var idx = start2; idx < end2; idx++) {
      var symbolSize = data.getItemVisual(idx, "symbolSize");
      var currentSymbolType = data.getItemVisual(idx, "symbol");
      var currentSymbolAspect;
      if (!(symbolSize instanceof Array)) {
        if (isNaN(symbolSize)) {
          continue;
        }
        currentSymbolAspect = 1;
        maxSymbolSize = Math.max(symbolSize, maxSymbolSize);
      } else {
        currentSymbolAspect = symbolSize[0] / symbolSize[1];
        maxSymbolSize = Math.max(Math.max(symbolSize[0], symbolSize[1]), maxSymbolSize);
      }
      symbolType = currentSymbolType;
      symbolAspect = currentSymbolAspect;
    }
    return {
      maxSize: maxSymbolSize,
      type: symbolType,
      aspect: symbolAspect
    };
  }
};
var Scatter3DView = ChartView$1.extend({
  type: "scatter3D",
  hasSymbolVisual: true,
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this._pointsBuilderList = [];
    this._currentStep = 0;
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    if (!seriesModel.getData().count()) {
      return;
    }
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      this._camera = coordSys.viewGL.camera;
      var pointsBuilder = this._pointsBuilderList[0];
      if (!pointsBuilder) {
        pointsBuilder = this._pointsBuilderList[0] = new PointsBuilder(false, api);
      }
      this._pointsBuilderList.length = 1;
      this.groupGL.add(pointsBuilder.rootNode);
      pointsBuilder.update(seriesModel, ecModel, api);
      pointsBuilder.updateView(coordSys.viewGL.camera);
    }
  },
  incrementalPrepareRender: function(seriesModel, ecModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      this._camera = coordSys.viewGL.camera;
    }
    this.groupGL.removeAll();
    this._currentStep = 0;
  },
  incrementalRender: function(params, seriesModel, ecModel, api) {
    if (params.end <= params.start) {
      return;
    }
    var pointsBuilder = this._pointsBuilderList[this._currentStep];
    if (!pointsBuilder) {
      pointsBuilder = new PointsBuilder(false, api);
      this._pointsBuilderList[this._currentStep] = pointsBuilder;
    }
    this.groupGL.add(pointsBuilder.rootNode);
    pointsBuilder.update(seriesModel, ecModel, api, params.start, params.end);
    pointsBuilder.updateView(seriesModel.coordinateSystem.viewGL.camera);
    this._currentStep++;
  },
  updateCamera: function() {
    this._pointsBuilderList.forEach(function(pointsBuilder) {
      pointsBuilder.updateView(this._camera);
    }, this);
  },
  highlight: function(seriesModel, ecModel, api, payload) {
    this._toggleStatus("highlight", seriesModel, ecModel, api, payload);
  },
  downplay: function(seriesModel, ecModel, api, payload) {
    this._toggleStatus("downplay", seriesModel, ecModel, api, payload);
  },
  _toggleStatus: function(status, seriesModel, ecModel, api, payload) {
    var data = seriesModel.getData();
    var dataIndex = retrieve$1.queryDataIndex(data, payload);
    var isHighlight = status === "highlight";
    if (dataIndex != null) {
      each$f(formatUtil$1.normalizeToArray(dataIndex), function(dataIdx) {
        for (var i = 0; i < this._pointsBuilderList.length; i++) {
          var pointsBuilder = this._pointsBuilderList[i];
          isHighlight ? pointsBuilder.highlight(data, dataIdx) : pointsBuilder.downplay(data, dataIdx);
        }
      }, this);
    } else {
      data.each(function(dataIdx) {
        for (var i = 0; i < this._pointsBuilderList.length; i++) {
          var pointsBuilder = this._pointsBuilderList[i];
          isHighlight ? pointsBuilder.highlight(data, dataIdx) : pointsBuilder.downplay(data, dataIdx);
        }
      });
    }
  },
  dispose: function() {
    this._pointsBuilderList.forEach(function(pointsBuilder) {
      pointsBuilder.dispose();
    });
    this.groupGL.removeAll();
  },
  remove: function() {
    this.groupGL.removeAll();
  }
});
function install$8(registers) {
  registers.registerChartView(Scatter3DView);
  registers.registerSeriesModel(Scatter3DSeries);
  registers.registerLayout({
    seriesType: "scatter3D",
    reset: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys) {
        var coordDims = coordSys.dimensions;
        if (coordDims.length < 3) {
          return;
        }
        var dims = coordDims.map(function(coordDim) {
          return seriesModel.coordDimToDataDim(coordDim)[0];
        });
        var item = [];
        var out2 = [];
        return {
          progress: function(params, data) {
            var points2 = new Float32Array((params.end - params.start) * 3);
            for (var idx = params.start; idx < params.end; idx++) {
              var idx3 = (idx - params.start) * 3;
              item[0] = data.get(dims[0], idx);
              item[1] = data.get(dims[1], idx);
              item[2] = data.get(dims[2], idx);
              coordSys.dataToPoint(item, out2);
              points2[idx3] = out2[0];
              points2[idx3 + 1] = out2[1];
              points2[idx3 + 2] = out2[2];
            }
            data.setLayout("points", points2);
          }
        };
      }
    }
  });
}
use(install$8);
var vec3$2 = glmatrix.vec3;
var vec2$2 = glmatrix.vec2;
var normalize$1 = vec3$2.normalize;
var cross = vec3$2.cross;
var sub = vec3$2.sub;
var add = vec3$2.add;
var create = vec3$2.create;
var normal = create();
var tangent = create();
var bitangent = create();
var halfVector = create();
var coord0 = [];
var coord1 = [];
function getCubicPointsOnGlobe(coords, coordSys) {
  vec2$2.copy(coord0, coords[0]);
  vec2$2.copy(coord1, coords[1]);
  var pts = [];
  var p02 = pts[0] = create();
  var p12 = pts[1] = create();
  var p22 = pts[2] = create();
  var p3 = pts[3] = create();
  coordSys.dataToPoint(coord0, p02);
  coordSys.dataToPoint(coord1, p3);
  normalize$1(normal, p02);
  sub(tangent, p3, p02);
  normalize$1(tangent, tangent);
  cross(bitangent, tangent, normal);
  normalize$1(bitangent, bitangent);
  cross(tangent, normal, bitangent);
  add(p12, normal, tangent);
  normalize$1(p12, p12);
  normalize$1(normal, p3);
  sub(tangent, p02, p3);
  normalize$1(tangent, tangent);
  cross(bitangent, tangent, normal);
  normalize$1(bitangent, bitangent);
  cross(tangent, normal, bitangent);
  add(p22, normal, tangent);
  normalize$1(p22, p22);
  add(halfVector, p02, p3);
  normalize$1(halfVector, halfVector);
  var projDist = vec3$2.dot(p02, halfVector);
  var cosTheta = vec3$2.dot(halfVector, p12);
  var len2 = (Math.max(vec3$2.len(p02), vec3$2.len(p3)) - projDist) / cosTheta * 2;
  vec3$2.scaleAndAdd(p12, p02, p12, len2);
  vec3$2.scaleAndAdd(p22, p3, p22, len2);
  return pts;
}
function getCubicPointsOnPlane(coords, coordSys, up) {
  var pts = [];
  var p02 = pts[0] = vec3$2.create();
  var p12 = pts[1] = vec3$2.create();
  var p22 = pts[2] = vec3$2.create();
  var p3 = pts[3] = vec3$2.create();
  coordSys.dataToPoint(coords[0], p02);
  coordSys.dataToPoint(coords[1], p3);
  var len2 = vec3$2.dist(p02, p3);
  vec3$2.lerp(p12, p02, p3, 0.3);
  vec3$2.lerp(p22, p02, p3, 0.3);
  vec3$2.scaleAndAdd(p12, p12, up, Math.min(len2 * 0.1, 10));
  vec3$2.scaleAndAdd(p22, p22, up, Math.min(len2 * 0.1, 10));
  return pts;
}
function getPolylinePoints(coords, coordSys) {
  var pts = new Float32Array(coords.length * 3);
  var off = 0;
  var pt = [];
  for (var i = 0; i < coords.length; i++) {
    coordSys.dataToPoint(coords[i], pt);
    pts[off++] = pt[0];
    pts[off++] = pt[1];
    pts[off++] = pt[2];
  }
  return pts;
}
function prepareCoords(data) {
  var coordsList = [];
  data.each(function(idx) {
    var itemModel = data.getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords", true);
    coordsList.push(coords);
  });
  return {
    coordsList
  };
}
function layoutGlobe(seriesModel, coordSys) {
  var data = seriesModel.getData();
  var isPolyline = seriesModel.get("polyline");
  data.setLayout("lineType", isPolyline ? "polyline" : "cubicBezier");
  var res = prepareCoords(data);
  data.each(function(idx) {
    var coords = res.coordsList[idx];
    var getPointsMethod = isPolyline ? getPolylinePoints : getCubicPointsOnGlobe;
    data.setItemLayout(idx, getPointsMethod(coords, coordSys));
  });
}
function layoutOnPlane(seriesModel, coordSys, normal2) {
  var data = seriesModel.getData();
  var isPolyline = seriesModel.get("polyline");
  var res = prepareCoords(data);
  data.setLayout("lineType", isPolyline ? "polyline" : "cubicBezier");
  data.each(function(idx) {
    var coords = res.coordsList[idx];
    var pts = isPolyline ? getPolylinePoints(coords, coordSys) : getCubicPointsOnPlane(coords, coordSys, normal2);
    data.setItemLayout(idx, pts);
  });
}
function lines3DLayout(ecModel, api) {
  ecModel.eachSeriesByType("lines3D", function(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys.type === "globe") {
      layoutGlobe(seriesModel, coordSys);
    } else if (coordSys.type === "geo3D") {
      layoutOnPlane(seriesModel, coordSys, [0, 1, 0]);
    } else if (coordSys.type === "mapbox3D" || coordSys.type === "maptalks3D") {
      layoutOnPlane(seriesModel, coordSys, [0, 0, 1]);
    }
  });
}
var Lines3DSeries = SeriesModel$1.extend({
  type: "series.lines3D",
  dependencies: ["globe"],
  visualStyleAccessPath: "lineStyle",
  visualDrawType: "stroke",
  getInitialData: function(option, ecModel) {
    var lineData = new SeriesData$1(["value"], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        var value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  },
  defaultOption: {
    coordinateSystem: "globe",
    globeIndex: 0,
    geo3DIndex: 0,
    zlevel: -10,
    polyline: false,
    effect: {
      show: false,
      period: 4,
      trailWidth: 4,
      trailLength: 0.2,
      spotIntensity: 6
    },
    silent: true,
    blendMode: "source-over",
    lineStyle: {
      width: 1,
      opacity: 0.5
    }
  }
});
var trail2GLSL = "@export ecgl.trail2.vertex\nattribute vec3 position: POSITION;\nattribute vec3 positionPrev;\nattribute vec3 positionNext;\nattribute float offset;\nattribute float dist;\nattribute float distAll;\nattribute float start;\n\nattribute vec4 a_Color : COLOR;\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\nuniform float near : NEAR;\n\nuniform float speed : 0;\nuniform float trailLength: 0.3;\nuniform float time;\nuniform float period: 1000;\n\nuniform float spotSize: 1;\n\nvarying vec4 v_Color;\nvarying float v_Percent;\nvarying float v_SpotPercent;\n\n@import ecgl.common.wireframe.vertexHeader\n\n@import ecgl.lines3D.clipNear\n\nvoid main()\n{\n @import ecgl.lines3D.expandLine\n\n gl_Position = currProj;\n\n v_Color = a_Color;\n\n @import ecgl.common.wireframe.vertexMain\n\n#ifdef CONSTANT_SPEED\n float t = mod((speed * time + start) / distAll, 1. + trailLength) - trailLength;\n#else\n float t = mod((time + start) / period, 1. + trailLength) - trailLength;\n#endif\n\n float trailLen = distAll * trailLength;\n\n v_Percent = (dist - t * distAll) / trailLen;\n\n v_SpotPercent = spotSize / distAll;\n\n }\n@end\n\n\n@export ecgl.trail2.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform float spotIntensity: 5;\n\nvarying vec4 v_Color;\nvarying float v_Percent;\nvarying float v_SpotPercent;\n\n@import ecgl.common.wireframe.fragmentHeader\n\n@import clay.util.srgb\n\nvoid main()\n{\n if (v_Percent > 1.0 || v_Percent < 0.0) {\n discard;\n }\n\n float fade = v_Percent;\n\n#ifdef SRGB_DECODE\n gl_FragColor = sRGBToLinear(color * v_Color);\n#else\n gl_FragColor = color * v_Color;\n#endif\n\n @import ecgl.common.wireframe.fragmentMain\n\n if (v_Percent > (1.0 - v_SpotPercent)) {\n gl_FragColor.rgb *= spotIntensity;\n }\n\n gl_FragColor.a *= fade;\n}\n\n@end";
var vec3$1 = glmatrix.vec3;
function sign(a) {
  return a > 0 ? 1 : -1;
}
graphicGL$1.Shader.import(trail2GLSL);
var TrailMesh2 = graphicGL$1.Mesh.extend(function() {
  var material = new graphicGL$1.Material({
    shader: new graphicGL$1.Shader(graphicGL$1.Shader.source("ecgl.trail2.vertex"), graphicGL$1.Shader.source("ecgl.trail2.fragment")),
    transparent: true,
    depthMask: false
  });
  var geometry = new LinesGeometry$3({
    dynamic: true
  });
  geometry.createAttribute("dist", "float", 1);
  geometry.createAttribute("distAll", "float", 1);
  geometry.createAttribute("start", "float", 1);
  return {
    geometry,
    material,
    culling: false,
    $ignorePicking: true
  };
}, {
  updateData: function(data, api, lines3DGeometry) {
    var seriesModel = data.hostModel;
    var geometry = this.geometry;
    var effectModel = seriesModel.getModel("effect");
    var size = effectModel.get("trailWidth") * api.getDevicePixelRatio();
    var trailLength = effectModel.get("trailLength");
    var speed = seriesModel.get("effect.constantSpeed");
    var period = seriesModel.get("effect.period") * 1e3;
    var useConstantSpeed = speed != null;
    useConstantSpeed ? this.material.set("speed", speed / 1e3) : this.material.set("period", period);
    this.material[useConstantSpeed ? "define" : "undefine"]("vertex", "CONSTANT_SPEED");
    var isPolyline = seriesModel.get("polyline");
    geometry.trailLength = trailLength;
    this.material.set("trailLength", trailLength);
    geometry.resetOffset();
    ["position", "positionPrev", "positionNext"].forEach(function(attrName) {
      geometry.attributes[attrName].value = lines3DGeometry.attributes[attrName].value;
    });
    var extraAttrs = ["dist", "distAll", "start", "offset", "color"];
    extraAttrs.forEach(function(attrName) {
      geometry.attributes[attrName].init(geometry.vertexCount);
    });
    geometry.indices = lines3DGeometry.indices;
    var colorArr = [];
    var effectColor = effectModel.get("trailColor");
    var effectOpacity = effectModel.get("trailOpacity");
    var hasEffectColor = effectColor != null;
    var hasEffectOpacity = effectOpacity != null;
    this.updateWorldTransform();
    var xScale = this.worldTransform.x.len();
    var yScale = this.worldTransform.y.len();
    var zScale = this.worldTransform.z.len();
    var vertexOffset = 0;
    var maxDistance = 0;
    data.each(function(idx) {
      var pts = data.getItemLayout(idx);
      var opacity = hasEffectOpacity ? effectOpacity : getItemVisualOpacity(data, idx);
      var color = getItemVisualColor(data, idx);
      if (opacity == null) {
        opacity = 1;
      }
      colorArr = graphicGL$1.parseColor(hasEffectColor ? effectColor : color, colorArr);
      colorArr[3] *= opacity;
      var vertexCount = isPolyline ? lines3DGeometry.getPolylineVertexCount(pts) : lines3DGeometry.getCubicCurveVertexCount(pts[0], pts[1], pts[2], pts[3]);
      var dist2 = 0;
      var pos = [];
      var posPrev = [];
      for (var i = vertexOffset; i < vertexOffset + vertexCount; i++) {
        geometry.attributes.position.get(i, pos);
        pos[0] *= xScale;
        pos[1] *= yScale;
        pos[2] *= zScale;
        if (i > vertexOffset) {
          dist2 += vec3$1.dist(pos, posPrev);
        }
        geometry.attributes.dist.set(i, dist2);
        vec3$1.copy(posPrev, pos);
      }
      maxDistance = Math.max(maxDistance, dist2);
      var randomStart = Math.random() * (useConstantSpeed ? dist2 : period);
      for (var i = vertexOffset; i < vertexOffset + vertexCount; i++) {
        geometry.attributes.distAll.set(i, dist2);
        geometry.attributes.start.set(i, randomStart);
        geometry.attributes.offset.set(i, sign(lines3DGeometry.attributes.offset.get(i)) * size / 2);
        geometry.attributes.color.set(i, colorArr);
      }
      vertexOffset += vertexCount;
    });
    this.material.set("spotSize", maxDistance * 0.1 * trailLength);
    this.material.set("spotIntensity", effectModel.get("spotIntensity"));
    geometry.dirty();
  },
  setAnimationTime: function(time) {
    this.material.set("time", time);
  }
});
graphicGL$1.Shader.import(lines3DGLSL);
function getCoordSysSize(coordSys) {
  if (coordSys.radius != null) {
    return coordSys.radius;
  }
  if (coordSys.size != null) {
    return Math.max(coordSys.size[0], coordSys.size[1], coordSys.size[2]);
  } else {
    return 100;
  }
}
var Lines3DView = ChartView$1.extend({
  type: "lines3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this._meshLinesMaterial = new graphicGL$1.Material({
      shader: graphicGL$1.createShader("ecgl.meshLines3D"),
      transparent: true,
      depthMask: false
    });
    this._linesMesh = new graphicGL$1.Mesh({
      geometry: new LinesGeometry$3(),
      material: this._meshLinesMaterial,
      $ignorePicking: true
    });
    this._trailMesh = new TrailMesh2();
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.add(this._linesMesh);
    var coordSys = seriesModel.coordinateSystem;
    var data = seriesModel.getData();
    if (coordSys && coordSys.viewGL) {
      var viewGL = coordSys.viewGL;
      viewGL.add(this.groupGL);
      this._updateLines(seriesModel, ecModel, api);
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      this._linesMesh.material[methodName]("fragment", "SRGB_DECODE");
      this._trailMesh.material[methodName]("fragment", "SRGB_DECODE");
    }
    var trailMesh = this._trailMesh;
    trailMesh.stopAnimation();
    if (seriesModel.get("effect.show")) {
      this.groupGL.add(trailMesh);
      trailMesh.updateData(data, api, this._linesMesh.geometry);
      trailMesh.__time = trailMesh.__time || 0;
      var time = 3600 * 1e3;
      this._curveEffectsAnimator = trailMesh.animate("", {
        loop: true
      }).when(time, {
        __time: time
      }).during(function() {
        trailMesh.setAnimationTime(trailMesh.__time);
      }).start();
    } else {
      this.groupGL.remove(trailMesh);
      this._curveEffectsAnimator = null;
    }
    this._linesMesh.material.blend = this._trailMesh.material.blend = seriesModel.get("blendMode") === "lighter" ? graphicGL$1.additiveBlend : null;
  },
  pauseEffect: function() {
    if (this._curveEffectsAnimator) {
      this._curveEffectsAnimator.pause();
    }
  },
  resumeEffect: function() {
    if (this._curveEffectsAnimator) {
      this._curveEffectsAnimator.resume();
    }
  },
  toggleEffect: function() {
    var animator = this._curveEffectsAnimator;
    if (animator) {
      animator.isPaused() ? animator.resume() : animator.pause();
    }
  },
  _updateLines: function(seriesModel, ecModel, api) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    var geometry = this._linesMesh.geometry;
    var isPolyline = seriesModel.get("polyline");
    geometry.expandLine = true;
    var size = getCoordSysSize(coordSys);
    geometry.segmentScale = size / 20;
    var lineWidthQueryPath = "lineStyle.width".split(".");
    var dpr2 = api.getDevicePixelRatio();
    data.each(function(idx) {
      var itemModel = data.getItemModel(idx);
      var lineWidth = itemModel.get(lineWidthQueryPath);
      if (lineWidth == null) {
        lineWidth = 1;
      }
      data.setItemVisual(idx, "lineWidth", lineWidth);
    });
    geometry.useNativeLine = false;
    var nVertex = 0;
    var nTriangle = 0;
    data.each(function(idx) {
      var pts = data.getItemLayout(idx);
      if (isPolyline) {
        nVertex += geometry.getPolylineVertexCount(pts);
        nTriangle += geometry.getPolylineTriangleCount(pts);
      } else {
        nVertex += geometry.getCubicCurveVertexCount(pts[0], pts[1], pts[2], pts[3]);
        nTriangle += geometry.getCubicCurveTriangleCount(pts[0], pts[1], pts[2], pts[3]);
      }
    });
    geometry.setVertexCount(nVertex);
    geometry.setTriangleCount(nTriangle);
    geometry.resetOffset();
    var colorArr = [];
    data.each(function(idx) {
      var pts = data.getItemLayout(idx);
      var color = getItemVisualColor(data, idx);
      var opacity = getItemVisualOpacity(data, idx);
      var lineWidth = data.getItemVisual(idx, "lineWidth") * dpr2;
      if (opacity == null) {
        opacity = 1;
      }
      colorArr = graphicGL$1.parseColor(color, colorArr);
      colorArr[3] *= opacity;
      if (isPolyline) {
        geometry.addPolyline(pts, colorArr, lineWidth);
      } else {
        geometry.addCubicCurve(pts[0], pts[1], pts[2], pts[3], colorArr, lineWidth);
      }
    });
    geometry.dirty();
  },
  remove: function() {
    this.groupGL.removeAll();
  },
  dispose: function() {
    this.groupGL.removeAll();
  }
});
function install$7(registers) {
  registers.registerChartView(Lines3DView);
  registers.registerSeriesModel(Lines3DSeries);
  registers.registerLayout(lines3DLayout);
  registers.registerAction({
    type: "lines3DPauseEffect",
    event: "lines3deffectpaused",
    update: "series.lines3D:pauseEffect"
  }, function() {
  });
  registers.registerAction({
    type: "lines3DResumeEffect",
    event: "lines3deffectresumed",
    update: "series.lines3D:resumeEffect"
  }, function() {
  });
  registers.registerAction({
    type: "lines3DToggleEffect",
    event: "lines3deffectchanged",
    update: "series.lines3D:toggleEffect"
  }, function() {
  });
}
use(install$7);
function transformPolygon$1(coordSys, poly) {
  var ret2 = [];
  for (var i = 0; i < poly.length; i++) {
    ret2.push(coordSys.dataToPoint(poly[i]));
  }
  return ret2;
}
var Polygons3DSeries = SeriesModel$1.extend({
  type: "series.polygons3D",
  getRegionModel: function(idx) {
    return this.getData().getItemModel(idx);
  },
  getRegionPolygonCoords: function(idx) {
    var coordSys = this.coordinateSystem;
    var itemModel = this.getData().getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
    if (!itemModel.get("multiPolygon")) {
      coords = [coords];
    }
    var out2 = [];
    for (var i = 0; i < coords.length; i++) {
      var interiors = [];
      for (var k = 1; k < coords[i].length; k++) {
        interiors.push(transformPolygon$1(coordSys, coords[i][k]));
      }
      out2.push({
        exterior: transformPolygon$1(coordSys, coords[i][0]),
        interiors
      });
    }
    return out2;
  },
  getInitialData: function(option) {
    var polygonsData = new SeriesData$1(["value"], this);
    polygonsData.hasItemOption = false;
    polygonsData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        polygonsData.hasItemOption = true;
        var value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return polygonsData;
  },
  defaultOption: {
    show: true,
    data: null,
    multiPolygon: false,
    progressiveThreshold: 1e3,
    progressive: 1e3,
    zlevel: -10,
    label: {
      show: false,
      distance: 2,
      textStyle: {
        fontSize: 20,
        color: "#000",
        backgroundColor: "rgba(255,255,255,0.7)",
        padding: 3,
        borderRadius: 4
      }
    },
    itemStyle: {
      color: "#fff",
      borderWidth: 0,
      borderColor: "#333"
    },
    emphasis: {
      itemStyle: {
        color: "#639fc0"
      },
      label: {
        show: true
      }
    }
  }
});
merge(Polygons3DSeries.prototype, componentShadingMixin);
var Polygons3DSeries$1 = Polygons3DSeries;
var Polygons3DView = ChartView$1.extend({
  type: "polygons3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this._geo3DBuilderList = [];
    this._currentStep = 0;
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
    }
    var geo3DBuilder = this._geo3DBuilderList[0];
    if (!geo3DBuilder) {
      geo3DBuilder = new Geo3DBuilder(api);
      geo3DBuilder.extrudeY = coordSys.type !== "mapbox3D" && coordSys.type !== "maptalks3D";
      this._geo3DBuilderList[0] = geo3DBuilder;
    }
    this._updateShaderDefines(coordSys, geo3DBuilder);
    geo3DBuilder.update(seriesModel, ecModel, api);
    this._geo3DBuilderList.length = 1;
    this.groupGL.add(geo3DBuilder.rootNode);
  },
  incrementalPrepareRender: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
    }
    this._currentStep = 0;
  },
  incrementalRender: function(params, seriesModel, ecModel, api) {
    var geo3DBuilder = this._geo3DBuilderList[this._currentStep];
    var coordSys = seriesModel.coordinateSystem;
    if (!geo3DBuilder) {
      geo3DBuilder = new Geo3DBuilder(api);
      geo3DBuilder.extrudeY = coordSys.type !== "mapbox3D" && coordSys.type !== "maptalks3D";
      this._geo3DBuilderList[this._currentStep] = geo3DBuilder;
    }
    geo3DBuilder.update(seriesModel, ecModel, api, params.start, params.end);
    this.groupGL.add(geo3DBuilder.rootNode);
    this._updateShaderDefines(coordSys, geo3DBuilder);
    this._currentStep++;
  },
  _updateShaderDefines: function(coordSys, geo3DBuilder) {
    var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
    geo3DBuilder.rootNode.traverse(function(mesh2) {
      if (mesh2.material) {
        mesh2.material[methodName]("fragment", "SRGB_DECODE");
        if (coordSys.type === "mapbox3D" || coordSys.type === "maptalks3D") {
          mesh2.material.define("fragment", "NORMAL_UP_AXIS", 2);
          mesh2.material.define("fragment", "NORMAL_FRONT_AXIS", 1);
        }
      }
    });
  },
  remove: function() {
    this.groupGL.removeAll();
  },
  dispose: function() {
    this.groupGL.removeAll();
    this._geo3DBuilderList.forEach(function(geo3DBuilder) {
      geo3DBuilder.dispose();
    });
  }
});
function install$6(registers) {
  registers.registerChartView(Polygons3DView);
  registers.registerSeriesModel(Polygons3DSeries$1);
}
use(install$6);
var SurfaceSeries = SeriesModel$1.extend({
  type: "series.surface",
  dependencies: ["globe", "grid3D", "geo3D"],
  visualStyleAccessPath: "itemStyle",
  formatTooltip: function(dataIndex) {
    return formatTooltip(this, dataIndex);
  },
  getInitialData: function(option, ecModel) {
    var data = option.data;
    function validateDimension(dimOpts) {
      return !(isNaN(dimOpts.min) || isNaN(dimOpts.max) || isNaN(dimOpts.step));
    }
    function getPrecision2(dimOpts) {
      var getPrecision3 = getPrecisionSafe;
      return Math.max(getPrecision3(dimOpts.min), getPrecision3(dimOpts.max), getPrecision3(dimOpts.step)) + 1;
    }
    if (!data) {
      if (!option.parametric) {
        var equation = option.equation || {};
        var xOpts = equation.x || {};
        var yOpts = equation.y || {};
        ["x", "y"].forEach(function(dim) {
          if (!validateDimension(equation[dim])) {
            return;
          }
        });
        if (typeof equation.z !== "function") {
          return;
        }
        var xCount = Math.floor((xOpts.max + xOpts.step - xOpts.min) / xOpts.step);
        var yCount = Math.floor((yOpts.max + yOpts.step - yOpts.min) / yOpts.step);
        data = new Float32Array(xCount * yCount * 3);
        var xPrecision = getPrecision2(xOpts);
        var yPrecision = getPrecision2(yOpts);
        var off = 0;
        for (var j = 0; j < yCount; j++) {
          for (var i = 0; i < xCount; i++) {
            var x = i * xOpts.step + xOpts.min;
            var y = j * yOpts.step + yOpts.min;
            var x2 = round$3(Math.min(x, xOpts.max), xPrecision);
            var y2 = round$3(Math.min(y, yOpts.max), yPrecision);
            var z = equation.z(x2, y2);
            data[off++] = x2;
            data[off++] = y2;
            data[off++] = z;
          }
        }
      } else {
        var parametricEquation = option.parametricEquation || {};
        var uOpts = parametricEquation.u || {};
        var vOpts = parametricEquation.v || {};
        ["u", "v"].forEach(function(dim) {
          if (!validateDimension(parametricEquation[dim])) {
            return;
          }
        });
        ["x", "y", "z"].forEach(function(dim) {
          if (typeof parametricEquation[dim] !== "function") {
            return;
          }
        });
        var uCount = Math.floor((uOpts.max + uOpts.step - uOpts.min) / uOpts.step);
        var vCount = Math.floor((vOpts.max + vOpts.step - vOpts.min) / vOpts.step);
        data = new Float32Array(uCount * vCount * 5);
        var uPrecision = getPrecision2(uOpts);
        var vPrecision = getPrecision2(vOpts);
        var off = 0;
        for (var j = 0; j < vCount; j++) {
          for (var i = 0; i < uCount; i++) {
            var u = i * uOpts.step + uOpts.min;
            var v = j * vOpts.step + vOpts.min;
            var u2 = round$3(Math.min(u, uOpts.max), uPrecision);
            var v22 = round$3(Math.min(v, vOpts.max), vPrecision);
            var x = parametricEquation.x(u2, v22);
            var y = parametricEquation.y(u2, v22);
            var z = parametricEquation.z(u2, v22);
            data[off++] = x;
            data[off++] = y;
            data[off++] = z;
            data[off++] = u2;
            data[off++] = v22;
          }
        }
      }
    }
    var dims = ["x", "y", "z"];
    if (option.parametric) {
      dims.push("u", "v");
    }
    var list = createList(this, dims, data);
    return list;
  },
  defaultOption: {
    coordinateSystem: "cartesian3D",
    zlevel: -10,
    grid3DIndex: 0,
    shading: "lambert",
    parametric: false,
    wireframe: {
      show: true,
      lineStyle: {
        color: "rgba(0,0,0,0.5)",
        width: 1
      }
    },
    equation: {
      x: {
        min: -1,
        max: 1,
        step: 0.1
      },
      y: {
        min: -1,
        max: 1,
        step: 0.1
      },
      z: null
    },
    parametricEquation: {
      u: {
        min: -1,
        max: 1,
        step: 0.1
      },
      v: {
        min: -1,
        max: 1,
        step: 0.1
      },
      x: null,
      y: null,
      z: null
    },
    dataShape: null,
    itemStyle: {},
    animationDurationUpdate: 500
  }
});
merge(SurfaceSeries.prototype, componentShadingMixin);
var SurfaceSeries$1 = SurfaceSeries;
var vec3 = glmatrix.vec3;
function isPointsNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]) || isNaN(pt[2]);
}
var SurfaceView = ChartView$1.extend({
  type: "surface",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
  },
  render: function(seriesModel, ecModel, api) {
    var tmp = this._prevSurfaceMesh;
    this._prevSurfaceMesh = this._surfaceMesh;
    this._surfaceMesh = tmp;
    if (!this._surfaceMesh) {
      this._surfaceMesh = this._createSurfaceMesh();
    }
    this.groupGL.remove(this._prevSurfaceMesh);
    this.groupGL.add(this._surfaceMesh);
    var coordSys = seriesModel.coordinateSystem;
    var shading = seriesModel.get("shading");
    var data = seriesModel.getData();
    var shadingPrefix = "ecgl." + shading;
    if (!this._surfaceMesh.material || this._surfaceMesh.material.shader.name !== shadingPrefix) {
      this._surfaceMesh.material = graphicGL$1.createMaterial(shadingPrefix, ["VERTEX_COLOR", "DOUBLE_SIDED"]);
    }
    graphicGL$1.setMaterialFromModel(shading, this._surfaceMesh.material, seriesModel, api);
    if (coordSys && coordSys.viewGL) {
      coordSys.viewGL.add(this.groupGL);
      var methodName = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
      this._surfaceMesh.material[methodName]("fragment", "SRGB_DECODE");
    }
    var isParametric = seriesModel.get("parametric");
    var dataShape = seriesModel.get("dataShape");
    if (!dataShape) {
      dataShape = this._getDataShape(data, isParametric);
    }
    var wireframeModel = seriesModel.getModel("wireframe");
    var wireframeLineWidth = wireframeModel.get("lineStyle.width");
    var showWireframe = wireframeModel.get("show") && wireframeLineWidth > 0;
    this._updateSurfaceMesh(this._surfaceMesh, seriesModel, dataShape, showWireframe);
    var material = this._surfaceMesh.material;
    if (showWireframe) {
      material.define("WIREFRAME_QUAD");
      material.set("wireframeLineWidth", wireframeLineWidth);
      material.set("wireframeLineColor", graphicGL$1.parseColor(wireframeModel.get("lineStyle.color")));
    } else {
      material.undefine("WIREFRAME_QUAD");
    }
    this._initHandler(seriesModel, api);
    this._updateAnimation(seriesModel);
  },
  _updateAnimation: function(seriesModel) {
    graphicGL$1.updateVertexAnimation([["prevPosition", "position"], ["prevNormal", "normal"]], this._prevSurfaceMesh, this._surfaceMesh, seriesModel);
  },
  _createSurfaceMesh: function() {
    var mesh2 = new graphicGL$1.Mesh({
      geometry: new graphicGL$1.Geometry({
        dynamic: true,
        sortTriangles: true
      }),
      shadowDepthMaterial: new graphicGL$1.Material({
        shader: new graphicGL$1.Shader(graphicGL$1.Shader.source("ecgl.sm.depth.vertex"), graphicGL$1.Shader.source("ecgl.sm.depth.fragment"))
      }),
      culling: false,
      renderOrder: 10,
      renderNormal: true
    });
    mesh2.geometry.createAttribute("barycentric", "float", 4);
    mesh2.geometry.createAttribute("prevPosition", "float", 3);
    mesh2.geometry.createAttribute("prevNormal", "float", 3);
    Object.assign(mesh2.geometry, trianglesSortMixin);
    return mesh2;
  },
  _initHandler: function(seriesModel, api) {
    var data = seriesModel.getData();
    var surfaceMesh = this._surfaceMesh;
    var coordSys = seriesModel.coordinateSystem;
    function getNearestPointIdx(triangle, point) {
      var nearestDist = Infinity;
      var nearestIdx = -1;
      var pos = [];
      for (var i = 0; i < triangle.length; i++) {
        surfaceMesh.geometry.attributes.position.get(triangle[i], pos);
        var dist2 = vec3.dist(point.array, pos);
        if (dist2 < nearestDist) {
          nearestDist = dist2;
          nearestIdx = triangle[i];
        }
      }
      return nearestIdx;
    }
    surfaceMesh.seriesIndex = seriesModel.seriesIndex;
    var lastDataIndex = -1;
    surfaceMesh.off("mousemove");
    surfaceMesh.off("mouseout");
    surfaceMesh.on("mousemove", function(e2) {
      var idx = getNearestPointIdx(e2.triangle, e2.point);
      if (idx >= 0) {
        var point = [];
        surfaceMesh.geometry.attributes.position.get(idx, point);
        var value = coordSys.pointToData(point);
        var minDist = Infinity;
        var dataIndex = -1;
        var item = [];
        for (var i = 0; i < data.count(); i++) {
          item[0] = data.get("x", i);
          item[1] = data.get("y", i);
          item[2] = data.get("z", i);
          var dist2 = vec3.squaredDistance(item, value);
          if (dist2 < minDist) {
            dataIndex = i;
            minDist = dist2;
          }
        }
        if (dataIndex !== lastDataIndex) {
          api.dispatchAction({
            type: "grid3DShowAxisPointer",
            value
          });
        }
        lastDataIndex = dataIndex;
        surfaceMesh.dataIndex = dataIndex;
      } else {
        surfaceMesh.dataIndex = -1;
      }
    }, this);
    surfaceMesh.on("mouseout", function(e2) {
      lastDataIndex = -1;
      surfaceMesh.dataIndex = -1;
      api.dispatchAction({
        type: "grid3DHideAxisPointer"
      });
    }, this);
  },
  _updateSurfaceMesh: function(surfaceMesh, seriesModel, dataShape, showWireframe) {
    var geometry = surfaceMesh.geometry;
    var data = seriesModel.getData();
    var pointsArr = data.getLayout("points");
    var invalidDataCount = 0;
    data.each(function(idx2) {
      if (!data.hasValue(idx2)) {
        invalidDataCount++;
      }
    });
    var needsSplitQuad = invalidDataCount || showWireframe;
    var positionAttr = geometry.attributes.position;
    var normalAttr = geometry.attributes.normal;
    var texcoordAttr = geometry.attributes.texcoord0;
    var barycentricAttr = geometry.attributes.barycentric;
    var colorAttr = geometry.attributes.color;
    var row = dataShape[0];
    var column = dataShape[1];
    var shading = seriesModel.get("shading");
    var needsNormal = shading !== "color";
    if (needsSplitQuad) {
      var vertexCount = (row - 1) * (column - 1) * 4;
      positionAttr.init(vertexCount);
      if (showWireframe) {
        barycentricAttr.init(vertexCount);
      }
    } else {
      positionAttr.value = new Float32Array(pointsArr);
    }
    colorAttr.init(geometry.vertexCount);
    texcoordAttr.init(geometry.vertexCount);
    var quadToTriangle = [0, 3, 1, 1, 3, 2];
    var quadBarycentric = [[1, 1, 0, 0], [0, 1, 0, 1], [1, 0, 0, 1], [1, 0, 1, 0]];
    var indices = geometry.indices = new (geometry.vertexCount > 65535 ? Uint32Array : Uint16Array)((row - 1) * (column - 1) * 6);
    var getQuadIndices = function(i2, j2, out2) {
      out2[1] = i2 * column + j2;
      out2[0] = i2 * column + j2 + 1;
      out2[3] = (i2 + 1) * column + j2 + 1;
      out2[2] = (i2 + 1) * column + j2;
    };
    var isTransparent = false;
    if (needsSplitQuad) {
      var quadIndices = [];
      var pos = [];
      var faceOffset = 0;
      if (needsNormal) {
        normalAttr.init(geometry.vertexCount);
      } else {
        normalAttr.value = null;
      }
      var pts = [[], [], []];
      var v21 = [], v32 = [];
      var normal2 = vec3.create();
      var getFromArray = function(arr, idx2, out2) {
        var idx32 = idx2 * 3;
        out2[0] = arr[idx32];
        out2[1] = arr[idx32 + 1];
        out2[2] = arr[idx32 + 2];
        return out2;
      };
      var vertexNormals = new Float32Array(pointsArr.length);
      var vertexColors = new Float32Array(pointsArr.length / 3 * 4);
      for (var i = 0; i < data.count(); i++) {
        if (data.hasValue(i)) {
          var rgbaArr = graphicGL$1.parseColor(getItemVisualColor(data, i));
          var opacity = getItemVisualOpacity(data, i);
          opacity != null && (rgbaArr[3] *= opacity);
          if (rgbaArr[3] < 0.99) {
            isTransparent = true;
          }
          for (var k = 0; k < 4; k++) {
            vertexColors[i * 4 + k] = rgbaArr[k];
          }
        }
      }
      var farPoints = [1e7, 1e7, 1e7];
      for (var i = 0; i < row - 1; i++) {
        for (var j = 0; j < column - 1; j++) {
          var dataIndex = i * (column - 1) + j;
          var vertexOffset = dataIndex * 4;
          getQuadIndices(i, j, quadIndices);
          var invisibleQuad = false;
          for (var k = 0; k < 4; k++) {
            getFromArray(pointsArr, quadIndices[k], pos);
            if (isPointsNaN(pos)) {
              invisibleQuad = true;
            }
          }
          for (var k = 0; k < 4; k++) {
            if (invisibleQuad) {
              positionAttr.set(vertexOffset + k, farPoints);
            } else {
              getFromArray(pointsArr, quadIndices[k], pos);
              positionAttr.set(vertexOffset + k, pos);
            }
            if (showWireframe) {
              barycentricAttr.set(vertexOffset + k, quadBarycentric[k]);
            }
          }
          for (var k = 0; k < 6; k++) {
            indices[faceOffset++] = quadToTriangle[k] + vertexOffset;
          }
          if (needsNormal && !invisibleQuad) {
            for (var k = 0; k < 2; k++) {
              var k3 = k * 3;
              for (var m2 = 0; m2 < 3; m2++) {
                var idx = quadIndices[quadToTriangle[k3] + m2];
                getFromArray(pointsArr, idx, pts[m2]);
              }
              vec3.sub(v21, pts[0], pts[1]);
              vec3.sub(v32, pts[1], pts[2]);
              vec3.cross(normal2, v21, v32);
              for (var m2 = 0; m2 < 3; m2++) {
                var idx3 = quadIndices[quadToTriangle[k3] + m2] * 3;
                vertexNormals[idx3] = vertexNormals[idx3] + normal2[0];
                vertexNormals[idx3 + 1] = vertexNormals[idx3 + 1] + normal2[1];
                vertexNormals[idx3 + 2] = vertexNormals[idx3 + 2] + normal2[2];
              }
            }
          }
        }
      }
      if (needsNormal) {
        for (var i = 0; i < vertexNormals.length / 3; i++) {
          getFromArray(vertexNormals, i, normal2);
          vec3.normalize(normal2, normal2);
          vertexNormals[i * 3] = normal2[0];
          vertexNormals[i * 3 + 1] = normal2[1];
          vertexNormals[i * 3 + 2] = normal2[2];
        }
      }
      var rgbaArr = [];
      var uvArr = [];
      for (var i = 0; i < row - 1; i++) {
        for (var j = 0; j < column - 1; j++) {
          var dataIndex = i * (column - 1) + j;
          var vertexOffset = dataIndex * 4;
          getQuadIndices(i, j, quadIndices);
          for (var k = 0; k < 4; k++) {
            for (var m2 = 0; m2 < 4; m2++) {
              rgbaArr[m2] = vertexColors[quadIndices[k] * 4 + m2];
            }
            colorAttr.set(vertexOffset + k, rgbaArr);
            if (needsNormal) {
              getFromArray(vertexNormals, quadIndices[k], normal2);
              normalAttr.set(vertexOffset + k, normal2);
            }
            var idx = quadIndices[k];
            uvArr[0] = idx % column / (column - 1);
            uvArr[1] = Math.floor(idx / column) / (row - 1);
            texcoordAttr.set(vertexOffset + k, uvArr);
          }
          dataIndex++;
        }
      }
    } else {
      var uvArr = [];
      for (var i = 0; i < data.count(); i++) {
        uvArr[0] = i % column / (column - 1);
        uvArr[1] = Math.floor(i / column) / (row - 1);
        var rgbaArr = graphicGL$1.parseColor(getItemVisualColor(data, i));
        var opacity = getItemVisualOpacity(data, i);
        opacity != null && (rgbaArr[3] *= opacity);
        if (rgbaArr[3] < 0.99) {
          isTransparent = true;
        }
        colorAttr.set(i, rgbaArr);
        texcoordAttr.set(i, uvArr);
      }
      var quadIndices = [];
      var cursor = 0;
      for (var i = 0; i < row - 1; i++) {
        for (var j = 0; j < column - 1; j++) {
          getQuadIndices(i, j, quadIndices);
          for (var k = 0; k < 6; k++) {
            indices[cursor++] = quadIndices[quadToTriangle[k]];
          }
        }
      }
      if (needsNormal) {
        geometry.generateVertexNormals();
      } else {
        normalAttr.value = null;
      }
    }
    if (surfaceMesh.material.get("normalMap")) {
      geometry.generateTangents();
    }
    geometry.updateBoundingBox();
    geometry.dirty();
    surfaceMesh.material.transparent = isTransparent;
    surfaceMesh.material.depthMask = !isTransparent;
  },
  _getDataShape: function(data, isParametric) {
    var prevX = -Infinity;
    var rowCount = 0;
    var columnCount = 0;
    var mayInvalid = false;
    var rowDim = isParametric ? "u" : "x";
    var dataCount = data.count();
    for (var i = 0; i < dataCount; i++) {
      var x = data.get(rowDim, i);
      if (x < prevX) {
        columnCount = 0;
        rowCount++;
      }
      prevX = x;
      columnCount++;
    }
    if (!rowCount || columnCount === 1) {
      mayInvalid = true;
    }
    if (!mayInvalid) {
      return [rowCount + 1, columnCount];
    }
    var rows = Math.floor(Math.sqrt(dataCount));
    while (rows > 0) {
      if (Math.floor(dataCount / rows) === dataCount / rows) {
        return [rows, dataCount / rows];
      }
      rows--;
    }
    rows = Math.floor(Math.sqrt(dataCount));
    return [rows, rows];
  },
  dispose: function() {
    this.groupGL.removeAll();
  },
  remove: function() {
    this.groupGL.removeAll();
  }
});
function install$5(registers) {
  registers.registerChartView(SurfaceView);
  registers.registerSeriesModel(SurfaceSeries$1);
  registers.registerLayout(function(ecModel, api) {
    ecModel.eachSeriesByType("surface", function(surfaceModel) {
      var cartesian = surfaceModel.coordinateSystem;
      if (!cartesian || cartesian.type !== "cartesian3D")
        ;
      var data = surfaceModel.getData();
      var points2 = new Float32Array(3 * data.count());
      var nanPoint = [NaN, NaN, NaN];
      if (cartesian && cartesian.type === "cartesian3D") {
        var coordDims = cartesian.dimensions;
        var dims = coordDims.map(function(coordDim) {
          return surfaceModel.coordDimToDataDim(coordDim)[0];
        });
        data.each(dims, function(x, y, z, idx) {
          var pt;
          if (!data.hasValue(idx)) {
            pt = nanPoint;
          } else {
            pt = cartesian.dataToPoint([x, y, z]);
          }
          points2[idx * 3] = pt[0];
          points2[idx * 3 + 1] = pt[1];
          points2[idx * 3 + 2] = pt[2];
        });
      }
      data.setLayout("points", points2);
    });
  });
}
use(install$5);
function transformPolygon(mapbox3DCoordSys, poly) {
  var newPoly = [];
  for (var k = 0; k < poly.length; k++) {
    newPoly.push(mapbox3DCoordSys.dataToPoint(poly[k]));
  }
  return newPoly;
}
var Map3DSeries = SeriesModel$1.extend({
  type: "series.map3D",
  layoutMode: "box",
  coordinateSystem: null,
  visualStyleAccessPath: "itemStyle",
  optionUpdated: function(newOpt) {
    var coordSysType = this.get("coordinateSystem");
    if (coordSysType == null || coordSysType === "geo3D") {
      return;
    }
    if (this.get("groundPlane.show")) {
      this.option.groundPlane.show = false;
    }
    this._geo = null;
  },
  getInitialData: function(option) {
    option.data = this.getFilledRegions(option.data, option.map);
    var dimensions = createDimensions(option.data, {
      coordDimensions: ["value"]
    });
    var list = new SeriesData$1(dimensions, this);
    list.initData(option.data);
    var regionModelMap = {};
    list.each(function(idx) {
      var name = list.getName(idx);
      var itemModel = list.getItemModel(idx);
      regionModelMap[name] = itemModel;
    });
    this._regionModelMap = regionModelMap;
    return list;
  },
  formatTooltip: function(dataIndex) {
    return formatTooltip(this, dataIndex);
  },
  getRegionModel: function(idx) {
    var name = this.getData().getName(idx);
    return this._regionModelMap[name] || new Model$1(null, this);
  },
  getRegionPolygonCoords: function(idx) {
    var coordSys = this.coordinateSystem;
    var name = this.getData().getName(idx);
    if (coordSys.transform) {
      var region = coordSys.getRegion(name);
      return region ? region.geometries : [];
    } else {
      if (!this._geo) {
        this._geo = geo3DCreator$1.createGeo3D(this);
      }
      var region = this._geo.getRegion(name);
      var ret2 = [];
      for (var k = 0; k < region.geometries.length; k++) {
        var geo = region.geometries[k];
        var interiors = [];
        var exterior = transformPolygon(coordSys, geo.exterior);
        if (interiors && interiors.length) {
          for (var m2 = 0; m2 < geo.interiors.length; m2++) {
            interiors.push(transformPolygon(coordSys, interiors[m2]));
          }
        }
        ret2.push({
          interiors,
          exterior
        });
      }
      return ret2;
    }
  },
  getFormattedLabel: function(dataIndex, status) {
    var text = formatUtil$1.getFormattedLabel(this, dataIndex, status);
    if (text == null) {
      text = this.getData().getName(dataIndex);
    }
    return text;
  },
  defaultOption: {
    coordinateSystem: "geo3D",
    data: null
  }
});
merge(Map3DSeries.prototype, geo3DModelMixin);
merge(Map3DSeries.prototype, componentViewControlMixin);
merge(Map3DSeries.prototype, componentPostEffectMixin);
merge(Map3DSeries.prototype, componentLightMixin);
merge(Map3DSeries.prototype, componentShadingMixin);
var Map3DSeries$1 = Map3DSeries;
var Map3DView = ChartView$1.extend({
  type: "map3D",
  __ecgl__: true,
  init: function(ecModel, api) {
    this._geo3DBuilder = new Geo3DBuilder(api);
    this.groupGL = new graphicGL$1.Node();
  },
  render: function(map3DModel, ecModel, api) {
    var coordSys = map3DModel.coordinateSystem;
    if (!coordSys || !coordSys.viewGL) {
      return;
    }
    this.groupGL.add(this._geo3DBuilder.rootNode);
    coordSys.viewGL.add(this.groupGL);
    if (coordSys.type === "geo3D") {
      if (!this._sceneHelper) {
        this._sceneHelper = new SceneHelper();
        this._sceneHelper.initLight(this.groupGL);
      }
      this._sceneHelper.setScene(coordSys.viewGL.scene);
      this._sceneHelper.updateLight(map3DModel);
      coordSys.viewGL.setPostEffect(map3DModel.getModel("postEffect"), api);
      coordSys.viewGL.setTemporalSuperSampling(map3DModel.getModel("temporalSuperSampling"));
      var control = this._control;
      if (!control) {
        control = this._control = new OrbitControl$1({
          zr: api.getZr()
        });
        this._control.init();
      }
      var viewControlModel = map3DModel.getModel("viewControl");
      control.setViewGL(coordSys.viewGL);
      control.setFromViewControlModel(viewControlModel, 0);
      control.off("update");
      control.on("update", function() {
        api.dispatchAction({
          type: "map3DChangeCamera",
          alpha: control.getAlpha(),
          beta: control.getBeta(),
          distance: control.getDistance(),
          from: this.uid,
          map3DId: map3DModel.id
        });
      });
      this._geo3DBuilder.extrudeY = true;
    } else {
      if (this._control) {
        this._control.dispose();
        this._control = null;
      }
      if (this._sceneHelper) {
        this._sceneHelper.dispose();
        this._sceneHelper = null;
      }
      map3DModel.getData().getLayout("geo3D");
      this._geo3DBuilder.extrudeY = false;
    }
    this._geo3DBuilder.update(map3DModel, ecModel, api, 0, map3DModel.getData().count());
    var srgbDefineMethod = coordSys.viewGL.isLinearSpace() ? "define" : "undefine";
    this._geo3DBuilder.rootNode.traverse(function(mesh2) {
      if (mesh2.material) {
        mesh2.material[srgbDefineMethod]("fragment", "SRGB_DECODE");
      }
    });
  },
  afterRender: function(map3DModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    var coordSys = map3DModel.coordinateSystem;
    if (coordSys && coordSys.type === "geo3D") {
      this._sceneHelper.updateAmbientCubemap(renderer, map3DModel, api);
      this._sceneHelper.updateSkybox(renderer, map3DModel, api);
    }
  },
  dispose: function() {
    this.groupGL.removeAll();
    this._control.dispose();
    this._geo3DBuilder.dispose();
  }
});
function install$4(registers) {
  install$e(registers);
  registers.registerChartView(Map3DView);
  registers.registerSeriesModel(Map3DSeries$1);
  registers.registerAction({
    type: "map3DChangeCamera",
    event: "map3dcamerachanged",
    update: "series:updateCamera"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "map3D",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
}
use(install$4);
var ScatterGLSeries = SeriesModel$1.extend({
  type: "series.scatterGL",
  dependencies: ["grid", "polar", "geo", "singleAxis"],
  visualStyleAccessPath: "itemStyle",
  hasSymbolVisual: true,
  getInitialData: function() {
    return createList$3(this);
  },
  defaultOption: {
    coordinateSystem: "cartesian2d",
    zlevel: 10,
    progressive: 1e5,
    progressiveThreshold: 1e5,
    large: false,
    symbol: "circle",
    symbolSize: 10,
    zoomScale: 0,
    blendMode: "source-over",
    itemStyle: {
      opacity: 0.8
    },
    postEffect: {
      enable: false,
      colorCorrection: {
        exposure: 0,
        brightness: 0,
        contrast: 1,
        saturation: 1,
        enable: true
      }
    }
  }
});
function GLViewHelper(viewGL) {
  this.viewGL = viewGL;
}
GLViewHelper.prototype.reset = function(seriesModel, api) {
  this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
  this._viewTransform = create$2();
  this.updateTransform(seriesModel, api);
};
GLViewHelper.prototype.updateTransform = function(seriesModel, api) {
  var coordinateSystem = seriesModel.coordinateSystem;
  if (coordinateSystem.getRoamTransform) {
    invert(this._viewTransform, coordinateSystem.getRoamTransform());
    this._setCameraTransform(this._viewTransform);
    api.getZr().refresh();
  }
};
GLViewHelper.prototype.dataToPoint = function(coordSys, data, pt) {
  pt = coordSys.dataToPoint(data, null, pt);
  var viewTransform = this._viewTransform;
  if (viewTransform) {
    applyTransform$1(pt, pt, viewTransform);
  }
};
GLViewHelper.prototype.removeTransformInPoint = function(pt) {
  if (this._viewTransform) {
    applyTransform$1(pt, pt, this._viewTransform);
  }
  return pt;
};
GLViewHelper.prototype.getZoom = function() {
  if (this._viewTransform) {
    var m2 = this._viewTransform;
    return 1 / Math.max(Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]), Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]));
  }
  return 1;
};
GLViewHelper.prototype._setCameraTransform = function(m2) {
  var camera2 = this.viewGL.camera;
  camera2.position.set(m2[4], m2[5], 0);
  camera2.scale.set(Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]), Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]), 1);
};
GLViewHelper.prototype._updateCamera = function(width, height, dpr2) {
  this.viewGL.setViewport(0, 0, width, height, dpr2);
  var camera2 = this.viewGL.camera;
  camera2.left = camera2.top = 0;
  camera2.bottom = height;
  camera2.right = width;
  camera2.near = 0;
  camera2.far = 100;
};
var ScatterGLView = ChartView$1.extend({
  type: "scatterGL",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this.viewGL = new ViewGL("orthographic");
    this.viewGL.add(this.groupGL);
    this._pointsBuilderList = [];
    this._currentStep = 0;
    this._sizeScale = 1;
    this._glViewHelper = new GLViewHelper(this.viewGL);
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    this._glViewHelper.reset(seriesModel, api);
    if (!seriesModel.getData().count()) {
      return;
    }
    var pointsBuilder = this._pointsBuilderList[0];
    if (!pointsBuilder) {
      pointsBuilder = this._pointsBuilderList[0] = new PointsBuilder(true, api);
    }
    this._pointsBuilderList.length = 1;
    this.groupGL.add(pointsBuilder.rootNode);
    this._removeTransformInPoints(seriesModel.getData().getLayout("points"));
    pointsBuilder.update(seriesModel, ecModel, api);
    this.viewGL.setPostEffect(seriesModel.getModel("postEffect"), api);
  },
  incrementalPrepareRender: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    this._glViewHelper.reset(seriesModel, api);
    this._currentStep = 0;
    this.viewGL.setPostEffect(seriesModel.getModel("postEffect"), api);
  },
  incrementalRender: function(params, seriesModel, ecModel, api) {
    if (params.end <= params.start) {
      return;
    }
    var pointsBuilder = this._pointsBuilderList[this._currentStep];
    if (!pointsBuilder) {
      pointsBuilder = new PointsBuilder(true, api);
      this._pointsBuilderList[this._currentStep] = pointsBuilder;
    }
    this.groupGL.add(pointsBuilder.rootNode);
    this._removeTransformInPoints(seriesModel.getData().getLayout("points"));
    pointsBuilder.setSizeScale(this._sizeScale);
    pointsBuilder.update(seriesModel, ecModel, api, params.start, params.end);
    api.getZr().refresh();
    this._currentStep++;
  },
  updateTransform: function(seriesModel, ecModel, api) {
    if (seriesModel.coordinateSystem.getRoamTransform) {
      this._glViewHelper.updateTransform(seriesModel, api);
      var zoom = this._glViewHelper.getZoom();
      var sizeScale = Math.max((seriesModel.get("zoomScale") || 0) * (zoom - 1) + 1, 0);
      this._sizeScale = sizeScale;
      this._pointsBuilderList.forEach(function(pointsBuilder) {
        pointsBuilder.setSizeScale(sizeScale);
      });
    }
  },
  _removeTransformInPoints: function(points2) {
    if (!points2) {
      return;
    }
    var pt = [];
    for (var i = 0; i < points2.length; i += 2) {
      pt[0] = points2[i];
      pt[1] = points2[i + 1];
      this._glViewHelper.removeTransformInPoint(pt);
      points2[i] = pt[0];
      points2[i + 1] = pt[1];
    }
  },
  dispose: function() {
    this.groupGL.removeAll();
    this._pointsBuilderList.forEach(function(pointsBuilder) {
      pointsBuilder.dispose();
    });
  },
  remove: function() {
    this.groupGL.removeAll();
  }
});
function install$3(registers) {
  registers.registerChartView(ScatterGLView);
  registers.registerSeriesModel(ScatterGLSeries);
  registers.registerLayout({
    seriesType: "scatterGL",
    reset: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var progress;
      if (coordSys) {
        var dims = coordSys.dimensions.map(function(dim) {
          return data.mapDimension(dim);
        }).slice(0, 2);
        var pt = [];
        if (dims.length === 1) {
          progress = function(params) {
            var points2 = new Float32Array((params.end - params.start) * 2);
            for (var idx = params.start; idx < params.end; idx++) {
              var offset = (idx - params.start) * 2;
              var x = data.get(dims[0], idx);
              var pt3 = coordSys.dataToPoint(x);
              points2[offset] = pt3[0];
              points2[offset + 1] = pt3[1];
            }
            data.setLayout("points", points2);
          };
        } else if (dims.length === 2) {
          progress = function(params) {
            var points2 = new Float32Array((params.end - params.start) * 2);
            for (var idx = params.start; idx < params.end; idx++) {
              var offset = (idx - params.start) * 2;
              var x = data.get(dims[0], idx);
              var y = data.get(dims[1], idx);
              pt[0] = x;
              pt[1] = y;
              pt = coordSys.dataToPoint(pt);
              points2[offset] = pt[0];
              points2[offset + 1] = pt[1];
            }
            data.setLayout("points", points2);
          };
        }
      }
      return {
        progress
      };
    }
  });
}
use(install$3);
function createGraphFromNodeEdge(nodes, edges, hostModel, directed, beforeLink) {
  var graph = new Graph$3(directed);
  for (var i = 0; i < nodes.length; i++) {
    graph.addNode(retrieve$1.firstNotNull(nodes[i].id, nodes[i].name, i), i);
  }
  var linkNameList = [];
  var validEdges = [];
  var linkCount = 0;
  for (var i = 0; i < edges.length; i++) {
    var link = edges[i];
    var source = link.source;
    var target = link.target;
    if (graph.addEdge(source, target, linkCount)) {
      validEdges.push(link);
      linkNameList.push(retrieve$1.firstNotNull(link.id, source + " > " + target));
      linkCount++;
    }
  }
  var nodeData;
  var dimensionNames = createDimensions(nodes, {
    coordDimensions: ["value"]
  });
  nodeData = new SeriesData$1(dimensionNames, hostModel);
  nodeData.initData(nodes);
  var edgeData = new SeriesData$1(["value"], hostModel);
  edgeData.initData(validEdges, linkNameList);
  beforeLink && beforeLink(nodeData, edgeData);
  linkSeriesData({
    mainData: nodeData,
    struct: graph,
    structAttr: "graph",
    datas: {
      node: nodeData,
      edge: edgeData
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  });
  graph.update();
  return graph;
}
var GraphSeries = SeriesModel$1.extend({
  type: "series.graphGL",
  visualStyleAccessPath: "itemStyle",
  hasSymbolVisual: true,
  init: function(option) {
    GraphSeries.superApply(this, "init", arguments);
    this.legendDataProvider = function() {
      return this._categoriesData;
    };
    this._updateCategoriesData();
  },
  mergeOption: function(option) {
    GraphSeries.superApply(this, "mergeOption", arguments);
    this._updateCategoriesData();
  },
  getFormattedLabel: function(dataIndex, status, dataType, dimIndex) {
    var text = formatUtil$1.getFormattedLabel(this, dataIndex, status, dataType, dimIndex);
    if (text == null) {
      var data = this.getData();
      var lastDim = data.dimensions[data.dimensions.length - 1];
      text = data.get(lastDim, dataIndex);
    }
    return text;
  },
  getInitialData: function(option, ecModel) {
    var edges = option.edges || option.links || [];
    var nodes = option.data || option.nodes || [];
    var self2 = this;
    if (nodes && edges) {
      return createGraphFromNodeEdge(nodes, edges, this, true, beforeLink).data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model) {
        const categoriesModels = self2._categoriesModels;
        const categoryIdx = model.getShallow("category");
        const categoryModel = categoriesModels[categoryIdx];
        if (categoryModel) {
          categoryModel.parentModel = model.parentModel;
          model.parentModel = categoryModel;
        }
        return model;
      });
      const oldGetModel = ecModel.getModel([]).getModel;
      function newGetModel(path, parentModel) {
        const model = oldGetModel.call(this, path, parentModel);
        model.resolveParentPath = resolveParentPath;
        return model;
      }
      edgeData.wrapMethod("getItemModel", function(model) {
        model.resolveParentPath = resolveParentPath;
        model.getModel = newGetModel;
        return model;
      });
      function resolveParentPath(pathArr) {
        if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
          const newPathArr = pathArr.slice();
          if (pathArr[0] === "label") {
            newPathArr[0] = "edgeLabel";
          } else if (pathArr[1] === "label") {
            newPathArr[1] = "edgeLabel";
          }
          return newPathArr;
        }
        return pathArr;
      }
    }
  },
  getGraph: function() {
    return this.getData().graph;
  },
  getEdgeData: function() {
    return this.getGraph().edgeData;
  },
  getCategoriesData: function() {
    return this._categoriesData;
  },
  formatTooltip: function(dataIndex, multipleSeries, dataType) {
    if (dataType === "edge") {
      var nodeData = this.getData();
      var params = this.getDataParams(dataIndex, dataType);
      var edge = nodeData.graph.getEdgeByIndex(dataIndex);
      var sourceName = nodeData.getName(edge.node1.dataIndex);
      var targetName = nodeData.getName(edge.node2.dataIndex);
      var html = [];
      sourceName != null && html.push(sourceName);
      targetName != null && html.push(targetName);
      html = encodeHTML(html.join(" > "));
      if (params.value) {
        html += " : " + encodeHTML(params.value);
      }
      return html;
    } else {
      return GraphSeries.superApply(this, "formatTooltip", arguments);
    }
  },
  _updateCategoriesData: function() {
    var categories = (this.option.categories || []).map(function(category) {
      return category.value != null ? category : Object.assign({
        value: 0
      }, category);
    });
    var categoriesData = new SeriesData$1(["value"], this);
    categoriesData.initData(categories);
    this._categoriesData = categoriesData;
    this._categoriesModels = categoriesData.mapArray(function(idx) {
      return categoriesData.getItemModel(idx, true);
    });
  },
  setView: function(payload) {
    if (payload.zoom != null) {
      this.option.zoom = payload.zoom;
    }
    if (payload.offset != null) {
      this.option.offset = payload.offset;
    }
  },
  setNodePosition: function(points2) {
    for (var i = 0; i < points2.length / 2; i++) {
      var x = points2[i * 2];
      var y = points2[i * 2 + 1];
      var opt = this.getData().getRawDataItem(i);
      opt.x = x;
      opt.y = y;
    }
  },
  isAnimationEnabled: function() {
    return GraphSeries.superCall(this, "isAnimationEnabled") && !(this.get("layout") === "force" && this.get("force.layoutAnimation"));
  },
  defaultOption: {
    zlevel: 10,
    z: 2,
    legendHoverLink: true,
    layout: "forceAtlas2",
    forceAtlas2: {
      initLayout: null,
      GPU: true,
      steps: 1,
      maxSteps: 1e3,
      repulsionByDegree: true,
      linLogMode: false,
      strongGravityMode: false,
      gravity: 1,
      edgeWeightInfluence: 1,
      edgeWeight: [1, 4],
      nodeWeight: [1, 4],
      preventOverlap: false,
      gravityCenter: null
    },
    focusNodeAdjacency: true,
    focusNodeAdjacencyOn: "mouseover",
    left: "center",
    top: "center",
    symbol: "circle",
    symbolSize: 5,
    roam: false,
    center: null,
    zoom: 1,
    label: {
      show: false,
      formatter: "{b}",
      position: "right",
      distance: 5,
      textStyle: {
        fontSize: 14
      }
    },
    itemStyle: {},
    lineStyle: {
      color: "#aaa",
      width: 1,
      opacity: 0.5
    },
    emphasis: {
      label: {
        show: true
      }
    },
    animation: false
  }
});
var GraphGLSeries = GraphSeries;
var vec2$1 = glmatrix.vec2;
var sampleLinePoints = [[0, 0], [1, 1]];
var LinesGeometry$1 = Geometry$1.extend(function() {
  return {
    segmentScale: 4,
    dynamic: true,
    useNativeLine: true,
    attributes: {
      position: new Geometry$1.Attribute("position", "float", 2, "POSITION"),
      normal: new Geometry$1.Attribute("normal", "float", 2),
      offset: new Geometry$1.Attribute("offset", "float", 1),
      color: new Geometry$1.Attribute("color", "float", 4, "COLOR")
    }
  };
}, {
  resetOffset: function() {
    this._vertexOffset = 0;
    this._faceOffset = 0;
    this._itemVertexOffsets = [];
  },
  setVertexCount: function(nVertex) {
    var attributes = this.attributes;
    if (this.vertexCount !== nVertex) {
      attributes.position.init(nVertex);
      attributes.color.init(nVertex);
      if (!this.useNativeLine) {
        attributes.offset.init(nVertex);
        attributes.normal.init(nVertex);
      }
      if (nVertex > 65535) {
        if (this.indices instanceof Uint16Array) {
          this.indices = new Uint32Array(this.indices);
        }
      } else {
        if (this.indices instanceof Uint32Array) {
          this.indices = new Uint16Array(this.indices);
        }
      }
    }
  },
  setTriangleCount: function(nTriangle) {
    if (this.triangleCount !== nTriangle) {
      if (nTriangle === 0) {
        this.indices = null;
      } else {
        this.indices = this.vertexCount > 65535 ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);
      }
    }
  },
  _getCubicCurveApproxStep: function(p02, p12, p22, p3) {
    var len2 = vec2$1.dist(p02, p12) + vec2$1.dist(p22, p12) + vec2$1.dist(p3, p22);
    var step = 1 / (len2 + 1) * this.segmentScale;
    return step;
  },
  getCubicCurveVertexCount: function(p02, p12, p22, p3) {
    var step = this._getCubicCurveApproxStep(p02, p12, p22, p3);
    var segCount = Math.ceil(1 / step);
    if (!this.useNativeLine) {
      return segCount * 2 + 2;
    } else {
      return segCount * 2;
    }
  },
  getCubicCurveTriangleCount: function(p02, p12, p22, p3) {
    var step = this._getCubicCurveApproxStep(p02, p12, p22, p3);
    var segCount = Math.ceil(1 / step);
    if (!this.useNativeLine) {
      return segCount * 2;
    } else {
      return 0;
    }
  },
  getLineVertexCount: function() {
    return this.getPolylineVertexCount(sampleLinePoints);
  },
  getLineTriangleCount: function() {
    return this.getPolylineTriangleCount(sampleLinePoints);
  },
  getPolylineVertexCount: function(points2) {
    var pointsLen;
    if (typeof points2 === "number") {
      pointsLen = points2;
    } else {
      var is2DArray2 = typeof points2[0] !== "number";
      pointsLen = is2DArray2 ? points2.length : points2.length / 2;
    }
    return !this.useNativeLine ? (pointsLen - 1) * 2 + 2 : (pointsLen - 1) * 2;
  },
  getPolylineTriangleCount: function(points2) {
    var pointsLen;
    if (typeof points2 === "number") {
      pointsLen = points2;
    } else {
      var is2DArray2 = typeof points2[0] !== "number";
      pointsLen = is2DArray2 ? points2.length : points2.length / 2;
    }
    return !this.useNativeLine ? (pointsLen - 1) * 2 : 0;
  },
  addCubicCurve: function(p02, p12, p22, p3, color, lineWidth) {
    if (lineWidth == null) {
      lineWidth = 1;
    }
    var x0 = p02[0], y0 = p02[1];
    var x1 = p12[0], y1 = p12[1];
    var x2 = p22[0], y2 = p22[1];
    var x3 = p3[0], y3 = p3[1];
    var step = this._getCubicCurveApproxStep(p02, p12, p22, p3);
    var step2 = step * step;
    var step3 = step2 * step;
    var pre1 = 3 * step;
    var pre2 = 3 * step2;
    var pre4 = 6 * step2;
    var pre5 = 6 * step3;
    var tmp1x = x0 - x1 * 2 + x2;
    var tmp1y = y0 - y1 * 2 + y2;
    var tmp2x = (x1 - x2) * 3 - x0 + x3;
    var tmp2y = (y1 - y2) * 3 - y0 + y3;
    var fx = x0;
    var fy = y0;
    var dfx = (x1 - x0) * pre1 + tmp1x * pre2 + tmp2x * step3;
    var dfy = (y1 - y0) * pre1 + tmp1y * pre2 + tmp2y * step3;
    var ddfx = tmp1x * pre4 + tmp2x * pre5;
    var ddfy = tmp1y * pre4 + tmp2y * pre5;
    var dddfx = tmp2x * pre5;
    var dddfy = tmp2y * pre5;
    var t = 0;
    var k = 0;
    var segCount = Math.ceil(1 / step);
    var points2 = new Float32Array((segCount + 1) * 3);
    var points2 = [];
    var offset = 0;
    for (var k = 0; k < segCount + 1; k++) {
      points2[offset++] = fx;
      points2[offset++] = fy;
      fx += dfx;
      fy += dfy;
      dfx += ddfx;
      dfy += ddfy;
      ddfx += dddfx;
      ddfy += dddfy;
      t += step;
      if (t > 1) {
        fx = dfx > 0 ? Math.min(fx, x3) : Math.max(fx, x3);
        fy = dfy > 0 ? Math.min(fy, y3) : Math.max(fy, y3);
      }
    }
    this.addPolyline(points2, color, lineWidth);
  },
  addLine: function(p02, p12, color, lineWidth) {
    this.addPolyline([p02, p12], color, lineWidth);
  },
  addPolyline: function() {
    var dirA = vec2$1.create();
    var dirB = vec2$1.create();
    var normal2 = vec2$1.create();
    var tangent2 = vec2$1.create();
    var point = [], nextPoint = [], prevPoint = [];
    return function(points2, color, lineWidth, arrayOffset, pointsCount) {
      if (!points2.length) {
        return;
      }
      var is2DArray2 = typeof points2[0] !== "number";
      if (pointsCount == null) {
        pointsCount = is2DArray2 ? points2.length : points2.length / 2;
      }
      if (pointsCount < 2) {
        return;
      }
      if (arrayOffset == null) {
        arrayOffset = 0;
      }
      if (lineWidth == null) {
        lineWidth = 1;
      }
      this._itemVertexOffsets.push(this._vertexOffset);
      var notSharingColor = is2DArray2 ? typeof color[0] !== "number" : color.length / 4 === pointsCount;
      var positionAttr = this.attributes.position;
      var colorAttr = this.attributes.color;
      var offsetAttr = this.attributes.offset;
      var normalAttr = this.attributes.normal;
      var indices = this.indices;
      var vertexOffset = this._vertexOffset;
      var pointColor;
      for (var k = 0; k < pointsCount; k++) {
        if (is2DArray2) {
          point = points2[k + arrayOffset];
          if (notSharingColor) {
            pointColor = color[k + arrayOffset];
          } else {
            pointColor = color;
          }
        } else {
          var k2 = k * 2 + arrayOffset;
          point = point || [];
          point[0] = points2[k2];
          point[1] = points2[k2 + 1];
          if (notSharingColor) {
            var k4 = k * 4 + arrayOffset;
            pointColor = pointColor || [];
            pointColor[0] = color[k4];
            pointColor[1] = color[k4 + 1];
            pointColor[2] = color[k4 + 2];
            pointColor[3] = color[k4 + 3];
          } else {
            pointColor = color;
          }
        }
        if (!this.useNativeLine) {
          var offset;
          if (k < pointsCount - 1) {
            if (is2DArray2) {
              vec2$1.copy(nextPoint, points2[k + 1]);
            } else {
              var k2 = (k + 1) * 2 + arrayOffset;
              nextPoint = nextPoint || [];
              nextPoint[0] = points2[k2];
              nextPoint[1] = points2[k2 + 1];
            }
            if (k > 0) {
              vec2$1.sub(dirA, point, prevPoint);
              vec2$1.sub(dirB, nextPoint, point);
              vec2$1.normalize(dirA, dirA);
              vec2$1.normalize(dirB, dirB);
              vec2$1.add(tangent2, dirA, dirB);
              vec2$1.normalize(tangent2, tangent2);
              var miter = lineWidth / 2 * Math.min(1 / vec2$1.dot(dirA, tangent2), 2);
              normal2[0] = -tangent2[1];
              normal2[1] = tangent2[0];
              offset = miter;
            } else {
              vec2$1.sub(dirA, nextPoint, point);
              vec2$1.normalize(dirA, dirA);
              normal2[0] = -dirA[1];
              normal2[1] = dirA[0];
              offset = lineWidth / 2;
            }
          } else {
            vec2$1.sub(dirA, point, prevPoint);
            vec2$1.normalize(dirA, dirA);
            normal2[0] = -dirA[1];
            normal2[1] = dirA[0];
            offset = lineWidth / 2;
          }
          normalAttr.set(vertexOffset, normal2);
          normalAttr.set(vertexOffset + 1, normal2);
          offsetAttr.set(vertexOffset, offset);
          offsetAttr.set(vertexOffset + 1, -offset);
          vec2$1.copy(prevPoint, point);
          positionAttr.set(vertexOffset, point);
          positionAttr.set(vertexOffset + 1, point);
          colorAttr.set(vertexOffset, pointColor);
          colorAttr.set(vertexOffset + 1, pointColor);
          vertexOffset += 2;
        } else {
          if (k > 1) {
            positionAttr.copy(vertexOffset, vertexOffset - 1);
            colorAttr.copy(vertexOffset, vertexOffset - 1);
            vertexOffset++;
          }
        }
        if (!this.useNativeLine) {
          if (k > 0) {
            var idx3 = this._faceOffset * 3;
            var indices = this.indices;
            indices[idx3] = vertexOffset - 4;
            indices[idx3 + 1] = vertexOffset - 3;
            indices[idx3 + 2] = vertexOffset - 2;
            indices[idx3 + 3] = vertexOffset - 3;
            indices[idx3 + 4] = vertexOffset - 1;
            indices[idx3 + 5] = vertexOffset - 2;
            this._faceOffset += 2;
          }
        } else {
          colorAttr.set(vertexOffset, pointColor);
          positionAttr.set(vertexOffset, point);
          vertexOffset++;
        }
      }
      this._vertexOffset = vertexOffset;
    };
  }(),
  setItemColor: function(idx, color) {
    var startOffset = this._itemVertexOffsets[idx];
    var endOffset = idx < this._itemVertexOffsets.length - 1 ? this._itemVertexOffsets[idx + 1] : this._vertexOffset;
    for (var i = startOffset; i < endOffset; i++) {
      this.attributes.color.set(i, color);
    }
    this.dirty("color");
  }
});
defaults(LinesGeometry$1.prototype, dynamicConvertMixin);
var Lines2DGeometry = LinesGeometry$1;
var forceAtlas2Code = "@export ecgl.forceAtlas2.updateNodeRepulsion\n\n#define NODE_COUNT 0\n\nuniform sampler2D positionTex;\n\nuniform vec2 textureSize;\nuniform float gravity;\nuniform float scaling;\nuniform vec2 gravityCenter;\n\nuniform bool strongGravityMode;\nuniform bool preventOverlap;\n\nvarying vec2 v_Texcoord;\n\nvoid main() {\n\n vec4 n0 = texture2D(positionTex, v_Texcoord);\n\n vec2 force = vec2(0.0);\n for (int i = 0; i < NODE_COUNT; i++) {\n vec2 uv = vec2(\n mod(float(i), textureSize.x) / (textureSize.x - 1.0),\n floor(float(i) / textureSize.x) / (textureSize.y - 1.0)\n );\n vec4 n1 = texture2D(positionTex, uv);\n\n vec2 dir = n0.xy - n1.xy;\n float d2 = dot(dir, dir);\n\n if (d2 > 0.0) {\n float factor = 0.0;\n if (preventOverlap) {\n float d = sqrt(d2);\n d = d - n0.w - n1.w;\n if (d > 0.0) {\n factor = scaling * n0.z * n1.z / (d * d);\n }\n else if (d < 0.0) {\n factor = scaling * 100.0 * n0.z * n1.z;\n }\n }\n else {\n factor = scaling * n0.z * n1.z / d2;\n }\n force += dir * factor;\n }\n }\n\n vec2 dir = gravityCenter - n0.xy;\n float d = 1.0;\n if (!strongGravityMode) {\n d = length(dir);\n }\n\n force += dir * n0.z * gravity / (d + 1.0);\n\n gl_FragColor = vec4(force, 0.0, 1.0);\n}\n@end\n\n@export ecgl.forceAtlas2.updateEdgeAttraction.vertex\n\nattribute vec2 node1;\nattribute vec2 node2;\nattribute float weight;\n\nuniform sampler2D positionTex;\nuniform float edgeWeightInfluence;\nuniform bool preventOverlap;\nuniform bool linLogMode;\n\nuniform vec2 windowSize: WINDOW_SIZE;\n\nvarying vec2 v_Force;\n\nvoid main() {\n\n vec4 n0 = texture2D(positionTex, node1);\n vec4 n1 = texture2D(positionTex, node2);\n\n vec2 dir = n1.xy - n0.xy;\n float d = length(dir);\n float w;\n if (edgeWeightInfluence == 0.0) {\n w = 1.0;\n }\n else if (edgeWeightInfluence == 1.0) {\n w = weight;\n }\n else {\n w = pow(weight, edgeWeightInfluence);\n }\n vec2 offset = vec2(1.0 / windowSize.x, 1.0 / windowSize.y);\n vec2 scale = vec2((windowSize.x - 1.0) / windowSize.x, (windowSize.y - 1.0) / windowSize.y);\n vec2 pos = node1 * scale * 2.0 - 1.0;\n gl_Position = vec4(pos + offset, 0.0, 1.0);\n gl_PointSize = 1.0;\n\n float factor;\n if (preventOverlap) {\n d = d - n1.w - n0.w;\n }\n if (d <= 0.0) {\n v_Force = vec2(0.0);\n return;\n }\n\n if (linLogMode) {\n factor = w * log(d) / d;\n }\n else {\n factor = w;\n }\n v_Force = dir * factor;\n}\n@end\n\n@export ecgl.forceAtlas2.updateEdgeAttraction.fragment\n\nvarying vec2 v_Force;\n\nvoid main() {\n gl_FragColor = vec4(v_Force, 0.0, 0.0);\n}\n@end\n\n@export ecgl.forceAtlas2.calcWeightedSum.vertex\n\nattribute vec2 node;\n\nvarying vec2 v_NodeUv;\n\nvoid main() {\n\n v_NodeUv = node;\n gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n gl_PointSize = 1.0;\n}\n@end\n\n@export ecgl.forceAtlas2.calcWeightedSum.fragment\n\nvarying vec2 v_NodeUv;\n\nuniform sampler2D positionTex;\nuniform sampler2D forceTex;\nuniform sampler2D forcePrevTex;\n\nvoid main() {\n vec2 force = texture2D(forceTex, v_NodeUv).rg;\n vec2 forcePrev = texture2D(forcePrevTex, v_NodeUv).rg;\n\n float mass = texture2D(positionTex, v_NodeUv).z;\n float swing = length(force - forcePrev) * mass;\n float traction = length(force + forcePrev) * 0.5 * mass;\n\n gl_FragColor = vec4(swing, traction, 0.0, 0.0);\n}\n@end\n\n@export ecgl.forceAtlas2.calcGlobalSpeed\n\nuniform sampler2D globalSpeedPrevTex;\nuniform sampler2D weightedSumTex;\nuniform float jitterTolerence;\n\nvoid main() {\n vec2 weightedSum = texture2D(weightedSumTex, vec2(0.5)).xy;\n float prevGlobalSpeed = texture2D(globalSpeedPrevTex, vec2(0.5)).x;\n float globalSpeed = jitterTolerence * jitterTolerence\n * weightedSum.y / weightedSum.x;\n if (prevGlobalSpeed > 0.0) {\n globalSpeed = min(globalSpeed / prevGlobalSpeed, 1.5) * prevGlobalSpeed;\n }\n gl_FragColor = vec4(globalSpeed, 0.0, 0.0, 1.0);\n}\n@end\n\n@export ecgl.forceAtlas2.updatePosition\n\nuniform sampler2D forceTex;\nuniform sampler2D forcePrevTex;\nuniform sampler2D positionTex;\nuniform sampler2D globalSpeedTex;\n\nvarying vec2 v_Texcoord;\n\nvoid main() {\n vec2 force = texture2D(forceTex, v_Texcoord).xy;\n vec2 forcePrev = texture2D(forcePrevTex, v_Texcoord).xy;\n vec4 node = texture2D(positionTex, v_Texcoord);\n\n float globalSpeed = texture2D(globalSpeedTex, vec2(0.5)).r;\n float swing = length(force - forcePrev);\n float speed = 0.1 * globalSpeed / (0.1 + globalSpeed * sqrt(swing));\n\n float df = length(force);\n if (df > 0.0) {\n speed = min(df * speed, 10.0) / df;\n\n gl_FragColor = vec4(node.xy + speed * force, node.zw);\n }\n else {\n gl_FragColor = node;\n }\n}\n@end\n\n@export ecgl.forceAtlas2.edges.vertex\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec2 node;\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n\nuniform sampler2D positionTex;\n\nvoid main()\n{\n gl_Position = worldViewProjection * vec4(\n texture2D(positionTex, node).xy, -10.0, 1.0\n );\n v_Color = a_Color;\n}\n@end\n\n@export ecgl.forceAtlas2.edges.fragment\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nvarying vec4 v_Color;\nvoid main() {\n gl_FragColor = color * v_Color;\n}\n@end";
graphicGL$1.Shader.import(forceAtlas2Code);
var defaultConfigs$1 = {
  repulsionByDegree: true,
  linLogMode: false,
  strongGravityMode: false,
  gravity: 1,
  scaling: 1,
  edgeWeightInfluence: 1,
  jitterTolerence: 0.1,
  preventOverlap: false,
  dissuadeHubs: false,
  gravityCenter: null
};
function ForceAtlas2GPU(options) {
  var textureOpt = {
    type: graphicGL$1.Texture.FLOAT,
    minFilter: graphicGL$1.Texture.NEAREST,
    magFilter: graphicGL$1.Texture.NEAREST
  };
  this._positionSourceTex = new graphicGL$1.Texture2D(textureOpt);
  this._positionSourceTex.flipY = false;
  this._positionTex = new graphicGL$1.Texture2D(textureOpt);
  this._positionPrevTex = new graphicGL$1.Texture2D(textureOpt);
  this._forceTex = new graphicGL$1.Texture2D(textureOpt);
  this._forcePrevTex = new graphicGL$1.Texture2D(textureOpt);
  this._weightedSumTex = new graphicGL$1.Texture2D(textureOpt);
  this._weightedSumTex.width = this._weightedSumTex.height = 1;
  this._globalSpeedTex = new graphicGL$1.Texture2D(textureOpt);
  this._globalSpeedPrevTex = new graphicGL$1.Texture2D(textureOpt);
  this._globalSpeedTex.width = this._globalSpeedTex.height = 1;
  this._globalSpeedPrevTex.width = this._globalSpeedPrevTex.height = 1;
  this._nodeRepulsionPass = new Pass$1({
    fragment: graphicGL$1.Shader.source("ecgl.forceAtlas2.updateNodeRepulsion")
  });
  this._positionPass = new Pass$1({
    fragment: graphicGL$1.Shader.source("ecgl.forceAtlas2.updatePosition")
  });
  this._globalSpeedPass = new Pass$1({
    fragment: graphicGL$1.Shader.source("ecgl.forceAtlas2.calcGlobalSpeed")
  });
  this._copyPass = new Pass$1({
    fragment: graphicGL$1.Shader.source("clay.compositor.output")
  });
  var additiveBlend = function(gl) {
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE);
  };
  this._edgeForceMesh = new graphicGL$1.Mesh({
    geometry: new graphicGL$1.Geometry({
      attributes: {
        node1: new graphicGL$1.Geometry.Attribute("node1", "float", 2),
        node2: new graphicGL$1.Geometry.Attribute("node2", "float", 2),
        weight: new graphicGL$1.Geometry.Attribute("weight", "float", 1)
      },
      dynamic: true,
      mainAttribute: "node1"
    }),
    material: new graphicGL$1.Material({
      transparent: true,
      shader: graphicGL$1.createShader("ecgl.forceAtlas2.updateEdgeAttraction"),
      blend: additiveBlend,
      depthMask: false,
      depthText: false
    }),
    mode: graphicGL$1.Mesh.POINTS
  });
  this._weightedSumMesh = new graphicGL$1.Mesh({
    geometry: new graphicGL$1.Geometry({
      attributes: {
        node: new graphicGL$1.Geometry.Attribute("node", "float", 2)
      },
      dynamic: true,
      mainAttribute: "node"
    }),
    material: new graphicGL$1.Material({
      transparent: true,
      shader: graphicGL$1.createShader("ecgl.forceAtlas2.calcWeightedSum"),
      blend: additiveBlend,
      depthMask: false,
      depthText: false
    }),
    mode: graphicGL$1.Mesh.POINTS
  });
  this._framebuffer = new FrameBuffer$1({
    depthBuffer: false
  });
  this._dummyCamera = new graphicGL$1.OrthographicCamera({
    left: -1,
    right: 1,
    top: 1,
    bottom: -1,
    near: 0,
    far: 100
  });
  this._globalSpeed = 0;
}
ForceAtlas2GPU.prototype.updateOption = function(options) {
  for (var name in defaultConfigs$1) {
    this[name] = defaultConfigs$1[name];
  }
  var nNodes = this._nodes.length;
  if (nNodes > 5e4) {
    this.jitterTolerence = 10;
  } else if (nNodes > 5e3) {
    this.jitterTolerence = 1;
  } else {
    this.jitterTolerence = 0.1;
  }
  if (nNodes > 100) {
    this.scaling = 2;
  } else {
    this.scaling = 10;
  }
  if (options) {
    for (var name in defaultConfigs$1) {
      if (options[name] != null) {
        this[name] = options[name];
      }
    }
  }
  if (this.repulsionByDegree) {
    var positionBuffer = this._positionSourceTex.pixels;
    for (var i = 0; i < this._nodes.length; i++) {
      positionBuffer[i * 4 + 2] = (this._nodes[i].degree || 0) + 1;
    }
  }
};
ForceAtlas2GPU.prototype._updateGravityCenter = function(options) {
  var nodes = this._nodes;
  var edges = this._edges;
  if (!this.gravityCenter) {
    var min3 = [Infinity, Infinity];
    var max3 = [-Infinity, -Infinity];
    for (var i = 0; i < nodes.length; i++) {
      min3[0] = Math.min(nodes[i].x, min3[0]);
      min3[1] = Math.min(nodes[i].y, min3[1]);
      max3[0] = Math.max(nodes[i].x, max3[0]);
      max3[1] = Math.max(nodes[i].y, max3[1]);
    }
    this._gravityCenter = [(min3[0] + max3[0]) * 0.5, (min3[1] + max3[1]) * 0.5];
  } else {
    this._gravityCenter = this.gravityCenter;
  }
  for (var i = 0; i < edges.length; i++) {
    var node1 = edges[i].node1;
    var node2 = edges[i].node2;
    nodes[node1].degree = (nodes[node1].degree || 0) + 1;
    nodes[node2].degree = (nodes[node2].degree || 0) + 1;
  }
};
ForceAtlas2GPU.prototype.initData = function(nodes, edges) {
  this._nodes = nodes;
  this._edges = edges;
  this._updateGravityCenter();
  var textureWidth = Math.ceil(Math.sqrt(nodes.length));
  var textureHeight = textureWidth;
  var positionBuffer = new Float32Array(textureWidth * textureHeight * 4);
  this._resize(textureWidth, textureHeight);
  var offset = 0;
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    positionBuffer[offset++] = node.x || 0;
    positionBuffer[offset++] = node.y || 0;
    positionBuffer[offset++] = node.mass || 1;
    positionBuffer[offset++] = node.size || 1;
  }
  this._positionSourceTex.pixels = positionBuffer;
  var edgeGeometry = this._edgeForceMesh.geometry;
  var edgeLen = edges.length;
  edgeGeometry.attributes.node1.init(edgeLen * 2);
  edgeGeometry.attributes.node2.init(edgeLen * 2);
  edgeGeometry.attributes.weight.init(edgeLen * 2);
  var uv = [];
  for (var i = 0; i < edges.length; i++) {
    var attributes = edgeGeometry.attributes;
    var weight = edges[i].weight;
    if (weight == null) {
      weight = 1;
    }
    attributes.node1.set(i, this.getNodeUV(edges[i].node1, uv));
    attributes.node2.set(i, this.getNodeUV(edges[i].node2, uv));
    attributes.weight.set(i, weight);
    attributes.node1.set(i + edgeLen, this.getNodeUV(edges[i].node2, uv));
    attributes.node2.set(i + edgeLen, this.getNodeUV(edges[i].node1, uv));
    attributes.weight.set(i + edgeLen, weight);
  }
  var weigtedSumGeo = this._weightedSumMesh.geometry;
  weigtedSumGeo.attributes.node.init(nodes.length);
  for (var i = 0; i < nodes.length; i++) {
    weigtedSumGeo.attributes.node.set(i, this.getNodeUV(i, uv));
  }
  edgeGeometry.dirty();
  weigtedSumGeo.dirty();
  this._nodeRepulsionPass.material.define("fragment", "NODE_COUNT", nodes.length);
  this._nodeRepulsionPass.material.setUniform("textureSize", [textureWidth, textureHeight]);
  this._inited = false;
  this._frame = 0;
};
ForceAtlas2GPU.prototype.getNodes = function() {
  return this._nodes;
};
ForceAtlas2GPU.prototype.getEdges = function() {
  return this._edges;
};
ForceAtlas2GPU.prototype.step = function(renderer) {
  if (!this._inited) {
    this._initFromSource(renderer);
    this._inited = true;
  }
  this._frame++;
  this._framebuffer.attach(this._forceTex);
  this._framebuffer.bind(renderer);
  var nodeRepulsionPass = this._nodeRepulsionPass;
  nodeRepulsionPass.setUniform("strongGravityMode", this.strongGravityMode);
  nodeRepulsionPass.setUniform("gravity", this.gravity);
  nodeRepulsionPass.setUniform("gravityCenter", this._gravityCenter);
  nodeRepulsionPass.setUniform("scaling", this.scaling);
  nodeRepulsionPass.setUniform("preventOverlap", this.preventOverlap);
  nodeRepulsionPass.setUniform("positionTex", this._positionPrevTex);
  nodeRepulsionPass.render(renderer);
  var edgeForceMesh = this._edgeForceMesh;
  edgeForceMesh.material.set("linLogMode", this.linLogMode);
  edgeForceMesh.material.set("edgeWeightInfluence", this.edgeWeightInfluence);
  edgeForceMesh.material.set("preventOverlap", this.preventOverlap);
  edgeForceMesh.material.set("positionTex", this._positionPrevTex);
  renderer.gl.enable(renderer.gl.BLEND);
  renderer.renderPass([edgeForceMesh], this._dummyCamera);
  this._framebuffer.attach(this._weightedSumTex);
  renderer.gl.clearColor(0, 0, 0, 0);
  renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
  renderer.gl.enable(renderer.gl.BLEND);
  var weightedSumMesh = this._weightedSumMesh;
  weightedSumMesh.material.set("positionTex", this._positionPrevTex);
  weightedSumMesh.material.set("forceTex", this._forceTex);
  weightedSumMesh.material.set("forcePrevTex", this._forcePrevTex);
  renderer.renderPass([weightedSumMesh], this._dummyCamera);
  this._framebuffer.attach(this._globalSpeedTex);
  var globalSpeedPass = this._globalSpeedPass;
  globalSpeedPass.setUniform("globalSpeedPrevTex", this._globalSpeedPrevTex);
  globalSpeedPass.setUniform("weightedSumTex", this._weightedSumTex);
  globalSpeedPass.setUniform("jitterTolerence", this.jitterTolerence);
  renderer.gl.disable(renderer.gl.BLEND);
  globalSpeedPass.render(renderer);
  var positionPass = this._positionPass;
  this._framebuffer.attach(this._positionTex);
  positionPass.setUniform("globalSpeedTex", this._globalSpeedTex);
  positionPass.setUniform("positionTex", this._positionPrevTex);
  positionPass.setUniform("forceTex", this._forceTex);
  positionPass.setUniform("forcePrevTex", this._forcePrevTex);
  positionPass.render(renderer);
  this._framebuffer.unbind(renderer);
  this._swapTexture();
};
ForceAtlas2GPU.prototype.update = function(renderer, steps, cb) {
  if (steps == null) {
    steps = 1;
  }
  steps = Math.max(steps, 1);
  for (var i = 0; i < steps; i++) {
    this.step(renderer);
  }
  cb && cb();
};
ForceAtlas2GPU.prototype.getNodePositionTexture = function() {
  return this._inited ? this._positionPrevTex : this._positionSourceTex;
};
ForceAtlas2GPU.prototype.getNodeUV = function(nodeIndex, uv) {
  uv = uv || [];
  var textureWidth = this._positionTex.width;
  var textureHeight = this._positionTex.height;
  uv[0] = nodeIndex % textureWidth / (textureWidth - 1);
  uv[1] = Math.floor(nodeIndex / textureWidth) / (textureHeight - 1) || 0;
  return uv;
};
ForceAtlas2GPU.prototype.getNodePosition = function(renderer, out2) {
  var positionArr = this._positionArr;
  var width = this._positionTex.width;
  var height = this._positionTex.height;
  var size = width * height;
  if (!positionArr || positionArr.length !== size * 4) {
    positionArr = this._positionArr = new Float32Array(size * 4);
  }
  this._framebuffer.bind(renderer);
  this._framebuffer.attach(this._positionPrevTex);
  renderer.gl.readPixels(0, 0, width, height, renderer.gl.RGBA, renderer.gl.FLOAT, positionArr);
  this._framebuffer.unbind(renderer);
  if (!out2) {
    out2 = new Float32Array(this._nodes.length * 2);
  }
  for (var i = 0; i < this._nodes.length; i++) {
    out2[i * 2] = positionArr[i * 4];
    out2[i * 2 + 1] = positionArr[i * 4 + 1];
  }
  return out2;
};
ForceAtlas2GPU.prototype.getTextureData = function(renderer, textureName) {
  var tex = this["_" + textureName + "Tex"];
  var width = tex.width;
  var height = tex.height;
  this._framebuffer.bind(renderer);
  this._framebuffer.attach(tex);
  var arr = new Float32Array(width * height * 4);
  renderer.gl.readPixels(0, 0, width, height, renderer.gl.RGBA, renderer.gl.FLOAT, arr);
  this._framebuffer.unbind(renderer);
  return arr;
};
ForceAtlas2GPU.prototype.getTextureSize = function() {
  return {
    width: this._positionTex.width,
    height: this._positionTex.height
  };
};
ForceAtlas2GPU.prototype.isFinished = function(maxSteps) {
  return this._frame > maxSteps;
};
ForceAtlas2GPU.prototype._swapTexture = function() {
  var tmp = this._positionPrevTex;
  this._positionPrevTex = this._positionTex;
  this._positionTex = tmp;
  var tmp = this._forcePrevTex;
  this._forcePrevTex = this._forceTex;
  this._forceTex = tmp;
  var tmp = this._globalSpeedPrevTex;
  this._globalSpeedPrevTex = this._globalSpeedTex;
  this._globalSpeedTex = tmp;
};
ForceAtlas2GPU.prototype._initFromSource = function(renderer) {
  this._framebuffer.attach(this._positionPrevTex);
  this._framebuffer.bind(renderer);
  this._copyPass.setUniform("texture", this._positionSourceTex);
  this._copyPass.render(renderer);
  renderer.gl.clearColor(0, 0, 0, 0);
  this._framebuffer.attach(this._forcePrevTex);
  renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
  this._framebuffer.attach(this._globalSpeedPrevTex);
  renderer.gl.clear(renderer.gl.COLOR_BUFFER_BIT);
  this._framebuffer.unbind(renderer);
};
ForceAtlas2GPU.prototype._resize = function(width, height) {
  ["_positionSourceTex", "_positionTex", "_positionPrevTex", "_forceTex", "_forcePrevTex"].forEach(function(texName) {
    this[texName].width = width;
    this[texName].height = height;
    this[texName].dirty();
  }, this);
};
ForceAtlas2GPU.prototype.dispose = function(renderer) {
  this._framebuffer.dispose(renderer);
  this._copyPass.dispose(renderer);
  this._nodeRepulsionPass.dispose(renderer);
  this._positionPass.dispose(renderer);
  this._globalSpeedPass.dispose(renderer);
  this._edgeForceMesh.geometry.dispose(renderer);
  this._weightedSumMesh.geometry.dispose(renderer);
  this._positionSourceTex.dispose(renderer);
  this._positionTex.dispose(renderer);
  this._positionPrevTex.dispose(renderer);
  this._forceTex.dispose(renderer);
  this._forcePrevTex.dispose(renderer);
  this._weightedSumTex.dispose(renderer);
  this._globalSpeedTex.dispose(renderer);
  this._globalSpeedPrevTex.dispose(renderer);
};
function forceAtlas2Worker() {
  var vec22 = {
    create: function() {
      return new Float32Array(2);
    },
    dist: function(a, b) {
      var x = b[0] - a[0];
      var y = b[1] - a[1];
      return Math.sqrt(x * x + y * y);
    },
    len: function(a) {
      var x = a[0];
      var y = a[1];
      return Math.sqrt(x * x + y * y);
    },
    scaleAndAdd: function(out2, a, b, scale2) {
      out2[0] = a[0] + b[0] * scale2;
      out2[1] = a[1] + b[1] * scale2;
      return out2;
    },
    scale: function(out2, a, b) {
      out2[0] = a[0] * b;
      out2[1] = a[1] * b;
      return out2;
    },
    add: function(out2, a, b) {
      out2[0] = a[0] + b[0];
      out2[1] = a[1] + b[1];
      return out2;
    },
    sub: function(out2, a, b) {
      out2[0] = a[0] - b[0];
      out2[1] = a[1] - b[1];
      return out2;
    },
    normalize: function(out2, a) {
      var x = a[0];
      var y = a[1];
      var len2 = x * x + y * y;
      if (len2 > 0) {
        len2 = 1 / Math.sqrt(len2);
        out2[0] = a[0] * len2;
        out2[1] = a[1] * len2;
      }
      return out2;
    },
    negate: function(out2, a) {
      out2[0] = -a[0];
      out2[1] = -a[1];
      return out2;
    },
    copy: function(out2, a) {
      out2[0] = a[0];
      out2[1] = a[1];
      return out2;
    },
    set: function(out2, x, y) {
      out2[0] = x;
      out2[1] = y;
      return out2;
    }
  };
  function Region2() {
    this.subRegions = [];
    this.nSubRegions = 0;
    this.node = null;
    this.mass = 0;
    this.centerOfMass = null;
    this.bbox = new Float32Array(4);
    this.size = 0;
  }
  var regionProto = Region2.prototype;
  regionProto.beforeUpdate = function() {
    for (var i = 0; i < this.nSubRegions; i++) {
      this.subRegions[i].beforeUpdate();
    }
    this.mass = 0;
    if (this.centerOfMass) {
      this.centerOfMass[0] = 0;
      this.centerOfMass[1] = 0;
    }
    this.nSubRegions = 0;
    this.node = null;
  };
  regionProto.afterUpdate = function() {
    this.subRegions.length = this.nSubRegions;
    for (var i = 0; i < this.nSubRegions; i++) {
      this.subRegions[i].afterUpdate();
    }
  };
  regionProto.addNode = function(node) {
    if (this.nSubRegions === 0) {
      if (this.node == null) {
        this.node = node;
        return;
      } else {
        this._addNodeToSubRegion(this.node);
        this.node = null;
      }
    }
    this._addNodeToSubRegion(node);
    this._updateCenterOfMass(node);
  };
  regionProto.findSubRegion = function(x, y) {
    for (var i = 0; i < this.nSubRegions; i++) {
      var region = this.subRegions[i];
      if (region.contain(x, y)) {
        return region;
      }
    }
  };
  regionProto.contain = function(x, y) {
    return this.bbox[0] <= x && this.bbox[2] >= x && this.bbox[1] <= y && this.bbox[3] >= y;
  };
  regionProto.setBBox = function(minX, minY, maxX, maxY) {
    this.bbox[0] = minX;
    this.bbox[1] = minY;
    this.bbox[2] = maxX;
    this.bbox[3] = maxY;
    this.size = (maxX - minX + maxY - minY) / 2;
  };
  regionProto._newSubRegion = function() {
    var subRegion = this.subRegions[this.nSubRegions];
    if (!subRegion) {
      subRegion = new Region2();
      this.subRegions[this.nSubRegions] = subRegion;
    }
    this.nSubRegions++;
    return subRegion;
  };
  regionProto._addNodeToSubRegion = function(node) {
    var subRegion = this.findSubRegion(node.position[0], node.position[1]);
    var bbox = this.bbox;
    if (!subRegion) {
      var cx = (bbox[0] + bbox[2]) / 2;
      var cy = (bbox[1] + bbox[3]) / 2;
      var w = (bbox[2] - bbox[0]) / 2;
      var h = (bbox[3] - bbox[1]) / 2;
      var xi = node.position[0] >= cx ? 1 : 0;
      var yi = node.position[1] >= cy ? 1 : 0;
      var subRegion = this._newSubRegion();
      subRegion.setBBox(xi * w + bbox[0], yi * h + bbox[1], (xi + 1) * w + bbox[0], (yi + 1) * h + bbox[1]);
    }
    subRegion.addNode(node);
  };
  regionProto._updateCenterOfMass = function(node) {
    if (this.centerOfMass == null) {
      this.centerOfMass = new Float32Array(2);
    }
    var x = this.centerOfMass[0] * this.mass;
    var y = this.centerOfMass[1] * this.mass;
    x += node.position[0] * node.mass;
    y += node.position[1] * node.mass;
    this.mass += node.mass;
    this.centerOfMass[0] = x / this.mass;
    this.centerOfMass[1] = y / this.mass;
  };
  function GraphNode2() {
    this.position = new Float32Array(2);
    this.force = vec22.create();
    this.forcePrev = vec22.create();
    this.mass = 1;
    this.inDegree = 0;
    this.outDegree = 0;
  }
  function GraphEdge2(source, target) {
    this.source = source;
    this.target = target;
    this.weight = 1;
  }
  function ForceAtlas22() {
    this.autoSettings = true;
    this.barnesHutOptimize = true;
    this.barnesHutTheta = 1.5;
    this.repulsionByDegree = true;
    this.linLogMode = false;
    this.strongGravityMode = false;
    this.gravity = 1;
    this.scaling = 1;
    this.edgeWeightInfluence = 1;
    this.jitterTolerence = 0.1;
    this.preventOverlap = false;
    this.dissuadeHubs = false;
    this.rootRegion = new Region2();
    this.rootRegion.centerOfMass = vec22.create();
    this.nodes = [];
    this.edges = [];
    this.bbox = new Float32Array(4);
    this.gravityCenter = null;
    this._massArr = null;
    this._swingingArr = null;
    this._sizeArr = null;
    this._globalSpeed = 0;
  }
  var forceAtlas2Proto = ForceAtlas22.prototype;
  forceAtlas2Proto.initNodes = function(positionArr, massArr, sizeArr) {
    var nNodes = massArr.length;
    this.nodes.length = 0;
    var haveSize = typeof sizeArr != "undefined";
    for (var i = 0; i < nNodes; i++) {
      var node = new GraphNode2();
      node.position[0] = positionArr[i * 2];
      node.position[1] = positionArr[i * 2 + 1];
      node.mass = massArr[i];
      if (haveSize) {
        node.size = sizeArr[i];
      }
      this.nodes.push(node);
    }
    this._massArr = massArr;
    this._swingingArr = new Float32Array(nNodes);
    if (haveSize) {
      this._sizeArr = sizeArr;
    }
  };
  forceAtlas2Proto.initEdges = function(edgeArr, edgeWeightArr) {
    var nEdges = edgeArr.length / 2;
    this.edges.length = 0;
    for (var i = 0; i < nEdges; i++) {
      var sIdx = edgeArr[i * 2];
      var tIdx = edgeArr[i * 2 + 1];
      var sNode = this.nodes[sIdx];
      var tNode = this.nodes[tIdx];
      if (!sNode || !tNode) {
        console.error("Node not exists, try initNodes before initEdges");
        return;
      }
      sNode.outDegree++;
      tNode.inDegree++;
      var edge = new GraphEdge2(sNode, tNode);
      if (edgeWeightArr) {
        edge.weight = edgeWeightArr[i];
      }
      this.edges.push(edge);
    }
  };
  forceAtlas2Proto.updateSettings = function() {
    if (this.repulsionByDegree) {
      for (var i = 0; i < this.nodes.length; i++) {
        var node = this.nodes[i];
        node.mass = node.inDegree + node.outDegree + 1;
      }
    } else {
      for (var i = 0; i < this.nodes.length; i++) {
        var node = this.nodes[i];
        node.mass = this._massArr[i];
      }
    }
  };
  forceAtlas2Proto.update = function() {
    var nNodes = this.nodes.length;
    this.updateSettings();
    this.updateBBox();
    if (this.barnesHutOptimize) {
      this.rootRegion.setBBox(this.bbox[0], this.bbox[1], this.bbox[2], this.bbox[3]);
      this.rootRegion.beforeUpdate();
      for (var i = 0; i < nNodes; i++) {
        this.rootRegion.addNode(this.nodes[i]);
      }
      this.rootRegion.afterUpdate();
    }
    for (var i = 0; i < nNodes; i++) {
      var node = this.nodes[i];
      vec22.copy(node.forcePrev, node.force);
      vec22.set(node.force, 0, 0);
    }
    for (var i = 0; i < nNodes; i++) {
      var na = this.nodes[i];
      if (this.barnesHutOptimize) {
        this.applyRegionToNodeRepulsion(this.rootRegion, na);
      } else {
        for (var j = i + 1; j < nNodes; j++) {
          var nb = this.nodes[j];
          this.applyNodeToNodeRepulsion(na, nb, false);
        }
      }
      if (this.gravity > 0) {
        if (this.strongGravityMode) {
          this.applyNodeStrongGravity(na);
        } else {
          this.applyNodeGravity(na);
        }
      }
    }
    for (var i = 0; i < this.edges.length; i++) {
      this.applyEdgeAttraction(this.edges[i]);
    }
    var swingWeightedSum = 0;
    var tractionWeightedSum = 0;
    var tmp = vec22.create();
    for (var i = 0; i < nNodes; i++) {
      var node = this.nodes[i];
      var swing = vec22.dist(node.force, node.forcePrev);
      swingWeightedSum += swing * node.mass;
      vec22.add(tmp, node.force, node.forcePrev);
      var traction = vec22.len(tmp) * 0.5;
      tractionWeightedSum += traction * node.mass;
      this._swingingArr[i] = swing;
    }
    var globalSpeed = this.jitterTolerence * this.jitterTolerence * tractionWeightedSum / swingWeightedSum;
    if (this._globalSpeed > 0) {
      globalSpeed = Math.min(globalSpeed / this._globalSpeed, 1.5) * this._globalSpeed;
    }
    this._globalSpeed = globalSpeed;
    for (var i = 0; i < nNodes; i++) {
      var node = this.nodes[i];
      var swing = this._swingingArr[i];
      var speed = 0.1 * globalSpeed / (1 + globalSpeed * Math.sqrt(swing));
      var df = vec22.len(node.force);
      if (df > 0) {
        speed = Math.min(df * speed, 10) / df;
        vec22.scaleAndAdd(node.position, node.position, node.force, speed);
      }
    }
  };
  forceAtlas2Proto.applyRegionToNodeRepulsion = function() {
    var v = vec22.create();
    return function applyRegionToNodeRepulsion(region, node) {
      if (region.node) {
        this.applyNodeToNodeRepulsion(region.node, node, true);
      } else {
        vec22.sub(v, node.position, region.centerOfMass);
        var d2 = v[0] * v[0] + v[1] * v[1];
        if (d2 > this.barnesHutTheta * region.size * region.size) {
          var factor = this.scaling * node.mass * region.mass / d2;
          vec22.scaleAndAdd(node.force, node.force, v, factor);
        } else {
          for (var i = 0; i < region.nSubRegions; i++) {
            this.applyRegionToNodeRepulsion(region.subRegions[i], node);
          }
        }
      }
    };
  }();
  forceAtlas2Proto.applyNodeToNodeRepulsion = function() {
    var v = vec22.create();
    return function applyNodeToNodeRepulsion(na, nb, oneWay) {
      if (na == nb) {
        return;
      }
      vec22.sub(v, na.position, nb.position);
      var d2 = v[0] * v[0] + v[1] * v[1];
      if (d2 === 0) {
        return;
      }
      var factor;
      if (this.preventOverlap) {
        var d = Math.sqrt(d2);
        d = d - na.size - nb.size;
        if (d > 0) {
          factor = this.scaling * na.mass * nb.mass / (d * d);
        } else if (d < 0) {
          factor = this.scaling * 100 * na.mass * nb.mass;
        } else {
          return;
        }
      } else {
        factor = this.scaling * na.mass * nb.mass / d2;
      }
      vec22.scaleAndAdd(na.force, na.force, v, factor);
      vec22.scaleAndAdd(nb.force, nb.force, v, -factor);
    };
  }();
  forceAtlas2Proto.applyEdgeAttraction = function() {
    var v = vec22.create();
    return function applyEdgeAttraction(edge) {
      var na = edge.source;
      var nb = edge.target;
      vec22.sub(v, na.position, nb.position);
      var d = vec22.len(v);
      var w;
      if (this.edgeWeightInfluence === 0) {
        w = 1;
      } else if (this.edgeWeightInfluence === 1) {
        w = edge.weight;
      } else {
        w = Math.pow(edge.weight, this.edgeWeightInfluence);
      }
      var factor;
      if (this.preventOverlap) {
        d = d - na.size - nb.size;
        if (d <= 0) {
          return;
        }
      }
      if (this.linLogMode) {
        factor = -w * Math.log(d + 1) / (d + 1);
      } else {
        factor = -w;
      }
      vec22.scaleAndAdd(na.force, na.force, v, factor);
      vec22.scaleAndAdd(nb.force, nb.force, v, -factor);
    };
  }();
  forceAtlas2Proto.applyNodeGravity = function() {
    var v = vec22.create();
    return function(node) {
      vec22.sub(v, this.gravityCenter, node.position);
      var d = vec22.len(v);
      vec22.scaleAndAdd(node.force, node.force, v, this.gravity * node.mass / (d + 1));
    };
  }();
  forceAtlas2Proto.applyNodeStrongGravity = function() {
    var v = vec22.create();
    return function(node) {
      vec22.sub(v, this.gravityCenter, node.position);
      vec22.scaleAndAdd(node.force, node.force, v, this.gravity * node.mass);
    };
  }();
  forceAtlas2Proto.updateBBox = function() {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;
    for (var i = 0; i < this.nodes.length; i++) {
      var pos = this.nodes[i].position;
      minX = Math.min(minX, pos[0]);
      minY = Math.min(minY, pos[1]);
      maxX = Math.max(maxX, pos[0]);
      maxY = Math.max(maxY, pos[1]);
    }
    this.bbox[0] = minX;
    this.bbox[1] = minY;
    this.bbox[2] = maxX;
    this.bbox[3] = maxY;
  };
  forceAtlas2Proto.getGlobalSpeed = function() {
    return this._globalSpeed;
  };
  var forceAtlas2 = null;
  self.onmessage = function(e2) {
    switch (e2.data.cmd) {
      case "init":
        forceAtlas2 = new ForceAtlas22();
        forceAtlas2.initNodes(e2.data.nodesPosition, e2.data.nodesMass, e2.data.nodesSize);
        forceAtlas2.initEdges(e2.data.edges, e2.data.edgesWeight);
        break;
      case "updateConfig":
        if (forceAtlas2) {
          for (var name in e2.data.config) {
            forceAtlas2[name] = e2.data.config[name];
          }
        }
        break;
      case "update":
        var steps = e2.data.steps;
        if (forceAtlas2) {
          for (var i = 0; i < steps; i++) {
            forceAtlas2.update();
          }
          var nNodes = forceAtlas2.nodes.length;
          var positionArr = new Float32Array(nNodes * 2);
          for (var i = 0; i < nNodes; i++) {
            var node = forceAtlas2.nodes[i];
            positionArr[i * 2] = node.position[0];
            positionArr[i * 2 + 1] = node.position[1];
          }
          self.postMessage({
            buffer: positionArr.buffer,
            globalSpeed: forceAtlas2.getGlobalSpeed()
          }, [positionArr.buffer]);
        } else {
          var emptyArr = new Float32Array();
          self.postMessage({
            buffer: emptyArr.buffer,
            globalSpeed: forceAtlas2.getGlobalSpeed()
          }, [emptyArr.buffer]);
        }
        break;
    }
  };
}
var workerUrl = forceAtlas2Worker.toString();
workerUrl = workerUrl.slice(workerUrl.indexOf("{") + 1, workerUrl.lastIndexOf("}"));
var defaultConfigs = {
  barnesHutOptimize: true,
  barnesHutTheta: 1.5,
  repulsionByDegree: true,
  linLogMode: false,
  strongGravityMode: false,
  gravity: 1,
  scaling: 1,
  edgeWeightInfluence: 1,
  jitterTolerence: 0.1,
  preventOverlap: false,
  dissuadeHubs: false,
  gravityCenter: null
};
var ForceAtlas2 = function(options) {
  for (var name in defaultConfigs) {
    this[name] = defaultConfigs[name];
  }
  if (options) {
    for (var name in options) {
      this[name] = options[name];
    }
  }
  this._nodes = [];
  this._edges = [];
  this._disposed = false;
  this._positionTex = new Texture2D$1({
    type: Texture$1.FLOAT,
    flipY: false,
    minFilter: Texture$1.NEAREST,
    magFilter: Texture$1.NEAREST
  });
};
ForceAtlas2.prototype.initData = function(nodes, edges) {
  var bb = new Blob([workerUrl]);
  var blobURL = window.URL.createObjectURL(bb);
  this._worker = new Worker(blobURL);
  this._worker.onmessage = this._$onupdate.bind(this);
  this._nodes = nodes;
  this._edges = edges;
  this._frame = 0;
  var nNodes = nodes.length;
  var nEdges = edges.length;
  var positionArr = new Float32Array(nNodes * 2);
  var massArr = new Float32Array(nNodes);
  var sizeArr = new Float32Array(nNodes);
  var edgeArr = new Float32Array(nEdges * 2);
  var edgeWeightArr = new Float32Array(nEdges);
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    positionArr[i * 2] = node.x;
    positionArr[i * 2 + 1] = node.y;
    massArr[i] = node.mass == null ? 1 : node.mass;
    sizeArr[i] = node.size == null ? 1 : node.size;
  }
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var source = edge.node1;
    var target = edge.node2;
    edgeArr[i * 2] = source;
    edgeArr[i * 2 + 1] = target;
    edgeWeightArr[i] = edge.weight == null ? 1 : edge.weight;
  }
  var textureWidth = Math.ceil(Math.sqrt(nodes.length));
  var textureHeight = textureWidth;
  var pixels = new Float32Array(textureWidth * textureHeight * 4);
  var positionTex = this._positionTex;
  positionTex.width = textureWidth;
  positionTex.height = textureHeight;
  positionTex.pixels = pixels;
  this._worker.postMessage({
    cmd: "init",
    nodesPosition: positionArr,
    nodesMass: massArr,
    nodesSize: sizeArr,
    edges: edgeArr,
    edgesWeight: edgeWeightArr
  });
  this._globalSpeed = Infinity;
};
ForceAtlas2.prototype.updateOption = function(options) {
  var config = {};
  for (var name in defaultConfigs) {
    config[name] = defaultConfigs[name];
  }
  var nodes = this._nodes;
  var edges = this._edges;
  var nNodes = nodes.length;
  if (nNodes > 5e4) {
    config.jitterTolerence = 10;
  } else if (nNodes > 5e3) {
    config.jitterTolerence = 1;
  } else {
    config.jitterTolerence = 0.1;
  }
  if (nNodes > 100) {
    config.scaling = 2;
  } else {
    config.scaling = 10;
  }
  if (nNodes > 1e3) {
    config.barnesHutOptimize = true;
  } else {
    config.barnesHutOptimize = false;
  }
  if (options) {
    for (var name in defaultConfigs) {
      if (options[name] != null) {
        config[name] = options[name];
      }
    }
  }
  if (!config.gravityCenter) {
    var min3 = [Infinity, Infinity];
    var max3 = [-Infinity, -Infinity];
    for (var i = 0; i < nodes.length; i++) {
      min3[0] = Math.min(nodes[i].x, min3[0]);
      min3[1] = Math.min(nodes[i].y, min3[1]);
      max3[0] = Math.max(nodes[i].x, max3[0]);
      max3[1] = Math.max(nodes[i].y, max3[1]);
    }
    config.gravityCenter = [(min3[0] + max3[0]) * 0.5, (min3[1] + max3[1]) * 0.5];
  }
  for (var i = 0; i < edges.length; i++) {
    var node1 = edges[i].node1;
    var node2 = edges[i].node2;
    nodes[node1].degree = (nodes[node1].degree || 0) + 1;
    nodes[node2].degree = (nodes[node2].degree || 0) + 1;
  }
  if (this._worker) {
    this._worker.postMessage({
      cmd: "updateConfig",
      config
    });
  }
};
ForceAtlas2.prototype.update = function(renderer, steps, cb) {
  if (steps == null) {
    steps = 1;
  }
  steps = Math.max(steps, 1);
  this._frame += steps;
  this._onupdate = cb;
  if (this._worker) {
    this._worker.postMessage({
      cmd: "update",
      steps: Math.round(steps)
    });
  }
};
ForceAtlas2.prototype._$onupdate = function(e2) {
  if (this._disposed) {
    return;
  }
  var positionArr = new Float32Array(e2.data.buffer);
  this._globalSpeed = e2.data.globalSpeed;
  this._positionArr = positionArr;
  this._updateTexture(positionArr);
  this._onupdate && this._onupdate();
};
ForceAtlas2.prototype.getNodePositionTexture = function() {
  return this._positionTex;
};
ForceAtlas2.prototype.getNodeUV = function(nodeIndex, uv) {
  uv = uv || [];
  var textureWidth = this._positionTex.width;
  var textureHeight = this._positionTex.height;
  uv[0] = nodeIndex % textureWidth / (textureWidth - 1);
  uv[1] = Math.floor(nodeIndex / textureWidth) / (textureHeight - 1);
  return uv;
};
ForceAtlas2.prototype.getNodes = function() {
  return this._nodes;
};
ForceAtlas2.prototype.getEdges = function() {
  return this._edges;
};
ForceAtlas2.prototype.isFinished = function(maxSteps) {
  return this._frame > maxSteps;
};
ForceAtlas2.prototype.getNodePosition = function(renderer, out2) {
  if (!out2) {
    out2 = new Float32Array(this._nodes.length * 2);
  }
  if (this._positionArr) {
    for (var i = 0; i < this._positionArr.length; i++) {
      out2[i] = this._positionArr[i];
    }
  }
  return out2;
};
ForceAtlas2.prototype._updateTexture = function(positionArr) {
  var pixels = this._positionTex.pixels;
  var offset = 0;
  for (var i = 0; i < positionArr.length; ) {
    pixels[offset++] = positionArr[i++];
    pixels[offset++] = positionArr[i++];
    pixels[offset++] = 1;
    pixels[offset++] = 1;
  }
  this._positionTex.dirty();
};
ForceAtlas2.prototype.dispose = function(renderer) {
  this._disposed = true;
  this._worker = null;
};
var ForceAtlas2$1 = ForceAtlas2;
var Roam2DControl = Base$1.extend(function() {
  return {
    zr: null,
    viewGL: null,
    minZoom: 0.2,
    maxZoom: 5,
    _needsUpdate: false,
    _dx: 0,
    _dy: 0,
    _zoom: 1
  };
}, function() {
  this._mouseDownHandler = this._mouseDownHandler.bind(this);
  this._mouseWheelHandler = this._mouseWheelHandler.bind(this);
  this._mouseMoveHandler = this._mouseMoveHandler.bind(this);
  this._mouseUpHandler = this._mouseUpHandler.bind(this);
  this._update = this._update.bind(this);
}, {
  init: function() {
    var zr = this.zr;
    zr.on("mousedown", this._mouseDownHandler);
    zr.on("mousewheel", this._mouseWheelHandler);
    zr.on("globalout", this._mouseUpHandler);
    zr.animation.on("frame", this._update);
  },
  setTarget: function(target) {
    this._target = target;
  },
  setZoom: function(zoom) {
    this._zoom = Math.max(Math.min(zoom, this.maxZoom), this.minZoom);
    this._needsUpdate = true;
  },
  setOffset: function(offset) {
    this._dx = offset[0];
    this._dy = offset[1];
    this._needsUpdate = true;
  },
  getZoom: function() {
    return this._zoom;
  },
  getOffset: function() {
    return [this._dx, this._dy];
  },
  _update: function() {
    if (!this._target) {
      return;
    }
    if (!this._needsUpdate) {
      return;
    }
    var target = this._target;
    var scale2 = this._zoom;
    target.position.x = this._dx;
    target.position.y = this._dy;
    target.scale.set(scale2, scale2, scale2);
    this.zr.refresh();
    this._needsUpdate = false;
    this.trigger("update");
  },
  _mouseDownHandler: function(e2) {
    if (e2.target) {
      return;
    }
    var x = e2.offsetX;
    var y = e2.offsetY;
    if (this.viewGL && !this.viewGL.containPoint(x, y)) {
      return;
    }
    this.zr.on("mousemove", this._mouseMoveHandler);
    this.zr.on("mouseup", this._mouseUpHandler);
    var pos = this._convertPos(x, y);
    this._x = pos.x;
    this._y = pos.y;
  },
  _convertPos: function(x, y) {
    var camera2 = this.viewGL.camera;
    var viewport = this.viewGL.viewport;
    return {
      x: (x - viewport.x) / viewport.width * (camera2.right - camera2.left) + camera2.left,
      y: (y - viewport.y) / viewport.height * (camera2.bottom - camera2.top) + camera2.top
    };
  },
  _mouseMoveHandler: function(e2) {
    var pos = this._convertPos(e2.offsetX, e2.offsetY);
    this._dx += pos.x - this._x;
    this._dy += pos.y - this._y;
    this._x = pos.x;
    this._y = pos.y;
    this._needsUpdate = true;
  },
  _mouseUpHandler: function(e2) {
    this.zr.off("mousemove", this._mouseMoveHandler);
    this.zr.off("mouseup", this._mouseUpHandler);
  },
  _mouseWheelHandler: function(e2) {
    e2 = e2.event;
    var delta = e2.wheelDelta || -e2.detail;
    if (delta === 0) {
      return;
    }
    var x = e2.offsetX;
    var y = e2.offsetY;
    if (this.viewGL && !this.viewGL.containPoint(x, y)) {
      return;
    }
    var zoomScale = delta > 0 ? 1.1 : 0.9;
    var newZoom = Math.max(Math.min(this._zoom * zoomScale, this.maxZoom), this.minZoom);
    zoomScale = newZoom / this._zoom;
    var pos = this._convertPos(x, y);
    var fixX = (pos.x - this._dx) * (zoomScale - 1);
    var fixY = (pos.y - this._dy) * (zoomScale - 1);
    this._dx -= fixX;
    this._dy -= fixY;
    this._zoom = newZoom;
    this._needsUpdate = true;
  },
  dispose: function() {
    var zr = this.zr;
    zr.off("mousedown", this._mouseDownHandler);
    zr.off("mousemove", this._mouseMoveHandler);
    zr.off("mouseup", this._mouseUpHandler);
    zr.off("mousewheel", this._mouseWheelHandler);
    zr.off("globalout", this._mouseUpHandler);
    zr.animation.off("frame", this._update);
  }
});
var Roam2DControl$1 = Roam2DControl;
var lines2DGLSL = "@export ecgl.lines2D.vertex\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nattribute vec2 position: POSITION;\nattribute vec4 a_Color : COLOR;\nvarying vec4 v_Color;\n\n#ifdef POSITIONTEXTURE_ENABLED\nuniform sampler2D positionTexture;\n#endif\n\nvoid main()\n{\n gl_Position = worldViewProjection * vec4(position, -10.0, 1.0);\n\n v_Color = a_Color;\n}\n\n@end\n\n@export ecgl.lines2D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\n\nvoid main()\n{\n gl_FragColor = color * v_Color;\n}\n@end\n\n\n@export ecgl.meshLines2D.vertex\n\nattribute vec2 position: POSITION;\nattribute vec2 normal;\nattribute float offset;\nattribute vec4 a_Color : COLOR;\n\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\nuniform vec4 viewport : VIEWPORT;\n\nvarying vec4 v_Color;\nvarying float v_Miter;\n\nvoid main()\n{\n vec4 p2 = worldViewProjection * vec4(position + normal, -10.0, 1.0);\n gl_Position = worldViewProjection * vec4(position, -10.0, 1.0);\n\n p2.xy /= p2.w;\n gl_Position.xy /= gl_Position.w;\n\n vec2 N = normalize(p2.xy - gl_Position.xy);\n gl_Position.xy += N * offset / viewport.zw * 2.0;\n\n gl_Position.xy *= gl_Position.w;\n\n v_Color = a_Color;\n}\n@end\n\n\n@export ecgl.meshLines2D.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\n\nvarying vec4 v_Color;\nvarying float v_Miter;\n\nvoid main()\n{\n gl_FragColor = color * v_Color;\n}\n\n@end";
var vec2 = glmatrix.vec2;
graphicGL$1.Shader.import(lines2DGLSL);
var globalLayoutId = 1;
var GraphGLView = ChartView$1.extend({
  type: "graphGL",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this.viewGL = new ViewGL("orthographic");
    this.viewGL.camera.left = this.viewGL.camera.right = 0;
    this.viewGL.add(this.groupGL);
    this._pointsBuilder = new PointsBuilder(true, api);
    this._forceEdgesMesh = new graphicGL$1.Mesh({
      material: new graphicGL$1.Material({
        shader: graphicGL$1.createShader("ecgl.forceAtlas2.edges"),
        transparent: true,
        depthMask: false,
        depthTest: false
      }),
      $ignorePicking: true,
      geometry: new graphicGL$1.Geometry({
        attributes: {
          node: new graphicGL$1.Geometry.Attribute("node", "float", 2),
          color: new graphicGL$1.Geometry.Attribute("color", "float", 4, "COLOR")
        },
        dynamic: true,
        mainAttribute: "node"
      }),
      renderOrder: -1,
      mode: graphicGL$1.Mesh.LINES
    });
    this._edgesMesh = new graphicGL$1.Mesh({
      material: new graphicGL$1.Material({
        shader: graphicGL$1.createShader("ecgl.meshLines2D"),
        transparent: true,
        depthMask: false,
        depthTest: false
      }),
      $ignorePicking: true,
      geometry: new Lines2DGeometry({
        useNativeLine: false,
        dynamic: true
      }),
      renderOrder: -1,
      culling: false
    });
    this._layoutId = 0;
    this._control = new Roam2DControl$1({
      zr: api.getZr(),
      viewGL: this.viewGL
    });
    this._control.setTarget(this.groupGL);
    this._control.init();
    this._clickHandler = this._clickHandler.bind(this);
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.add(this._pointsBuilder.rootNode);
    this._model = seriesModel;
    this._api = api;
    this._initLayout(seriesModel, ecModel, api);
    this._pointsBuilder.update(seriesModel, ecModel, api);
    if (!(this._forceLayoutInstance instanceof ForceAtlas2GPU)) {
      this.groupGL.remove(this._forceEdgesMesh);
    }
    this._updateCamera(seriesModel, api);
    this._control.off("update");
    this._control.on("update", function() {
      api.dispatchAction({
        type: "graphGLRoam",
        seriesId: seriesModel.id,
        zoom: this._control.getZoom(),
        offset: this._control.getOffset()
      });
      this._pointsBuilder.updateView(this.viewGL.camera);
    }, this);
    this._control.setZoom(retrieve$1.firstNotNull(seriesModel.get("zoom"), 1));
    this._control.setOffset(seriesModel.get("offset") || [0, 0]);
    var mesh2 = this._pointsBuilder.getPointsMesh();
    mesh2.off("mousemove", this._mousemoveHandler);
    mesh2.off("mouseout", this._mouseOutHandler, this);
    api.getZr().off("click", this._clickHandler);
    this._pointsBuilder.highlightOnMouseover = true;
    if (seriesModel.get("focusNodeAdjacency")) {
      var focusNodeAdjacencyOn = seriesModel.get("focusNodeAdjacencyOn");
      if (focusNodeAdjacencyOn === "click") {
        api.getZr().on("click", this._clickHandler);
      } else if (focusNodeAdjacencyOn === "mouseover") {
        mesh2.on("mousemove", this._mousemoveHandler, this);
        mesh2.on("mouseout", this._mouseOutHandler, this);
        this._pointsBuilder.highlightOnMouseover = false;
      } else
        ;
    }
    this._lastMouseOverDataIndex = -1;
  },
  _clickHandler: function(e2) {
    if (this._layouting) {
      return;
    }
    var dataIndex = this._pointsBuilder.getPointsMesh().dataIndex;
    if (dataIndex >= 0) {
      this._api.dispatchAction({
        type: "graphGLFocusNodeAdjacency",
        seriesId: this._model.id,
        dataIndex
      });
    } else {
      this._api.dispatchAction({
        type: "graphGLUnfocusNodeAdjacency",
        seriesId: this._model.id
      });
    }
  },
  _mousemoveHandler: function(e2) {
    if (this._layouting) {
      return;
    }
    var dataIndex = this._pointsBuilder.getPointsMesh().dataIndex;
    if (dataIndex >= 0) {
      if (dataIndex !== this._lastMouseOverDataIndex) {
        this._api.dispatchAction({
          type: "graphGLFocusNodeAdjacency",
          seriesId: this._model.id,
          dataIndex
        });
      }
    } else {
      this._mouseOutHandler(e2);
    }
    this._lastMouseOverDataIndex = dataIndex;
  },
  _mouseOutHandler: function(e2) {
    if (this._layouting) {
      return;
    }
    this._api.dispatchAction({
      type: "graphGLUnfocusNodeAdjacency",
      seriesId: this._model.id
    });
    this._lastMouseOverDataIndex = -1;
  },
  _updateForceEdgesGeometry: function(edges, seriesModel) {
    var geometry = this._forceEdgesMesh.geometry;
    var edgeData = seriesModel.getEdgeData();
    var offset = 0;
    var layoutInstance = this._forceLayoutInstance;
    var vertexCount = edgeData.count() * 2;
    geometry.attributes.node.init(vertexCount);
    geometry.attributes.color.init(vertexCount);
    edgeData.each(function(idx) {
      var edge = edges[idx];
      geometry.attributes.node.set(offset, layoutInstance.getNodeUV(edge.node1));
      geometry.attributes.node.set(offset + 1, layoutInstance.getNodeUV(edge.node2));
      var color = getItemVisualColor(edgeData, edge.dataIndex);
      var colorArr = graphicGL$1.parseColor(color);
      colorArr[3] *= retrieve$1.firstNotNull(getItemVisualOpacity(edgeData, edge.dataIndex), 1);
      geometry.attributes.color.set(offset, colorArr);
      geometry.attributes.color.set(offset + 1, colorArr);
      offset += 2;
    });
    geometry.dirty();
  },
  _updateMeshLinesGeometry: function() {
    var edgeData = this._model.getEdgeData();
    var geometry = this._edgesMesh.geometry;
    var edgeData = this._model.getEdgeData();
    var points2 = this._model.getData().getLayout("points");
    geometry.resetOffset();
    geometry.setVertexCount(edgeData.count() * geometry.getLineVertexCount());
    geometry.setTriangleCount(edgeData.count() * geometry.getLineTriangleCount());
    var p02 = [];
    var p12 = [];
    var lineWidthQuery = ["lineStyle", "width"];
    this._originalEdgeColors = new Float32Array(edgeData.count() * 4);
    this._edgeIndicesMap = new Float32Array(edgeData.count());
    edgeData.each(function(idx) {
      var edge = edgeData.graph.getEdgeByIndex(idx);
      var idx1 = edge.node1.dataIndex * 2;
      var idx2 = edge.node2.dataIndex * 2;
      p02[0] = points2[idx1];
      p02[1] = points2[idx1 + 1];
      p12[0] = points2[idx2];
      p12[1] = points2[idx2 + 1];
      var color = getItemVisualColor(edgeData, edge.dataIndex);
      var colorArr = graphicGL$1.parseColor(color);
      colorArr[3] *= retrieve$1.firstNotNull(getItemVisualOpacity(edgeData, edge.dataIndex), 1);
      var itemModel = edgeData.getItemModel(edge.dataIndex);
      var lineWidth = retrieve$1.firstNotNull(itemModel.get(lineWidthQuery), 1) * this._api.getDevicePixelRatio();
      geometry.addLine(p02, p12, colorArr, lineWidth);
      for (var k = 0; k < 4; k++) {
        this._originalEdgeColors[edge.dataIndex * 4 + k] = colorArr[k];
      }
      this._edgeIndicesMap[edge.dataIndex] = idx;
    }, this);
    geometry.dirty();
  },
  _updateForceNodesGeometry: function(nodeData) {
    var pointsMesh = this._pointsBuilder.getPointsMesh();
    var pos = [];
    for (var i = 0; i < nodeData.count(); i++) {
      this._forceLayoutInstance.getNodeUV(i, pos);
      pointsMesh.geometry.attributes.position.set(i, pos);
    }
    pointsMesh.geometry.dirty("position");
  },
  _initLayout: function(seriesModel, ecModel, api) {
    var layout2 = seriesModel.get("layout");
    var graph = seriesModel.getGraph();
    var boxLayoutOption = seriesModel.getBoxLayoutParams();
    var viewport = getLayoutRect(boxLayoutOption, {
      width: api.getWidth(),
      height: api.getHeight()
    });
    if (layout2 === "force") {
      layout2 = "forceAtlas2";
    }
    this.stopLayout(seriesModel, ecModel, api, {
      beforeLayout: true
    });
    var nodeData = seriesModel.getData();
    var edgeData = seriesModel.getData();
    if (layout2 === "forceAtlas2") {
      var layoutModel = seriesModel.getModel("forceAtlas2");
      var layoutInstance = this._forceLayoutInstance;
      var nodes = [];
      var edges = [];
      var nodeDataExtent = nodeData.getDataExtent("value");
      var edgeDataExtent = edgeData.getDataExtent("value");
      var edgeWeightRange = retrieve$1.firstNotNull(layoutModel.get("edgeWeight"), 1);
      var nodeWeightRange = retrieve$1.firstNotNull(layoutModel.get("nodeWeight"), 1);
      if (typeof edgeWeightRange === "number") {
        edgeWeightRange = [edgeWeightRange, edgeWeightRange];
      }
      if (typeof nodeWeightRange === "number") {
        nodeWeightRange = [nodeWeightRange, nodeWeightRange];
      }
      var offset = 0;
      var nodesIndicesMap = {};
      var layoutPoints = new Float32Array(nodeData.count() * 2);
      graph.eachNode(function(node) {
        var dataIndex = node.dataIndex;
        var value = nodeData.get("value", dataIndex);
        var x;
        var y;
        if (nodeData.hasItemOption) {
          var itemModel = nodeData.getItemModel(dataIndex);
          x = itemModel.get("x");
          y = itemModel.get("y");
        }
        if (x == null) {
          x = viewport.x + Math.random() * viewport.width;
          y = viewport.y + Math.random() * viewport.height;
        }
        layoutPoints[offset * 2] = x;
        layoutPoints[offset * 2 + 1] = y;
        nodesIndicesMap[node.id] = offset++;
        var mass = linearMap$2(value, nodeDataExtent, nodeWeightRange);
        if (isNaN(mass)) {
          if (!isNaN(nodeWeightRange[0])) {
            mass = nodeWeightRange[0];
          } else {
            mass = 1;
          }
        }
        nodes.push({
          x,
          y,
          mass,
          size: nodeData.getItemVisual(dataIndex, "symbolSize")
        });
      });
      nodeData.setLayout("points", layoutPoints);
      graph.eachEdge(function(edge) {
        var dataIndex = edge.dataIndex;
        var value = nodeData.get("value", dataIndex);
        var weight = linearMap$2(value, edgeDataExtent, edgeWeightRange);
        if (isNaN(weight)) {
          if (!isNaN(edgeWeightRange[0])) {
            weight = edgeWeightRange[0];
          } else {
            weight = 1;
          }
        }
        edges.push({
          node1: nodesIndicesMap[edge.node1.id],
          node2: nodesIndicesMap[edge.node2.id],
          weight,
          dataIndex
        });
      });
      if (!layoutInstance) {
        var isGPU = layoutModel.get("GPU");
        if (this._forceLayoutInstance) {
          if (isGPU && !(this._forceLayoutInstance instanceof ForceAtlas2GPU) || !isGPU && !(this._forceLayoutInstance instanceof ForceAtlas2$1)) {
            this._forceLayoutInstanceToDispose = this._forceLayoutInstance;
          }
        }
        layoutInstance = this._forceLayoutInstance = isGPU ? new ForceAtlas2GPU() : new ForceAtlas2$1();
      }
      layoutInstance.initData(nodes, edges);
      layoutInstance.updateOption(layoutModel.option);
      this._updateForceEdgesGeometry(layoutInstance.getEdges(), seriesModel);
      this._updatePositionTexture();
      api.dispatchAction({
        type: "graphGLStartLayout",
        from: this.uid
      });
    } else {
      var layoutPoints = new Float32Array(nodeData.count() * 2);
      var offset = 0;
      graph.eachNode(function(node) {
        var dataIndex = node.dataIndex;
        var x;
        var y;
        if (nodeData.hasItemOption) {
          var itemModel = nodeData.getItemModel(dataIndex);
          x = itemModel.get("x");
          y = itemModel.get("y");
        }
        layoutPoints[offset++] = x;
        layoutPoints[offset++] = y;
      });
      nodeData.setLayout("points", layoutPoints);
      this._updateAfterLayout(seriesModel, ecModel, api);
    }
  },
  _updatePositionTexture: function() {
    var positionTex = this._forceLayoutInstance.getNodePositionTexture();
    this._pointsBuilder.setPositionTexture(positionTex);
    this._forceEdgesMesh.material.set("positionTex", positionTex);
  },
  startLayout: function(seriesModel, ecModel, api, payload) {
    if (payload && payload.from != null && payload.from !== this.uid) {
      return;
    }
    var viewGL = this.viewGL;
    var api = this._api;
    var layoutInstance = this._forceLayoutInstance;
    var data = this._model.getData();
    var layoutModel = this._model.getModel("forceAtlas2");
    if (!layoutInstance) {
      return;
    }
    this.groupGL.remove(this._edgesMesh);
    this.groupGL.add(this._forceEdgesMesh);
    if (!this._forceLayoutInstance) {
      return;
    }
    this._updateForceNodesGeometry(seriesModel.getData());
    this._pointsBuilder.hideLabels();
    var self2 = this;
    var layoutId = this._layoutId = globalLayoutId++;
    var maxSteps = layoutModel.getShallow("maxSteps");
    var steps = layoutModel.getShallow("steps");
    var stepsCount = 0;
    var syncStepCount = Math.max(steps * 2, 20);
    var doLayout = function(layoutId2) {
      if (layoutId2 !== self2._layoutId) {
        return;
      }
      if (layoutInstance.isFinished(maxSteps)) {
        api.dispatchAction({
          type: "graphGLStopLayout",
          from: self2.uid
        });
        api.dispatchAction({
          type: "graphGLFinishLayout",
          points: data.getLayout("points"),
          from: self2.uid
        });
        return;
      }
      layoutInstance.update(viewGL.layer.renderer, steps, function() {
        self2._updatePositionTexture();
        stepsCount += steps;
        if (stepsCount >= syncStepCount) {
          self2._syncNodePosition(seriesModel);
          stepsCount = 0;
        }
        api.getZr().refresh();
        requestAnimationFrame$2(function() {
          doLayout(layoutId2);
        });
      });
    };
    requestAnimationFrame$2(function() {
      if (self2._forceLayoutInstanceToDispose) {
        self2._forceLayoutInstanceToDispose.dispose(viewGL.layer.renderer);
        self2._forceLayoutInstanceToDispose = null;
      }
      doLayout(layoutId);
    });
    this._layouting = true;
  },
  stopLayout: function(seriesModel, ecModel, api, payload) {
    if (payload && payload.from != null && payload.from !== this.uid) {
      return;
    }
    this._layoutId = 0;
    this.groupGL.remove(this._forceEdgesMesh);
    this.groupGL.add(this._edgesMesh);
    if (!this._forceLayoutInstance) {
      return;
    }
    if (!this.viewGL.layer) {
      return;
    }
    if (!(payload && payload.beforeLayout)) {
      this._syncNodePosition(seriesModel);
      this._updateAfterLayout(seriesModel, ecModel, api);
    }
    this._api.getZr().refresh();
    this._layouting = false;
  },
  _syncNodePosition: function(seriesModel) {
    var points2 = this._forceLayoutInstance.getNodePosition(this.viewGL.layer.renderer);
    seriesModel.getData().setLayout("points", points2);
    seriesModel.setNodePosition(points2);
  },
  _updateAfterLayout: function(seriesModel, ecModel, api) {
    this._updateMeshLinesGeometry();
    this._pointsBuilder.removePositionTexture();
    this._pointsBuilder.updateLayout(seriesModel, ecModel, api);
    this._pointsBuilder.updateView(this.viewGL.camera);
    this._pointsBuilder.updateLabels();
    this._pointsBuilder.showLabels();
  },
  focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
    var data = this._model.getData();
    this._downplayAll();
    var dataIndex = payload.dataIndex;
    var graph = data.graph;
    var focusNodes = [];
    var node = graph.getNodeByIndex(dataIndex);
    focusNodes.push(node);
    node.edges.forEach(function(edge) {
      if (edge.dataIndex < 0) {
        return;
      }
      edge.node1 !== node && focusNodes.push(edge.node1);
      edge.node2 !== node && focusNodes.push(edge.node2);
    }, this);
    this._pointsBuilder.fadeOutAll(0.05);
    this._fadeOutEdgesAll(0.05);
    focusNodes.forEach(function(node2) {
      this._pointsBuilder.highlight(data, node2.dataIndex);
    }, this);
    this._pointsBuilder.updateLabels(focusNodes.map(function(node2) {
      return node2.dataIndex;
    }));
    var focusEdges = [];
    node.edges.forEach(function(edge) {
      if (edge.dataIndex >= 0) {
        this._highlightEdge(edge.dataIndex);
        focusEdges.push(edge);
      }
    }, this);
    this._focusNodes = focusNodes;
    this._focusEdges = focusEdges;
  },
  unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
    this._downplayAll();
    this._pointsBuilder.fadeInAll();
    this._fadeInEdgesAll();
    this._pointsBuilder.updateLabels();
  },
  _highlightEdge: function(dataIndex) {
    var itemModel = this._model.getEdgeData().getItemModel(dataIndex);
    var emphasisColor = graphicGL$1.parseColor(itemModel.get("emphasis.lineStyle.color") || itemModel.get("lineStyle.color"));
    var emphasisOpacity = retrieve$1.firstNotNull(itemModel.get("emphasis.lineStyle.opacity"), itemModel.get("lineStyle.opacity"), 1);
    emphasisColor[3] *= emphasisOpacity;
    this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], emphasisColor);
  },
  _downplayAll: function() {
    if (this._focusNodes) {
      this._focusNodes.forEach(function(node) {
        this._pointsBuilder.downplay(this._model.getData(), node.dataIndex);
      }, this);
    }
    if (this._focusEdges) {
      this._focusEdges.forEach(function(edge) {
        this._downplayEdge(edge.dataIndex);
      }, this);
    }
  },
  _downplayEdge: function(dataIndex) {
    var color = this._getColor(dataIndex, []);
    this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], color);
  },
  _setEdgeFade: function() {
    var color = [];
    return function(dataIndex, percent) {
      this._getColor(dataIndex, color);
      color[3] *= percent;
      this._edgesMesh.geometry.setItemColor(this._edgeIndicesMap[dataIndex], color);
    };
  }(),
  _getColor: function(dataIndex, out2) {
    for (var i = 0; i < 4; i++) {
      out2[i] = this._originalEdgeColors[dataIndex * 4 + i];
    }
    return out2;
  },
  _fadeOutEdgesAll: function(percent) {
    var graph = this._model.getData().graph;
    graph.eachEdge(function(edge) {
      this._setEdgeFade(edge.dataIndex, percent);
    }, this);
  },
  _fadeInEdgesAll: function() {
    this._fadeOutEdgesAll(1);
  },
  _updateCamera: function(seriesModel, api) {
    this.viewGL.setViewport(0, 0, api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
    var camera2 = this.viewGL.camera;
    var nodeData = seriesModel.getData();
    var points2 = nodeData.getLayout("points");
    var min3 = vec2.create(Infinity, Infinity);
    var max3 = vec2.create(-Infinity, -Infinity);
    var pt = [];
    for (var i = 0; i < points2.length; ) {
      pt[0] = points2[i++];
      pt[1] = points2[i++];
      vec2.min(min3, min3, pt);
      vec2.max(max3, max3, pt);
    }
    var cy = (max3[1] + min3[1]) / 2;
    var cx = (max3[0] + min3[0]) / 2;
    if (cx > camera2.left && cx < camera2.right && cy < camera2.bottom && cy > camera2.top) {
      return;
    }
    var width = Math.max(max3[0] - min3[0], 10);
    var height = width / api.getWidth() * api.getHeight();
    width *= 1.4;
    height *= 1.4;
    min3[0] -= width * 0.2;
    camera2.left = min3[0];
    camera2.top = cy - height / 2;
    camera2.bottom = cy + height / 2;
    camera2.right = width + min3[0];
    camera2.near = 0;
    camera2.far = 100;
  },
  dispose: function() {
    var renderer = this.viewGL.layer.renderer;
    if (this._forceLayoutInstance) {
      this._forceLayoutInstance.dispose(renderer);
    }
    this.groupGL.removeAll();
    this._layoutId = -1;
    this._pointsBuilder.dispose();
  },
  remove: function() {
    this.groupGL.removeAll();
    this._control.dispose();
  }
});
function normalize(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
function install$2(registers) {
  registers.registerChartView(GraphGLView);
  registers.registerSeriesModel(GraphGLSeries);
  registers.registerVisual(function(ecModel) {
    const paletteScope = {};
    ecModel.eachSeriesByType("graphGL", function(seriesModel) {
      var categoriesData = seriesModel.getCategoriesData();
      var data = seriesModel.getData();
      var categoryNameIdxMap = {};
      categoriesData.each(function(idx) {
        var name = categoriesData.getName(idx);
        categoryNameIdxMap["ec-" + name] = idx;
        var itemModel = categoriesData.getItemModel(idx);
        var style = itemModel.getModel("itemStyle").getItemStyle();
        if (!style.fill) {
          style.fill = seriesModel.getColorFromPalette(name, paletteScope);
        }
        categoriesData.setItemVisual(idx, "style", style);
        var symbolVisualList = ["symbol", "symbolSize", "symbolKeepAspect"];
        for (let i = 0; i < symbolVisualList.length; i++) {
          var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);
          if (symbolVisual != null) {
            categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
          }
        }
      });
      if (categoriesData.count()) {
        data.each(function(idx) {
          var model = data.getItemModel(idx);
          let categoryIdx = model.getShallow("category");
          if (categoryIdx != null) {
            if (typeof categoryIdx === "string") {
              categoryIdx = categoryNameIdxMap["ec-" + categoryIdx];
            }
            var categoryStyle = categoriesData.getItemVisual(categoryIdx, "style");
            var style = data.ensureUniqueItemVisual(idx, "style");
            extend$1(style, categoryStyle);
            var visualList = ["symbol", "symbolSize", "symbolKeepAspect"];
            for (let i = 0; i < visualList.length; i++) {
              data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
            }
          }
        });
      }
    });
  });
  registers.registerVisual(function(ecModel) {
    ecModel.eachSeriesByType("graphGL", function(seriesModel) {
      var graph = seriesModel.getGraph();
      var edgeData = seriesModel.getEdgeData();
      var symbolType = normalize(seriesModel.get("edgeSymbol"));
      var symbolSize = normalize(seriesModel.get("edgeSymbolSize"));
      edgeData.setVisual("drawType", "stroke");
      edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
      edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
      edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
      edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
      edgeData.setVisual("style", seriesModel.getModel("lineStyle").getLineStyle());
      edgeData.each(function(idx) {
        var itemModel = edgeData.getItemModel(idx);
        var edge = graph.getEdgeByIndex(idx);
        var symbolType2 = normalize(itemModel.getShallow("symbol", true));
        var symbolSize2 = normalize(itemModel.getShallow("symbolSize", true));
        var style = itemModel.getModel("lineStyle").getLineStyle();
        var existsStyle = edgeData.ensureUniqueItemVisual(idx, "style");
        extend$1(existsStyle, style);
        switch (existsStyle.stroke) {
          case "source": {
            var nodeStyle = edge.node1.getVisual("style");
            existsStyle.stroke = nodeStyle && nodeStyle.fill;
            break;
          }
          case "target": {
            var nodeStyle = edge.node2.getVisual("style");
            existsStyle.stroke = nodeStyle && nodeStyle.fill;
            break;
          }
        }
        symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
        symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
        symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
        symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
      });
    });
  });
  registers.registerAction({
    type: "graphGLRoam",
    event: "graphglroam",
    update: "series.graphGL:roam"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      query: payload
    }, function(componentModel) {
      componentModel.setView(payload);
    });
  });
  function noop2() {
  }
  registers.registerAction({
    type: "graphGLStartLayout",
    event: "graphgllayoutstarted",
    update: "series.graphGL:startLayout"
  }, noop2);
  registers.registerAction({
    type: "graphGLStopLayout",
    event: "graphgllayoutstopped",
    update: "series.graphGL:stopLayout"
  }, noop2);
  registers.registerAction({
    type: "graphGLFocusNodeAdjacency",
    event: "graphGLFocusNodeAdjacency",
    update: "series.graphGL:focusNodeAdjacency"
  }, noop2);
  registers.registerAction({
    type: "graphGLUnfocusNodeAdjacency",
    event: "graphGLUnfocusNodeAdjacency",
    update: "series.graphGL:unfocusNodeAdjacency"
  }, noop2);
}
use(install$2);
var FlowGLSeries = SeriesModel$1.extend({
  type: "series.flowGL",
  dependencies: ["geo", "grid", "bmap"],
  visualStyleAccessPath: "itemStyle",
  getInitialData: function(option, ecModel) {
    var coordType = this.get("coordinateSystem");
    var coordSysDimensions = coordType === "geo" ? ["lng", "lat"] : getCoordinateSystemDimensions(coordType) || ["x", "y"];
    coordSysDimensions.push("vx", "vy");
    var dimensions = createDimensions(this.getSource(), {
      coordDimensions: coordSysDimensions,
      encodeDefine: this.get("encode"),
      dimensionsDefine: this.get("dimensions")
    });
    var data = new SeriesData$1(dimensions, this);
    data.initData(this.getSource());
    return data;
  },
  defaultOption: {
    coordinateSystem: "cartesian2d",
    zlevel: 10,
    supersampling: 1,
    particleType: "point",
    particleDensity: 128,
    particleSize: 1,
    particleSpeed: 1,
    particleTrail: 2,
    colorTexture: null,
    gridWidth: "auto",
    gridHeight: "auto",
    itemStyle: {
      color: "#fff",
      opacity: 0.8
    }
  }
});
var LinesGeometry = Geometry$1.extend(function() {
  return {
    dynamic: true,
    attributes: {
      position: new Geometry$1.Attribute("position", "float", 3, "POSITION")
    }
  };
}, {
  resetOffset: function() {
    this._vertexOffset = 0;
    this._faceOffset = 0;
  },
  setLineCount: function(nLine) {
    var attributes = this.attributes;
    var nVertex = 4 * nLine;
    var nTriangle = 2 * nLine;
    if (this.vertexCount !== nVertex) {
      attributes.position.init(nVertex);
    }
    if (this.triangleCount !== nTriangle) {
      if (nTriangle === 0) {
        this.indices = null;
      } else {
        this.indices = this.vertexCount > 65535 ? new Uint32Array(nTriangle * 3) : new Uint16Array(nTriangle * 3);
      }
    }
  },
  addLine: function(p) {
    var vertexOffset = this._vertexOffset;
    this.attributes.position.set(vertexOffset, [p[0], p[1], 1]);
    this.attributes.position.set(vertexOffset + 1, [p[0], p[1], -1]);
    this.attributes.position.set(vertexOffset + 2, [p[0], p[1], 2]);
    this.attributes.position.set(vertexOffset + 3, [p[0], p[1], -2]);
    this.setTriangleIndices(this._faceOffset++, [vertexOffset, vertexOffset + 1, vertexOffset + 2]);
    this.setTriangleIndices(this._faceOffset++, [vertexOffset + 1, vertexOffset + 2, vertexOffset + 3]);
    this._vertexOffset += 4;
  }
});
var Line2DGeometry = LinesGeometry;
var vectorFieldParticleGLSL = "@export ecgl.vfParticle.particle.fragment\n\nuniform sampler2D particleTexture;\nuniform sampler2D spawnTexture;\nuniform sampler2D velocityTexture;\n\nuniform float deltaTime;\nuniform float elapsedTime;\n\nuniform float speedScaling : 1.0;\n\nuniform vec2 textureSize;\nuniform vec4 region : [0, 0, 1, 1];\nuniform float firstFrameTime;\n\nvarying vec2 v_Texcoord;\n\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, v_Texcoord);\n bool spawn = false;\n if (p.w <= 0.0) {\n p = texture2D(spawnTexture, fract(v_Texcoord + elapsedTime / 10.0));\n p.w -= firstFrameTime;\n spawn = true;\n }\n vec2 v = texture2D(velocityTexture, fract(p.xy * region.zw + region.xy)).xy;\n v = (v - 0.5) * 2.0;\n p.z = length(v);\n p.xy += v * deltaTime / 10.0 * speedScaling;\n p.w -= deltaTime;\n\n if (spawn || p.xy != fract(p.xy)) {\n p.z = 0.0;\n }\n p.xy = fract(p.xy);\n\n gl_FragColor = p;\n}\n@end\n\n@export ecgl.vfParticle.renderPoints.vertex\n\n#define PI 3.1415926\n\nattribute vec2 texcoord : TEXCOORD_0;\n\nuniform sampler2D particleTexture;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nuniform float size : 1.0;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, texcoord);\n\n if (p.w > 0.0 && p.z > 1e-5) {\n gl_Position = worldViewProjection * vec4(p.xy * 2.0 - 1.0, 0.0, 1.0);\n }\n else {\n gl_Position = vec4(100000.0, 100000.0, 100000.0, 1.0);\n }\n\n v_Mag = p.z;\n v_Uv = p.xy;\n\n gl_PointSize = size;\n}\n\n@end\n\n@export ecgl.vfParticle.renderPoints.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform sampler2D gradientTexture;\nuniform sampler2D colorTexture;\nuniform sampler2D spriteTexture;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n gl_FragColor = color;\n#ifdef SPRITETEXTURE_ENABLED\n gl_FragColor *= texture2D(spriteTexture, gl_PointCoord);\n if (color.a == 0.0) {\n discard;\n }\n#endif\n#ifdef GRADIENTTEXTURE_ENABLED\n gl_FragColor *= texture2D(gradientTexture, vec2(v_Mag, 0.5));\n#endif\n#ifdef COLORTEXTURE_ENABLED\n gl_FragColor *= texture2D(colorTexture, v_Uv);\n#endif\n}\n\n@end\n\n@export ecgl.vfParticle.renderLines.vertex\n\n#define PI 3.1415926\n\nattribute vec3 position : POSITION;\n\nuniform sampler2D particleTexture;\nuniform sampler2D prevParticleTexture;\n\nuniform float size : 1.0;\nuniform vec4 vp: VIEWPORT;\nuniform mat4 worldViewProjection : WORLDVIEWPROJECTION;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\n@import clay.util.rand\n\nvoid main()\n{\n vec4 p = texture2D(particleTexture, position.xy);\n vec4 p2 = texture2D(prevParticleTexture, position.xy);\n\n p.xy = p.xy * 2.0 - 1.0;\n p2.xy = p2.xy * 2.0 - 1.0;\n\n if (p.w > 0.0 && p.z > 1e-5) {\n vec2 dir = normalize(p.xy - p2.xy);\n vec2 norm = vec2(dir.y / vp.z, -dir.x / vp.w) * sign(position.z) * size;\n if (abs(position.z) == 2.0) {\n gl_Position = vec4(p.xy + norm, 0.0, 1.0);\n v_Uv = p.xy;\n v_Mag = p.z;\n }\n else {\n gl_Position = vec4(p2.xy + norm, 0.0, 1.0);\n v_Mag = p2.z;\n v_Uv = p2.xy;\n }\n gl_Position = worldViewProjection * gl_Position;\n }\n else {\n gl_Position = vec4(100000.0, 100000.0, 100000.0, 1.0);\n }\n}\n\n@end\n\n@export ecgl.vfParticle.renderLines.fragment\n\nuniform vec4 color : [1.0, 1.0, 1.0, 1.0];\nuniform sampler2D gradientTexture;\nuniform sampler2D colorTexture;\n\nvarying float v_Mag;\nvarying vec2 v_Uv;\n\nvoid main()\n{\n gl_FragColor = color;\n #ifdef GRADIENTTEXTURE_ENABLED\n gl_FragColor *= texture2D(gradientTexture, vec2(v_Mag, 0.5));\n#endif\n#ifdef COLORTEXTURE_ENABLED\n gl_FragColor *= texture2D(colorTexture, v_Uv);\n#endif\n}\n\n@end\n";
Shader["import"](vectorFieldParticleGLSL);
function createSpriteCanvas(size) {
  var canvas = document.createElement("canvas");
  canvas.width = canvas.height = size;
  var ctx = canvas.getContext("2d");
  ctx.fillStyle = "#fff";
  ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
  ctx.fill();
  return canvas;
}
var VectorFieldParticleSurface = function() {
  this.motionBlurFactor = 0.99;
  this.vectorFieldTexture = new Texture2D$1({
    type: Texture$1.FLOAT,
    flipY: false
  });
  this.particleLife = [5, 20];
  this._particleType = "point";
  this._particleSize = 1;
  this.particleColor = [1, 1, 1, 1];
  this.particleSpeedScaling = 1;
  this._thisFrameTexture = null;
  this._particlePass = null;
  this._spawnTexture = null;
  this._particleTexture0 = null;
  this._particleTexture1 = null;
  this._particlePointsMesh = null;
  this._surfaceFrameBuffer = null;
  this._elapsedTime = 0;
  this._scene = null;
  this._camera = null;
  this._lastFrameTexture = null;
  this._supersampling = 1;
  this._downsampleTextures = [];
  this._width = 512;
  this._height = 512;
  this.init();
};
VectorFieldParticleSurface.prototype = {
  constructor: VectorFieldParticleSurface,
  init: function() {
    var parameters = {
      type: Texture$1.FLOAT,
      minFilter: Texture$1.NEAREST,
      magFilter: Texture$1.NEAREST,
      useMipmap: false
    };
    this._spawnTexture = new Texture2D$1(parameters);
    this._particleTexture0 = new Texture2D$1(parameters);
    this._particleTexture1 = new Texture2D$1(parameters);
    this._frameBuffer = new FrameBuffer$1({
      depthBuffer: false
    });
    this._particlePass = new Pass$1({
      fragment: Shader.source("ecgl.vfParticle.particle.fragment")
    });
    this._particlePass.setUniform("velocityTexture", this.vectorFieldTexture);
    this._particlePass.setUniform("spawnTexture", this._spawnTexture);
    this._downsamplePass = new Pass$1({
      fragment: Shader.source("clay.compositor.downsample")
    });
    var particlePointsMesh = new Mesh$1({
      renderOrder: 10,
      material: new Material$1({
        shader: new Shader(Shader.source("ecgl.vfParticle.renderPoints.vertex"), Shader.source("ecgl.vfParticle.renderPoints.fragment"))
      }),
      mode: Mesh$1.POINTS,
      geometry: new Geometry$1({
        dynamic: true,
        mainAttribute: "texcoord0"
      })
    });
    var particleLinesMesh = new Mesh$1({
      renderOrder: 10,
      material: new Material$1({
        shader: new Shader(Shader.source("ecgl.vfParticle.renderLines.vertex"), Shader.source("ecgl.vfParticle.renderLines.fragment"))
      }),
      geometry: new Line2DGeometry(),
      culling: false
    });
    var lastFrameFullQuad = new Mesh$1({
      material: new Material$1({
        shader: new Shader(Shader.source("ecgl.color.vertex"), Shader.source("ecgl.color.fragment"))
      }),
      geometry: new PlaneGeometry()
    });
    lastFrameFullQuad.material.enableTexture("diffuseMap");
    this._particlePointsMesh = particlePointsMesh;
    this._particleLinesMesh = particleLinesMesh;
    this._lastFrameFullQuadMesh = lastFrameFullQuad;
    this._camera = new OrthoCamera();
    this._thisFrameTexture = new Texture2D$1();
    this._lastFrameTexture = new Texture2D$1();
  },
  setParticleDensity: function(width, height) {
    var nVertex = width * height;
    var spawnTextureData = new Float32Array(nVertex * 4);
    var off = 0;
    var lifeRange = this.particleLife;
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++, off++) {
        spawnTextureData[off * 4] = Math.random();
        spawnTextureData[off * 4 + 1] = Math.random();
        spawnTextureData[off * 4 + 2] = Math.random();
        var life = (lifeRange[1] - lifeRange[0]) * Math.random() + lifeRange[0];
        spawnTextureData[off * 4 + 3] = life;
      }
    }
    if (this._particleType === "line") {
      this._setLineGeometry(width, height);
    } else {
      this._setPointsGeometry(width, height);
    }
    this._spawnTexture.width = width;
    this._spawnTexture.height = height;
    this._spawnTexture.pixels = spawnTextureData;
    this._particleTexture0.width = this._particleTexture1.width = width;
    this._particleTexture0.height = this._particleTexture1.height = height;
    this._particlePass.setUniform("textureSize", [width, height]);
  },
  _setPointsGeometry: function(width, height) {
    var nVertex = width * height;
    var geometry = this._particlePointsMesh.geometry;
    var attributes = geometry.attributes;
    attributes.texcoord0.init(nVertex);
    var off = 0;
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++, off++) {
        attributes.texcoord0.value[off * 2] = i / width;
        attributes.texcoord0.value[off * 2 + 1] = j / height;
      }
    }
    geometry.dirty();
  },
  _setLineGeometry: function(width, height) {
    var nLine = width * height;
    var geometry = this._getParticleMesh().geometry;
    geometry.setLineCount(nLine);
    geometry.resetOffset();
    for (var i = 0; i < width; i++) {
      for (var j = 0; j < height; j++) {
        geometry.addLine([i / width, j / height]);
      }
    }
    geometry.dirty();
  },
  _getParticleMesh: function() {
    return this._particleType === "line" ? this._particleLinesMesh : this._particlePointsMesh;
  },
  update: function(renderer, api, deltaTime, firstFrame) {
    var particleMesh = this._getParticleMesh();
    var frameBuffer = this._frameBuffer;
    var particlePass = this._particlePass;
    if (firstFrame) {
      this._updateDownsampleTextures(renderer, api);
    }
    particleMesh.material.set("size", this._particleSize * this._supersampling);
    particleMesh.material.set("color", this.particleColor);
    particlePass.setUniform("speedScaling", this.particleSpeedScaling);
    frameBuffer.attach(this._particleTexture1);
    particlePass.setUniform("firstFrameTime", firstFrame ? (this.particleLife[1] + this.particleLife[0]) / 2 : 0);
    particlePass.setUniform("particleTexture", this._particleTexture0);
    particlePass.setUniform("deltaTime", deltaTime);
    particlePass.setUniform("elapsedTime", this._elapsedTime);
    particlePass.render(renderer, frameBuffer);
    particleMesh.material.set("particleTexture", this._particleTexture1);
    particleMesh.material.set("prevParticleTexture", this._particleTexture0);
    frameBuffer.attach(this._thisFrameTexture);
    frameBuffer.bind(renderer);
    renderer.gl.clear(renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT);
    var lastFrameFullQuad = this._lastFrameFullQuadMesh;
    lastFrameFullQuad.material.set("diffuseMap", this._lastFrameTexture);
    lastFrameFullQuad.material.set("color", [1, 1, 1, this.motionBlurFactor]);
    this._camera.update(true);
    renderer.renderPass([lastFrameFullQuad, particleMesh], this._camera);
    frameBuffer.unbind(renderer);
    this._downsample(renderer);
    this._swapTexture();
    this._elapsedTime += deltaTime;
  },
  _downsample: function(renderer) {
    var downsampleTextures = this._downsampleTextures;
    if (downsampleTextures.length === 0) {
      return;
    }
    var current = 0;
    var sourceTexture = this._thisFrameTexture;
    var targetTexture = downsampleTextures[current];
    while (targetTexture) {
      this._frameBuffer.attach(targetTexture);
      this._downsamplePass.setUniform("texture", sourceTexture);
      this._downsamplePass.setUniform("textureSize", [sourceTexture.width, sourceTexture.height]);
      this._downsamplePass.render(renderer, this._frameBuffer);
      sourceTexture = targetTexture;
      targetTexture = downsampleTextures[++current];
    }
  },
  getSurfaceTexture: function() {
    var downsampleTextures = this._downsampleTextures;
    return downsampleTextures.length > 0 ? downsampleTextures[downsampleTextures.length - 1] : this._lastFrameTexture;
  },
  setRegion: function(region) {
    this._particlePass.setUniform("region", region);
  },
  resize: function(width, height) {
    this._lastFrameTexture.width = width * this._supersampling;
    this._lastFrameTexture.height = height * this._supersampling;
    this._thisFrameTexture.width = width * this._supersampling;
    this._thisFrameTexture.height = height * this._supersampling;
    this._width = width;
    this._height = height;
  },
  setParticleSize: function(size) {
    var particleMesh = this._getParticleMesh();
    if (size <= 2) {
      particleMesh.material.disableTexture("spriteTexture");
      particleMesh.material.transparent = false;
      return;
    }
    if (!this._spriteTexture) {
      this._spriteTexture = new Texture2D$1();
    }
    if (!this._spriteTexture.image || this._spriteTexture.image.width !== size) {
      this._spriteTexture.image = createSpriteCanvas(size);
      this._spriteTexture.dirty();
    }
    particleMesh.material.transparent = true;
    particleMesh.material.enableTexture("spriteTexture");
    particleMesh.material.set("spriteTexture", this._spriteTexture);
    this._particleSize = size;
  },
  setGradientTexture: function(gradientTexture) {
    var material = this._getParticleMesh().material;
    material[gradientTexture ? "enableTexture" : "disableTexture"]("gradientTexture");
    material.setUniform("gradientTexture", gradientTexture);
  },
  setColorTextureImage: function(colorTextureImg, api) {
    var material = this._getParticleMesh().material;
    material.setTextureImage("colorTexture", colorTextureImg, api, {
      flipY: true
    });
  },
  setParticleType: function(type) {
    this._particleType = type;
  },
  clearFrame: function(renderer) {
    var frameBuffer = this._frameBuffer;
    frameBuffer.attach(this._lastFrameTexture);
    frameBuffer.bind(renderer);
    renderer.gl.clear(renderer.gl.DEPTH_BUFFER_BIT | renderer.gl.COLOR_BUFFER_BIT);
    frameBuffer.unbind(renderer);
  },
  setSupersampling: function(supersampling) {
    this._supersampling = supersampling;
    this.resize(this._width, this._height);
  },
  _updateDownsampleTextures: function(renderer, api) {
    var downsampleTextures = this._downsampleTextures;
    var upScale = Math.max(Math.floor(Math.log(this._supersampling / api.getDevicePixelRatio()) / Math.log(2)), 0);
    var scale2 = 2;
    var width = this._width * this._supersampling;
    var height = this._height * this._supersampling;
    for (var i = 0; i < upScale; i++) {
      downsampleTextures[i] = downsampleTextures[i] || new Texture2D$1();
      downsampleTextures[i].width = width / scale2;
      downsampleTextures[i].height = height / scale2;
      scale2 *= 2;
    }
    for (; i < downsampleTextures.length; i++) {
      downsampleTextures[i].dispose(renderer);
    }
    downsampleTextures.length = upScale;
  },
  _swapTexture: function() {
    var tmp = this._particleTexture0;
    this._particleTexture0 = this._particleTexture1;
    this._particleTexture1 = tmp;
    var tmp = this._thisFrameTexture;
    this._thisFrameTexture = this._lastFrameTexture;
    this._lastFrameTexture = tmp;
  },
  dispose: function(renderer) {
    renderer.disposeFrameBuffer(this._frameBuffer);
    renderer.disposeTexture(this.vectorFieldTexture);
    renderer.disposeTexture(this._spawnTexture);
    renderer.disposeTexture(this._particleTexture0);
    renderer.disposeTexture(this._particleTexture1);
    renderer.disposeTexture(this._thisFrameTexture);
    renderer.disposeTexture(this._lastFrameTexture);
    renderer.disposeGeometry(this._particleLinesMesh.geometry);
    renderer.disposeGeometry(this._particlePointsMesh.geometry);
    renderer.disposeGeometry(this._lastFrameFullQuadMesh.geometry);
    if (this._spriteTexture) {
      renderer.disposeTexture(this._spriteTexture);
    }
    this._particlePass.dispose(renderer);
    this._downsamplePass.dispose(renderer);
    this._downsampleTextures.forEach(function(texture) {
      texture.dispose(renderer);
    });
  }
};
var VectorFieldParticleSurface$1 = VectorFieldParticleSurface;
var FlowGLView = ChartView$1.extend({
  type: "flowGL",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.viewGL = new ViewGL("orthographic");
    this.groupGL = new graphicGL$1.Node();
    this.viewGL.add(this.groupGL);
    this._particleSurface = new VectorFieldParticleSurface$1();
    var planeMesh = new graphicGL$1.Mesh({
      geometry: new graphicGL$1.PlaneGeometry(),
      material: new graphicGL$1.Material({
        shader: new graphicGL$1.Shader({
          vertex: graphicGL$1.Shader.source("ecgl.color.vertex"),
          fragment: graphicGL$1.Shader.source("ecgl.color.fragment")
        }),
        transparent: true
      })
    });
    planeMesh.material.enableTexture("diffuseMap");
    this.groupGL.add(planeMesh);
    this._planeMesh = planeMesh;
  },
  render: function(seriesModel, ecModel, api) {
    var particleSurface = this._particleSurface;
    particleSurface.setParticleType(seriesModel.get("particleType"));
    particleSurface.setSupersampling(seriesModel.get("supersampling"));
    this._updateData(seriesModel, api);
    this._updateCamera(api.getWidth(), api.getHeight(), api.getDevicePixelRatio());
    var particleDensity = retrieve$1.firstNotNull(seriesModel.get("particleDensity"), 128);
    particleSurface.setParticleDensity(particleDensity, particleDensity);
    var planeMesh = this._planeMesh;
    var time = +new Date();
    var self2 = this;
    var firstFrame = true;
    planeMesh.__percent = 0;
    planeMesh.stopAnimation();
    planeMesh.animate("", {
      loop: true
    }).when(1e5, {
      __percent: 1
    }).during(function() {
      var timeNow = +new Date();
      var dTime = Math.min(timeNow - time, 20);
      time = time + dTime;
      if (self2._renderer) {
        particleSurface.update(self2._renderer, api, dTime / 1e3, firstFrame);
        planeMesh.material.set("diffuseMap", particleSurface.getSurfaceTexture());
      }
      firstFrame = false;
    }).start();
    var itemStyleModel = seriesModel.getModel("itemStyle");
    var color = graphicGL$1.parseColor(itemStyleModel.get("color"));
    color[3] *= retrieve$1.firstNotNull(itemStyleModel.get("opacity"), 1);
    planeMesh.material.set("color", color);
    particleSurface.setColorTextureImage(seriesModel.get("colorTexture"), api);
    particleSurface.setParticleSize(seriesModel.get("particleSize"));
    particleSurface.particleSpeedScaling = seriesModel.get("particleSpeed");
    particleSurface.motionBlurFactor = 1 - Math.pow(0.1, seriesModel.get("particleTrail"));
  },
  updateTransform: function(seriesModel, ecModel, api) {
    this._updateData(seriesModel, api);
  },
  afterRender: function(globeModel, ecModel, api, layerGL) {
    var renderer = layerGL.renderer;
    this._renderer = renderer;
  },
  _updateData: function(seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var dims = coordSys.dimensions.map(function(coordDim) {
      return seriesModel.coordDimToDataDim(coordDim)[0];
    });
    var data = seriesModel.getData();
    var xExtent = data.getDataExtent(dims[0]);
    var yExtent = data.getDataExtent(dims[1]);
    var gridWidth = seriesModel.get("gridWidth");
    var gridHeight = seriesModel.get("gridHeight");
    if (gridWidth == null || gridWidth === "auto") {
      var aspect = (xExtent[1] - xExtent[0]) / (yExtent[1] - yExtent[0]);
      gridWidth = Math.round(Math.sqrt(aspect * data.count()));
    }
    if (gridHeight == null || gridHeight === "auto") {
      gridHeight = Math.ceil(data.count() / gridWidth);
    }
    var vectorFieldTexture = this._particleSurface.vectorFieldTexture;
    var pixels = vectorFieldTexture.pixels;
    if (!pixels || pixels.length !== gridHeight * gridWidth * 4) {
      pixels = vectorFieldTexture.pixels = new Float32Array(gridWidth * gridHeight * 4);
    } else {
      for (var i = 0; i < pixels.length; i++) {
        pixels[i] = 0;
      }
    }
    var maxMag = 0;
    var minMag = Infinity;
    var points2 = new Float32Array(data.count() * 2);
    var offset = 0;
    var bbox = [[Infinity, Infinity], [-Infinity, -Infinity]];
    data.each([dims[0], dims[1], "vx", "vy"], function(x, y, vx, vy) {
      var pt = coordSys.dataToPoint([x, y]);
      points2[offset++] = pt[0];
      points2[offset++] = pt[1];
      bbox[0][0] = Math.min(pt[0], bbox[0][0]);
      bbox[0][1] = Math.min(pt[1], bbox[0][1]);
      bbox[1][0] = Math.max(pt[0], bbox[1][0]);
      bbox[1][1] = Math.max(pt[1], bbox[1][1]);
      var mag = Math.sqrt(vx * vx + vy * vy);
      maxMag = Math.max(maxMag, mag);
      minMag = Math.min(minMag, mag);
    });
    data.each(["vx", "vy"], function(vx, vy, i2) {
      var xPix = Math.round((points2[i2 * 2] - bbox[0][0]) / (bbox[1][0] - bbox[0][0]) * (gridWidth - 1));
      var yPix = gridHeight - 1 - Math.round((points2[i2 * 2 + 1] - bbox[0][1]) / (bbox[1][1] - bbox[0][1]) * (gridHeight - 1));
      var idx = (yPix * gridWidth + xPix) * 4;
      pixels[idx] = vx / maxMag * 0.5 + 0.5;
      pixels[idx + 1] = vy / maxMag * 0.5 + 0.5;
      pixels[idx + 3] = 1;
    });
    vectorFieldTexture.width = gridWidth;
    vectorFieldTexture.height = gridHeight;
    if (seriesModel.get("coordinateSystem") === "bmap") {
      this._fillEmptyPixels(vectorFieldTexture);
    }
    vectorFieldTexture.dirty();
    this._updatePlanePosition(bbox[0], bbox[1], seriesModel, api);
    this._updateGradientTexture(data.getVisual("visualMeta"), [minMag, maxMag]);
  },
  _fillEmptyPixels: function(texture) {
    var pixels = texture.pixels;
    var width = texture.width;
    var height = texture.height;
    function fetchPixel(x2, y2, rg) {
      x2 = Math.max(Math.min(x2, width - 1), 0);
      y2 = Math.max(Math.min(y2, height - 1), 0);
      var idx2 = (y2 * (width - 1) + x2) * 4;
      if (pixels[idx2 + 3] === 0) {
        return false;
      }
      rg[0] = pixels[idx2];
      rg[1] = pixels[idx2 + 1];
      return true;
    }
    function addPixel(a, b, out2) {
      out2[0] = a[0] + b[0];
      out2[1] = a[1] + b[1];
    }
    var center2 = [], left = [], right = [], top = [], bottom = [];
    var weight = 0;
    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        var idx = (y * (width - 1) + x) * 4;
        if (pixels[idx + 3] === 0) {
          weight = center2[0] = center2[1] = 0;
          if (fetchPixel(x - 1, y, left)) {
            weight++;
            addPixel(left, center2, center2);
          }
          if (fetchPixel(x + 1, y, right)) {
            weight++;
            addPixel(right, center2, center2);
          }
          if (fetchPixel(x, y - 1, top)) {
            weight++;
            addPixel(top, center2, center2);
          }
          if (fetchPixel(x, y + 1, bottom)) {
            weight++;
            addPixel(bottom, center2, center2);
          }
          center2[0] /= weight;
          center2[1] /= weight;
          pixels[idx] = center2[0];
          pixels[idx + 1] = center2[1];
        }
        pixels[idx + 3] = 1;
      }
    }
  },
  _updateGradientTexture: function(visualMeta, magExtent) {
    if (!visualMeta || !visualMeta.length) {
      this._particleSurface.setGradientTexture(null);
      return;
    }
    this._gradientTexture = this._gradientTexture || new graphicGL$1.Texture2D({
      image: document.createElement("canvas")
    });
    var gradientTexture = this._gradientTexture;
    var canvas = gradientTexture.image;
    canvas.width = 200;
    canvas.height = 1;
    var ctx = canvas.getContext("2d");
    var gradient = ctx.createLinearGradient(0, 0.5, canvas.width, 0.5);
    visualMeta[0].stops.forEach(function(stop2) {
      var offset;
      if (magExtent[1] === magExtent[0]) {
        offset = 0;
      } else {
        offset = stop2.value / magExtent[1];
        offset = Math.min(Math.max(offset, 0), 1);
      }
      gradient.addColorStop(offset, stop2.color);
    });
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    gradientTexture.dirty();
    this._particleSurface.setGradientTexture(this._gradientTexture);
  },
  _updatePlanePosition: function(leftTop, rightBottom, seriesModel, api) {
    var limitedResult = this._limitInViewportAndFullFill(leftTop, rightBottom, seriesModel, api);
    leftTop = limitedResult.leftTop;
    rightBottom = limitedResult.rightBottom;
    this._particleSurface.setRegion(limitedResult.region);
    this._planeMesh.position.set((leftTop[0] + rightBottom[0]) / 2, api.getHeight() - (leftTop[1] + rightBottom[1]) / 2, 0);
    var width = rightBottom[0] - leftTop[0];
    var height = rightBottom[1] - leftTop[1];
    this._planeMesh.scale.set(width / 2, height / 2, 1);
    this._particleSurface.resize(Math.max(Math.min(width, 2048), 1), Math.max(Math.min(height, 2048), 1));
    if (this._renderer) {
      this._particleSurface.clearFrame(this._renderer);
    }
  },
  _limitInViewportAndFullFill: function(leftTop, rightBottom, seriesModel, api) {
    var newLeftTop = [Math.max(leftTop[0], 0), Math.max(leftTop[1], 0)];
    var newRightBottom = [Math.min(rightBottom[0], api.getWidth()), Math.min(rightBottom[1], api.getHeight())];
    if (seriesModel.get("coordinateSystem") === "bmap") {
      var lngRange = seriesModel.getData().getDataExtent(seriesModel.coordDimToDataDim("lng")[0]);
      var isContinuous = Math.floor(lngRange[1] - lngRange[0]) >= 359;
      if (isContinuous) {
        if (newLeftTop[0] > 0) {
          newLeftTop[0] = 0;
        }
        if (newRightBottom[0] < api.getWidth()) {
          newRightBottom[0] = api.getWidth();
        }
      }
    }
    var width = rightBottom[0] - leftTop[0];
    var height = rightBottom[1] - leftTop[1];
    var newWidth = newRightBottom[0] - newLeftTop[0];
    var newHeight = newRightBottom[1] - newLeftTop[1];
    var region = [(newLeftTop[0] - leftTop[0]) / width, 1 - newHeight / height - (newLeftTop[1] - leftTop[1]) / height, newWidth / width, newHeight / height];
    return {
      leftTop: newLeftTop,
      rightBottom: newRightBottom,
      region
    };
  },
  _updateCamera: function(width, height, dpr2) {
    this.viewGL.setViewport(0, 0, width, height, dpr2);
    var camera2 = this.viewGL.camera;
    camera2.left = camera2.bottom = 0;
    camera2.top = height;
    camera2.right = width;
    camera2.near = 0;
    camera2.far = 100;
    camera2.position.z = 10;
  },
  remove: function() {
    this._planeMesh.stopAnimation();
    this.groupGL.removeAll();
  },
  dispose: function() {
    if (this._renderer) {
      this._particleSurface.dispose(this._renderer);
    }
    this.groupGL.removeAll();
  }
});
function install$1(registers) {
  registers.registerChartView(FlowGLView);
  registers.registerSeriesModel(FlowGLSeries);
}
use(install$1);
var LinesGLSeries = SeriesModel$1.extend({
  type: "series.linesGL",
  dependencies: ["grid", "geo"],
  visualStyleAccessPath: "lineStyle",
  visualDrawType: "stroke",
  streamEnabled: true,
  init: function(option) {
    var result = this._processFlatCoordsArray(option.data);
    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;
    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }
    LinesGLSeries.superApply(this, "init", arguments);
  },
  mergeOption: function(option) {
    var result = this._processFlatCoordsArray(option.data);
    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;
    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }
    LinesGLSeries.superApply(this, "mergeOption", arguments);
  },
  appendData: function(params) {
    var result = this._processFlatCoordsArray(params.data);
    if (result.flatCoords) {
      if (!this._flatCoords) {
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
      } else {
        this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
        this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
      }
      params.data = new Float32Array(result.count);
    }
    this.getRawData().appendData(params.data);
  },
  _getCoordsFromItemModel: function(idx) {
    var itemModel = this.getData().getItemModel(idx);
    var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
    return coords;
  },
  getLineCoordsCount: function(idx) {
    if (this._flatCoordsOffset) {
      return this._flatCoordsOffset[idx * 2 + 1];
    } else {
      return this._getCoordsFromItemModel(idx).length;
    }
  },
  getLineCoords: function(idx, out2) {
    if (this._flatCoordsOffset) {
      var offset = this._flatCoordsOffset[idx * 2];
      var len2 = this._flatCoordsOffset[idx * 2 + 1];
      for (var i = 0; i < len2; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = this._flatCoords[offset + i * 2];
        out2[i][1] = this._flatCoords[offset + i * 2 + 1];
      }
      return len2;
    } else {
      var coords = this._getCoordsFromItemModel(idx);
      for (var i = 0; i < coords.length; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = coords[i][0];
        out2[i][1] = coords[i][1];
      }
      return coords.length;
    }
  },
  _processFlatCoordsArray: function(data) {
    var startOffset = 0;
    if (this._flatCoords) {
      startOffset = this._flatCoords.length;
    }
    if (typeof data[0] === "number") {
      var len2 = data.length;
      var coordsOffsetAndLenStorage = new Uint32Array(len2);
      var coordsStorage = new Float64Array(len2);
      var coordsCursor = 0;
      var offsetCursor = 0;
      var dataCount = 0;
      for (var i = 0; i < len2; ) {
        dataCount++;
        var count2 = data[i++];
        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
        coordsOffsetAndLenStorage[offsetCursor++] = count2;
        for (var k = 0; k < count2; k++) {
          var x = data[i++];
          var y = data[i++];
          coordsStorage[coordsCursor++] = x;
          coordsStorage[coordsCursor++] = y;
        }
      }
      return {
        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
        flatCoords: coordsStorage,
        count: dataCount
      };
    }
    return {
      flatCoordsOffset: null,
      flatCoords: null,
      count: data.length
    };
  },
  getInitialData: function(option, ecModel) {
    var lineData = new SeriesData$1(["value"], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        var value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  },
  defaultOption: {
    coordinateSystem: "geo",
    zlevel: 10,
    progressive: 1e4,
    progressiveThreshold: 5e4,
    blendMode: "source-over",
    lineStyle: {
      opacity: 0.8
    },
    postEffect: {
      enable: false,
      colorCorrection: {
        exposure: 0,
        brightness: 0,
        contrast: 1,
        saturation: 1,
        enable: true
      }
    }
  }
});
var LinesGLSeries$1 = LinesGLSeries;
var LinesGLView = ChartView$1.extend({
  type: "linesGL",
  __ecgl__: true,
  init: function(ecModel, api) {
    this.groupGL = new graphicGL$1.Node();
    this.viewGL = new ViewGL("orthographic");
    this.viewGL.add(this.groupGL);
    this._glViewHelper = new GLViewHelper(this.viewGL);
    this._nativeLinesShader = graphicGL$1.createShader("ecgl.lines3D");
    this._meshLinesShader = graphicGL$1.createShader("ecgl.meshLines3D");
    this._linesMeshes = [];
    this._currentStep = 0;
  },
  render: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    this._glViewHelper.reset(seriesModel, api);
    var linesMesh = this._linesMeshes[0];
    if (!linesMesh) {
      linesMesh = this._linesMeshes[0] = this._createLinesMesh(seriesModel);
    }
    this._linesMeshes.length = 1;
    this.groupGL.add(linesMesh);
    this._updateLinesMesh(seriesModel, linesMesh, 0, seriesModel.getData().count());
    this.viewGL.setPostEffect(seriesModel.getModel("postEffect"), api);
  },
  incrementalPrepareRender: function(seriesModel, ecModel, api) {
    this.groupGL.removeAll();
    this._glViewHelper.reset(seriesModel, api);
    this._currentStep = 0;
    this.viewGL.setPostEffect(seriesModel.getModel("postEffect"), api);
  },
  incrementalRender: function(params, seriesModel, ecModel, api) {
    var linesMesh = this._linesMeshes[this._currentStep];
    if (!linesMesh) {
      linesMesh = this._createLinesMesh(seriesModel);
      this._linesMeshes[this._currentStep] = linesMesh;
    }
    this._updateLinesMesh(seriesModel, linesMesh, params.start, params.end);
    this.groupGL.add(linesMesh);
    api.getZr().refresh();
    this._currentStep++;
  },
  updateTransform: function(seriesModel, ecModel, api) {
    if (seriesModel.coordinateSystem.getRoamTransform) {
      this._glViewHelper.updateTransform(seriesModel, api);
    }
  },
  _createLinesMesh: function(seriesModel) {
    var linesMesh = new graphicGL$1.Mesh({
      $ignorePicking: true,
      material: new graphicGL$1.Material({
        shader: graphicGL$1.createShader("ecgl.lines3D"),
        transparent: true,
        depthMask: false,
        depthTest: false
      }),
      geometry: new Lines2DGeometry({
        segmentScale: 10,
        useNativeLine: true,
        dynamic: false
      }),
      mode: graphicGL$1.Mesh.LINES,
      culling: false
    });
    return linesMesh;
  },
  _updateLinesMesh: function(seriesModel, linesMesh, start2, end2) {
    var data = seriesModel.getData();
    linesMesh.material.blend = seriesModel.get("blendMode") === "lighter" ? graphicGL$1.additiveBlend : null;
    var curveness = seriesModel.get("lineStyle.curveness") || 0;
    var isPolyline = seriesModel.get("polyline");
    var geometry = linesMesh.geometry;
    var coordSys = seriesModel.coordinateSystem;
    var lineWidth = retrieve$1.firstNotNull(seriesModel.get("lineStyle.width"), 1);
    if (lineWidth > 1) {
      if (linesMesh.material.shader !== this._meshLinesShader) {
        linesMesh.material.attachShader(this._meshLinesShader);
      }
      linesMesh.mode = graphicGL$1.Mesh.TRIANGLES;
    } else {
      if (linesMesh.material.shader !== this._nativeLinesShader) {
        linesMesh.material.attachShader(this._nativeLinesShader);
      }
      linesMesh.mode = graphicGL$1.Mesh.LINES;
    }
    start2 = start2 || 0;
    end2 = end2 || data.count();
    geometry.resetOffset();
    var vertexCount = 0;
    var triangleCount = 0;
    var p02 = [];
    var p12 = [];
    var p22 = [];
    var p3 = [];
    var lineCoords = [];
    var t = 0.3;
    var t2 = 0.7;
    function updateBezierControlPoints() {
      p12[0] = p02[0] * t2 + p3[0] * t - (p02[1] - p3[1]) * curveness;
      p12[1] = p02[1] * t2 + p3[1] * t - (p3[0] - p02[0]) * curveness;
      p22[0] = p02[0] * t + p3[0] * t2 - (p02[1] - p3[1]) * curveness;
      p22[1] = p02[1] * t + p3[1] * t2 - (p3[0] - p02[0]) * curveness;
    }
    if (isPolyline || curveness !== 0) {
      for (var idx = start2; idx < end2; idx++) {
        if (isPolyline) {
          var count2 = seriesModel.getLineCoordsCount(idx);
          vertexCount += geometry.getPolylineVertexCount(count2);
          triangleCount += geometry.getPolylineTriangleCount(count2);
        } else {
          seriesModel.getLineCoords(idx, lineCoords);
          this._glViewHelper.dataToPoint(coordSys, lineCoords[0], p02);
          this._glViewHelper.dataToPoint(coordSys, lineCoords[1], p3);
          updateBezierControlPoints();
          vertexCount += geometry.getCubicCurveVertexCount(p02, p12, p22, p3);
          triangleCount += geometry.getCubicCurveTriangleCount(p02, p12, p22, p3);
        }
      }
    } else {
      var lineCount = end2 - start2;
      vertexCount += lineCount * geometry.getLineVertexCount();
      triangleCount += lineCount * geometry.getLineVertexCount();
    }
    geometry.setVertexCount(vertexCount);
    geometry.setTriangleCount(triangleCount);
    var dataIndex = start2;
    var colorArr = [];
    for (var idx = start2; idx < end2; idx++) {
      graphicGL$1.parseColor(getItemVisualColor(data, dataIndex), colorArr);
      var opacity = retrieve$1.firstNotNull(getItemVisualOpacity(data, dataIndex), 1);
      colorArr[3] *= opacity;
      var count2 = seriesModel.getLineCoords(idx, lineCoords);
      for (var k = 0; k < count2; k++) {
        this._glViewHelper.dataToPoint(coordSys, lineCoords[k], lineCoords[k]);
      }
      if (isPolyline) {
        geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, count2);
      } else if (curveness !== 0) {
        p02 = lineCoords[0];
        p3 = lineCoords[1];
        updateBezierControlPoints();
        geometry.addCubicCurve(p02, p12, p22, p3, colorArr, lineWidth);
      } else {
        geometry.addPolyline(lineCoords, colorArr, lineWidth, 0, 2);
      }
      dataIndex++;
    }
  },
  dispose: function() {
    this.groupGL.removeAll();
  },
  remove: function() {
    this.groupGL.removeAll();
  }
});
function install(registers) {
  registers.registerChartView(LinesGLView);
  registers.registerSeriesModel(LinesGLSeries$1);
}
use(install);
extendSeriesModel({
  type: "series.liquidFill",
  optionUpdated: function() {
    var option = this.option;
    option.gridSize = Math.max(Math.floor(option.gridSize), 4);
  },
  getInitialData: function(option, ecModel) {
    var dimensions = createDimensions(option.data, {
      coordDimensions: ["value"]
    });
    var list = new SeriesData$1(dimensions, this);
    list.initData(option.data);
    return list;
  },
  defaultOption: {
    color: ["#294D99", "#156ACF", "#1598ED", "#45BDFF"],
    center: ["50%", "50%"],
    radius: "50%",
    amplitude: "8%",
    waveLength: "80%",
    phase: "auto",
    period: "auto",
    direction: "right",
    shape: "circle",
    waveAnimation: true,
    animationEasing: "linear",
    animationEasingUpdate: "linear",
    animationDuration: 2e3,
    animationDurationUpdate: 1e3,
    outline: {
      show: true,
      borderDistance: 8,
      itemStyle: {
        color: "none",
        borderColor: "#294D99",
        borderWidth: 8,
        shadowBlur: 20,
        shadowColor: "rgba(0, 0, 0, 0.25)"
      }
    },
    backgroundStyle: {
      color: "#E3F7FF"
    },
    itemStyle: {
      opacity: 0.95,
      shadowBlur: 50,
      shadowColor: "rgba(0, 0, 0, 0.4)"
    },
    label: {
      show: true,
      color: "#294D99",
      insideColor: "#fff",
      fontSize: 50,
      fontWeight: "bold",
      align: "center",
      baseline: "middle",
      position: "inside"
    },
    emphasis: {
      itemStyle: {
        opacity: 0.8
      }
    }
  }
});
var LiquidShape = extendShape({
  type: "ec-liquid-fill",
  shape: {
    waveLength: 0,
    radius: 0,
    radiusY: 0,
    cx: 0,
    cy: 0,
    waterLevel: 0,
    amplitude: 0,
    phase: 0,
    inverse: false
  },
  buildPath: function(ctx, shape) {
    if (shape.radiusY == null) {
      shape.radiusY = shape.radius;
    }
    var curves = Math.max(Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2, 8);
    while (shape.phase < -Math.PI * 2) {
      shape.phase += Math.PI * 2;
    }
    while (shape.phase > 0) {
      shape.phase -= Math.PI * 2;
    }
    var phase = shape.phase / Math.PI / 2 * shape.waveLength;
    var left = shape.cx - shape.radius + phase - shape.radius * 2;
    ctx.moveTo(left, shape.waterLevel);
    var waveRight = 0;
    for (var c = 0; c < curves; ++c) {
      var stage = c % 4;
      var pos = getWaterPositions(c * shape.waveLength / 4, stage, shape.waveLength, shape.amplitude);
      ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel, pos[1][0] + left, -pos[1][1] + shape.waterLevel, pos[2][0] + left, -pos[2][1] + shape.waterLevel);
      if (c === curves - 1) {
        waveRight = pos[2][0];
      }
    }
    if (shape.inverse) {
      ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);
      ctx.lineTo(left, shape.cy - shape.radiusY);
      ctx.lineTo(left, shape.waterLevel);
    } else {
      ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);
      ctx.lineTo(left, shape.cy + shape.radiusY);
      ctx.lineTo(left, shape.waterLevel);
    }
    ctx.closePath();
  }
});
function getWaterPositions(x, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
      [x + 1 / 2 * waveLength / Math.PI, amplitude],
      [x + waveLength / 4, amplitude]
    ];
  } else if (stage === 1) {
    return [
      [
        x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),
        amplitude
      ],
      [
        x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        amplitude / 2
      ],
      [x + waveLength / 4, 0]
    ];
  } else if (stage === 2) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
      [x + 1 / 2 * waveLength / Math.PI, -amplitude],
      [x + waveLength / 4, -amplitude]
    ];
  } else {
    return [
      [
        x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),
        -amplitude
      ],
      [
        x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        -amplitude / 2
      ],
      [x + waveLength / 4, 0]
    ];
  }
}
var parsePercent = parsePercent$1;
function isPathSymbol(symbol) {
  return symbol && symbol.indexOf("path://") === 0;
}
extendChartView({
  type: "liquidFill",
  render: function(seriesModel, ecModel, api) {
    var self2 = this;
    var group = this.group;
    group.removeAll();
    var data = seriesModel.getData();
    var itemModel = data.getItemModel(0);
    var center2 = itemModel.get("center");
    var radius = itemModel.get("radius");
    var width = api.getWidth();
    var height = api.getHeight();
    var size = Math.min(width, height);
    var outlineDistance = 0;
    var outlineBorderWidth = 0;
    var showOutline = seriesModel.get("outline.show");
    if (showOutline) {
      outlineDistance = seriesModel.get("outline.borderDistance");
      outlineBorderWidth = parsePercent(seriesModel.get("outline.itemStyle.borderWidth"), size);
    }
    var cx = parsePercent(center2[0], width);
    var cy = parsePercent(center2[1], height);
    var outterRadius;
    var innerRadius;
    var paddingRadius;
    var isFillContainer = false;
    var symbol = seriesModel.get("shape");
    if (symbol === "container") {
      isFillContainer = true;
      outterRadius = [
        width / 2,
        height / 2
      ];
      innerRadius = [
        outterRadius[0] - outlineBorderWidth / 2,
        outterRadius[1] - outlineBorderWidth / 2
      ];
      paddingRadius = [
        parsePercent(outlineDistance, width),
        parsePercent(outlineDistance, height)
      ];
      radius = [
        Math.max(innerRadius[0] - paddingRadius[0], 0),
        Math.max(innerRadius[1] - paddingRadius[1], 0)
      ];
    } else {
      outterRadius = parsePercent(radius, size) / 2;
      innerRadius = outterRadius - outlineBorderWidth / 2;
      paddingRadius = parsePercent(outlineDistance, size);
      radius = Math.max(innerRadius - paddingRadius, 0);
    }
    if (showOutline) {
      var outline = getOutline();
      outline.style.lineWidth = outlineBorderWidth;
      group.add(getOutline());
    }
    var left = isFillContainer ? 0 : cx - radius;
    var top = isFillContainer ? 0 : cy - radius;
    var wavePath = null;
    group.add(getBackground());
    var oldData = this._data;
    var waves = [];
    data.diff(oldData).add(function(idx) {
      var wave = getWave(idx, false);
      var waterLevel = wave.shape.waterLevel;
      wave.shape.waterLevel = isFillContainer ? height / 2 : radius;
      initProps(wave, {
        shape: {
          waterLevel
        }
      }, seriesModel);
      wave.z2 = 2;
      setWaveAnimation(idx, wave, null);
      group.add(wave);
      data.setItemGraphicEl(idx, wave);
      waves.push(wave);
    }).update(function(newIdx, oldIdx) {
      var waveElement = oldData.getItemGraphicEl(oldIdx);
      var newWave = getWave(newIdx, false, waveElement);
      var shape = {};
      var shapeAttrs = ["amplitude", "cx", "cy", "phase", "radius", "radiusY", "waterLevel", "waveLength"];
      for (var i = 0; i < shapeAttrs.length; ++i) {
        var attr = shapeAttrs[i];
        if (newWave.shape.hasOwnProperty(attr)) {
          shape[attr] = newWave.shape[attr];
        }
      }
      var style = {};
      var styleAttrs = ["fill", "opacity", "shadowBlur", "shadowColor"];
      for (var i = 0; i < styleAttrs.length; ++i) {
        var attr = styleAttrs[i];
        if (newWave.style.hasOwnProperty(attr)) {
          style[attr] = newWave.style[attr];
        }
      }
      if (isFillContainer) {
        shape.radiusY = height / 2;
      }
      updateProps$1(waveElement, {
        shape,
        x: newWave.x,
        y: newWave.y
      }, seriesModel);
      if (seriesModel.isUniversalTransitionEnabled && seriesModel.isUniversalTransitionEnabled()) {
        updateProps$1(waveElement, {
          style
        }, seriesModel);
      } else {
        waveElement.useStyle(style);
      }
      var oldWaveClipPath = waveElement.getClipPath();
      var newWaveClipPath = newWave.getClipPath();
      waveElement.setClipPath(newWave.getClipPath());
      waveElement.shape.inverse = newWave.inverse;
      if (oldWaveClipPath && newWaveClipPath && self2._shape === symbol && !isPathSymbol(symbol)) {
        updateProps$1(newWaveClipPath, {
          shape: oldWaveClipPath.shape
        }, seriesModel, { isFrom: true });
      }
      setWaveAnimation(newIdx, waveElement, waveElement);
      group.add(waveElement);
      data.setItemGraphicEl(newIdx, waveElement);
      waves.push(waveElement);
    }).remove(function(idx) {
      var wave = oldData.getItemGraphicEl(idx);
      group.remove(wave);
    }).execute();
    if (itemModel.get("label.show")) {
      group.add(getText(waves));
    }
    this._shape = symbol;
    this._data = data;
    function getPath(r, isForClipping) {
      if (symbol) {
        if (isPathSymbol(symbol)) {
          var path = makePath$1(symbol.slice(7), {});
          var bouding = path.getBoundingRect();
          var w = bouding.width;
          var h = bouding.height;
          if (w > h) {
            h = r * 2 / w * h;
            w = r * 2;
          } else {
            w = r * 2 / h * w;
            h = r * 2;
          }
          var left2 = isForClipping ? 0 : cx - w / 2;
          var top2 = isForClipping ? 0 : cy - h / 2;
          path = makePath$1(symbol.slice(7), {}, new BoundingRect$1(left2, top2, w, h));
          if (isForClipping) {
            path.x = -w / 2;
            path.y = -h / 2;
          }
          return path;
        } else if (isFillContainer) {
          var x = isForClipping ? -r[0] : cx - r[0];
          var y = isForClipping ? -r[1] : cy - r[1];
          return createSymbol$1("rect", x, y, r[0] * 2, r[1] * 2);
        } else {
          var x = isForClipping ? -r : cx - r;
          var y = isForClipping ? -r : cy - r;
          if (symbol === "pin") {
            y += r;
          } else if (symbol === "arrow") {
            y -= r;
          }
          return createSymbol$1(symbol, x, y, r * 2, r * 2);
        }
      }
      return new Circle$1({
        shape: {
          cx: isForClipping ? 0 : cx,
          cy: isForClipping ? 0 : cy,
          r
        }
      });
    }
    function getOutline() {
      var outlinePath = getPath(outterRadius);
      outlinePath.style.fill = null;
      outlinePath.setStyle(seriesModel.getModel("outline.itemStyle").getItemStyle());
      return outlinePath;
    }
    function getBackground() {
      var strokePath = getPath(radius);
      strokePath.setStyle(seriesModel.getModel("backgroundStyle").getItemStyle());
      strokePath.style.fill = null;
      strokePath.z2 = 5;
      var fillPath = getPath(radius);
      fillPath.setStyle(seriesModel.getModel("backgroundStyle").getItemStyle());
      fillPath.style.stroke = null;
      var group2 = new Group$4();
      group2.add(strokePath);
      group2.add(fillPath);
      return group2;
    }
    function getWave(idx, isInverse, oldWave) {
      var radiusX = isFillContainer ? radius[0] : radius;
      var radiusY = isFillContainer ? height / 2 : radius;
      var itemModel2 = data.getItemModel(idx);
      var itemStyleModel = itemModel2.getModel("itemStyle");
      var phase = itemModel2.get("phase");
      var amplitude = parsePercent(itemModel2.get("amplitude"), radiusY * 2);
      var waveLength = parsePercent(itemModel2.get("waveLength"), radiusX * 2);
      var value = data.get("value", idx);
      var waterLevel = radiusY - value * radiusY * 2;
      phase = oldWave ? oldWave.shape.phase : phase === "auto" ? idx * Math.PI / 4 : phase;
      var normalStyle = itemStyleModel.getItemStyle();
      if (!normalStyle.fill) {
        var seriesColor = seriesModel.get("color");
        var id = idx % seriesColor.length;
        normalStyle.fill = seriesColor[id];
      }
      var x = radiusX * 2;
      var wave = new LiquidShape({
        shape: {
          waveLength,
          radius: radiusX,
          radiusY,
          cx: x,
          cy: 0,
          waterLevel,
          amplitude,
          phase,
          inverse: isInverse
        },
        style: normalStyle,
        x: cx,
        y: cy
      });
      wave.shape._waterLevel = waterLevel;
      var hoverStyle = itemModel2.getModel("emphasis.itemStyle").getItemStyle();
      hoverStyle.lineWidth = 0;
      wave.ensureState("emphasis").style = hoverStyle;
      enableHoverEmphasis(wave);
      var clip2 = getPath(radius, true);
      clip2.setStyle({
        fill: "white"
      });
      wave.setClipPath(clip2);
      return wave;
    }
    function setWaveAnimation(idx, wave, oldWave) {
      var itemModel2 = data.getItemModel(idx);
      var maxSpeed = itemModel2.get("period");
      var direction = itemModel2.get("direction");
      var value = data.get("value", idx);
      var phase = itemModel2.get("phase");
      phase = oldWave ? oldWave.shape.phase : phase === "auto" ? idx * Math.PI / 4 : phase;
      var defaultSpeed = function(maxSpeed2) {
        var cnt = data.count();
        return cnt === 0 ? maxSpeed2 : maxSpeed2 * (0.2 + (cnt - idx) / cnt * 0.8);
      };
      var speed = 0;
      if (maxSpeed === "auto") {
        speed = defaultSpeed(5e3);
      } else {
        speed = typeof maxSpeed === "function" ? maxSpeed(value, idx) : maxSpeed;
      }
      var phaseOffset = 0;
      if (direction === "right" || direction == null) {
        phaseOffset = Math.PI;
      } else if (direction === "left") {
        phaseOffset = -Math.PI;
      } else if (direction === "none") {
        phaseOffset = 0;
      } else {
        console.error("Illegal direction value for liquid fill.");
      }
      if (direction !== "none" && itemModel2.get("waveAnimation")) {
        wave.animate("shape", true).when(0, {
          phase
        }).when(speed / 2, {
          phase: phaseOffset + phase
        }).when(speed, {
          phase: phaseOffset * 2 + phase
        }).during(function() {
          if (wavePath) {
            wavePath.dirty(true);
          }
        }).start();
      }
    }
    function getText(waves2) {
      var labelModel = itemModel.getModel("label");
      function formatLabel2() {
        var formatted = seriesModel.getFormattedLabel(0, "normal");
        var defaultVal = data.get("value", 0) * 100;
        var defaultLabel = data.getName(0) || seriesModel.name;
        if (!isNaN(defaultVal)) {
          defaultLabel = defaultVal.toFixed(0) + "%";
        }
        return formatted == null ? defaultLabel : formatted;
      }
      var textRectOption = {
        z2: 10,
        shape: {
          x: left,
          y: top,
          width: (isFillContainer ? radius[0] : radius) * 2,
          height: (isFillContainer ? radius[1] : radius) * 2
        },
        style: {
          fill: "transparent"
        },
        textConfig: {
          position: labelModel.get("position") || "inside"
        },
        silent: true
      };
      var textOption = {
        style: {
          text: formatLabel2(),
          textAlign: labelModel.get("align"),
          textVerticalAlign: labelModel.get("baseline")
        }
      };
      Object.assign(textOption.style, createTextStyle(labelModel));
      var outsideTextRect = new Rect$3(textRectOption);
      var insideTextRect = new Rect$3(textRectOption);
      insideTextRect.disableLabelAnimation = true;
      outsideTextRect.disableLabelAnimation = true;
      var outsideText = new ZRText$1(textOption);
      var insideText = new ZRText$1(textOption);
      outsideTextRect.setTextContent(outsideText);
      insideTextRect.setTextContent(insideText);
      var insColor = labelModel.get("insideColor");
      insideText.style.fill = insColor;
      var group2 = new Group$4();
      group2.add(outsideTextRect);
      group2.add(insideTextRect);
      var boundingCircle = getPath(radius, true);
      wavePath = new CompoundPath$1({
        shape: {
          paths: waves2
        },
        x: cx,
        y: cy
      });
      wavePath.setClipPath(boundingCircle);
      insideTextRect.setClipPath(wavePath);
      return group2;
    }
  },
  dispose: function() {
  }
});
const isBrowser = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getTargetElement(target, defaultElement) {
  if (!isBrowser) {
    return void 0;
  }
  if (!target) {
    return defaultElement;
  }
  let targetElement;
  if (typeof target === "function") {
    targetElement = target();
  } else if (isRef(target)) {
    targetElement = target.value;
  } else {
    targetElement = target;
  }
  return targetElement;
}
function depsAreSame(oldDeps, deps) {
  if (oldDeps === deps)
    return true;
  for (let i = 0; i < oldDeps.length; i++) {
    if (!Object.is(oldDeps[i], deps[i]))
      return false;
  }
  return true;
}
const createEffectWithTarget = (useEffectType) => {
  const useEffectWithTarget2 = (effect, deps, target) => {
    const hasInitRef = ref(false);
    const lastElementRef = ref([]);
    const lastDepsRef = ref([]);
    const unLoadRef = ref();
    useEffectType(() => {
      var _a2;
      const targets2 = Array.isArray(target) ? target : [target];
      const els = targets2.map((item) => getTargetElement(item));
      if (!hasInitRef.value) {
        hasInitRef.value = true;
        lastElementRef.value = els;
        lastDepsRef.value = deps;
        unLoadRef.value = effect();
        return;
      }
      if (els.length !== lastElementRef.value.length || !depsAreSame(els, lastElementRef.value) || !depsAreSame(deps, lastDepsRef.value)) {
        (_a2 = unLoadRef.value) == null ? void 0 : _a2.call(unLoadRef);
        lastElementRef.value = els;
        lastDepsRef.value = deps;
        unLoadRef.value = effect();
      }
    });
    onUnmounted(() => {
      var _a2;
      (_a2 = unLoadRef.value) == null ? void 0 : _a2.call(unLoadRef);
      hasInitRef.value = false;
    });
  };
  return useEffectWithTarget2;
};
const useEffectWithTarget = createEffectWithTarget(watchEffect);
function useEventListener(eventName, handler, options = {}) {
  const handlerRef = ref(handler);
  useEffectWithTarget(() => {
    const targetElement = getTargetElement(options.target, window);
    if (!(targetElement == null ? void 0 : targetElement.addEventListener)) {
      return;
    }
    const eventListener = (event) => {
      return handlerRef.value(event);
    };
    targetElement.addEventListener(eventName, eventListener, {
      capture: options.capture,
      once: options.once,
      passive: options.passive
    });
    return () => {
      targetElement.removeEventListener(eventName, eventListener, {
        capture: options.capture
      });
    };
  }, [eventName, options.capture, options.once, options.passive], options.target);
}
function useEcharts(options) {
  const { defaultOptions } = options != null ? options : {};
  const container = ref(null);
  const chart = ref();
  const optionsRef = ref(defaultOptions);
  onMounted(() => {
    if (!container.value) {
      return;
    }
    const myEcharts = init$1(container.value);
    chart.value = myEcharts;
  });
  watchEffect(() => {
    var _a2;
    if (optionsRef.value && chart.value) {
      (_a2 = chart.value) == null ? void 0 : _a2.setOption(optionsRef.value);
    }
  });
  onUnmounted(() => {
    var _a2, _b2, _c2, _d;
    (_b2 = (_a2 = chart.value) == null ? void 0 : _a2.dispose) == null ? void 0 : _b2.call(_a2);
    (_d = (_c2 = chart.value) == null ? void 0 : _c2.off) == null ? void 0 : _d.call(_c2, "*");
    chart.value = void 0;
  });
  useEventListener("resize", () => {
    requestAnimationFrame(() => {
      var _a2, _b2;
      (_b2 = (_a2 = chart == null ? void 0 : chart.value) == null ? void 0 : _a2.resize) == null ? void 0 : _b2.call(_a2);
    });
  });
  return { chart, container };
}
class EventEmitter {
  constructor() {
    __publicField(this, "subscriptions", new Map());
    __publicField(this, "useSubscription", (event, listener) => {
      const callbackRef = ref();
      watchEffect((onInvalidate) => {
        callbackRef.value = listener;
        function subscription(val) {
          if (callbackRef.value) {
            callbackRef.value(val);
          }
        }
        this.subscriptions.set(event, subscription);
        onInvalidate(() => {
          this.subscriptions.delete(event);
        });
      });
    });
    __publicField(this, "emit", (event, ...args) => {
      if (typeof event === "string" || typeof event === "number") {
        const subscriptionValuesCallback = this.subscriptions.get(event);
        subscriptionValuesCallback == null ? void 0 : subscriptionValuesCallback({
          params: lodash.exports.cloneDeep(args),
          event
        });
      } else
        throw new TypeError("event must be string or number !");
    });
    __publicField(this, "removeListener", (event) => {
      this.subscriptions.delete(event);
    });
    __publicField(this, "clear", () => {
      this.subscriptions.clear();
    });
    this.clear();
  }
}
const eventEmitterOverall = new EventEmitter();
function useEventEmitter(options) {
  const eventRef = ref();
  const eventEmitterOptions = computed(() => options != null ? options : { global: false });
  if (!eventRef.value) {
    eventRef.value = eventEmitterOptions.value.global ? eventRef.value = eventEmitterOverall : eventRef.value = new EventEmitter();
  }
  watchEffect((onInvalidate) => {
    onInvalidate(() => {
      var _a2;
      return (_a2 = eventRef.value) == null ? void 0 : _a2.clear();
    });
  });
  return eventRef.value;
}
function isFunction(obj) {
  return typeof obj === "function";
}
function createUseStorageState(getStorage) {
  function useStorageState(key, options) {
    let storage2;
    try {
      storage2 = getStorage();
    } catch (err) {
      console.error(err);
    }
    const serializer = (value) => {
      if (options == null ? void 0 : options.serializer) {
        return options == null ? void 0 : options.serializer(value);
      }
      return JSON.stringify(value);
    };
    const deserializer = (value) => {
      if (options == null ? void 0 : options.deserializer) {
        return options == null ? void 0 : options.deserializer(value);
      }
      return JSON.parse(value);
    };
    function getStoredValue() {
      try {
        const raw = storage2 == null ? void 0 : storage2.getItem(key.value);
        if (raw) {
          return deserializer(raw);
        }
      } catch (e2) {
        console.error(e2);
      }
      if (isFunction(options == null ? void 0 : options.defaultValue)) {
        return options == null ? void 0 : options.defaultValue();
      }
      return options == null ? void 0 : options.defaultValue;
    }
    const state = ref(getStoredValue());
    watchEffect(() => {
      if (key)
        state.value = getStoredValue();
    });
    const updateState = (value) => {
      if (typeof value === "undefined") {
        state.value = void 0;
        storage2 == null ? void 0 : storage2.removeItem(key.value);
      } else if (isFunction(value)) {
        const currentState = value(state.value);
        try {
          state.value = currentState;
          storage2 == null ? void 0 : storage2.setItem(key.value, serializer(currentState));
        } catch (e2) {
          console.error(e2);
        }
      } else {
        try {
          state.value = value;
          storage2 == null ? void 0 : storage2.setItem(key.value, serializer(value));
        } catch (e2) {
          console.error(e2);
        }
      }
    };
    return [state, updateState];
  }
  return useStorageState;
}
const useLocalStorageState = createUseStorageState(() => isBrowser ? localStorage : void 0);
function useLockFn(fn) {
  const lockRef = ref(false);
  return async (...args) => {
    if (lockRef.value)
      return;
    lockRef.value = true;
    try {
      const ret2 = await fn(...args);
      lockRef.value = false;
      return ret2;
    } catch (e2) {
      lockRef.value = false;
      throw e2;
    }
  };
}
const getScrollTop = (el) => {
  if (el === document || el === document.body) {
    return Math.max(window.pageYOffset, document.documentElement.scrollTop, document.body.scrollTop);
  }
  return el.scrollTop;
};
const getScrollHeight = (el) => {
  return el.scrollHeight || Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);
};
const getClientHeight = (el) => {
  return el.clientHeight || Math.max(document.documentElement.clientHeight, document.body.clientHeight);
};
const useInfiniteScroll = (service, options = {}) => {
  const {
    target,
    isNoMore,
    threshold = 100,
    reloadDeps = [],
    manual,
    onBefore,
    onSuccess,
    onError,
    onFinally
  } = options;
  const finalData = ref();
  const [loadingMore, { set: setLoadingMore }] = useBoolean();
  const setFinalData = (mutateData) => {
    finalData.value = mutateData;
  };
  const noMore = computed(() => {
    if (!isNoMore)
      return false;
    return isNoMore(finalData.value);
  });
  const { loading, run, runAsync, cancel } = useRequest(async (lastData) => {
    const currentData = await service(lastData);
    if (!lastData) {
      finalData.value = currentData;
    } else {
      finalData.value = __spreadProps(__spreadValues({}, currentData), {
        list: [...lastData.list, ...currentData.list]
      });
    }
    console.log(currentData);
    return currentData;
  }, {
    manual,
    onFinally: (_, d, e2) => {
      setLoadingMore(false);
      onFinally == null ? void 0 : onFinally(d, e2);
    },
    onBefore: () => onBefore == null ? void 0 : onBefore(),
    onSuccess: (d) => {
      setTimeout(() => {
        scrollMethod();
      });
      onSuccess == null ? void 0 : onSuccess(d);
    },
    onError: (e2) => onError == null ? void 0 : onError(e2)
  });
  const loadMore = () => {
    if (noMore.value)
      return;
    setLoadingMore(true);
    run(finalData.value);
  };
  const loadMoreAsync = () => {
    if (noMore)
      return;
    setLoadingMore(true);
    return runAsync(finalData.value);
  };
  const reload = () => run();
  const reloadAsync = () => runAsync();
  const scrollMethod = () => {
    const el = getTargetElement(target);
    if (!el) {
      return;
    }
    const scrollTop = getScrollTop(el);
    const scrollHeight = getScrollHeight(el);
    const clientHeight = getClientHeight(el);
    if (scrollHeight - scrollTop <= clientHeight + threshold) {
      loadMore();
    }
  };
  useEventListener("scroll", () => {
    if (loading.value || loadingMore.value) {
      return;
    }
    scrollMethod();
  }, { target });
  watch([...reloadDeps], () => {
    run();
  });
  const _loading = computed(() => loadingMore.value && loading.value);
  return {
    data: finalData,
    loading: _loading,
    loadingMore,
    noMore,
    loadMore,
    loadMoreAsync,
    reload,
    reloadAsync,
    mutate: setFinalData,
    scrollMethod,
    cancel
  };
};
function useMap(initialValue) {
  const initialMap = initialValue ? new Map(initialValue) : new Map();
  const state = ref(initialMap);
  const actions2 = {
    set: (key, value) => {
      state.value.set(key, value);
    },
    get: (key) => {
      return state.value.get(key);
    },
    remove: (key) => {
      state.value.delete(key);
    },
    has: (key) => state.value.has(key),
    clear: () => state.value.clear(),
    setAll: (newMap) => {
      state.value = new Map(newMap);
    },
    reset: () => state.value = initialMap
  };
  return [state, markRaw(actions2)];
}
const useSessionStorageState = createUseStorageState(() => isBrowser ? sessionStorage : void 0);
function useSet(initialValue) {
  const initialSet = initialValue ? new Set(initialValue) : new Set();
  const state = ref(initialSet);
  const actions2 = {
    add: (value) => {
      state.value.add(value);
    },
    remove: (value) => {
      state.value.delete(value);
    },
    has: (value) => state.value.has(value),
    clear: () => state.value.clear(),
    reset: () => {
      state.value = new Set();
    }
  };
  return [state, markRaw(actions2)];
}
function useWinResize(Action = () => {
}) {
  const fn = () => {
    nextTick(() => {
      Action();
    });
  };
  onMounted(() => {
    window.addEventListener("resize", fn, false);
  });
  onBeforeUnmount(() => {
    window.removeEventListener("resize", fn);
  });
  return null;
}
function useSize(target) {
  const size = reactive({
    width: 0,
    height: 0
  });
  const getSizeInfo = () => {
    var _a2, _b2;
    const targetDom = getTargetElement(target);
    size.width = (_a2 = targetDom == null ? void 0 : targetDom.clientWidth) != null ? _a2 : 0;
    size.height = (_b2 = targetDom == null ? void 0 : targetDom.clientHeight) != null ? _b2 : 0;
  };
  useWinResize(getSizeInfo);
  onMounted(() => {
    setTimeout(() => {
      getSizeInfo();
    }, 120);
  });
  return __spreadValues({}, toRefs(size));
}
const DEFAULT_OPTIONS = {
  restoreOnUnmount: false
};
function useTitle(title, options = DEFAULT_OPTIONS) {
  const titleRef = ref(isBrowser ? document.title : "");
  watch(title, () => {
    document.title = title.value;
  });
  onMounted(() => {
    document.title = title.value;
  });
  onUnmounted(() => {
    if (options.restoreOnUnmount) {
      document.title = titleRef.value;
    }
  });
}
var queryString = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp(token, "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split2) {
  try {
    return decodeURIComponent(components.join(""));
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split2 = split2 || 1;
  var left = components.slice(0, split2);
  var right = components.slice(split2);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher);
    for (var i = 1; i < tokens.length; i++) {
      input = decodeComponents(tokens, i).join("");
      tokens = input.match(singleMatcher);
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap2 = {
    "%FE%FF": "\uFFFD\uFFFD",
    "%FF%FE": "\uFFFD\uFFFD"
  };
  var match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap2[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode(match[0]);
      if (result !== match[0]) {
        replaceMap2[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap2["%C2"] = "\uFFFD";
  var entries = Object.keys(replaceMap2);
  for (var i = 0; i < entries.length; i++) {
    var key = entries[i];
    input = input.replace(new RegExp(key, "g"), replaceMap2[key]);
  }
  return input;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
var splitOnFirst = (string, separator) => {
  if (!(typeof string === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator === "") {
    return [string];
  }
  const separatorIndex = string.indexOf(separator);
  if (separatorIndex === -1) {
    return [string];
  }
  return [
    string.slice(0, separatorIndex),
    string.slice(separatorIndex + separator.length)
  ];
};
var filterObj = function(obj, predicate) {
  var ret2 = {};
  var keys2 = Object.keys(obj);
  var isArr = Array.isArray(predicate);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    var val = obj[key];
    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
      ret2[key] = val;
    }
  }
  return ret2;
};
(function(exports) {
  const strictUriEncode$1 = strictUriEncode;
  const decodeComponent = decodeUriComponent;
  const splitOnFirst$1 = splitOnFirst;
  const filterObject = filterObj;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key) => (result, value) => {
          const index = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), "[", index, "]"].join("")];
          }
          return [
            ...result,
            [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
          ];
        };
      case "bracket":
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), "[]"].join("")];
          }
          return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
        };
      case "colon-list-separator":
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode(key, options), ":list="].join("")];
          }
          return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
          }
          return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
        };
      }
      default:
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode(key, options)];
          }
          return [...result, [encode(key, options), "=", encode(value, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      case "bracket":
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "colon-list-separator":
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "comma":
      case "separator":
        return (key, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key] = newValue;
        };
      case "bracket-separator":
        return (key, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, "");
          if (!isArray2) {
            accumulator[key] = value ? decode2(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode2(item, options));
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }
    return hash;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const ret2 = Object.create(null);
    if (typeof query !== "string") {
      return ret2;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
      return ret2;
    }
    for (const param of query.split("&")) {
      if (param === "") {
        continue;
      }
      let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter(decode2(key, options), value, ret2);
    }
    for (const key of Object.keys(ret2)) {
      const value = ret2[key];
      if (typeof value === "object" && value !== null) {
        for (const k of Object.keys(value)) {
          value[k] = parseValue(value[k], options);
        }
      } else {
        ret2[key] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return ret2;
    }
    return (options.sort === true ? Object.keys(ret2).sort() : Object.keys(ret2).sort(options.sort)).reduce((result, key) => {
      const value = ret2[key];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
      return result;
    }, Object.create(null));
  }
  exports.extract = extract;
  exports.parse = parse2;
  exports.stringify = (object, options) => {
    if (!object) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }
    const keys2 = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys2.sort(options.sort);
    }
    return keys2.map((key) => {
      const value = object[key];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode(key, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === "bracket-separator") {
          return encode(key, options) + "[]";
        }
        return value.reduce(formatter(key), []).join("&");
      }
      return encode(key, options) + "=" + encode(value, options);
    }).filter((x) => x.length > 0).join("&");
  };
  exports.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash] = splitOnFirst$1(url, "#");
    return Object.assign({
      url: url_.split("?")[0] || "",
      query: parse2(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode2(hash, options) } : {});
  };
  exports.stringifyUrl = (object, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object.url).split("?")[0] || "";
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash = getHash(object.url);
    if (object.fragmentIdentifier) {
      hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash}`;
  };
  exports.pick = (input, filter2, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter2),
      fragmentIdentifier
    }, options);
  };
  exports.exclude = (input, filter2, options) => {
    const exclusionFilter = Array.isArray(filter2) ? (key) => !filter2.includes(key) : (key, value) => !filter2(key, value);
    return exports.pick(input, exclusionFilter, options);
  };
})(queryString);
const baseParseConfig = {
  parseNumbers: false,
  parseBooleans: false
};
const baseStringifyConfig = {
  skipNull: false,
  skipEmptyString: false
};
const useUrlState = (initialState, options) => {
  const { parseOptions, stringifyOptions } = options || {};
  const mergedParseOptions = __spreadValues(__spreadValues({}, baseParseConfig), parseOptions);
  const mergedStringifyOptions = __spreadValues(__spreadValues({}, baseStringifyConfig), stringifyOptions);
  const initialStateRef = ref(typeof initialState === "function" ? initialState() : initialState || {});
  const state = ref(initialStateRef.value);
  const [path] = location.hash.slice(1).split("?");
  const queryFromUrl = computed(() => {
    return queryString.parse(location.search, mergedParseOptions);
  });
  const routerPushFn = (s) => location.hash = s;
  const targetQuery = computed(() => __spreadValues(__spreadValues({}, initialStateRef.value), queryFromUrl.value));
  onMounted(() => {
    state.value = __spreadValues(__spreadValues({}, initialStateRef.value), queryFromUrl.value);
  });
  watchEffect(() => {
    state.value = __spreadValues(__spreadValues({}, initialStateRef.value), queryFromUrl.value);
  });
  const setState = (s) => {
    const newQuery = typeof s === "function" ? s(__spreadValues(__spreadValues({}, targetQuery.value), state.value)) : s;
    state.value = __spreadValues(__spreadValues({}, state.value), newQuery);
  };
  watch(state, (curr) => {
    routerPushFn(`${path}?${queryString.stringify(__spreadValues(__spreadValues(__spreadValues({}, initialStateRef.value), queryFromUrl.value), curr), mergedStringifyOptions)}`);
  });
  return { state, setState };
};
const useVirtualList = (list, options) => {
  const containerTarget = ref();
  const { wrapperTarget, itemHeight, overscan = 5 } = options;
  const itemHeightRef = ref(itemHeight);
  const size = useSize(containerTarget);
  const targetList2 = ref([]);
  const scrollTriggerByScrollToFunc = ref(false);
  const getVisibleCount = (containerHeight, fromIndex) => {
    if (typeof itemHeightRef.value === "number") {
      return Math.ceil(containerHeight / itemHeightRef.value);
    }
    let sum2 = 0;
    let endIndex = 0;
    for (let i = fromIndex; i < list.value.length; i++) {
      const height = itemHeightRef.value(i, list.value[i]);
      sum2 += height;
      endIndex = i;
      if (sum2 >= containerHeight) {
        break;
      }
    }
    return endIndex - fromIndex;
  };
  const getOffset = (scrollTop) => {
    if (typeof itemHeightRef.value === "number") {
      return Math.floor(scrollTop / itemHeightRef.value) + 1;
    }
    let sum2 = 0;
    let offset = 0;
    for (let i = 0; i < list.value.length; i++) {
      const height = itemHeightRef.value(i, list.value[i]);
      sum2 += height;
      if (sum2 >= scrollTop) {
        offset = i;
        break;
      }
    }
    return offset + 1;
  };
  const getDistanceTop = (index) => {
    var _a2, _b2;
    if (typeof itemHeightRef.value === "number") {
      const height2 = index * itemHeightRef.value;
      return height2;
    }
    const height = (_b2 = (_a2 = list.value) == null ? void 0 : _a2.slice(0, index)) == null ? void 0 : _b2.reduce((sum2, _, i) => sum2 + itemHeightRef.value(i, list == null ? void 0 : list.value[index]), 0);
    return height;
  };
  const totalHeight = computed(() => {
    if (typeof itemHeightRef.value === "number") {
      return list.value.length * itemHeightRef.value;
    }
    return list.value.reduce((sum2, _, index) => sum2 + itemHeightRef.value(index, list[index]), 0);
  });
  const calculateRange = () => {
    const container2 = getTargetElement(containerTarget);
    const wrapper = getTargetElement(wrapperTarget);
    if (container2 && wrapper) {
      const { scrollTop, clientHeight } = container2;
      const offset = getOffset(scrollTop);
      const visibleCount = getVisibleCount(clientHeight, offset);
      const start2 = Math.max(0, offset - overscan);
      const end2 = Math.min(list.value.length, offset + visibleCount + overscan);
      const offsetTop = getDistanceTop(start2);
      wrapper.style.height = totalHeight.value - offsetTop + "px";
      wrapper.style.marginTop = offsetTop + "px";
      targetList2.value = list.value.slice(start2, end2).map((ele, index) => ({
        data: ele,
        index: index + start2
      }));
    }
  };
  watch([size, list], () => {
    if (!(size == null ? void 0 : size.width) || !(size == null ? void 0 : size.height) || list.value.length) {
      return;
    }
    calculateRange();
  });
  onMounted(() => {
    if ((size == null ? void 0 : size.width) && (size == null ? void 0 : size.height) && list.value.length) {
      calculateRange();
    }
  });
  const scrollTo = (index) => {
    const container2 = getTargetElement(containerTarget);
    if (container2) {
      scrollTriggerByScrollToFunc.value = true;
      container2.scrollTop = getDistanceTop(index);
      calculateRange();
    }
  };
  const container = reactive({
    ref: (ele) => {
      containerTarget.value = ele;
    },
    onScroll: (e2) => {
      if (scrollTriggerByScrollToFunc.value) {
        scrollTriggerByScrollToFunc.value = false;
        return;
      }
      e2.preventDefault();
      calculateRange();
    }
  });
  return [targetList2, container, scrollTo];
};
export { useAsync, useBoolean, useCookieState, useDebounce, useDebounceFn, useEcharts, useEventEmitter, useEventListener, useInfiniteScroll, useLocalStorageState, useLockFn, useMap, useRequest, useSessionStorageState, useSet, useSize, useTitle, useToggle, useUpdate, useUrlState, useVirtualList, useWinResize };
